Directory structure:
└── pkg/
    ├── generate_models.go
    ├── chdb/
    │   ├── clickhouse.go
    │   ├── config.go
    │   ├── metrics.go
    │   ├── migrator.go
    │   ├── mock.go
    │   └── migrations/
    │       ├── 0001_create_metrics_table.down.sql
    │       └── 0001_create_metrics_table.up.sql
    ├── cloud/
    │   ├── config.go
    │   └── auth/
    │       └── provider.go
    ├── consts/
    │   ├── aws.go
    │   ├── envd.go
    │   ├── gcp.go
    │   └── sandboxes.go
    ├── db/
    │   ├── apiKeys.go
    │   ├── auth.go
    │   ├── client.go
    │   ├── env_aliases.go
    │   ├── envs.go
    │   ├── errors.go
    │   ├── snapshot.go
    │   └── users.go
    ├── fc/
    │   ├── firecracker.yml
    │   ├── client/
    │   │   ├── firecracker_client.go
    │   │   └── operations/
    │   │       ├── create_snapshot_parameters.go
    │   │       ├── create_snapshot_responses.go
    │   │       ├── create_sync_action_parameters.go
    │   │       ├── create_sync_action_responses.go
    │   │       ├── describe_balloon_config_parameters.go
    │   │       ├── describe_balloon_config_responses.go
    │   │       ├── describe_balloon_stats_parameters.go
    │   │       ├── describe_balloon_stats_responses.go
    │   │       ├── describe_instance_parameters.go
    │   │       ├── describe_instance_responses.go
    │   │       ├── get_export_vm_config_parameters.go
    │   │       ├── get_export_vm_config_responses.go
    │   │       ├── get_firecracker_version_parameters.go
    │   │       ├── get_firecracker_version_responses.go
    │   │       ├── get_machine_configuration_parameters.go
    │   │       ├── get_machine_configuration_responses.go
    │   │       ├── get_mmds_parameters.go
    │   │       ├── get_mmds_responses.go
    │   │       ├── load_snapshot_parameters.go
    │   │       ├── load_snapshot_responses.go
    │   │       ├── operations_client.go
    │   │       ├── patch_balloon_parameters.go
    │   │       ├── patch_balloon_responses.go
    │   │       ├── patch_balloon_stats_interval_parameters.go
    │   │       ├── patch_balloon_stats_interval_responses.go
    │   │       ├── patch_guest_drive_by_id_parameters.go
    │   │       ├── patch_guest_drive_by_id_responses.go
    │   │       ├── patch_guest_network_interface_by_id_parameters.go
    │   │       ├── patch_guest_network_interface_by_id_responses.go
    │   │       ├── patch_machine_configuration_parameters.go
    │   │       ├── patch_machine_configuration_responses.go
    │   │       ├── patch_mmds_parameters.go
    │   │       ├── patch_mmds_responses.go
    │   │       ├── patch_vm_parameters.go
    │   │       ├── patch_vm_responses.go
    │   │       ├── put_balloon_parameters.go
    │   │       ├── put_balloon_responses.go
    │   │       ├── put_cpu_configuration_parameters.go
    │   │       ├── put_cpu_configuration_responses.go
    │   │       ├── put_entropy_device_parameters.go
    │   │       ├── put_entropy_device_responses.go
    │   │       ├── put_guest_boot_source_parameters.go
    │   │       ├── put_guest_boot_source_responses.go
    │   │       ├── put_guest_drive_by_id_parameters.go
    │   │       ├── put_guest_drive_by_id_responses.go
    │   │       ├── put_guest_network_interface_by_id_parameters.go
    │   │       ├── put_guest_network_interface_by_id_responses.go
    │   │       ├── put_guest_vsock_parameters.go
    │   │       ├── put_guest_vsock_responses.go
    │   │       ├── put_logger_parameters.go
    │   │       ├── put_logger_responses.go
    │   │       ├── put_machine_configuration_parameters.go
    │   │       ├── put_machine_configuration_responses.go
    │   │       ├── put_metrics_parameters.go
    │   │       ├── put_metrics_responses.go
    │   │       ├── put_mmds_config_parameters.go
    │   │       ├── put_mmds_config_responses.go
    │   │       ├── put_mmds_parameters.go
    │   │       └── put_mmds_responses.go
    │   └── models/
    │       ├── balloon.go
    │       ├── balloon_stats.go
    │       ├── balloon_stats_update.go
    │       ├── balloon_update.go
    │       ├── boot_source.go
    │       ├── cpu_config.go
    │       ├── cpu_template.go
    │       ├── drive.go
    │       ├── entropy_device.go
    │       ├── error.go
    │       ├── firecracker_version.go
    │       ├── full_vm_configuration.go
    │       ├── instance_action_info.go
    │       ├── instance_info.go
    │       ├── logger.go
    │       ├── machine_configuration.go
    │       ├── memory_backend.go
    │       ├── metrics.go
    │       ├── mmds_config.go
    │       ├── mmds_contents_object.go
    │       ├── network_interface.go
    │       ├── partial_drive.go
    │       ├── partial_network_interface.go
    │       ├── rate_limiter.go
    │       ├── snapshot_create_params.go
    │       ├── snapshot_load_params.go
    │       ├── token_bucket.go
    │       ├── vm.go
    │       └── vsock.go
    ├── gin_utils/
    │   └── middleware/
    │       ├── exclude.go
    │       └── otel/
    │           ├── metrics/
    │           │   ├── config.go
    │           │   ├── middleware.go
    │           │   ├── option.go
    │           │   ├── otelrecorder.go
    │           │   ├── recorder.go
    │           │   └── version.go
    │           └── tracing/
    │               └── middleware.go
    ├── grpc/
    │   ├── connection.go
    │   ├── dummy_client.go
    │   ├── filter.go
    │   ├── orchestrator/
    │   │   ├── orchestrator.pb.go
    │   │   └── orchestrator_grpc.pb.go
    │   └── template-manager/
    │       ├── template-manager.pb.go
    │       └── template-manager_grpc.pb.go
    ├── id/
    │   └── id.go
    ├── logger/
    │   ├── exporter.go
    │   ├── grpc.go
    │   ├── logger.go
    │   └── sandbox/
    │       ├── global.go
    │       ├── logger.go
    │       ├── metadata.go
    │       └── sandbox_logger.go
    ├── meters/
    │   └── main.go
    ├── models/
    │   ├── accesstoken.go
    │   ├── accesstoken_create.go
    │   ├── accesstoken_delete.go
    │   ├── accesstoken_query.go
    │   ├── accesstoken_update.go
    │   ├── client.go
    │   ├── ent.go
    │   ├── env.go
    │   ├── env_create.go
    │   ├── env_delete.go
    │   ├── env_query.go
    │   ├── env_update.go
    │   ├── envalias.go
    │   ├── envalias_create.go
    │   ├── envalias_delete.go
    │   ├── envalias_query.go
    │   ├── envalias_update.go
    │   ├── envbuild.go
    │   ├── envbuild_create.go
    │   ├── envbuild_delete.go
    │   ├── envbuild_query.go
    │   ├── envbuild_update.go
    │   ├── mutation.go
    │   ├── runtime.go
    │   ├── snapshot.go
    │   ├── snapshot_create.go
    │   ├── snapshot_delete.go
    │   ├── snapshot_query.go
    │   ├── snapshot_update.go
    │   ├── team.go
    │   ├── team_create.go
    │   ├── team_delete.go
    │   ├── team_query.go
    │   ├── team_update.go
    │   ├── teamapikey.go
    │   ├── teamapikey_create.go
    │   ├── teamapikey_delete.go
    │   ├── teamapikey_query.go
    │   ├── teamapikey_update.go
    │   ├── tier.go
    │   ├── tier_create.go
    │   ├── tier_delete.go
    │   ├── tier_query.go
    │   ├── tier_update.go
    │   ├── tx.go
    │   ├── user.go
    │   ├── user_create.go
    │   ├── user_delete.go
    │   ├── user_query.go
    │   ├── user_update.go
    │   ├── usersteams.go
    │   ├── usersteams_create.go
    │   ├── usersteams_delete.go
    │   ├── usersteams_query.go
    │   ├── usersteams_update.go
    │   ├── accesstoken/
    │   │   ├── accesstoken.go
    │   │   └── where.go
    │   ├── chmodels/
    │   │   ├── clickhouse.go
    │   │   └── metrics.go
    │   ├── enttest/
    │   │   └── enttest.go
    │   ├── env/
    │   │   ├── env.go
    │   │   └── where.go
    │   ├── envalias/
    │   │   ├── envalias.go
    │   │   └── where.go
    │   ├── envbuild/
    │   │   ├── envbuild.go
    │   │   └── where.go
    │   ├── hook/
    │   │   └── hook.go
    │   ├── internal/
    │   │   └── schemaconfig.go
    │   ├── migrate/
    │   │   ├── migrate.go
    │   │   └── schema.go
    │   ├── predicate/
    │   │   └── predicate.go
    │   ├── runtime/
    │   │   └── runtime.go
    │   ├── snapshot/
    │   │   ├── snapshot.go
    │   │   └── where.go
    │   ├── team/
    │   │   ├── team.go
    │   │   └── where.go
    │   ├── teamapikey/
    │   │   ├── teamapikey.go
    │   │   └── where.go
    │   ├── tier/
    │   │   ├── tier.go
    │   │   └── where.go
    │   ├── user/
    │   │   ├── user.go
    │   │   └── where.go
    │   └── usersteams/
    │       ├── usersteams.go
    │       └── where.go
    ├── schema/
    │   ├── access_token.go
    │   ├── build.go
    │   ├── env.go
    │   ├── env_alias.go
    │   ├── mixin.go
    │   ├── snapshots.go
    │   ├── team.go
    │   ├── team_api_key.go
    │   ├── tier.go
    │   ├── user.go
    │   └── users_teams.go
    ├── smap/
    │   └── smap.go
    ├── storage/
    │   ├── provider.go
    │   ├── sandbox.go
    │   ├── template.go
    │   ├── template_build.go
    │   ├── template_cache.go
    │   ├── gcs/
    │   │   ├── bucket.go
    │   │   ├── client.go
    │   │   ├── dir.go
    │   │   └── object.go
    │   ├── header/
    │   │   ├── block.go
    │   │   ├── diff.go
    │   │   ├── header.go
    │   │   ├── inspect.go
    │   │   ├── mapping.go
    │   │   ├── mapping_test.go
    │   │   └── serialization.go
    │   └── s3/
    │       ├── bucket.go
    │       ├── client.go
    │       ├── dir.go
    │       └── object.go
    ├── telemetry/
    │   ├── otel.go
    │   ├── tracing.go
    │   └── writer.go
    └── utils/
        ├── context.go
        ├── env.go
        ├── must.go
        ├── set_once.go
        ├── set_once_test.go
        └── wait_map.go

================================================
File: generate_models.go
================================================
package pkg

//go:generate go run entgo.io/ent/cmd/ent generate --feature sql/schemaconfig,sql/upsert,sql/modifier ./schema --target ./models



================================================
File: chdb/clickhouse.go
================================================
package chdb

import (
	"context"
	"crypto/tls"
	"fmt"
	"time"

	"github.com/ClickHouse/clickhouse-go/v2"
	"github.com/ClickHouse/clickhouse-go/v2/lib/driver"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/chmodels"
)

type Store interface {
	Close() error

	// Base queries
	Query(ctx context.Context, query string, args ...any) (driver.Rows, error)
	Exec(ctx context.Context, query string, args ...any) error

	// Metrics queries
	InsertMetrics(ctx context.Context, metrics chmodels.Metrics) error
	QueryMetrics(ctx context.Context, sandboxID, teamID string, start int64, limit int) ([]chmodels.Metrics, error)
}

type ClickHouseStore struct {
	Conn driver.Conn
}

func NewConn(config ClickHouseConfig) (driver.Conn, error) {
	if err := config.Validate(); err != nil {
		return nil, fmt.Errorf("failed to validate ClickHouse config: %w", err)
	}

	var (
		ctx       = context.Background()
		conn, err = clickhouse.Open(&clickhouse.Options{
			Addr:     []string{config.ConnectionString},
			Protocol: clickhouse.Native,
			TLS:      &tls.Config{}, // Not using TLS for now
			Auth: clickhouse.Auth{
				Database: config.Database,
				Username: config.Username,
				Password: config.Password,
			},
			DialTimeout: time.Second * 5,
			ReadTimeout: time.Second * 90,
			Debug:       config.Debug,
			Compression: &clickhouse.Compression{
				Method: clickhouse.CompressionLZ4,
			},
		})
	)

	if err != nil {
		return nil, err
	}

	if err := conn.Ping(ctx); err != nil {
		return nil, err
	}

	return conn, nil
}

func NewStore(config ClickHouseConfig) (Store, error) {
	conn, err := NewConn(config)
	if err != nil {
		return nil, err
	}

	return &ClickHouseStore{conn}, nil
}

func (c *ClickHouseStore) Close() error {
	return c.Conn.Close()
}

func (c *ClickHouseStore) Query(ctx context.Context, query string, args ...any) (driver.Rows, error) {
	return c.Conn.Query(ctx, query, args...)
}

func (c *ClickHouseStore) Exec(ctx context.Context, query string, args ...any) error {
	return c.Conn.Exec(ctx, query, args...)
}



================================================
File: chdb/config.go
================================================
package chdb

import "fmt"

type ClickHouseConfig struct {
	ConnectionString string
	Username         string
	Password         string
	Database         string
	Debug            bool
}

func (c ClickHouseConfig) Validate() error {
	if c.ConnectionString == "" {
		return fmt.Errorf("clickhouse connection string cannot be empty string")
	}

	if c.Username == "" {
		return fmt.Errorf("clickhouse username cannot be empty string")
	}

	if c.Database == "" {
		return fmt.Errorf("clickhouse database cannot be empty string")
	}

	return nil
}



================================================
File: chdb/metrics.go
================================================
package chdb

import (
	"context"
	"fmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/models/chmodels"
)

func (c *ClickHouseStore) InsertMetrics(ctx context.Context, metrics chmodels.Metrics) error {
	batch, err := c.Conn.PrepareBatch(ctx, "INSERT INTO metrics")
	if err != nil {
		return err
	}
	err = batch.AppendStruct(&metrics)
	if err != nil {
		batch.Abort()
		return fmt.Errorf("failed to append metrics struct to clickhouse batcher: %w", err)
	}

	return batch.Send()
}

func (c *ClickHouseStore) QueryMetrics(ctx context.Context, sandboxID, teamID string, start int64, limit int) ([]chmodels.Metrics, error) {
	query := "SELECT * FROM metrics WHERE sandbox_id = (?) AND team_id = (?) AND timestamp >= (?) LIMIT (?)"

	rows, err := c.Query(ctx, query, sandboxID, teamID, start, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var metrics []chmodels.Metrics
	for rows.Next() {
		var metric chmodels.Metrics
		if err := rows.ScanStruct(&metric); err != nil {
			return nil, err
		}
		metrics = append(metrics, metric)
	}

	return metrics, rows.Err()
}



================================================
File: chdb/migrator.go
================================================
package chdb

import (
	"crypto/tls"
	"embed"
	"fmt"

	"github.com/ClickHouse/clickhouse-go/v2"
	"github.com/golang-migrate/migrate/v4"
	migch "github.com/golang-migrate/migrate/v4/database/clickhouse"
	"github.com/golang-migrate/migrate/v4/source/iofs"
)

// Thin wrapper around the migrate package to make it easier to use.

//go:embed migrations/*.sql
var migrationsFS embed.FS

type ClickhouseMigrator struct {
	m *migrate.Migrate
}

func (chMig *ClickhouseMigrator) Up() error {
	return chMig.m.Up()
}

func (chMig *ClickhouseMigrator) Down() error {
	return chMig.m.Down()
}

func (chMig *ClickhouseMigrator) Version() (uint, bool, error) {
	return chMig.m.Version()
}

func (chMig *ClickhouseMigrator) To(version uint) error {
	return chMig.m.Migrate(version)
}

func (chMig *ClickhouseMigrator) Force(version int) error {
	return chMig.m.Force(version)
}

func (chMig *ClickhouseMigrator) List() ([]string, error) {
	dirEntries, err := migrationsFS.ReadDir("migrations")
	if err != nil {
		return nil, err
	}

	migrationFiles := make([]string, 0)
	for _, entry := range dirEntries {
		migrationFiles = append(migrationFiles, entry.Name())
	}
	return migrationFiles, nil
}

func (chMig *ClickhouseMigrator) Close() error {
	err1, err2 := chMig.m.Close()
	if err1 != nil || err2 != nil {
		return fmt.Errorf("source close error: %v, driver close error: %v", err1, err2)
	}
	return nil
}

func (chMig *ClickhouseMigrator) SetLogger(logger migrate.Logger) {
	chMig.m.Log = logger
}

func NewMigrator(config ClickHouseConfig) (*ClickhouseMigrator, error) {
	if err := config.Validate(); err != nil {
		return nil, fmt.Errorf("failed to validate ClickHouse config: %w", err)
	}

	d, err := iofs.New(migrationsFS, "migrations")
	if err != nil {
		return nil, fmt.Errorf("failed to open Clickhouse migrations iofs: %w", err)
	}

	db := clickhouse.OpenDB(&clickhouse.Options{
		Addr:     []string{config.ConnectionString},
		Protocol: clickhouse.Native,
		TLS:      &tls.Config{}, // Not using TLS for now
		Auth: clickhouse.Auth{
			Database: config.Database,
			Username: config.Username,
			Password: config.Password,
		},
	})

	_, err = db.Exec(`
		CREATE TABLE IF NOT EXISTS schema_migrations (
			version    Int64,
			dirty      UInt8,
			sequence   UInt64
		)
		ENGINE = ReplicatedMergeTree
		ORDER BY tuple();
	`)
	if err != nil {
		return nil, fmt.Errorf("failed to create schema_migrations table: %w", err)
	}

	driver, err := migch.WithInstance(db, &migch.Config{
		DatabaseName: config.Database,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create cl,ickhouse driver: %w", err)
	}

	m, err := migrate.NewWithInstance(
		"iofs", d,
		"clickhouse", driver)
	if err != nil {
		return nil, fmt.Errorf("failed to create clickhouse migrate instance: %w", err)
	}

	return &ClickhouseMigrator{
		m: m,
	}, nil
}



================================================
File: chdb/mock.go
================================================
package chdb

import (
	"context"

	"github.com/ClickHouse/clickhouse-go/v2/lib/driver"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/chmodels"
)

type MockStore struct{}

func NewMockStore() *MockStore {
	return &MockStore{}
}

func (m *MockStore) Close() error {
	return nil
}

func (m *MockStore) Query(ctx context.Context, query string, args ...any) (driver.Rows, error) {
	return nil, nil
}

func (m *MockStore) Exec(ctx context.Context, query string, args ...any) error {
	return nil
}

func (m *MockStore) InsertMetrics(ctx context.Context, metrics chmodels.Metrics) error {
	return nil
}

func (m *MockStore) QueryMetrics(ctx context.Context, sandboxID, teamID string, start int64, limit int) ([]chmodels.Metrics, error) {
	return nil, nil
}



================================================
File: chdb/migrations/0001_create_metrics_table.down.sql
================================================
DROP TABLE IF EXISTS metrics;



================================================
File: chdb/migrations/0001_create_metrics_table.up.sql
================================================
CREATE TABLE IF NOT EXISTS metrics (
	timestamp DateTime('UTC'),
	sandbox_id String,
	team_id String,
	cpu_count UInt32,
	cpu_used_pct Float32,
	mem_total_mib UInt64,
	mem_used_mib UInt64
) Engine MergeTree()
 ORDER BY (timestamp)
 PRIMARY KEY timestamp;


================================================
File: cloud/config.go
================================================
package cloud

// CloudProvider 定义云服务提供商类型
type CloudProvider string

const (
	GCP CloudProvider = "gcp"
	AWS CloudProvider = "aws"
)

// CloudConfig 定义通用云配置接口
type CloudConfig interface {
	GetProjectID() string
	GetRegion() string
	GetCredentials() string
	GetDockerRegistry() string
}

// GCPConfig 定义GCP云配置
type GCPConfig struct {
	ProjectID      string
	Region         string
	ServiceAccount string
	DockerRegistry string
}

// AWSConfig 定义AWS云配置
type AWSConfig struct {
	AccountID       string
	Region          string
	AccessKeyID     string
	SecretAccessKey string
	ECRRegistry     string
}

// GetStoragePackage returns the storage package name for the cloud provider
func GetStoragePackage(provider CloudProvider) string {
	switch provider {
	case GCP:
		return "gcs"
	case AWS:
		return "s3"
	default:
		return ""
	}
}



================================================
File: cloud/auth/provider.go
================================================
package auth

// 创建认证提供者接口
type AuthProvider interface {
	GetCredentials() (interface{}, error)
	GetDockerCredentials() (string, error)
}

// GCP认证实现
type GCPAuthProvider struct {
	serviceAccountKey string
}

// AWS认证实现
type AWSAuthProvider struct {
	accessKeyID     string
	secretAccessKey string
}



================================================
File: consts/aws.go
================================================
package consts

import (
	"os"
)

var (
	// AWS基础配置
	AWSRegion    = os.Getenv("AWS_REGION")
	AWSAccountID = os.Getenv("AWS_ACCOUNT_ID")

	// AWS认证相关
	AWSAccessKeyID     = os.Getenv("AWS_ACCESS_KEY_ID")
	AWSSecretAccessKey = os.Getenv("AWS_SECRET_ACCESS_KEY")

	// AWS服务相关
	AWSECRRegistry = os.Getenv("AWS_ECR_REGISTRY")

	// 其他AWS服务配置
	AWSS3Bucket = os.Getenv("AWS_S3_BUCKET")
)



================================================
File: consts/envd.go
================================================
package consts

const (
	DefaultEnvdServerPort int64 = 49983
	OldEnvdServerPort     int64 = 49982
)



================================================
File: consts/gcp.go
================================================
package consts

import (
	"encoding/base64"
	"fmt"
	"os"
)

var (
	GCPProject                 = os.Getenv("GCP_PROJECT_ID")
	Domain                     = os.Getenv("DOMAIN_NAME")
	DockerRegistry             = os.Getenv("GCP_DOCKER_REPOSITORY_NAME")
	GoogleServiceAccountSecret = os.Getenv("GOOGLE_SERVICE_ACCOUNT_BASE64")
	DockerAuthConfig           = os.Getenv("DOCKER_AUTH_BASE64")
	GCPRegion                  = os.Getenv("GCP_REGION")
)

var EncodedDockerCredentials = base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("_json_key_base64:%s", GoogleServiceAccountSecret)))



================================================
File: consts/sandboxes.go
================================================
package consts

import "os"

const NodeIDLength = 8

var OrchestratorPort = os.Getenv("ORCHESTRATOR_PORT")



================================================
File: db/apiKeys.go
================================================
package db

import (
	"context"
	"fmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/models"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/accesstoken"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/teamapikey"
	"github.com/google/uuid"
)

type TeamUsageError struct {
	message string
}

func (e *TeamUsageError) Error() string {
	return e.message
}

func validateTeamUsage(team *models.Team) error {
	if team.IsBanned {
		return &TeamUsageError{message: "team is banned"}
	}

	if team.IsBlocked {
		if team.BlockedReason == nil {
			return &TeamUsageError{message: "team was blocked"}
		}

		return &TeamUsageError{message: fmt.Sprintf("team was blocked, reason: %s", *team.BlockedReason)}
	}

	return nil
}

func (db *DB) GetTeamAuth(ctx context.Context, apiKey string) (*models.Team, *models.Tier, error) {
	result, err := db.
		Client.
		TeamAPIKey.
		Query().
		WithTeam().
		Where(teamapikey.APIKey(apiKey)).
		QueryTeam().
		WithTeamTier().
		Only(ctx)

	if err != nil {
		errMsg := fmt.Errorf("failed to get team from API key: %w", err)

		return nil, nil, errMsg
	}

	err = validateTeamUsage(result)
	if err != nil {
		return nil, nil, err
	}

	return result, result.Edges.TeamTier, nil
}

func (db *DB) GetUserID(ctx context.Context, token string) (*uuid.UUID, error) {
	result, err := db.
		Client.
		AccessToken.
		Query().
		Where(accesstoken.ID(token)).
		Only(ctx)

	if err != nil {
		errMsg := fmt.Errorf("failed to get user from access token: %w", err)

		return nil, errMsg
	}

	return &result.UserID, nil
}



================================================
File: db/auth.go
================================================
package db

import (
	"context"
	"fmt"

	"github.com/google/uuid"

	"github.com/e2b-dev/infra/packages/shared/pkg/models"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"
)

func (db *DB) GetTeamByIDAndUserIDAuth(ctx context.Context, teamID string, userID uuid.UUID) (*models.Team, *models.Tier, error) {
	teamIDParsed, err := uuid.Parse(teamID)
	if err != nil {
		errMsg := fmt.Errorf("failed to parse team ID: %w", err)

		return nil, nil, errMsg
	}

	result, err := db.
		Client.
		Team.
		Query().
		Where(
			team.ID(teamIDParsed),
			team.HasUsersTeamsWith(
				usersteams.UserID(userID),
			),
		).
		WithTeamTier().
		Only(ctx)
	if err != nil {
		errMsg := fmt.Errorf("failed to get team from teamID and userID key: %w", err)

		return nil, nil, errMsg
	}

	err = validateTeamUsage(result)
	if err != nil {
		return nil, nil, err
	}

	return result, result.Edges.TeamTier, nil
}



================================================
File: db/client.go
================================================
package db

import (
	"fmt"
	"os"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	_ "github.com/lib/pq"

	"github.com/e2b-dev/infra/packages/shared/pkg/models"
)

type DB struct {
	Client *models.Client
}

var databaseURL = os.Getenv("POSTGRES_CONNECTION_STRING")

func NewClient() (*DB, error) {
	if databaseURL == "" {
		return nil, fmt.Errorf("database URL is empty")
	}

	drv, err := sql.Open(dialect.Postgres, databaseURL)
	if err != nil {
		return nil, err
	}

	// Get the underlying sql.DB object of the driver.
	db := drv.DB()
	db.SetMaxOpenConns(100)

	client := models.NewClient(models.Driver(drv))

	return &DB{Client: client}, nil
}

func (db *DB) Close() error {
	return db.Client.Close()
}



================================================
File: db/env_aliases.go
================================================
package db

import (
	"context"
	"fmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/models"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envalias"
)

func (db *DB) DeleteEnvAlias(ctx context.Context, alias string) error {
	err := db.
		Client.
		EnvAlias.
		DeleteOneID(alias).
		Exec(ctx)

	if err != nil {
		errMsg := fmt.Errorf("failed to delete env alias '%s': %w", alias, err)

		return errMsg
	}

	return nil
}

func (db *DB) reserveEnvAlias(ctx context.Context, envID, alias string) error {
	err := db.
		Client.
		EnvAlias.
		Create().
		SetID(alias).
		SetEnvID(envID).
		Exec(ctx)

	if err != nil {
		errMsg := fmt.Errorf("failed to reserve env alias '%s': %w", alias, err)

		return errMsg
	}

	return nil
}

// rollback calls to tx.Rollback and wraps the given error
// with the rollback error if occurred.
func rollback(tx *models.Tx, err error) error {
	if rerr := tx.Rollback(); rerr != nil {
		err = fmt.Errorf("%w: %w", err, rerr)
	}

	return err
}

func (db *DB) UpdateEnvAlias(ctx context.Context, alias, envID string) error {
	tx, err := db.Client.Tx(ctx)
	if err != nil {
		return fmt.Errorf("starting a transaction: %w", err)
	}

	_, err = tx.
		EnvAlias.
		Delete().
		Where(
			envalias.EnvID(envID),
			envalias.IsRenamable(true)).
		Exec(ctx)

	if err != nil {
		errMsg := fmt.Errorf("failed to delete env alias '%s' for env '%s': %w", alias, envID, err)

		return rollback(tx, errMsg)
	}

	err = tx.
		EnvAlias.
		Create().
		SetID(alias).
		SetEnvID(envID).
		Exec(ctx)

	if err != nil {
		errMsg := fmt.Errorf("failed to update env alias '%s' for env '%s': %w", alias, envID, err)

		return rollback(tx, errMsg)
	}

	err = tx.Commit()

	if err != nil {
		errMsg := fmt.Errorf("committing transaction: %w", err)

		return errMsg
	}

	return nil
}



================================================
File: db/envs.go
================================================
package db

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"

	"github.com/e2b-dev/infra/packages/shared/pkg/models"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envalias"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envbuild"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/snapshot"
)

type TemplateCreator struct {
	Email string
	Id    uuid.UUID
}

type Template struct {
	TemplateID    string
	BuildID       string
	TeamID        uuid.UUID
	VCPU          int64
	DiskMB        int64
	RAMMB         int64
	Public        bool
	Aliases       *[]string
	CreatedAt     time.Time
	UpdatedAt     time.Time
	LastSpawnedAt time.Time
	SpawnCount    int64
	BuildCount    int32
	CreatedBy     *TemplateCreator
}

type UpdateEnvInput struct {
	Public bool
}

func (db *DB) DeleteEnv(ctx context.Context, envID string) error {
	_, err := db.
		Client.
		Env.
		Delete().
		Where(env.ID(envID)).
		Exec(ctx)
	if err != nil {
		return fmt.Errorf("failed to delete env '%s': %w", envID, err)
	}

	return nil
}

func (db *DB) UpdateEnv(ctx context.Context, envID string, input UpdateEnvInput) error {
	return db.Client.Env.UpdateOneID(envID).SetPublic(input.Public).Exec(ctx)
}

func (db *DB) GetEnvs(ctx context.Context, teamID uuid.UUID) (result []*Template, err error) {
	envs, err := db.
		Client.
		Env.
		Query().
		Where(
			env.TeamID(teamID),
			env.HasBuildsWith(envbuild.StatusEQ(envbuild.StatusUploaded)),
			env.Not(env.HasSnapshots()),
		).
		Order(models.Asc(env.FieldCreatedAt)).
		WithEnvAliases().
		WithCreator().
		WithBuilds(func(query *models.EnvBuildQuery) {
			query.Where(envbuild.StatusEQ(envbuild.StatusUploaded)).Order(models.Desc(envbuild.FieldFinishedAt))
		}).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list envs: %w", err)
	}

	for _, item := range envs {
		aliases := make([]string, len(item.Edges.EnvAliases))
		for i, alias := range item.Edges.EnvAliases {
			aliases[i] = alias.ID
		}

		var createdBy *TemplateCreator
		if item.Edges.Creator != nil {
			createdBy = &TemplateCreator{Id: item.Edges.Creator.ID, Email: item.Edges.Creator.Email}
		}

		build := item.Edges.Builds[0]
		result = append(result, &Template{
			TemplateID:    item.ID,
			TeamID:        item.TeamID,
			BuildID:       build.ID.String(),
			VCPU:          build.Vcpu,
			RAMMB:         build.RAMMB,
			DiskMB:        build.FreeDiskSizeMB,
			Public:        item.Public,
			Aliases:       &aliases,
			CreatedAt:     item.CreatedAt,
			UpdatedAt:     item.UpdatedAt,
			LastSpawnedAt: item.LastSpawnedAt,
			SpawnCount:    item.SpawnCount,
			BuildCount:    item.BuildCount,
			CreatedBy:     createdBy,
		})
	}

	return result, nil
}

func (db *DB) GetEnv(ctx context.Context, aliasOrEnvID string) (result *Template, build *models.EnvBuild, err error) {
	template, err := db.
		Client.
		Env.
		Query().
		Where(
			env.Or(
				env.HasEnvAliasesWith(envalias.ID(aliasOrEnvID)),
				env.ID(aliasOrEnvID),
			),
		).
		WithEnvAliases(func(query *models.EnvAliasQuery) {
			query.Order(models.Asc(envalias.FieldID)) // TODO: remove once we have only 1 alias per env
		}).Only(ctx)

	notFound := models.IsNotFound(err)
	if notFound {
		return nil, nil, fmt.Errorf("template '%s' not found: %w", aliasOrEnvID, err)
	} else if err != nil {
		return nil, nil, fmt.Errorf("failed to get template '%s': %w", aliasOrEnvID, err)
	}

	build, err = db.Client.EnvBuild.Query().Where(envbuild.EnvID(template.ID), envbuild.StatusEQ(envbuild.StatusUploaded)).Order(models.Desc(envbuild.FieldFinishedAt)).First(ctx)
	notFound = models.IsNotFound(err)
	if notFound {
		return nil, nil, fmt.Errorf("build for '%s' not found: %w", aliasOrEnvID, err)
	} else if err != nil {
		return nil, nil, fmt.Errorf("failed to get template build '%s': %w", aliasOrEnvID, err)
	}

	aliases := make([]string, len(template.Edges.EnvAliases))
	for i, alias := range template.Edges.EnvAliases {
		aliases[i] = alias.ID
	}

	return &Template{
		TemplateID:    template.ID,
		BuildID:       build.ID.String(),
		VCPU:          build.Vcpu,
		RAMMB:         build.RAMMB,
		DiskMB:        build.FreeDiskSizeMB,
		Public:        template.Public,
		Aliases:       &aliases,
		TeamID:        template.TeamID,
		CreatedAt:     template.CreatedAt,
		UpdatedAt:     template.UpdatedAt,
		LastSpawnedAt: template.LastSpawnedAt,
		SpawnCount:    template.SpawnCount,
		BuildCount:    template.BuildCount,
	}, build, nil
}

func (db *DB) CheckBaseEnvHasSnapshots(ctx context.Context, envID string) (result bool, err error) {
	result, err = db.Client.Snapshot.Query().Where(snapshot.BaseEnvID(envID)).Exist(ctx)
	if err != nil {
		return false, fmt.Errorf("failed to check if base env has snapshots for '%s': %w", envID, err)
	}

	return result, nil
}

func (db *DB) FinishEnvBuild(
	ctx context.Context,
	envID string,
	buildID uuid.UUID,
	totalDiskSizeMB int64,
	envdVersion string,
) error {
	err := db.Client.EnvBuild.Update().Where(envbuild.ID(buildID), envbuild.EnvID(envID)).
		SetFinishedAt(time.Now()).
		SetTotalDiskSizeMB(totalDiskSizeMB).
		SetStatus(envbuild.StatusUploaded).
		SetEnvdVersion(envdVersion).
		Exec(ctx)
	if err != nil {
		return fmt.Errorf("failed to finish template build '%s': %w", buildID, err)
	}

	return nil
}

func (db *DB) EnvBuildSetStatus(
	ctx context.Context,
	envID string,
	buildID uuid.UUID,
	status envbuild.Status,
) error {
	err := db.Client.EnvBuild.Update().Where(envbuild.ID(buildID), envbuild.EnvID(envID)).
		SetStatus(status).SetFinishedAt(time.Now()).Exec(ctx)
	if err != nil {
		return fmt.Errorf("failed to set template build status %s for '%s': %w", status, buildID, err)
	}

	return nil
}

func (db *DB) UpdateEnvLastUsed(ctx context.Context, count int64, time time.Time, envID string) (err error) {
	return db.Client.Env.UpdateOneID(envID).AddSpawnCount(count).SetLastSpawnedAt(time).Exec(ctx)
}



================================================
File: db/errors.go
================================================
package db

type ErrNotFound error
type TemplateNotFound struct{ ErrNotFound }

func (TemplateNotFound) Error() string {
	return "Template not found"
}

type SnapshotNotFound struct{ ErrNotFound }

func (SnapshotNotFound) Error() string {
	return "Snapshot not found"
}

type BuildNotFound struct{ ErrNotFound }

func (BuildNotFound) Error() string {
	return "Build not found"
}

type EnvNotFound struct{ ErrNotFound }

func (EnvNotFound) Error() string {
	return "Env not found"
}



================================================
File: db/snapshot.go
================================================
package db

import (
	"context"
	"fmt"

	"github.com/google/uuid"

	"github.com/e2b-dev/infra/packages/shared/pkg/id"
	"github.com/e2b-dev/infra/packages/shared/pkg/models"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envbuild"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/snapshot"
)

type SnapshotInfo struct {
	SandboxID          string
	BaseTemplateID     string
	VCPU               int64
	RAMMB              int64
	Metadata           map[string]string
	TotalDiskSizeMB    int64
	KernelVersion      string
	FirecrackerVersion string
	EnvdVersion        string
}

// Check if there exists snapshot with the ID, if yes then return a new
// snapshot and env build. Otherwise create a new one.
func (db *DB) NewSnapshotBuild(
	ctx context.Context,
	snapshotConfig *SnapshotInfo,
	teamID uuid.UUID,
) (*models.EnvBuild, error) {
	tx, err := db.Client.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to start transaction: %w", err)
	}
	defer tx.Rollback()

	s, err := tx.
		Snapshot.
		Query().
		Where(
			snapshot.SandboxID(snapshotConfig.SandboxID),
			snapshot.HasEnvWith(env.TeamID(teamID)),
		).
		WithEnv().
		Only(ctx)

	notFound := models.IsNotFound(err)

	if err != nil && !notFound {
		return nil, fmt.Errorf("failed to get snapshot '%s': %w", snapshotConfig.SandboxID, err)
	}

	var e *models.Env

	if notFound {
		envID := id.Generate()

		e, err = tx.
			Env.
			Create().
			SetPublic(false).
			SetNillableCreatedBy(nil).
			SetTeamID(teamID).
			SetID(envID).
			Save(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to create env '%s': %w", snapshotConfig.SandboxID, err)
		}

		s, err = tx.
			Snapshot.
			Create().
			SetSandboxID(snapshotConfig.SandboxID).
			SetBaseEnvID(snapshotConfig.BaseTemplateID).
			SetEnv(e).
			SetMetadata(snapshotConfig.Metadata).
			Save(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to create snapshot '%s': %w", snapshotConfig.SandboxID, err)
		}
	} else {
		e = s.Edges.Env
		// Update existing snapshot with new metadata and pause time
		s, err = tx.
			Snapshot.
			UpdateOne(s).
			SetMetadata(snapshotConfig.Metadata).
			Save(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to update snapshot '%s': %w", snapshotConfig.SandboxID, err)
		}
	}

	b, err := tx.
		EnvBuild.
		Create().
		SetEnv(e).
		SetVcpu(snapshotConfig.VCPU).
		SetRAMMB(snapshotConfig.RAMMB).
		SetFreeDiskSizeMB(0).
		SetKernelVersion(snapshotConfig.KernelVersion).
		SetFirecrackerVersion(snapshotConfig.FirecrackerVersion).
		SetEnvdVersion(snapshotConfig.EnvdVersion).
		SetStatus(envbuild.StatusBuilding).
		SetTotalDiskSizeMB(snapshotConfig.TotalDiskSizeMB).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create env build '%s': %w", snapshotConfig.SandboxID, err)
	}

	err = tx.Commit()
	if err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return b, nil
}

func (db *DB) GetLastSnapshot(ctx context.Context, sandboxID string, teamID uuid.UUID) (
	*models.Snapshot,
	*models.EnvBuild,
	error,
) {

	snap, err := db.Client.Snapshot.Query().Where(snapshot.SandboxID(sandboxID)).Only(ctx)
	if err != nil {
		notFound := models.IsNotFound(err)

		if notFound {
			return nil, nil, SnapshotNotFound{}
		} else {
			return nil, nil, fmt.Errorf("failed to get snapshot for '%s': %w", sandboxID, err)
		}
	}

	build, err := db.Client.EnvBuild.Query().Where(envbuild.StatusEQ(envbuild.StatusSuccess), envbuild.EnvID(snap.EnvID)).Order(models.Desc(envbuild.FieldFinishedAt)).First(ctx)
	if err != nil {
		notFound := models.IsNotFound(err)

		if notFound {
			return snap, nil, BuildNotFound{}
		} else {
			return nil, nil, fmt.Errorf("failed to get build for '%s': %w", sandboxID, err)
		}
	}

	_, err = db.
		Client.
		Env.
		Query().
		Where(
			env.ID(snap.EnvID),
			env.TeamID(teamID),
		).Only(ctx)
	if err != nil {
		notFound := models.IsNotFound(err)

		if notFound {
			return nil, nil, TemplateNotFound{}
		} else {
			return nil, nil, fmt.Errorf("failed to get template for '%s': %w", sandboxID, err)
		}
	}

	return snap, build, nil
}

func (db *DB) GetSnapshotBuilds(ctx context.Context, sandboxID string, teamID uuid.UUID) (
	*models.Env,
	[]*models.EnvBuild,
	error,
) {
	e, err := db.
		Client.
		Env.
		Query().
		Where(
			env.HasSnapshotsWith(snapshot.SandboxID(sandboxID)),
			env.TeamID(teamID),
		).
		WithBuilds().
		Only(ctx)

	notFound := models.IsNotFound(err)

	if notFound {
		return nil, nil, EnvNotFound{}
	}

	if err != nil {
		return nil, nil, fmt.Errorf("failed to get snapshot build for '%s': %w", sandboxID, err)
	}

	return e, e.Edges.Builds, nil
}



================================================
File: db/users.go
================================================
package db

import (
	"context"
	"fmt"

	"github.com/google/uuid"

	"github.com/e2b-dev/infra/packages/shared/pkg/models"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"
)

func (db *DB) GetTeams(ctx context.Context, userID uuid.UUID) ([]*models.Team, error) {
	t, err := db.
		Client.
		Team.
		Query().
		Where(team.HasUsersWith(user.ID(userID))).
		WithTeamTier().
		WithUsersTeams(func(query *models.UsersTeamsQuery) {
			query.Where(usersteams.UserID(userID))
		}).
		All(ctx)

	if err != nil {
		errMsg := fmt.Errorf("failed to get default team from user: %w", err)

		return nil, errMsg
	}

	return t, nil
}



================================================
File: fc/firecracker.yml
================================================
swagger: "2.0"
info:
  title: Firecracker API
  description: RESTful public-facing API.
    The API is accessible through HTTP calls on specific URLs
    carrying JSON modeled data.
    The transport medium is a Unix Domain Socket.
  version: 1.7.0-dev
  termsOfService: ""
  contact:
    email: "compute-capsule@amazon.com"
  license:
    name: "Apache 2.0"
    url: "http://www.apache.org/licenses/LICENSE-2.0.html"

host: "localhost"
basePath: "/"

schemes:
  - http
consumes:
  - application/json
produces:
  - application/json

paths:
  /:
    get:
      summary: Returns general information about an instance.
      operationId: describeInstance
      responses:
        200:
          description: The instance information
          schema:
            $ref: "#/definitions/InstanceInfo"
        default:
          description: Internal Server Error
          schema:
            $ref: "#/definitions/Error"

  /actions:
    put:
      summary: Creates a synchronous action.
      operationId: createSyncAction
      parameters:
        - name: info
          in: body
          required: true
          schema:
            $ref: "#/definitions/InstanceActionInfo"
      responses:
        204:
          description: The update was successful
        400:
          description: The action cannot be executed due to bad input
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal Server Error
          schema:
            $ref: "#/definitions/Error"

  /balloon:
    get:
      summary: Returns the current balloon device configuration.
      operationId: describeBalloonConfig
      responses:
        200:
          description: The balloon device configuration
          schema:
            $ref: "#/definitions/Balloon"
        400:
          description: Balloon device not configured.
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal Server Error
          schema:
            $ref: "#/definitions/Error"
    put:
      summary: Creates or updates a balloon device.
      description:
        Creates a new balloon device if one does not already exist, otherwise updates it, before machine startup.
        This will fail after machine startup.
        Will fail if update is not possible.
      operationId: putBalloon
      parameters:
        - name: body
          in: body
          description: Balloon properties
          required: true
          schema:
            $ref: "#/definitions/Balloon"
      responses:
        204:
          description: Balloon device created/updated
        400:
          description: Balloon device cannot be created/updated due to bad input
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"
    patch:
      summary: Updates a balloon device.
      description:
        Updates an existing balloon device, before or after machine startup.
        Will fail if update is not possible.
      operationId: patchBalloon
      parameters:
        - name: body
          in: body
          description: Balloon properties
          required: true
          schema:
            $ref: "#/definitions/BalloonUpdate"
      responses:
        204:
          description: Balloon device updated
        400:
          description: Balloon device cannot be updated due to bad input
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

  /balloon/statistics:
    get:
      summary: Returns the latest balloon device statistics, only if enabled pre-boot.
      operationId: describeBalloonStats
      responses:
        200:
          description: The balloon device statistics
          schema:
            $ref: "#/definitions/BalloonStats"
        400:
          description: The balloon device statistics were not enabled when the device was configured.
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal Server Error
          schema:
            $ref: "#/definitions/Error"
    patch:
      summary: Updates a balloon device statistics polling interval.
      description:
        Updates an existing balloon device statistics interval, before or after machine startup.
        Will fail if update is not possible.
      operationId: patchBalloonStatsInterval
      parameters:
        - name: body
          in: body
          description: Balloon properties
          required: true
          schema:
            $ref: "#/definitions/BalloonStatsUpdate"
      responses:
        204:
          description: Balloon statistics interval updated
        400:
          description: Balloon statistics interval cannot be updated due to bad input
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

  /boot-source:
    put:
      summary: Creates or updates the boot source. Pre-boot only.
      description:
        Creates new boot source if one does not already exist, otherwise updates it.
        Will fail if update is not possible.
      operationId: putGuestBootSource
      parameters:
        - name: body
          in: body
          description: Guest boot source properties
          required: true
          schema:
            $ref: "#/definitions/BootSource"
      responses:
        204:
          description: Boot source created/updated
        400:
          description: Boot source cannot be created due to bad input
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

  /cpu-config:
    put:
      summary: Configures CPU features flags for the vCPUs of the guest VM. Pre-boot only.
      description:
        Provides configuration to the Firecracker process to specify vCPU resource configuration prior to
        launching the guest machine.
      operationId: putCpuConfiguration
      parameters:
        - name: body
          in: body
          description: CPU configuration request
          schema:
            $ref: "#/definitions/CpuConfig"
      responses:
        204:
          description: CPU configuration set successfully
        400:
          description: CPU configuration cannot be updated due to invalid input format
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

  /drives/{drive_id}:
    put:
      summary: Creates or updates a drive. Pre-boot only.
      description:
        Creates new drive with ID specified by drive_id path parameter.
        If a drive with the specified ID already exists, updates its state based on new input.
        Will fail if update is not possible.
      operationId: putGuestDriveByID
      parameters:
        - name: drive_id
          in: path
          description: The id of the guest drive
          required: true
          type: string
        - name: body
          in: body
          description: Guest drive properties
          required: true
          schema:
            $ref: "#/definitions/Drive"
      responses:
        204:
          description: Drive created/updated
        400:
          description: Drive cannot be created/updated due to bad input
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error.
          schema:
            $ref: "#/definitions/Error"
    patch:
      summary: Updates the properties of a drive. Post-boot only.
      description:
        Updates the properties of the drive with the ID specified by drive_id path parameter.
        Will fail if update is not possible.
      operationId: patchGuestDriveByID
      parameters:
        - name: drive_id
          in: path
          description: The id of the guest drive
          required: true
          type: string
        - name: body
          in: body
          description: Guest drive properties
          required: true
          schema:
            $ref: "#/definitions/PartialDrive"
      responses:
        204:
          description: Drive updated
        400:
          description: Drive cannot be updated due to bad input
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error.
          schema:
            $ref: "#/definitions/Error"

  /logger:
    put:
      summary: Initializes the logger by specifying a named pipe or a file for the logs output.
      operationId: putLogger
      parameters:
        - name: body
          in: body
          description: Logging system description
          required: true
          schema:
            $ref: "#/definitions/Logger"
      responses:
        204:
          description: Logger created.
        400:
          description: Logger cannot be initialized due to bad input.
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error.
          schema:
            $ref: "#/definitions/Error"

  /machine-config:
    get:
      summary: Gets the machine configuration of the VM.
      description:
        Gets the machine configuration of the VM. When called before the PUT operation, it
        will return the default values for the vCPU count (=1), memory size (=128 MiB).
        By default SMT is disabled and there is no CPU Template.
      operationId: getMachineConfiguration
      responses:
        200:
          description: OK
          schema:
            $ref: "#/definitions/MachineConfiguration"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

    put:
      summary: Updates the Machine Configuration of the VM. Pre-boot only.
      description:
        Updates the Virtual Machine Configuration with the specified input.
        Firecracker starts with default values for vCPU count (=1) and memory size (=128 MiB).
        The vCPU count is restricted to the [1, 32] range.
        With SMT enabled, the vCPU count is required to be either 1 or an even number in the range.
        otherwise there are no restrictions regarding the vCPU count.
        If 2M hugetlbfs pages are specified, then `mem_size_mib` must be a multiple of 2.
        If any of the parameters has an incorrect value, the whole update fails.
        All parameters that are optional and are not specified are set to their default values
        (smt = false, track_dirty_pages = false, cpu_template = None, huge_pages = None).
      operationId: putMachineConfiguration
      parameters:
        - name: body
          in: body
          description: Machine Configuration Parameters
          schema:
            $ref: "#/definitions/MachineConfiguration"
      responses:
        204:
          description: Machine Configuration created/updated
        400:
          description: Machine Configuration cannot be updated due to bad input
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

    patch:
      summary: Partially updates the Machine Configuration of the VM. Pre-boot only.
      description:
        Partially updates the Virtual Machine Configuration with the specified input.
        If any of the parameters has an incorrect value, the whole update fails.
      operationId: patchMachineConfiguration
      parameters:
        - name: body
          in: body
          description: A subset of Machine Configuration Parameters
          schema:
            $ref: "#/definitions/MachineConfiguration"
      responses:
        204:
          description: Machine Configuration created/updated
        400:
          description: Machine Configuration cannot be updated due to bad input
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

  /metrics:
    put:
      summary: Initializes the metrics system by specifying a named pipe or a file for the metrics output.
      operationId: putMetrics
      parameters:
        - name: body
          in: body
          description: Metrics system description
          required: true
          schema:
            $ref: "#/definitions/Metrics"
      responses:
        204:
          description: Metrics system created.
        400:
          description: Metrics system cannot be initialized due to bad input request or metrics system already initialized.
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error.
          schema:
            $ref: "#/definitions/Error"

  /mmds:
    put:
      summary: Creates a MMDS (Microvm Metadata Service) data store.
      operationId: putMmds
      parameters:
        - name: body
          in: body
          description: The MMDS data store as JSON.
          schema:
            $ref: "#/definitions/MmdsContentsObject"
      responses:
        204:
          description: MMDS data store created/updated.
        400:
          description: MMDS data store cannot be created due to bad input.
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"
    patch:
      summary: Updates the MMDS data store.
      operationId: patchMmds
      parameters:
        - name: body
          in: body
          description: The MMDS data store patch JSON.
          schema:
            $ref: "#/definitions/MmdsContentsObject"
      responses:
        204:
          description: MMDS data store updated.
        400:
          description: MMDS data store cannot be updated due to bad input.
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"
    get:
      summary: Get the MMDS data store.
      operationId: getMmds
      responses:
        200:
          description: The MMDS data store JSON.
          schema:
            type: object
        404:
          description: The MMDS data store content can not be found.
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

  /mmds/config:
    put:
      summary: Set MMDS configuration. Pre-boot only.
      operationId: putMmdsConfig
      description:
        Configures MMDS version, IPv4 address used by the MMDS network stack
        and interfaces that allow MMDS requests.
      parameters:
        - name: body
          in: body
          description: The MMDS configuration as JSON.
          required: true
          schema:
            $ref: "#/definitions/MmdsConfig"
      responses:
        204:
          description: MMDS configuration was created/updated.
        400:
          description: MMDS configuration cannot be updated due to bad input.
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

  /entropy:
    put:
      summary: Creates an entropy device. Pre-boot only.
      description: Enables an entropy device that provides high-quality random data to the guest.
      operationId: putEntropyDevice
      parameters:
        - name: body
          in: body
          description: Guest entropy device properties
          required: true
          schema:
            $ref: "#/definitions/EntropyDevice"
      responses:
        204:
          description: Entropy device created
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

  /network-interfaces/{iface_id}:
    put:
      summary: Creates a network interface. Pre-boot only.
      description: Creates new network interface with ID specified by iface_id path parameter.
      operationId: putGuestNetworkInterfaceByID
      parameters:
        - name: iface_id
          in: path
          description: The id of the guest network interface
          required: true
          type: string
        - name: body
          in: body
          description: Guest network interface properties
          required: true
          schema:
            $ref: "#/definitions/NetworkInterface"
      responses:
        204:
          description: Network interface created/updated
        400:
          description: Network interface cannot be created due to bad input
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"
    patch:
      summary: Updates the rate limiters applied to a network interface. Post-boot only.
      description: Updates the rate limiters applied to a network interface.
      operationId: patchGuestNetworkInterfaceByID
      parameters:
        - name: iface_id
          in: path
          description: The id of the guest network interface
          required: true
          type: string
        - name: body
          in: body
          description: A subset of the guest network interface properties
          required: true
          schema:
            $ref: "#/definitions/PartialNetworkInterface"
      responses:
        204:
          description: Network interface updated
        400:
          description: Network interface cannot be updated due to bad input
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

  /snapshot/create:
    put:
      summary: Creates a full or diff snapshot. Post-boot only.
      description:
        Creates a snapshot of the microVM state. The microVM should be
        in the `Paused` state.
      operationId: createSnapshot
      parameters:
        - name: body
          in: body
          description: The configuration used for creating a snaphot.
          required: true
          schema:
            $ref: "#/definitions/SnapshotCreateParams"
      responses:
        204:
          description: Snapshot created
        400:
          description: Snapshot cannot be created due to bad input
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

  /snapshot/load:
    put:
      summary: Loads a snapshot. Pre-boot only.
      description: Loads the microVM state from a snapshot.
        Only accepted on a fresh Firecracker process (before configuring
        any resource other than the Logger and Metrics).
      operationId: loadSnapshot
      parameters:
        - name: body
          in: body
          description: The configuration used for loading a snaphot.
          required: true
          schema:
            $ref: "#/definitions/SnapshotLoadParams"
      responses:
        204:
          description: Snapshot loaded
        400:
          description: Snapshot cannot be loaded due to bad input
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

  /version:
    get:
      summary: Gets the Firecracker version.
      operationId: getFirecrackerVersion
      responses:
        200:
          description: OK
          schema:
            $ref: "#/definitions/FirecrackerVersion"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

  /vm:
    patch:
      summary: Updates the microVM state.
      description: Sets the desired state (Paused or Resumed) for the microVM.
      operationId: patchVm
      parameters:
        - name: body
          in: body
          description: The microVM state
          required: true
          schema:
            $ref: "#/definitions/Vm"
      responses:
        204:
          description: Vm state updated
        400:
          description: Vm state cannot be updated due to bad input
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

  /vm/config:
    get:
      summary: Gets the full VM configuration.
      description:
        Gets configuration for all VM resources. If the VM is restored from a snapshot, the boot-source,
        machine-config.smt and machine-config.cpu_template will be empty.
      operationId: getExportVmConfig
      responses:
        200:
          description: OK
          schema:
            $ref: "#/definitions/FullVmConfiguration"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

  /vsock:
    put:
      summary: Creates/updates a vsock device. Pre-boot only.
      description:
        The first call creates the device with the configuration specified
        in body. Subsequent calls will update the device configuration.
        May fail if update is not possible.
      operationId: putGuestVsock
      parameters:
        - name: body
          in: body
          description: Guest vsock properties
          required: true
          schema:
            $ref: "#/definitions/Vsock"
      responses:
        204:
          description: Vsock created/updated
        400:
          description: Vsock cannot be created due to bad input
          schema:
            $ref: "#/definitions/Error"
        default:
          description: Internal server error
          schema:
            $ref: "#/definitions/Error"

definitions:
  Balloon:
    type: object
    required:
      - amount_mib
      - deflate_on_oom
    description: Balloon device descriptor.
    properties:
      amount_mib:
        type: integer
        description: Target balloon size in MiB.
      deflate_on_oom:
        type: boolean
        description: Whether the balloon should deflate when the guest has memory pressure.
      stats_polling_interval_s:
        type: integer
        description: Interval in seconds between refreshing statistics. A non-zero value will enable the statistics. Defaults to 0.

  BalloonUpdate:
    type: object
    required:
      - amount_mib
    description: Balloon device descriptor.
    properties:
      amount_mib:
        type: integer
        description: Target balloon size in MiB.

  BalloonStats:
    type: object
    description: Describes the balloon device statistics.
    required:
      - target_pages
      - actual_pages
      - target_mib
      - actual_mib
    properties:
      target_pages:
        description: Target number of pages the device aims to hold.
        type: integer
      actual_pages:
        description: Actual number of pages the device is holding.
        type: integer
      target_mib:
        description: Target amount of memory (in MiB) the device aims to hold.
        type: integer
      actual_mib:
        description: Actual amount of memory (in MiB) the device is holding.
        type: integer
      swap_in:
        description: The amount of memory that has been swapped in (in bytes).
        type: integer
        format: int64
      swap_out:
        description: The amount of memory that has been swapped out to disk (in bytes).
        type: integer
        format: int64
      major_faults:
        description: The number of major page faults that have occurred.
        type: integer
        format: int64
      minor_faults:
        description: The number of minor page faults that have occurred.
        type: integer
        format: int64
      free_memory:
        description: The amount of memory not being used for any purpose (in bytes).
        type: integer
        format: int64
      total_memory:
        description: The total amount of memory available (in bytes).
        type: integer
        format: int64
      available_memory:
        description: An estimate of how much memory is available (in bytes) for starting new applications, without pushing the system to swap.
        type: integer
        format: int64
      disk_caches:
        description: The amount of memory, in bytes, that can be quickly reclaimed without additional I/O. Typically these pages are used for caching files from disk.
        type: integer
        format: int64
      hugetlb_allocations:
        description: The number of successful hugetlb page allocations in the guest.
        type: integer
        format: int64
      hugetlb_failures:
        description: The number of failed hugetlb page allocations in the guest.
        type: integer
        format: int64

  BalloonStatsUpdate:
    type: object
    required:
      - stats_polling_interval_s
    description: Update the statistics polling interval, with the first statistics update scheduled immediately. Statistics cannot be turned on/off after boot.
    properties:
      stats_polling_interval_s:
        type: integer
        description: Interval in seconds between refreshing statistics.

  BootSource:
    type: object
    required:
      - kernel_image_path
    description: Boot source descriptor.
    properties:
      boot_args:
        type: string
        description: Kernel boot arguments
      initrd_path:
        type: string
        description: Host level path to the initrd image used to boot the guest
      kernel_image_path:
        type: string
        description: Host level path to the kernel image used to boot the guest

  CpuTemplate:
    type: string
    description:
      The CPU Template defines a set of flags to be disabled from the microvm so that
      the features exposed to the guest are the same as in the selected instance type.
      This parameter has been deprecated and it will be removed in future Firecracker
      release.
    enum:
      - C3
      - T2
      - T2S
      - T2CL
      - T2A
      - V1N1
      - None
    default: "None"

  CpuConfig:
    type: string
    description:
      The CPU configuration template defines a set of bit maps as modifiers of flags accessed by register
      to be disabled/enabled for the microvm.
    properties:
      cpuid_modifiers:
        type: object
        description: A collection of CPUIDs to be modified. (x86_64)
      msr_modifiers:
        type: object
        description: A collection of model specific registers to be modified. (x86_64)
      reg_modifiers:
        type: object
        description: A collection of registers to be modified. (aarch64)

  Drive:
    type: object
    required:
      - drive_id
      - is_root_device
    properties:
      drive_id:
        type: string
      partuuid:
        type: string
        description:
          Represents the unique id of the boot partition of this device. It is
          optional and it will be taken into account only if the is_root_device
          field is true.
      is_root_device:
        type: boolean
      cache_type:
        type: string
        description: Represents the caching strategy for the block device.
        enum: ["Unsafe", "Writeback"]
        default: "Unsafe"

      # VirtioBlock specific parameters
      is_read_only:
        type: boolean
        description: Is block read only.
          This field is required for virtio-block config and should be omitted for vhost-user-block configuration.
      path_on_host:
        type: string
        description: Host level path for the guest drive.
          This field is required for virtio-block config and should be omitted for vhost-user-block configuration.
      rate_limiter:
        $ref: "#/definitions/RateLimiter"
      io_engine:
        type: string
        description:
          Type of the IO engine used by the device. "Async" is supported on
          host kernels newer than 5.10.51.
          This field is optional for virtio-block config and should be omitted for vhost-user-block configuration.
        enum: ["Sync", "Async"]
        default: "Sync"

      # VhostUserBlock specific parameters
      socket:
        type: string
        description: Path to the socket of vhost-user-block backend.
          This field is required for vhost-user-block config should be omitted for virtio-block configuration.

  Error:
    type: object
    properties:
      fault_message:
        type: string
        description: A description of the error condition
        readOnly: true

  FullVmConfiguration:
    type: object
    properties:
      balloon:
        $ref: "#/definitions/Balloon"
      drives:
        type: array
        description: Configurations for all block devices.
        items:
          $ref: "#/definitions/Drive"
      boot-source:
        $ref: "#/definitions/BootSource"
      logger:
        $ref: "#/definitions/Logger"
      machine-config:
        $ref: "#/definitions/MachineConfiguration"
      metrics:
        $ref: "#/definitions/Metrics"
      mmds-config:
        $ref: "#/definitions/MmdsConfig"
      network-interfaces:
        type: array
        description: Configurations for all net devices.
        items:
          $ref: "#/definitions/NetworkInterface"
      vsock:
        $ref: "#/definitions/Vsock"

  InstanceActionInfo:
    type: object
    description: Variant wrapper containing the real action.
    required:
      - action_type
    properties:
      action_type:
        description: Enumeration indicating what type of action is contained in the payload
        type: string
        enum:
          - FlushMetrics
          - InstanceStart
          - SendCtrlAltDel

  InstanceInfo:
    type: object
    description: Describes MicroVM instance information.
    required:
      - app_name
      - id
      - state
      - vmm_version
    properties:
      app_name:
        description: Application name.
        type: string
      id:
        description: MicroVM / instance ID.
        type: string
      state:
        description:
          The current detailed state (Not started, Running, Paused) of the Firecracker instance.
          This value is read-only for the control-plane.
        type: string
        enum:
          - Not started
          - Running
          - Paused
      vmm_version:
        description: MicroVM hypervisor build version.
        type: string

  Logger:
    type: object
    description: Describes the configuration option for the logging capability.
    properties:
      level:
        type: string
        description: Set the level. The possible values are case-insensitive.
        enum: [Error, Warning, Info, Debug, Trace, Off]
        default: Info
      log_path:
        type: string
        description: Path to the named pipe or file for the human readable log output.
      show_level:
        type: boolean
        description: Whether or not to output the level in the logs.
        default: false
      show_log_origin:
        type: boolean
        description: Whether or not to include the file path and line number of the log's origin.
        default: false
      module:
        type: string
        description: The module path to filter log messages by.
        example: api_server::request

  MachineConfiguration:
    type: object
    description:
      Describes the number of vCPUs, memory size, SMT capabilities, huge page configuration and
      the CPU template.
    required:
      - mem_size_mib
      - vcpu_count
    properties:
      cpu_template:
        $ref: "#/definitions/CpuTemplate"
      smt:
        type: boolean
        description: Flag for enabling/disabling simultaneous multithreading. Can be enabled only on x86.
        default: false
      mem_size_mib:
        type: integer
        description: Memory size of VM
      track_dirty_pages:
        type: boolean
        description:
          Enable dirty page tracking. If this is enabled, then incremental guest memory
          snapshots can be created. These belong to diff snapshots, which contain, besides
          the microVM state, only the memory dirtied since a previous snapshot. Full snapshots
          each contain a full copy of the guest memory.
        default: false
      vcpu_count:
        type: integer
        minimum: 1
        maximum: 32
        description: Number of vCPUs (either 1 or an even number)
      huge_pages:
        type: string
        enum:
          - None
          - 2M
        description: Which huge pages configuration (if any) should be used to back guest memory.

  MemoryBackend:
    type: object
    required:
      - backend_type
      - backend_path
    properties:
      backend_type:
        type: string
        enum:
          - File
          - Uffd
      backend_path:
        type: string
        description: Based on 'backend_type' it is either
          1) Path to the file that contains the guest memory to be loaded
          2) Path to the UDS where a process is listening for a UFFD initialization
          control payload and open file descriptor that it can use to serve this
          process's guest memory page faults

  Metrics:
    type: object
    description: Describes the configuration option for the metrics capability.
    required:
      - metrics_path
    properties:
      metrics_path:
        type: string
        description: Path to the named pipe or file where the JSON-formatted metrics are flushed.

  MmdsConfig:
    type: object
    description: Defines the MMDS configuration.
    required:
      - network_interfaces
    properties:
      version:
        description: Enumeration indicating the MMDS version to be configured.
        type: string
        enum:
          - V1
          - V2
        default: V1
      network_interfaces:
        description:
          List of the network interface IDs capable of forwarding packets to
          the MMDS. Network interface IDs mentioned must be valid at the time
          of this request. The net device model will reply to HTTP GET requests
          sent to the MMDS address via the interfaces mentioned. In this
          case, both ARP requests and TCP segments heading to `ipv4_address`
          are intercepted by the device model, and do not reach the associated
          TAP device.
        type: array
        items:
          type: string
      ipv4_address:
        type: string
        format: "169.254.([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-4]).([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])"
        default: "169.254.169.254"
        description: A valid IPv4 link-local address.

  MmdsContentsObject:
    type: object
    description: Describes the contents of MMDS in JSON format.

  NetworkInterface:
    type: object
    description: Defines a network interface.
    required:
      - host_dev_name
      - iface_id
    properties:
      guest_mac:
        type: string
      host_dev_name:
        type: string
        description: Host level path for the guest network interface
      iface_id:
        type: string
      rx_rate_limiter:
        $ref: "#/definitions/RateLimiter"
      tx_rate_limiter:
        $ref: "#/definitions/RateLimiter"

  PartialDrive:
    type: object
    required:
      - drive_id
    properties:
      drive_id:
        type: string
      path_on_host:
        type: string
        description: Host level path for the guest drive.
          This field is optional for virtio-block config and should be omitted for vhost-user-block configuration.
      rate_limiter:
        $ref: "#/definitions/RateLimiter"

  PartialNetworkInterface:
    type: object
    description:
      Defines a partial network interface structure, used to update the rate limiters
      for that interface, after microvm start.
    required:
      - iface_id
    properties:
      iface_id:
        type: string
      rx_rate_limiter:
        $ref: "#/definitions/RateLimiter"
      tx_rate_limiter:
        $ref: "#/definitions/RateLimiter"

  RateLimiter:
    type: object
    description:
      Defines an IO rate limiter with independent bytes/s and ops/s limits.
      Limits are defined by configuring each of the _bandwidth_ and _ops_ token buckets.
      This field is optional for virtio-block config and should be omitted for vhost-user-block configuration.
    properties:
      bandwidth:
        $ref: "#/definitions/TokenBucket"
        description: Token bucket with bytes as tokens
      ops:
        $ref: "#/definitions/TokenBucket"
        description: Token bucket with operations as tokens

  SnapshotCreateParams:
    type: object
    required:
      - mem_file_path
      - snapshot_path
    properties:
      mem_file_path:
        type: string
        description: Path to the file that will contain the guest memory.
      snapshot_path:
        type: string
        description: Path to the file that will contain the microVM state.
      snapshot_type:
        type: string
        enum:
          - Full
          - Diff
        description:
          Type of snapshot to create. It is optional and by default, a full
          snapshot is created.

  SnapshotLoadParams:
    type: object
    description:
      Defines the configuration used for handling snapshot resume. Exactly one of
      the two `mem_*` fields must be present in the body of the request.
    required:
      - snapshot_path
    properties:
      enable_diff_snapshots:
        type: boolean
        description: Enable support for incremental (diff) snapshots by tracking dirty guest pages.
      mem_file_path:
        type: string
        description:
          Path to the file that contains the guest memory to be loaded.
          It is only allowed if `mem_backend` is not present. This parameter has
          been deprecated and it will be removed in future Firecracker release.
      mem_backend:
        $ref: "#/definitions/MemoryBackend"
        description:
          Configuration for the backend that handles memory load. If this field
          is specified, `mem_file_path` is forbidden. Either `mem_backend` or
          `mem_file_path` must be present at a time.
      snapshot_path:
        type: string
        description: Path to the file that contains the microVM state to be loaded.
      resume_vm:
        type: boolean
        description: When set to true, the vm is also resumed if the snapshot load is successful.

  TokenBucket:
    type: object
    description:
      Defines a token bucket with a maximum capacity (size), an initial burst size
      (one_time_burst) and an interval for refilling purposes (refill_time).
      The refill-rate is derived from size and refill_time, and it is the constant
      rate at which the tokens replenish. The refill process only starts happening after
      the initial burst budget is consumed.
      Consumption from the token bucket is unbounded in speed which allows for bursts
      bound in size by the amount of tokens available.
      Once the token bucket is empty, consumption speed is bound by the refill_rate.
    required:
      - refill_time
      - size
    properties:
      one_time_burst:
        type: integer
        format: int64
        description: The initial size of a token bucket.
        minimum: 0
      refill_time:
        type: integer
        format: int64
        description: The amount of milliseconds it takes for the bucket to refill.
        minimum: 0
      size:
        type: integer
        format: int64
        description: The total number of tokens this bucket can hold.
        minimum: 0

  Vm:
    type: object
    description: Defines the microVM running state. It is especially useful in the snapshotting context.
    required:
      - state
    properties:
      state:
        type: string
        enum:
          - Paused
          - Resumed

  EntropyDevice:
    type: object
    description: Defines an entropy device.
    properties:
      rate_limiter:
        $ref: "#/definitions/RateLimiter"

  FirecrackerVersion:
    type: object
    description: Describes the Firecracker version.
    required:
      - firecracker_version
    properties:
      firecracker_version:
        description: Firecracker build version.
        type: string

  Vsock:
    type: object
    description:
      Defines a vsock device, backed by a set of Unix Domain Sockets, on the host side.
      For host-initiated connections, Firecracker will be listening on the Unix socket
      identified by the path `uds_path`. Firecracker will create this socket, bind and
      listen on it. Host-initiated connections will be performed by connection to this
      socket and issuing a connection forwarding request to the desired guest-side vsock
      port (i.e. `CONNECT 52\n`, to connect to port 52).
      For guest-initiated connections, Firecracker will expect host software to be
      bound and listening on Unix sockets at `uds_path_<PORT>`.
      E.g. "/path/to/host_vsock.sock_52" for port number 52.
    required:
      - guest_cid
      - uds_path
    properties:
      guest_cid:
        type: integer
        minimum: 3
        description: Guest Vsock CID
      uds_path:
        type: string
        description: Path to UNIX domain socket, used to proxy vsock connections.
      vsock_id:
        type: string
        description:
          This parameter has been deprecated and it will be removed in future
          Firecracker release.



================================================
File: fc/client/firecracker_client.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package client

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/e2b-dev/infra/packages/shared/pkg/fc/client/operations"
	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// Default firecracker HTTP client.
var Default = NewHTTPClient(nil)

const (
	// DefaultHost is the default Host
	// found in Meta (info) section of spec file
	DefaultHost string = "localhost"
	// DefaultBasePath is the default BasePath
	// found in Meta (info) section of spec file
	DefaultBasePath string = "/"
)

// DefaultSchemes are the default schemes found in Meta (info) section of spec file
var DefaultSchemes = []string{"http"}

// NewHTTPClient creates a new firecracker HTTP client.
func NewHTTPClient(formats strfmt.Registry) *Firecracker {
	return NewHTTPClientWithConfig(formats, nil)
}

// NewHTTPClientWithConfig creates a new firecracker HTTP client,
// using a customizable transport config.
func NewHTTPClientWithConfig(formats strfmt.Registry, cfg *TransportConfig) *Firecracker {
	// ensure nullable parameters have default
	if cfg == nil {
		cfg = DefaultTransportConfig()
	}

	// create transport and client
	transport := httptransport.New(cfg.Host, cfg.BasePath, cfg.Schemes)
	return New(transport, formats)
}

// New creates a new firecracker client
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Firecracker {
	// ensure nullable parameters have default
	if formats == nil {
		formats = strfmt.Default
	}

	cli := new(Firecracker)
	cli.Transport = transport
	cli.Operations = operations.New(transport, formats)
	return cli
}

// DefaultTransportConfig creates a TransportConfig with the
// default settings taken from the meta section of the spec file.
func DefaultTransportConfig() *TransportConfig {
	return &TransportConfig{
		Host:     DefaultHost,
		BasePath: DefaultBasePath,
		Schemes:  DefaultSchemes,
	}
}

// TransportConfig contains the transport related info,
// found in the meta section of the spec file.
type TransportConfig struct {
	Host     string
	BasePath string
	Schemes  []string
}

// WithHost overrides the default host,
// provided by the meta section of the spec file.
func (cfg *TransportConfig) WithHost(host string) *TransportConfig {
	cfg.Host = host
	return cfg
}

// WithBasePath overrides the default basePath,
// provided by the meta section of the spec file.
func (cfg *TransportConfig) WithBasePath(basePath string) *TransportConfig {
	cfg.BasePath = basePath
	return cfg
}

// WithSchemes overrides the default schemes,
// provided by the meta section of the spec file.
func (cfg *TransportConfig) WithSchemes(schemes []string) *TransportConfig {
	cfg.Schemes = schemes
	return cfg
}

// Firecracker is a client for firecracker
type Firecracker struct {
	Operations operations.ClientService

	Transport runtime.ClientTransport
}

// SetTransport changes the transport on the client and all its subresources
func (c *Firecracker) SetTransport(transport runtime.ClientTransport) {
	c.Transport = transport
	c.Operations.SetTransport(transport)
}



================================================
File: fc/client/operations/create_snapshot_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewCreateSnapshotParams creates a new CreateSnapshotParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewCreateSnapshotParams() *CreateSnapshotParams {
	return &CreateSnapshotParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewCreateSnapshotParamsWithTimeout creates a new CreateSnapshotParams object
// with the ability to set a timeout on a request.
func NewCreateSnapshotParamsWithTimeout(timeout time.Duration) *CreateSnapshotParams {
	return &CreateSnapshotParams{
		timeout: timeout,
	}
}

// NewCreateSnapshotParamsWithContext creates a new CreateSnapshotParams object
// with the ability to set a context for a request.
func NewCreateSnapshotParamsWithContext(ctx context.Context) *CreateSnapshotParams {
	return &CreateSnapshotParams{
		Context: ctx,
	}
}

// NewCreateSnapshotParamsWithHTTPClient creates a new CreateSnapshotParams object
// with the ability to set a custom HTTPClient for a request.
func NewCreateSnapshotParamsWithHTTPClient(client *http.Client) *CreateSnapshotParams {
	return &CreateSnapshotParams{
		HTTPClient: client,
	}
}

/*
CreateSnapshotParams contains all the parameters to send to the API endpoint

	for the create snapshot operation.

	Typically these are written to a http.Request.
*/
type CreateSnapshotParams struct {

	/* Body.

	   The configuration used for creating a snaphot.
	*/
	Body *models.SnapshotCreateParams

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the create snapshot params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *CreateSnapshotParams) WithDefaults() *CreateSnapshotParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the create snapshot params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *CreateSnapshotParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the create snapshot params
func (o *CreateSnapshotParams) WithTimeout(timeout time.Duration) *CreateSnapshotParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the create snapshot params
func (o *CreateSnapshotParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the create snapshot params
func (o *CreateSnapshotParams) WithContext(ctx context.Context) *CreateSnapshotParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the create snapshot params
func (o *CreateSnapshotParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the create snapshot params
func (o *CreateSnapshotParams) WithHTTPClient(client *http.Client) *CreateSnapshotParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the create snapshot params
func (o *CreateSnapshotParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the create snapshot params
func (o *CreateSnapshotParams) WithBody(body *models.SnapshotCreateParams) *CreateSnapshotParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the create snapshot params
func (o *CreateSnapshotParams) SetBody(body *models.SnapshotCreateParams) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *CreateSnapshotParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/create_snapshot_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// CreateSnapshotReader is a Reader for the CreateSnapshot structure.
type CreateSnapshotReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *CreateSnapshotReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewCreateSnapshotNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewCreateSnapshotBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewCreateSnapshotDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewCreateSnapshotNoContent creates a CreateSnapshotNoContent with default headers values
func NewCreateSnapshotNoContent() *CreateSnapshotNoContent {
	return &CreateSnapshotNoContent{}
}

/*
CreateSnapshotNoContent describes a response with status code 204, with default header values.

Snapshot created
*/
type CreateSnapshotNoContent struct {
}

// IsSuccess returns true when this create snapshot no content response has a 2xx status code
func (o *CreateSnapshotNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this create snapshot no content response has a 3xx status code
func (o *CreateSnapshotNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create snapshot no content response has a 4xx status code
func (o *CreateSnapshotNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this create snapshot no content response has a 5xx status code
func (o *CreateSnapshotNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this create snapshot no content response a status code equal to that given
func (o *CreateSnapshotNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the create snapshot no content response
func (o *CreateSnapshotNoContent) Code() int {
	return 204
}

func (o *CreateSnapshotNoContent) Error() string {
	return fmt.Sprintf("[PUT /snapshot/create][%d] createSnapshotNoContent ", 204)
}

func (o *CreateSnapshotNoContent) String() string {
	return fmt.Sprintf("[PUT /snapshot/create][%d] createSnapshotNoContent ", 204)
}

func (o *CreateSnapshotNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewCreateSnapshotBadRequest creates a CreateSnapshotBadRequest with default headers values
func NewCreateSnapshotBadRequest() *CreateSnapshotBadRequest {
	return &CreateSnapshotBadRequest{}
}

/*
CreateSnapshotBadRequest describes a response with status code 400, with default header values.

Snapshot cannot be created due to bad input
*/
type CreateSnapshotBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this create snapshot bad request response has a 2xx status code
func (o *CreateSnapshotBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create snapshot bad request response has a 3xx status code
func (o *CreateSnapshotBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create snapshot bad request response has a 4xx status code
func (o *CreateSnapshotBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this create snapshot bad request response has a 5xx status code
func (o *CreateSnapshotBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this create snapshot bad request response a status code equal to that given
func (o *CreateSnapshotBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the create snapshot bad request response
func (o *CreateSnapshotBadRequest) Code() int {
	return 400
}

func (o *CreateSnapshotBadRequest) Error() string {
	return fmt.Sprintf("[PUT /snapshot/create][%d] createSnapshotBadRequest  %+v", 400, o.Payload)
}

func (o *CreateSnapshotBadRequest) String() string {
	return fmt.Sprintf("[PUT /snapshot/create][%d] createSnapshotBadRequest  %+v", 400, o.Payload)
}

func (o *CreateSnapshotBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *CreateSnapshotBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateSnapshotDefault creates a CreateSnapshotDefault with default headers values
func NewCreateSnapshotDefault(code int) *CreateSnapshotDefault {
	return &CreateSnapshotDefault{
		_statusCode: code,
	}
}

/*
CreateSnapshotDefault describes a response with status code -1, with default header values.

Internal server error
*/
type CreateSnapshotDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this create snapshot default response has a 2xx status code
func (o *CreateSnapshotDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this create snapshot default response has a 3xx status code
func (o *CreateSnapshotDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this create snapshot default response has a 4xx status code
func (o *CreateSnapshotDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this create snapshot default response has a 5xx status code
func (o *CreateSnapshotDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this create snapshot default response a status code equal to that given
func (o *CreateSnapshotDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the create snapshot default response
func (o *CreateSnapshotDefault) Code() int {
	return o._statusCode
}

func (o *CreateSnapshotDefault) Error() string {
	return fmt.Sprintf("[PUT /snapshot/create][%d] createSnapshot default  %+v", o._statusCode, o.Payload)
}

func (o *CreateSnapshotDefault) String() string {
	return fmt.Sprintf("[PUT /snapshot/create][%d] createSnapshot default  %+v", o._statusCode, o.Payload)
}

func (o *CreateSnapshotDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *CreateSnapshotDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/create_sync_action_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewCreateSyncActionParams creates a new CreateSyncActionParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewCreateSyncActionParams() *CreateSyncActionParams {
	return &CreateSyncActionParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewCreateSyncActionParamsWithTimeout creates a new CreateSyncActionParams object
// with the ability to set a timeout on a request.
func NewCreateSyncActionParamsWithTimeout(timeout time.Duration) *CreateSyncActionParams {
	return &CreateSyncActionParams{
		timeout: timeout,
	}
}

// NewCreateSyncActionParamsWithContext creates a new CreateSyncActionParams object
// with the ability to set a context for a request.
func NewCreateSyncActionParamsWithContext(ctx context.Context) *CreateSyncActionParams {
	return &CreateSyncActionParams{
		Context: ctx,
	}
}

// NewCreateSyncActionParamsWithHTTPClient creates a new CreateSyncActionParams object
// with the ability to set a custom HTTPClient for a request.
func NewCreateSyncActionParamsWithHTTPClient(client *http.Client) *CreateSyncActionParams {
	return &CreateSyncActionParams{
		HTTPClient: client,
	}
}

/*
CreateSyncActionParams contains all the parameters to send to the API endpoint

	for the create sync action operation.

	Typically these are written to a http.Request.
*/
type CreateSyncActionParams struct {

	// Info.
	Info *models.InstanceActionInfo

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the create sync action params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *CreateSyncActionParams) WithDefaults() *CreateSyncActionParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the create sync action params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *CreateSyncActionParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the create sync action params
func (o *CreateSyncActionParams) WithTimeout(timeout time.Duration) *CreateSyncActionParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the create sync action params
func (o *CreateSyncActionParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the create sync action params
func (o *CreateSyncActionParams) WithContext(ctx context.Context) *CreateSyncActionParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the create sync action params
func (o *CreateSyncActionParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the create sync action params
func (o *CreateSyncActionParams) WithHTTPClient(client *http.Client) *CreateSyncActionParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the create sync action params
func (o *CreateSyncActionParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithInfo adds the info to the create sync action params
func (o *CreateSyncActionParams) WithInfo(info *models.InstanceActionInfo) *CreateSyncActionParams {
	o.SetInfo(info)
	return o
}

// SetInfo adds the info to the create sync action params
func (o *CreateSyncActionParams) SetInfo(info *models.InstanceActionInfo) {
	o.Info = info
}

// WriteToRequest writes these params to a swagger request
func (o *CreateSyncActionParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Info != nil {
		if err := r.SetBodyParam(o.Info); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/create_sync_action_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// CreateSyncActionReader is a Reader for the CreateSyncAction structure.
type CreateSyncActionReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *CreateSyncActionReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewCreateSyncActionNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewCreateSyncActionBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewCreateSyncActionDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewCreateSyncActionNoContent creates a CreateSyncActionNoContent with default headers values
func NewCreateSyncActionNoContent() *CreateSyncActionNoContent {
	return &CreateSyncActionNoContent{}
}

/*
CreateSyncActionNoContent describes a response with status code 204, with default header values.

The update was successful
*/
type CreateSyncActionNoContent struct {
}

// IsSuccess returns true when this create sync action no content response has a 2xx status code
func (o *CreateSyncActionNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this create sync action no content response has a 3xx status code
func (o *CreateSyncActionNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create sync action no content response has a 4xx status code
func (o *CreateSyncActionNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this create sync action no content response has a 5xx status code
func (o *CreateSyncActionNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this create sync action no content response a status code equal to that given
func (o *CreateSyncActionNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the create sync action no content response
func (o *CreateSyncActionNoContent) Code() int {
	return 204
}

func (o *CreateSyncActionNoContent) Error() string {
	return fmt.Sprintf("[PUT /actions][%d] createSyncActionNoContent ", 204)
}

func (o *CreateSyncActionNoContent) String() string {
	return fmt.Sprintf("[PUT /actions][%d] createSyncActionNoContent ", 204)
}

func (o *CreateSyncActionNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewCreateSyncActionBadRequest creates a CreateSyncActionBadRequest with default headers values
func NewCreateSyncActionBadRequest() *CreateSyncActionBadRequest {
	return &CreateSyncActionBadRequest{}
}

/*
CreateSyncActionBadRequest describes a response with status code 400, with default header values.

The action cannot be executed due to bad input
*/
type CreateSyncActionBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this create sync action bad request response has a 2xx status code
func (o *CreateSyncActionBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create sync action bad request response has a 3xx status code
func (o *CreateSyncActionBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create sync action bad request response has a 4xx status code
func (o *CreateSyncActionBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this create sync action bad request response has a 5xx status code
func (o *CreateSyncActionBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this create sync action bad request response a status code equal to that given
func (o *CreateSyncActionBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the create sync action bad request response
func (o *CreateSyncActionBadRequest) Code() int {
	return 400
}

func (o *CreateSyncActionBadRequest) Error() string {
	return fmt.Sprintf("[PUT /actions][%d] createSyncActionBadRequest  %+v", 400, o.Payload)
}

func (o *CreateSyncActionBadRequest) String() string {
	return fmt.Sprintf("[PUT /actions][%d] createSyncActionBadRequest  %+v", 400, o.Payload)
}

func (o *CreateSyncActionBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *CreateSyncActionBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateSyncActionDefault creates a CreateSyncActionDefault with default headers values
func NewCreateSyncActionDefault(code int) *CreateSyncActionDefault {
	return &CreateSyncActionDefault{
		_statusCode: code,
	}
}

/*
CreateSyncActionDefault describes a response with status code -1, with default header values.

Internal Server Error
*/
type CreateSyncActionDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this create sync action default response has a 2xx status code
func (o *CreateSyncActionDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this create sync action default response has a 3xx status code
func (o *CreateSyncActionDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this create sync action default response has a 4xx status code
func (o *CreateSyncActionDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this create sync action default response has a 5xx status code
func (o *CreateSyncActionDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this create sync action default response a status code equal to that given
func (o *CreateSyncActionDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the create sync action default response
func (o *CreateSyncActionDefault) Code() int {
	return o._statusCode
}

func (o *CreateSyncActionDefault) Error() string {
	return fmt.Sprintf("[PUT /actions][%d] createSyncAction default  %+v", o._statusCode, o.Payload)
}

func (o *CreateSyncActionDefault) String() string {
	return fmt.Sprintf("[PUT /actions][%d] createSyncAction default  %+v", o._statusCode, o.Payload)
}

func (o *CreateSyncActionDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *CreateSyncActionDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/describe_balloon_config_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// NewDescribeBalloonConfigParams creates a new DescribeBalloonConfigParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewDescribeBalloonConfigParams() *DescribeBalloonConfigParams {
	return &DescribeBalloonConfigParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewDescribeBalloonConfigParamsWithTimeout creates a new DescribeBalloonConfigParams object
// with the ability to set a timeout on a request.
func NewDescribeBalloonConfigParamsWithTimeout(timeout time.Duration) *DescribeBalloonConfigParams {
	return &DescribeBalloonConfigParams{
		timeout: timeout,
	}
}

// NewDescribeBalloonConfigParamsWithContext creates a new DescribeBalloonConfigParams object
// with the ability to set a context for a request.
func NewDescribeBalloonConfigParamsWithContext(ctx context.Context) *DescribeBalloonConfigParams {
	return &DescribeBalloonConfigParams{
		Context: ctx,
	}
}

// NewDescribeBalloonConfigParamsWithHTTPClient creates a new DescribeBalloonConfigParams object
// with the ability to set a custom HTTPClient for a request.
func NewDescribeBalloonConfigParamsWithHTTPClient(client *http.Client) *DescribeBalloonConfigParams {
	return &DescribeBalloonConfigParams{
		HTTPClient: client,
	}
}

/*
DescribeBalloonConfigParams contains all the parameters to send to the API endpoint

	for the describe balloon config operation.

	Typically these are written to a http.Request.
*/
type DescribeBalloonConfigParams struct {
	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the describe balloon config params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *DescribeBalloonConfigParams) WithDefaults() *DescribeBalloonConfigParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the describe balloon config params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *DescribeBalloonConfigParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the describe balloon config params
func (o *DescribeBalloonConfigParams) WithTimeout(timeout time.Duration) *DescribeBalloonConfigParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the describe balloon config params
func (o *DescribeBalloonConfigParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the describe balloon config params
func (o *DescribeBalloonConfigParams) WithContext(ctx context.Context) *DescribeBalloonConfigParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the describe balloon config params
func (o *DescribeBalloonConfigParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the describe balloon config params
func (o *DescribeBalloonConfigParams) WithHTTPClient(client *http.Client) *DescribeBalloonConfigParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the describe balloon config params
func (o *DescribeBalloonConfigParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WriteToRequest writes these params to a swagger request
func (o *DescribeBalloonConfigParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/describe_balloon_config_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// DescribeBalloonConfigReader is a Reader for the DescribeBalloonConfig structure.
type DescribeBalloonConfigReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *DescribeBalloonConfigReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewDescribeBalloonConfigOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewDescribeBalloonConfigBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewDescribeBalloonConfigDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewDescribeBalloonConfigOK creates a DescribeBalloonConfigOK with default headers values
func NewDescribeBalloonConfigOK() *DescribeBalloonConfigOK {
	return &DescribeBalloonConfigOK{}
}

/*
DescribeBalloonConfigOK describes a response with status code 200, with default header values.

The balloon device configuration
*/
type DescribeBalloonConfigOK struct {
	Payload *models.Balloon
}

// IsSuccess returns true when this describe balloon config o k response has a 2xx status code
func (o *DescribeBalloonConfigOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this describe balloon config o k response has a 3xx status code
func (o *DescribeBalloonConfigOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this describe balloon config o k response has a 4xx status code
func (o *DescribeBalloonConfigOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this describe balloon config o k response has a 5xx status code
func (o *DescribeBalloonConfigOK) IsServerError() bool {
	return false
}

// IsCode returns true when this describe balloon config o k response a status code equal to that given
func (o *DescribeBalloonConfigOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the describe balloon config o k response
func (o *DescribeBalloonConfigOK) Code() int {
	return 200
}

func (o *DescribeBalloonConfigOK) Error() string {
	return fmt.Sprintf("[GET /balloon][%d] describeBalloonConfigOK  %+v", 200, o.Payload)
}

func (o *DescribeBalloonConfigOK) String() string {
	return fmt.Sprintf("[GET /balloon][%d] describeBalloonConfigOK  %+v", 200, o.Payload)
}

func (o *DescribeBalloonConfigOK) GetPayload() *models.Balloon {
	return o.Payload
}

func (o *DescribeBalloonConfigOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Balloon)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewDescribeBalloonConfigBadRequest creates a DescribeBalloonConfigBadRequest with default headers values
func NewDescribeBalloonConfigBadRequest() *DescribeBalloonConfigBadRequest {
	return &DescribeBalloonConfigBadRequest{}
}

/*
DescribeBalloonConfigBadRequest describes a response with status code 400, with default header values.

Balloon device not configured.
*/
type DescribeBalloonConfigBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this describe balloon config bad request response has a 2xx status code
func (o *DescribeBalloonConfigBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this describe balloon config bad request response has a 3xx status code
func (o *DescribeBalloonConfigBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this describe balloon config bad request response has a 4xx status code
func (o *DescribeBalloonConfigBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this describe balloon config bad request response has a 5xx status code
func (o *DescribeBalloonConfigBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this describe balloon config bad request response a status code equal to that given
func (o *DescribeBalloonConfigBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the describe balloon config bad request response
func (o *DescribeBalloonConfigBadRequest) Code() int {
	return 400
}

func (o *DescribeBalloonConfigBadRequest) Error() string {
	return fmt.Sprintf("[GET /balloon][%d] describeBalloonConfigBadRequest  %+v", 400, o.Payload)
}

func (o *DescribeBalloonConfigBadRequest) String() string {
	return fmt.Sprintf("[GET /balloon][%d] describeBalloonConfigBadRequest  %+v", 400, o.Payload)
}

func (o *DescribeBalloonConfigBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *DescribeBalloonConfigBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewDescribeBalloonConfigDefault creates a DescribeBalloonConfigDefault with default headers values
func NewDescribeBalloonConfigDefault(code int) *DescribeBalloonConfigDefault {
	return &DescribeBalloonConfigDefault{
		_statusCode: code,
	}
}

/*
DescribeBalloonConfigDefault describes a response with status code -1, with default header values.

Internal Server Error
*/
type DescribeBalloonConfigDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this describe balloon config default response has a 2xx status code
func (o *DescribeBalloonConfigDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this describe balloon config default response has a 3xx status code
func (o *DescribeBalloonConfigDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this describe balloon config default response has a 4xx status code
func (o *DescribeBalloonConfigDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this describe balloon config default response has a 5xx status code
func (o *DescribeBalloonConfigDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this describe balloon config default response a status code equal to that given
func (o *DescribeBalloonConfigDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the describe balloon config default response
func (o *DescribeBalloonConfigDefault) Code() int {
	return o._statusCode
}

func (o *DescribeBalloonConfigDefault) Error() string {
	return fmt.Sprintf("[GET /balloon][%d] describeBalloonConfig default  %+v", o._statusCode, o.Payload)
}

func (o *DescribeBalloonConfigDefault) String() string {
	return fmt.Sprintf("[GET /balloon][%d] describeBalloonConfig default  %+v", o._statusCode, o.Payload)
}

func (o *DescribeBalloonConfigDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *DescribeBalloonConfigDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/describe_balloon_stats_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// NewDescribeBalloonStatsParams creates a new DescribeBalloonStatsParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewDescribeBalloonStatsParams() *DescribeBalloonStatsParams {
	return &DescribeBalloonStatsParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewDescribeBalloonStatsParamsWithTimeout creates a new DescribeBalloonStatsParams object
// with the ability to set a timeout on a request.
func NewDescribeBalloonStatsParamsWithTimeout(timeout time.Duration) *DescribeBalloonStatsParams {
	return &DescribeBalloonStatsParams{
		timeout: timeout,
	}
}

// NewDescribeBalloonStatsParamsWithContext creates a new DescribeBalloonStatsParams object
// with the ability to set a context for a request.
func NewDescribeBalloonStatsParamsWithContext(ctx context.Context) *DescribeBalloonStatsParams {
	return &DescribeBalloonStatsParams{
		Context: ctx,
	}
}

// NewDescribeBalloonStatsParamsWithHTTPClient creates a new DescribeBalloonStatsParams object
// with the ability to set a custom HTTPClient for a request.
func NewDescribeBalloonStatsParamsWithHTTPClient(client *http.Client) *DescribeBalloonStatsParams {
	return &DescribeBalloonStatsParams{
		HTTPClient: client,
	}
}

/*
DescribeBalloonStatsParams contains all the parameters to send to the API endpoint

	for the describe balloon stats operation.

	Typically these are written to a http.Request.
*/
type DescribeBalloonStatsParams struct {
	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the describe balloon stats params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *DescribeBalloonStatsParams) WithDefaults() *DescribeBalloonStatsParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the describe balloon stats params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *DescribeBalloonStatsParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the describe balloon stats params
func (o *DescribeBalloonStatsParams) WithTimeout(timeout time.Duration) *DescribeBalloonStatsParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the describe balloon stats params
func (o *DescribeBalloonStatsParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the describe balloon stats params
func (o *DescribeBalloonStatsParams) WithContext(ctx context.Context) *DescribeBalloonStatsParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the describe balloon stats params
func (o *DescribeBalloonStatsParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the describe balloon stats params
func (o *DescribeBalloonStatsParams) WithHTTPClient(client *http.Client) *DescribeBalloonStatsParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the describe balloon stats params
func (o *DescribeBalloonStatsParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WriteToRequest writes these params to a swagger request
func (o *DescribeBalloonStatsParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/describe_balloon_stats_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// DescribeBalloonStatsReader is a Reader for the DescribeBalloonStats structure.
type DescribeBalloonStatsReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *DescribeBalloonStatsReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewDescribeBalloonStatsOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewDescribeBalloonStatsBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewDescribeBalloonStatsDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewDescribeBalloonStatsOK creates a DescribeBalloonStatsOK with default headers values
func NewDescribeBalloonStatsOK() *DescribeBalloonStatsOK {
	return &DescribeBalloonStatsOK{}
}

/*
DescribeBalloonStatsOK describes a response with status code 200, with default header values.

The balloon device statistics
*/
type DescribeBalloonStatsOK struct {
	Payload *models.BalloonStats
}

// IsSuccess returns true when this describe balloon stats o k response has a 2xx status code
func (o *DescribeBalloonStatsOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this describe balloon stats o k response has a 3xx status code
func (o *DescribeBalloonStatsOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this describe balloon stats o k response has a 4xx status code
func (o *DescribeBalloonStatsOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this describe balloon stats o k response has a 5xx status code
func (o *DescribeBalloonStatsOK) IsServerError() bool {
	return false
}

// IsCode returns true when this describe balloon stats o k response a status code equal to that given
func (o *DescribeBalloonStatsOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the describe balloon stats o k response
func (o *DescribeBalloonStatsOK) Code() int {
	return 200
}

func (o *DescribeBalloonStatsOK) Error() string {
	return fmt.Sprintf("[GET /balloon/statistics][%d] describeBalloonStatsOK  %+v", 200, o.Payload)
}

func (o *DescribeBalloonStatsOK) String() string {
	return fmt.Sprintf("[GET /balloon/statistics][%d] describeBalloonStatsOK  %+v", 200, o.Payload)
}

func (o *DescribeBalloonStatsOK) GetPayload() *models.BalloonStats {
	return o.Payload
}

func (o *DescribeBalloonStatsOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.BalloonStats)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewDescribeBalloonStatsBadRequest creates a DescribeBalloonStatsBadRequest with default headers values
func NewDescribeBalloonStatsBadRequest() *DescribeBalloonStatsBadRequest {
	return &DescribeBalloonStatsBadRequest{}
}

/*
DescribeBalloonStatsBadRequest describes a response with status code 400, with default header values.

The balloon device statistics were not enabled when the device was configured.
*/
type DescribeBalloonStatsBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this describe balloon stats bad request response has a 2xx status code
func (o *DescribeBalloonStatsBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this describe balloon stats bad request response has a 3xx status code
func (o *DescribeBalloonStatsBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this describe balloon stats bad request response has a 4xx status code
func (o *DescribeBalloonStatsBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this describe balloon stats bad request response has a 5xx status code
func (o *DescribeBalloonStatsBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this describe balloon stats bad request response a status code equal to that given
func (o *DescribeBalloonStatsBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the describe balloon stats bad request response
func (o *DescribeBalloonStatsBadRequest) Code() int {
	return 400
}

func (o *DescribeBalloonStatsBadRequest) Error() string {
	return fmt.Sprintf("[GET /balloon/statistics][%d] describeBalloonStatsBadRequest  %+v", 400, o.Payload)
}

func (o *DescribeBalloonStatsBadRequest) String() string {
	return fmt.Sprintf("[GET /balloon/statistics][%d] describeBalloonStatsBadRequest  %+v", 400, o.Payload)
}

func (o *DescribeBalloonStatsBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *DescribeBalloonStatsBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewDescribeBalloonStatsDefault creates a DescribeBalloonStatsDefault with default headers values
func NewDescribeBalloonStatsDefault(code int) *DescribeBalloonStatsDefault {
	return &DescribeBalloonStatsDefault{
		_statusCode: code,
	}
}

/*
DescribeBalloonStatsDefault describes a response with status code -1, with default header values.

Internal Server Error
*/
type DescribeBalloonStatsDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this describe balloon stats default response has a 2xx status code
func (o *DescribeBalloonStatsDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this describe balloon stats default response has a 3xx status code
func (o *DescribeBalloonStatsDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this describe balloon stats default response has a 4xx status code
func (o *DescribeBalloonStatsDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this describe balloon stats default response has a 5xx status code
func (o *DescribeBalloonStatsDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this describe balloon stats default response a status code equal to that given
func (o *DescribeBalloonStatsDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the describe balloon stats default response
func (o *DescribeBalloonStatsDefault) Code() int {
	return o._statusCode
}

func (o *DescribeBalloonStatsDefault) Error() string {
	return fmt.Sprintf("[GET /balloon/statistics][%d] describeBalloonStats default  %+v", o._statusCode, o.Payload)
}

func (o *DescribeBalloonStatsDefault) String() string {
	return fmt.Sprintf("[GET /balloon/statistics][%d] describeBalloonStats default  %+v", o._statusCode, o.Payload)
}

func (o *DescribeBalloonStatsDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *DescribeBalloonStatsDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/describe_instance_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// NewDescribeInstanceParams creates a new DescribeInstanceParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewDescribeInstanceParams() *DescribeInstanceParams {
	return &DescribeInstanceParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewDescribeInstanceParamsWithTimeout creates a new DescribeInstanceParams object
// with the ability to set a timeout on a request.
func NewDescribeInstanceParamsWithTimeout(timeout time.Duration) *DescribeInstanceParams {
	return &DescribeInstanceParams{
		timeout: timeout,
	}
}

// NewDescribeInstanceParamsWithContext creates a new DescribeInstanceParams object
// with the ability to set a context for a request.
func NewDescribeInstanceParamsWithContext(ctx context.Context) *DescribeInstanceParams {
	return &DescribeInstanceParams{
		Context: ctx,
	}
}

// NewDescribeInstanceParamsWithHTTPClient creates a new DescribeInstanceParams object
// with the ability to set a custom HTTPClient for a request.
func NewDescribeInstanceParamsWithHTTPClient(client *http.Client) *DescribeInstanceParams {
	return &DescribeInstanceParams{
		HTTPClient: client,
	}
}

/*
DescribeInstanceParams contains all the parameters to send to the API endpoint

	for the describe instance operation.

	Typically these are written to a http.Request.
*/
type DescribeInstanceParams struct {
	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the describe instance params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *DescribeInstanceParams) WithDefaults() *DescribeInstanceParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the describe instance params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *DescribeInstanceParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the describe instance params
func (o *DescribeInstanceParams) WithTimeout(timeout time.Duration) *DescribeInstanceParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the describe instance params
func (o *DescribeInstanceParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the describe instance params
func (o *DescribeInstanceParams) WithContext(ctx context.Context) *DescribeInstanceParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the describe instance params
func (o *DescribeInstanceParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the describe instance params
func (o *DescribeInstanceParams) WithHTTPClient(client *http.Client) *DescribeInstanceParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the describe instance params
func (o *DescribeInstanceParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WriteToRequest writes these params to a swagger request
func (o *DescribeInstanceParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/describe_instance_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// DescribeInstanceReader is a Reader for the DescribeInstance structure.
type DescribeInstanceReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *DescribeInstanceReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewDescribeInstanceOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	default:
		result := NewDescribeInstanceDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewDescribeInstanceOK creates a DescribeInstanceOK with default headers values
func NewDescribeInstanceOK() *DescribeInstanceOK {
	return &DescribeInstanceOK{}
}

/*
DescribeInstanceOK describes a response with status code 200, with default header values.

The instance information
*/
type DescribeInstanceOK struct {
	Payload *models.InstanceInfo
}

// IsSuccess returns true when this describe instance o k response has a 2xx status code
func (o *DescribeInstanceOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this describe instance o k response has a 3xx status code
func (o *DescribeInstanceOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this describe instance o k response has a 4xx status code
func (o *DescribeInstanceOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this describe instance o k response has a 5xx status code
func (o *DescribeInstanceOK) IsServerError() bool {
	return false
}

// IsCode returns true when this describe instance o k response a status code equal to that given
func (o *DescribeInstanceOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the describe instance o k response
func (o *DescribeInstanceOK) Code() int {
	return 200
}

func (o *DescribeInstanceOK) Error() string {
	return fmt.Sprintf("[GET /][%d] describeInstanceOK  %+v", 200, o.Payload)
}

func (o *DescribeInstanceOK) String() string {
	return fmt.Sprintf("[GET /][%d] describeInstanceOK  %+v", 200, o.Payload)
}

func (o *DescribeInstanceOK) GetPayload() *models.InstanceInfo {
	return o.Payload
}

func (o *DescribeInstanceOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.InstanceInfo)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewDescribeInstanceDefault creates a DescribeInstanceDefault with default headers values
func NewDescribeInstanceDefault(code int) *DescribeInstanceDefault {
	return &DescribeInstanceDefault{
		_statusCode: code,
	}
}

/*
DescribeInstanceDefault describes a response with status code -1, with default header values.

Internal Server Error
*/
type DescribeInstanceDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this describe instance default response has a 2xx status code
func (o *DescribeInstanceDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this describe instance default response has a 3xx status code
func (o *DescribeInstanceDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this describe instance default response has a 4xx status code
func (o *DescribeInstanceDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this describe instance default response has a 5xx status code
func (o *DescribeInstanceDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this describe instance default response a status code equal to that given
func (o *DescribeInstanceDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the describe instance default response
func (o *DescribeInstanceDefault) Code() int {
	return o._statusCode
}

func (o *DescribeInstanceDefault) Error() string {
	return fmt.Sprintf("[GET /][%d] describeInstance default  %+v", o._statusCode, o.Payload)
}

func (o *DescribeInstanceDefault) String() string {
	return fmt.Sprintf("[GET /][%d] describeInstance default  %+v", o._statusCode, o.Payload)
}

func (o *DescribeInstanceDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *DescribeInstanceDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/get_export_vm_config_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// NewGetExportVMConfigParams creates a new GetExportVMConfigParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewGetExportVMConfigParams() *GetExportVMConfigParams {
	return &GetExportVMConfigParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewGetExportVMConfigParamsWithTimeout creates a new GetExportVMConfigParams object
// with the ability to set a timeout on a request.
func NewGetExportVMConfigParamsWithTimeout(timeout time.Duration) *GetExportVMConfigParams {
	return &GetExportVMConfigParams{
		timeout: timeout,
	}
}

// NewGetExportVMConfigParamsWithContext creates a new GetExportVMConfigParams object
// with the ability to set a context for a request.
func NewGetExportVMConfigParamsWithContext(ctx context.Context) *GetExportVMConfigParams {
	return &GetExportVMConfigParams{
		Context: ctx,
	}
}

// NewGetExportVMConfigParamsWithHTTPClient creates a new GetExportVMConfigParams object
// with the ability to set a custom HTTPClient for a request.
func NewGetExportVMConfigParamsWithHTTPClient(client *http.Client) *GetExportVMConfigParams {
	return &GetExportVMConfigParams{
		HTTPClient: client,
	}
}

/*
GetExportVMConfigParams contains all the parameters to send to the API endpoint

	for the get export Vm config operation.

	Typically these are written to a http.Request.
*/
type GetExportVMConfigParams struct {
	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the get export Vm config params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *GetExportVMConfigParams) WithDefaults() *GetExportVMConfigParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the get export Vm config params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *GetExportVMConfigParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the get export Vm config params
func (o *GetExportVMConfigParams) WithTimeout(timeout time.Duration) *GetExportVMConfigParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the get export Vm config params
func (o *GetExportVMConfigParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the get export Vm config params
func (o *GetExportVMConfigParams) WithContext(ctx context.Context) *GetExportVMConfigParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the get export Vm config params
func (o *GetExportVMConfigParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the get export Vm config params
func (o *GetExportVMConfigParams) WithHTTPClient(client *http.Client) *GetExportVMConfigParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the get export Vm config params
func (o *GetExportVMConfigParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WriteToRequest writes these params to a swagger request
func (o *GetExportVMConfigParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/get_export_vm_config_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// GetExportVMConfigReader is a Reader for the GetExportVMConfig structure.
type GetExportVMConfigReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *GetExportVMConfigReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewGetExportVMConfigOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	default:
		result := NewGetExportVMConfigDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewGetExportVMConfigOK creates a GetExportVMConfigOK with default headers values
func NewGetExportVMConfigOK() *GetExportVMConfigOK {
	return &GetExportVMConfigOK{}
}

/*
GetExportVMConfigOK describes a response with status code 200, with default header values.

OK
*/
type GetExportVMConfigOK struct {
	Payload *models.FullVMConfiguration
}

// IsSuccess returns true when this get export Vm config o k response has a 2xx status code
func (o *GetExportVMConfigOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this get export Vm config o k response has a 3xx status code
func (o *GetExportVMConfigOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get export Vm config o k response has a 4xx status code
func (o *GetExportVMConfigOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this get export Vm config o k response has a 5xx status code
func (o *GetExportVMConfigOK) IsServerError() bool {
	return false
}

// IsCode returns true when this get export Vm config o k response a status code equal to that given
func (o *GetExportVMConfigOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the get export Vm config o k response
func (o *GetExportVMConfigOK) Code() int {
	return 200
}

func (o *GetExportVMConfigOK) Error() string {
	return fmt.Sprintf("[GET /vm/config][%d] getExportVmConfigOK  %+v", 200, o.Payload)
}

func (o *GetExportVMConfigOK) String() string {
	return fmt.Sprintf("[GET /vm/config][%d] getExportVmConfigOK  %+v", 200, o.Payload)
}

func (o *GetExportVMConfigOK) GetPayload() *models.FullVMConfiguration {
	return o.Payload
}

func (o *GetExportVMConfigOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.FullVMConfiguration)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetExportVMConfigDefault creates a GetExportVMConfigDefault with default headers values
func NewGetExportVMConfigDefault(code int) *GetExportVMConfigDefault {
	return &GetExportVMConfigDefault{
		_statusCode: code,
	}
}

/*
GetExportVMConfigDefault describes a response with status code -1, with default header values.

Internal server error
*/
type GetExportVMConfigDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this get export Vm config default response has a 2xx status code
func (o *GetExportVMConfigDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this get export Vm config default response has a 3xx status code
func (o *GetExportVMConfigDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this get export Vm config default response has a 4xx status code
func (o *GetExportVMConfigDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this get export Vm config default response has a 5xx status code
func (o *GetExportVMConfigDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this get export Vm config default response a status code equal to that given
func (o *GetExportVMConfigDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the get export Vm config default response
func (o *GetExportVMConfigDefault) Code() int {
	return o._statusCode
}

func (o *GetExportVMConfigDefault) Error() string {
	return fmt.Sprintf("[GET /vm/config][%d] getExportVmConfig default  %+v", o._statusCode, o.Payload)
}

func (o *GetExportVMConfigDefault) String() string {
	return fmt.Sprintf("[GET /vm/config][%d] getExportVmConfig default  %+v", o._statusCode, o.Payload)
}

func (o *GetExportVMConfigDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *GetExportVMConfigDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/get_firecracker_version_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// NewGetFirecrackerVersionParams creates a new GetFirecrackerVersionParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewGetFirecrackerVersionParams() *GetFirecrackerVersionParams {
	return &GetFirecrackerVersionParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewGetFirecrackerVersionParamsWithTimeout creates a new GetFirecrackerVersionParams object
// with the ability to set a timeout on a request.
func NewGetFirecrackerVersionParamsWithTimeout(timeout time.Duration) *GetFirecrackerVersionParams {
	return &GetFirecrackerVersionParams{
		timeout: timeout,
	}
}

// NewGetFirecrackerVersionParamsWithContext creates a new GetFirecrackerVersionParams object
// with the ability to set a context for a request.
func NewGetFirecrackerVersionParamsWithContext(ctx context.Context) *GetFirecrackerVersionParams {
	return &GetFirecrackerVersionParams{
		Context: ctx,
	}
}

// NewGetFirecrackerVersionParamsWithHTTPClient creates a new GetFirecrackerVersionParams object
// with the ability to set a custom HTTPClient for a request.
func NewGetFirecrackerVersionParamsWithHTTPClient(client *http.Client) *GetFirecrackerVersionParams {
	return &GetFirecrackerVersionParams{
		HTTPClient: client,
	}
}

/*
GetFirecrackerVersionParams contains all the parameters to send to the API endpoint

	for the get firecracker version operation.

	Typically these are written to a http.Request.
*/
type GetFirecrackerVersionParams struct {
	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the get firecracker version params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *GetFirecrackerVersionParams) WithDefaults() *GetFirecrackerVersionParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the get firecracker version params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *GetFirecrackerVersionParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the get firecracker version params
func (o *GetFirecrackerVersionParams) WithTimeout(timeout time.Duration) *GetFirecrackerVersionParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the get firecracker version params
func (o *GetFirecrackerVersionParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the get firecracker version params
func (o *GetFirecrackerVersionParams) WithContext(ctx context.Context) *GetFirecrackerVersionParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the get firecracker version params
func (o *GetFirecrackerVersionParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the get firecracker version params
func (o *GetFirecrackerVersionParams) WithHTTPClient(client *http.Client) *GetFirecrackerVersionParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the get firecracker version params
func (o *GetFirecrackerVersionParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WriteToRequest writes these params to a swagger request
func (o *GetFirecrackerVersionParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/get_firecracker_version_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// GetFirecrackerVersionReader is a Reader for the GetFirecrackerVersion structure.
type GetFirecrackerVersionReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *GetFirecrackerVersionReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewGetFirecrackerVersionOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	default:
		result := NewGetFirecrackerVersionDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewGetFirecrackerVersionOK creates a GetFirecrackerVersionOK with default headers values
func NewGetFirecrackerVersionOK() *GetFirecrackerVersionOK {
	return &GetFirecrackerVersionOK{}
}

/*
GetFirecrackerVersionOK describes a response with status code 200, with default header values.

OK
*/
type GetFirecrackerVersionOK struct {
	Payload *models.FirecrackerVersion
}

// IsSuccess returns true when this get firecracker version o k response has a 2xx status code
func (o *GetFirecrackerVersionOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this get firecracker version o k response has a 3xx status code
func (o *GetFirecrackerVersionOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get firecracker version o k response has a 4xx status code
func (o *GetFirecrackerVersionOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this get firecracker version o k response has a 5xx status code
func (o *GetFirecrackerVersionOK) IsServerError() bool {
	return false
}

// IsCode returns true when this get firecracker version o k response a status code equal to that given
func (o *GetFirecrackerVersionOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the get firecracker version o k response
func (o *GetFirecrackerVersionOK) Code() int {
	return 200
}

func (o *GetFirecrackerVersionOK) Error() string {
	return fmt.Sprintf("[GET /version][%d] getFirecrackerVersionOK  %+v", 200, o.Payload)
}

func (o *GetFirecrackerVersionOK) String() string {
	return fmt.Sprintf("[GET /version][%d] getFirecrackerVersionOK  %+v", 200, o.Payload)
}

func (o *GetFirecrackerVersionOK) GetPayload() *models.FirecrackerVersion {
	return o.Payload
}

func (o *GetFirecrackerVersionOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.FirecrackerVersion)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetFirecrackerVersionDefault creates a GetFirecrackerVersionDefault with default headers values
func NewGetFirecrackerVersionDefault(code int) *GetFirecrackerVersionDefault {
	return &GetFirecrackerVersionDefault{
		_statusCode: code,
	}
}

/*
GetFirecrackerVersionDefault describes a response with status code -1, with default header values.

Internal server error
*/
type GetFirecrackerVersionDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this get firecracker version default response has a 2xx status code
func (o *GetFirecrackerVersionDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this get firecracker version default response has a 3xx status code
func (o *GetFirecrackerVersionDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this get firecracker version default response has a 4xx status code
func (o *GetFirecrackerVersionDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this get firecracker version default response has a 5xx status code
func (o *GetFirecrackerVersionDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this get firecracker version default response a status code equal to that given
func (o *GetFirecrackerVersionDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the get firecracker version default response
func (o *GetFirecrackerVersionDefault) Code() int {
	return o._statusCode
}

func (o *GetFirecrackerVersionDefault) Error() string {
	return fmt.Sprintf("[GET /version][%d] getFirecrackerVersion default  %+v", o._statusCode, o.Payload)
}

func (o *GetFirecrackerVersionDefault) String() string {
	return fmt.Sprintf("[GET /version][%d] getFirecrackerVersion default  %+v", o._statusCode, o.Payload)
}

func (o *GetFirecrackerVersionDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *GetFirecrackerVersionDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/get_machine_configuration_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// NewGetMachineConfigurationParams creates a new GetMachineConfigurationParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewGetMachineConfigurationParams() *GetMachineConfigurationParams {
	return &GetMachineConfigurationParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewGetMachineConfigurationParamsWithTimeout creates a new GetMachineConfigurationParams object
// with the ability to set a timeout on a request.
func NewGetMachineConfigurationParamsWithTimeout(timeout time.Duration) *GetMachineConfigurationParams {
	return &GetMachineConfigurationParams{
		timeout: timeout,
	}
}

// NewGetMachineConfigurationParamsWithContext creates a new GetMachineConfigurationParams object
// with the ability to set a context for a request.
func NewGetMachineConfigurationParamsWithContext(ctx context.Context) *GetMachineConfigurationParams {
	return &GetMachineConfigurationParams{
		Context: ctx,
	}
}

// NewGetMachineConfigurationParamsWithHTTPClient creates a new GetMachineConfigurationParams object
// with the ability to set a custom HTTPClient for a request.
func NewGetMachineConfigurationParamsWithHTTPClient(client *http.Client) *GetMachineConfigurationParams {
	return &GetMachineConfigurationParams{
		HTTPClient: client,
	}
}

/*
GetMachineConfigurationParams contains all the parameters to send to the API endpoint

	for the get machine configuration operation.

	Typically these are written to a http.Request.
*/
type GetMachineConfigurationParams struct {
	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the get machine configuration params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *GetMachineConfigurationParams) WithDefaults() *GetMachineConfigurationParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the get machine configuration params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *GetMachineConfigurationParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the get machine configuration params
func (o *GetMachineConfigurationParams) WithTimeout(timeout time.Duration) *GetMachineConfigurationParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the get machine configuration params
func (o *GetMachineConfigurationParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the get machine configuration params
func (o *GetMachineConfigurationParams) WithContext(ctx context.Context) *GetMachineConfigurationParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the get machine configuration params
func (o *GetMachineConfigurationParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the get machine configuration params
func (o *GetMachineConfigurationParams) WithHTTPClient(client *http.Client) *GetMachineConfigurationParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the get machine configuration params
func (o *GetMachineConfigurationParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WriteToRequest writes these params to a swagger request
func (o *GetMachineConfigurationParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/get_machine_configuration_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// GetMachineConfigurationReader is a Reader for the GetMachineConfiguration structure.
type GetMachineConfigurationReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *GetMachineConfigurationReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewGetMachineConfigurationOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	default:
		result := NewGetMachineConfigurationDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewGetMachineConfigurationOK creates a GetMachineConfigurationOK with default headers values
func NewGetMachineConfigurationOK() *GetMachineConfigurationOK {
	return &GetMachineConfigurationOK{}
}

/*
GetMachineConfigurationOK describes a response with status code 200, with default header values.

OK
*/
type GetMachineConfigurationOK struct {
	Payload *models.MachineConfiguration
}

// IsSuccess returns true when this get machine configuration o k response has a 2xx status code
func (o *GetMachineConfigurationOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this get machine configuration o k response has a 3xx status code
func (o *GetMachineConfigurationOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get machine configuration o k response has a 4xx status code
func (o *GetMachineConfigurationOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this get machine configuration o k response has a 5xx status code
func (o *GetMachineConfigurationOK) IsServerError() bool {
	return false
}

// IsCode returns true when this get machine configuration o k response a status code equal to that given
func (o *GetMachineConfigurationOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the get machine configuration o k response
func (o *GetMachineConfigurationOK) Code() int {
	return 200
}

func (o *GetMachineConfigurationOK) Error() string {
	return fmt.Sprintf("[GET /machine-config][%d] getMachineConfigurationOK  %+v", 200, o.Payload)
}

func (o *GetMachineConfigurationOK) String() string {
	return fmt.Sprintf("[GET /machine-config][%d] getMachineConfigurationOK  %+v", 200, o.Payload)
}

func (o *GetMachineConfigurationOK) GetPayload() *models.MachineConfiguration {
	return o.Payload
}

func (o *GetMachineConfigurationOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.MachineConfiguration)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetMachineConfigurationDefault creates a GetMachineConfigurationDefault with default headers values
func NewGetMachineConfigurationDefault(code int) *GetMachineConfigurationDefault {
	return &GetMachineConfigurationDefault{
		_statusCode: code,
	}
}

/*
GetMachineConfigurationDefault describes a response with status code -1, with default header values.

Internal server error
*/
type GetMachineConfigurationDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this get machine configuration default response has a 2xx status code
func (o *GetMachineConfigurationDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this get machine configuration default response has a 3xx status code
func (o *GetMachineConfigurationDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this get machine configuration default response has a 4xx status code
func (o *GetMachineConfigurationDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this get machine configuration default response has a 5xx status code
func (o *GetMachineConfigurationDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this get machine configuration default response a status code equal to that given
func (o *GetMachineConfigurationDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the get machine configuration default response
func (o *GetMachineConfigurationDefault) Code() int {
	return o._statusCode
}

func (o *GetMachineConfigurationDefault) Error() string {
	return fmt.Sprintf("[GET /machine-config][%d] getMachineConfiguration default  %+v", o._statusCode, o.Payload)
}

func (o *GetMachineConfigurationDefault) String() string {
	return fmt.Sprintf("[GET /machine-config][%d] getMachineConfiguration default  %+v", o._statusCode, o.Payload)
}

func (o *GetMachineConfigurationDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *GetMachineConfigurationDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/get_mmds_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// NewGetMmdsParams creates a new GetMmdsParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewGetMmdsParams() *GetMmdsParams {
	return &GetMmdsParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewGetMmdsParamsWithTimeout creates a new GetMmdsParams object
// with the ability to set a timeout on a request.
func NewGetMmdsParamsWithTimeout(timeout time.Duration) *GetMmdsParams {
	return &GetMmdsParams{
		timeout: timeout,
	}
}

// NewGetMmdsParamsWithContext creates a new GetMmdsParams object
// with the ability to set a context for a request.
func NewGetMmdsParamsWithContext(ctx context.Context) *GetMmdsParams {
	return &GetMmdsParams{
		Context: ctx,
	}
}

// NewGetMmdsParamsWithHTTPClient creates a new GetMmdsParams object
// with the ability to set a custom HTTPClient for a request.
func NewGetMmdsParamsWithHTTPClient(client *http.Client) *GetMmdsParams {
	return &GetMmdsParams{
		HTTPClient: client,
	}
}

/*
GetMmdsParams contains all the parameters to send to the API endpoint

	for the get mmds operation.

	Typically these are written to a http.Request.
*/
type GetMmdsParams struct {
	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the get mmds params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *GetMmdsParams) WithDefaults() *GetMmdsParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the get mmds params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *GetMmdsParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the get mmds params
func (o *GetMmdsParams) WithTimeout(timeout time.Duration) *GetMmdsParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the get mmds params
func (o *GetMmdsParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the get mmds params
func (o *GetMmdsParams) WithContext(ctx context.Context) *GetMmdsParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the get mmds params
func (o *GetMmdsParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the get mmds params
func (o *GetMmdsParams) WithHTTPClient(client *http.Client) *GetMmdsParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the get mmds params
func (o *GetMmdsParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WriteToRequest writes these params to a swagger request
func (o *GetMmdsParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/get_mmds_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// GetMmdsReader is a Reader for the GetMmds structure.
type GetMmdsReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *GetMmdsReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewGetMmdsOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 404:
		result := NewGetMmdsNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewGetMmdsDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewGetMmdsOK creates a GetMmdsOK with default headers values
func NewGetMmdsOK() *GetMmdsOK {
	return &GetMmdsOK{}
}

/*
GetMmdsOK describes a response with status code 200, with default header values.

The MMDS data store JSON.
*/
type GetMmdsOK struct {
	Payload interface{}
}

// IsSuccess returns true when this get mmds o k response has a 2xx status code
func (o *GetMmdsOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this get mmds o k response has a 3xx status code
func (o *GetMmdsOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get mmds o k response has a 4xx status code
func (o *GetMmdsOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this get mmds o k response has a 5xx status code
func (o *GetMmdsOK) IsServerError() bool {
	return false
}

// IsCode returns true when this get mmds o k response a status code equal to that given
func (o *GetMmdsOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the get mmds o k response
func (o *GetMmdsOK) Code() int {
	return 200
}

func (o *GetMmdsOK) Error() string {
	return fmt.Sprintf("[GET /mmds][%d] getMmdsOK  %+v", 200, o.Payload)
}

func (o *GetMmdsOK) String() string {
	return fmt.Sprintf("[GET /mmds][%d] getMmdsOK  %+v", 200, o.Payload)
}

func (o *GetMmdsOK) GetPayload() interface{} {
	return o.Payload
}

func (o *GetMmdsOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response payload
	if err := consumer.Consume(response.Body(), &o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetMmdsNotFound creates a GetMmdsNotFound with default headers values
func NewGetMmdsNotFound() *GetMmdsNotFound {
	return &GetMmdsNotFound{}
}

/*
GetMmdsNotFound describes a response with status code 404, with default header values.

The MMDS data store content can not be found.
*/
type GetMmdsNotFound struct {
	Payload *models.Error
}

// IsSuccess returns true when this get mmds not found response has a 2xx status code
func (o *GetMmdsNotFound) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this get mmds not found response has a 3xx status code
func (o *GetMmdsNotFound) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get mmds not found response has a 4xx status code
func (o *GetMmdsNotFound) IsClientError() bool {
	return true
}

// IsServerError returns true when this get mmds not found response has a 5xx status code
func (o *GetMmdsNotFound) IsServerError() bool {
	return false
}

// IsCode returns true when this get mmds not found response a status code equal to that given
func (o *GetMmdsNotFound) IsCode(code int) bool {
	return code == 404
}

// Code gets the status code for the get mmds not found response
func (o *GetMmdsNotFound) Code() int {
	return 404
}

func (o *GetMmdsNotFound) Error() string {
	return fmt.Sprintf("[GET /mmds][%d] getMmdsNotFound  %+v", 404, o.Payload)
}

func (o *GetMmdsNotFound) String() string {
	return fmt.Sprintf("[GET /mmds][%d] getMmdsNotFound  %+v", 404, o.Payload)
}

func (o *GetMmdsNotFound) GetPayload() *models.Error {
	return o.Payload
}

func (o *GetMmdsNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetMmdsDefault creates a GetMmdsDefault with default headers values
func NewGetMmdsDefault(code int) *GetMmdsDefault {
	return &GetMmdsDefault{
		_statusCode: code,
	}
}

/*
GetMmdsDefault describes a response with status code -1, with default header values.

Internal server error
*/
type GetMmdsDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this get mmds default response has a 2xx status code
func (o *GetMmdsDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this get mmds default response has a 3xx status code
func (o *GetMmdsDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this get mmds default response has a 4xx status code
func (o *GetMmdsDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this get mmds default response has a 5xx status code
func (o *GetMmdsDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this get mmds default response a status code equal to that given
func (o *GetMmdsDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the get mmds default response
func (o *GetMmdsDefault) Code() int {
	return o._statusCode
}

func (o *GetMmdsDefault) Error() string {
	return fmt.Sprintf("[GET /mmds][%d] getMmds default  %+v", o._statusCode, o.Payload)
}

func (o *GetMmdsDefault) String() string {
	return fmt.Sprintf("[GET /mmds][%d] getMmds default  %+v", o._statusCode, o.Payload)
}

func (o *GetMmdsDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *GetMmdsDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/load_snapshot_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewLoadSnapshotParams creates a new LoadSnapshotParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewLoadSnapshotParams() *LoadSnapshotParams {
	return &LoadSnapshotParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewLoadSnapshotParamsWithTimeout creates a new LoadSnapshotParams object
// with the ability to set a timeout on a request.
func NewLoadSnapshotParamsWithTimeout(timeout time.Duration) *LoadSnapshotParams {
	return &LoadSnapshotParams{
		timeout: timeout,
	}
}

// NewLoadSnapshotParamsWithContext creates a new LoadSnapshotParams object
// with the ability to set a context for a request.
func NewLoadSnapshotParamsWithContext(ctx context.Context) *LoadSnapshotParams {
	return &LoadSnapshotParams{
		Context: ctx,
	}
}

// NewLoadSnapshotParamsWithHTTPClient creates a new LoadSnapshotParams object
// with the ability to set a custom HTTPClient for a request.
func NewLoadSnapshotParamsWithHTTPClient(client *http.Client) *LoadSnapshotParams {
	return &LoadSnapshotParams{
		HTTPClient: client,
	}
}

/*
LoadSnapshotParams contains all the parameters to send to the API endpoint

	for the load snapshot operation.

	Typically these are written to a http.Request.
*/
type LoadSnapshotParams struct {

	/* Body.

	   The configuration used for loading a snaphot.
	*/
	Body *models.SnapshotLoadParams

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the load snapshot params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *LoadSnapshotParams) WithDefaults() *LoadSnapshotParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the load snapshot params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *LoadSnapshotParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the load snapshot params
func (o *LoadSnapshotParams) WithTimeout(timeout time.Duration) *LoadSnapshotParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the load snapshot params
func (o *LoadSnapshotParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the load snapshot params
func (o *LoadSnapshotParams) WithContext(ctx context.Context) *LoadSnapshotParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the load snapshot params
func (o *LoadSnapshotParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the load snapshot params
func (o *LoadSnapshotParams) WithHTTPClient(client *http.Client) *LoadSnapshotParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the load snapshot params
func (o *LoadSnapshotParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the load snapshot params
func (o *LoadSnapshotParams) WithBody(body *models.SnapshotLoadParams) *LoadSnapshotParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the load snapshot params
func (o *LoadSnapshotParams) SetBody(body *models.SnapshotLoadParams) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *LoadSnapshotParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/load_snapshot_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// LoadSnapshotReader is a Reader for the LoadSnapshot structure.
type LoadSnapshotReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *LoadSnapshotReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewLoadSnapshotNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewLoadSnapshotBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewLoadSnapshotDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewLoadSnapshotNoContent creates a LoadSnapshotNoContent with default headers values
func NewLoadSnapshotNoContent() *LoadSnapshotNoContent {
	return &LoadSnapshotNoContent{}
}

/*
LoadSnapshotNoContent describes a response with status code 204, with default header values.

Snapshot loaded
*/
type LoadSnapshotNoContent struct {
}

// IsSuccess returns true when this load snapshot no content response has a 2xx status code
func (o *LoadSnapshotNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this load snapshot no content response has a 3xx status code
func (o *LoadSnapshotNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this load snapshot no content response has a 4xx status code
func (o *LoadSnapshotNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this load snapshot no content response has a 5xx status code
func (o *LoadSnapshotNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this load snapshot no content response a status code equal to that given
func (o *LoadSnapshotNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the load snapshot no content response
func (o *LoadSnapshotNoContent) Code() int {
	return 204
}

func (o *LoadSnapshotNoContent) Error() string {
	return fmt.Sprintf("[PUT /snapshot/load][%d] loadSnapshotNoContent ", 204)
}

func (o *LoadSnapshotNoContent) String() string {
	return fmt.Sprintf("[PUT /snapshot/load][%d] loadSnapshotNoContent ", 204)
}

func (o *LoadSnapshotNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewLoadSnapshotBadRequest creates a LoadSnapshotBadRequest with default headers values
func NewLoadSnapshotBadRequest() *LoadSnapshotBadRequest {
	return &LoadSnapshotBadRequest{}
}

/*
LoadSnapshotBadRequest describes a response with status code 400, with default header values.

Snapshot cannot be loaded due to bad input
*/
type LoadSnapshotBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this load snapshot bad request response has a 2xx status code
func (o *LoadSnapshotBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this load snapshot bad request response has a 3xx status code
func (o *LoadSnapshotBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this load snapshot bad request response has a 4xx status code
func (o *LoadSnapshotBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this load snapshot bad request response has a 5xx status code
func (o *LoadSnapshotBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this load snapshot bad request response a status code equal to that given
func (o *LoadSnapshotBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the load snapshot bad request response
func (o *LoadSnapshotBadRequest) Code() int {
	return 400
}

func (o *LoadSnapshotBadRequest) Error() string {
	return fmt.Sprintf("[PUT /snapshot/load][%d] loadSnapshotBadRequest  %+v", 400, o.Payload)
}

func (o *LoadSnapshotBadRequest) String() string {
	return fmt.Sprintf("[PUT /snapshot/load][%d] loadSnapshotBadRequest  %+v", 400, o.Payload)
}

func (o *LoadSnapshotBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *LoadSnapshotBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewLoadSnapshotDefault creates a LoadSnapshotDefault with default headers values
func NewLoadSnapshotDefault(code int) *LoadSnapshotDefault {
	return &LoadSnapshotDefault{
		_statusCode: code,
	}
}

/*
LoadSnapshotDefault describes a response with status code -1, with default header values.

Internal server error
*/
type LoadSnapshotDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this load snapshot default response has a 2xx status code
func (o *LoadSnapshotDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this load snapshot default response has a 3xx status code
func (o *LoadSnapshotDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this load snapshot default response has a 4xx status code
func (o *LoadSnapshotDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this load snapshot default response has a 5xx status code
func (o *LoadSnapshotDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this load snapshot default response a status code equal to that given
func (o *LoadSnapshotDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the load snapshot default response
func (o *LoadSnapshotDefault) Code() int {
	return o._statusCode
}

func (o *LoadSnapshotDefault) Error() string {
	return fmt.Sprintf("[PUT /snapshot/load][%d] loadSnapshot default  %+v", o._statusCode, o.Payload)
}

func (o *LoadSnapshotDefault) String() string {
	return fmt.Sprintf("[PUT /snapshot/load][%d] loadSnapshot default  %+v", o._statusCode, o.Payload)
}

func (o *LoadSnapshotDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *LoadSnapshotDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/operations_client.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new operations API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for operations API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	CreateSnapshot(params *CreateSnapshotParams, opts ...ClientOption) (*CreateSnapshotNoContent, error)

	CreateSyncAction(params *CreateSyncActionParams, opts ...ClientOption) (*CreateSyncActionNoContent, error)

	DescribeBalloonConfig(params *DescribeBalloonConfigParams, opts ...ClientOption) (*DescribeBalloonConfigOK, error)

	DescribeBalloonStats(params *DescribeBalloonStatsParams, opts ...ClientOption) (*DescribeBalloonStatsOK, error)

	DescribeInstance(params *DescribeInstanceParams, opts ...ClientOption) (*DescribeInstanceOK, error)

	GetExportVMConfig(params *GetExportVMConfigParams, opts ...ClientOption) (*GetExportVMConfigOK, error)

	GetFirecrackerVersion(params *GetFirecrackerVersionParams, opts ...ClientOption) (*GetFirecrackerVersionOK, error)

	GetMachineConfiguration(params *GetMachineConfigurationParams, opts ...ClientOption) (*GetMachineConfigurationOK, error)

	GetMmds(params *GetMmdsParams, opts ...ClientOption) (*GetMmdsOK, error)

	LoadSnapshot(params *LoadSnapshotParams, opts ...ClientOption) (*LoadSnapshotNoContent, error)

	PatchBalloon(params *PatchBalloonParams, opts ...ClientOption) (*PatchBalloonNoContent, error)

	PatchBalloonStatsInterval(params *PatchBalloonStatsIntervalParams, opts ...ClientOption) (*PatchBalloonStatsIntervalNoContent, error)

	PatchGuestDriveByID(params *PatchGuestDriveByIDParams, opts ...ClientOption) (*PatchGuestDriveByIDNoContent, error)

	PatchGuestNetworkInterfaceByID(params *PatchGuestNetworkInterfaceByIDParams, opts ...ClientOption) (*PatchGuestNetworkInterfaceByIDNoContent, error)

	PatchMachineConfiguration(params *PatchMachineConfigurationParams, opts ...ClientOption) (*PatchMachineConfigurationNoContent, error)

	PatchMmds(params *PatchMmdsParams, opts ...ClientOption) (*PatchMmdsNoContent, error)

	PatchVM(params *PatchVMParams, opts ...ClientOption) (*PatchVMNoContent, error)

	PutBalloon(params *PutBalloonParams, opts ...ClientOption) (*PutBalloonNoContent, error)

	PutCPUConfiguration(params *PutCPUConfigurationParams, opts ...ClientOption) (*PutCPUConfigurationNoContent, error)

	PutEntropyDevice(params *PutEntropyDeviceParams, opts ...ClientOption) (*PutEntropyDeviceNoContent, error)

	PutGuestBootSource(params *PutGuestBootSourceParams, opts ...ClientOption) (*PutGuestBootSourceNoContent, error)

	PutGuestDriveByID(params *PutGuestDriveByIDParams, opts ...ClientOption) (*PutGuestDriveByIDNoContent, error)

	PutGuestNetworkInterfaceByID(params *PutGuestNetworkInterfaceByIDParams, opts ...ClientOption) (*PutGuestNetworkInterfaceByIDNoContent, error)

	PutGuestVsock(params *PutGuestVsockParams, opts ...ClientOption) (*PutGuestVsockNoContent, error)

	PutLogger(params *PutLoggerParams, opts ...ClientOption) (*PutLoggerNoContent, error)

	PutMachineConfiguration(params *PutMachineConfigurationParams, opts ...ClientOption) (*PutMachineConfigurationNoContent, error)

	PutMetrics(params *PutMetricsParams, opts ...ClientOption) (*PutMetricsNoContent, error)

	PutMmds(params *PutMmdsParams, opts ...ClientOption) (*PutMmdsNoContent, error)

	PutMmdsConfig(params *PutMmdsConfigParams, opts ...ClientOption) (*PutMmdsConfigNoContent, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
CreateSnapshot creates a full or diff snapshot post boot only

Creates a snapshot of the microVM state. The microVM should be in the `Paused` state.
*/
func (a *Client) CreateSnapshot(params *CreateSnapshotParams, opts ...ClientOption) (*CreateSnapshotNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateSnapshotParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createSnapshot",
		Method:             "PUT",
		PathPattern:        "/snapshot/create",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateSnapshotReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateSnapshotNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateSnapshotDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateSyncAction creates a synchronous action
*/
func (a *Client) CreateSyncAction(params *CreateSyncActionParams, opts ...ClientOption) (*CreateSyncActionNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateSyncActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createSyncAction",
		Method:             "PUT",
		PathPattern:        "/actions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateSyncActionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateSyncActionNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateSyncActionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DescribeBalloonConfig returns the current balloon device configuration
*/
func (a *Client) DescribeBalloonConfig(params *DescribeBalloonConfigParams, opts ...ClientOption) (*DescribeBalloonConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDescribeBalloonConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "describeBalloonConfig",
		Method:             "GET",
		PathPattern:        "/balloon",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DescribeBalloonConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DescribeBalloonConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DescribeBalloonConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DescribeBalloonStats returns the latest balloon device statistics only if enabled pre boot
*/
func (a *Client) DescribeBalloonStats(params *DescribeBalloonStatsParams, opts ...ClientOption) (*DescribeBalloonStatsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDescribeBalloonStatsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "describeBalloonStats",
		Method:             "GET",
		PathPattern:        "/balloon/statistics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DescribeBalloonStatsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DescribeBalloonStatsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DescribeBalloonStatsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DescribeInstance returns general information about an instance
*/
func (a *Client) DescribeInstance(params *DescribeInstanceParams, opts ...ClientOption) (*DescribeInstanceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDescribeInstanceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "describeInstance",
		Method:             "GET",
		PathPattern:        "/",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DescribeInstanceReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DescribeInstanceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DescribeInstanceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetExportVMConfig gets the full VM configuration

Gets configuration for all VM resources. If the VM is restored from a snapshot, the boot-source, machine-config.smt and machine-config.cpu_template will be empty.
*/
func (a *Client) GetExportVMConfig(params *GetExportVMConfigParams, opts ...ClientOption) (*GetExportVMConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetExportVMConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getExportVmConfig",
		Method:             "GET",
		PathPattern:        "/vm/config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetExportVMConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetExportVMConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetExportVMConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetFirecrackerVersion gets the firecracker version
*/
func (a *Client) GetFirecrackerVersion(params *GetFirecrackerVersionParams, opts ...ClientOption) (*GetFirecrackerVersionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetFirecrackerVersionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getFirecrackerVersion",
		Method:             "GET",
		PathPattern:        "/version",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetFirecrackerVersionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetFirecrackerVersionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetFirecrackerVersionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetMachineConfiguration gets the machine configuration of the VM

Gets the machine configuration of the VM. When called before the PUT operation, it will return the default values for the vCPU count (=1), memory size (=128 MiB). By default SMT is disabled and there is no CPU Template.
*/
func (a *Client) GetMachineConfiguration(params *GetMachineConfigurationParams, opts ...ClientOption) (*GetMachineConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMachineConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMachineConfiguration",
		Method:             "GET",
		PathPattern:        "/machine-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetMachineConfigurationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMachineConfigurationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMachineConfigurationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetMmds gets the m m d s data store
*/
func (a *Client) GetMmds(params *GetMmdsParams, opts ...ClientOption) (*GetMmdsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMmdsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMmds",
		Method:             "GET",
		PathPattern:        "/mmds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetMmdsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetMmdsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMmdsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
LoadSnapshot loads a snapshot pre boot only

Loads the microVM state from a snapshot. Only accepted on a fresh Firecracker process (before configuring any resource other than the Logger and Metrics).
*/
func (a *Client) LoadSnapshot(params *LoadSnapshotParams, opts ...ClientOption) (*LoadSnapshotNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewLoadSnapshotParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "loadSnapshot",
		Method:             "PUT",
		PathPattern:        "/snapshot/load",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &LoadSnapshotReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*LoadSnapshotNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*LoadSnapshotDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PatchBalloon updates a balloon device

Updates an existing balloon device, before or after machine startup. Will fail if update is not possible.
*/
func (a *Client) PatchBalloon(params *PatchBalloonParams, opts ...ClientOption) (*PatchBalloonNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchBalloonParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "patchBalloon",
		Method:             "PATCH",
		PathPattern:        "/balloon",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PatchBalloonReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PatchBalloonNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PatchBalloonDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PatchBalloonStatsInterval updates a balloon device statistics polling interval

Updates an existing balloon device statistics interval, before or after machine startup. Will fail if update is not possible.
*/
func (a *Client) PatchBalloonStatsInterval(params *PatchBalloonStatsIntervalParams, opts ...ClientOption) (*PatchBalloonStatsIntervalNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchBalloonStatsIntervalParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "patchBalloonStatsInterval",
		Method:             "PATCH",
		PathPattern:        "/balloon/statistics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PatchBalloonStatsIntervalReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PatchBalloonStatsIntervalNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PatchBalloonStatsIntervalDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PatchGuestDriveByID updates the properties of a drive post boot only

Updates the properties of the drive with the ID specified by drive_id path parameter. Will fail if update is not possible.
*/
func (a *Client) PatchGuestDriveByID(params *PatchGuestDriveByIDParams, opts ...ClientOption) (*PatchGuestDriveByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchGuestDriveByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "patchGuestDriveByID",
		Method:             "PATCH",
		PathPattern:        "/drives/{drive_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PatchGuestDriveByIDReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PatchGuestDriveByIDNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PatchGuestDriveByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PatchGuestNetworkInterfaceByID updates the rate limiters applied to a network interface post boot only

Updates the rate limiters applied to a network interface.
*/
func (a *Client) PatchGuestNetworkInterfaceByID(params *PatchGuestNetworkInterfaceByIDParams, opts ...ClientOption) (*PatchGuestNetworkInterfaceByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchGuestNetworkInterfaceByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "patchGuestNetworkInterfaceByID",
		Method:             "PATCH",
		PathPattern:        "/network-interfaces/{iface_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PatchGuestNetworkInterfaceByIDReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PatchGuestNetworkInterfaceByIDNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PatchGuestNetworkInterfaceByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PatchMachineConfiguration partiallies updates the machine configuration of the VM pre boot only

Partially updates the Virtual Machine Configuration with the specified input. If any of the parameters has an incorrect value, the whole update fails.
*/
func (a *Client) PatchMachineConfiguration(params *PatchMachineConfigurationParams, opts ...ClientOption) (*PatchMachineConfigurationNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchMachineConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "patchMachineConfiguration",
		Method:             "PATCH",
		PathPattern:        "/machine-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PatchMachineConfigurationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PatchMachineConfigurationNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PatchMachineConfigurationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PatchMmds updates the m m d s data store
*/
func (a *Client) PatchMmds(params *PatchMmdsParams, opts ...ClientOption) (*PatchMmdsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchMmdsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "patchMmds",
		Method:             "PATCH",
		PathPattern:        "/mmds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PatchMmdsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PatchMmdsNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PatchMmdsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PatchVM updates the micro VM state

Sets the desired state (Paused or Resumed) for the microVM.
*/
func (a *Client) PatchVM(params *PatchVMParams, opts ...ClientOption) (*PatchVMNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchVMParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "patchVm",
		Method:             "PATCH",
		PathPattern:        "/vm",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PatchVMReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PatchVMNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PatchVMDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PutBalloon creates or updates a balloon device

Creates a new balloon device if one does not already exist, otherwise updates it, before machine startup. This will fail after machine startup. Will fail if update is not possible.
*/
func (a *Client) PutBalloon(params *PutBalloonParams, opts ...ClientOption) (*PutBalloonNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutBalloonParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "putBalloon",
		Method:             "PUT",
		PathPattern:        "/balloon",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PutBalloonReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutBalloonNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PutBalloonDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PutCPUConfiguration configures CPU features flags for the v c p us of the guest VM pre boot only

Provides configuration to the Firecracker process to specify vCPU resource configuration prior to launching the guest machine.
*/
func (a *Client) PutCPUConfiguration(params *PutCPUConfigurationParams, opts ...ClientOption) (*PutCPUConfigurationNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutCPUConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "putCpuConfiguration",
		Method:             "PUT",
		PathPattern:        "/cpu-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PutCPUConfigurationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutCPUConfigurationNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PutCPUConfigurationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PutEntropyDevice creates an entropy device pre boot only

Enables an entropy device that provides high-quality random data to the guest.
*/
func (a *Client) PutEntropyDevice(params *PutEntropyDeviceParams, opts ...ClientOption) (*PutEntropyDeviceNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutEntropyDeviceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "putEntropyDevice",
		Method:             "PUT",
		PathPattern:        "/entropy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PutEntropyDeviceReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutEntropyDeviceNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PutEntropyDeviceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PutGuestBootSource creates or updates the boot source pre boot only

Creates new boot source if one does not already exist, otherwise updates it. Will fail if update is not possible.
*/
func (a *Client) PutGuestBootSource(params *PutGuestBootSourceParams, opts ...ClientOption) (*PutGuestBootSourceNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutGuestBootSourceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "putGuestBootSource",
		Method:             "PUT",
		PathPattern:        "/boot-source",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PutGuestBootSourceReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutGuestBootSourceNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PutGuestBootSourceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PutGuestDriveByID creates or updates a drive pre boot only

Creates new drive with ID specified by drive_id path parameter. If a drive with the specified ID already exists, updates its state based on new input. Will fail if update is not possible.
*/
func (a *Client) PutGuestDriveByID(params *PutGuestDriveByIDParams, opts ...ClientOption) (*PutGuestDriveByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutGuestDriveByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "putGuestDriveByID",
		Method:             "PUT",
		PathPattern:        "/drives/{drive_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PutGuestDriveByIDReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutGuestDriveByIDNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PutGuestDriveByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PutGuestNetworkInterfaceByID creates a network interface pre boot only

Creates new network interface with ID specified by iface_id path parameter.
*/
func (a *Client) PutGuestNetworkInterfaceByID(params *PutGuestNetworkInterfaceByIDParams, opts ...ClientOption) (*PutGuestNetworkInterfaceByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutGuestNetworkInterfaceByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "putGuestNetworkInterfaceByID",
		Method:             "PUT",
		PathPattern:        "/network-interfaces/{iface_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PutGuestNetworkInterfaceByIDReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutGuestNetworkInterfaceByIDNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PutGuestNetworkInterfaceByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PutGuestVsock creates updates a vsock device pre boot only

The first call creates the device with the configuration specified in body. Subsequent calls will update the device configuration. May fail if update is not possible.
*/
func (a *Client) PutGuestVsock(params *PutGuestVsockParams, opts ...ClientOption) (*PutGuestVsockNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutGuestVsockParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "putGuestVsock",
		Method:             "PUT",
		PathPattern:        "/vsock",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PutGuestVsockReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutGuestVsockNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PutGuestVsockDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PutLogger initializes the logger by specifying a named pipe or a file for the logs output
*/
func (a *Client) PutLogger(params *PutLoggerParams, opts ...ClientOption) (*PutLoggerNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutLoggerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "putLogger",
		Method:             "PUT",
		PathPattern:        "/logger",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PutLoggerReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutLoggerNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PutLoggerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PutMachineConfiguration updates the machine configuration of the VM pre boot only

Updates the Virtual Machine Configuration with the specified input. Firecracker starts with default values for vCPU count (=1) and memory size (=128 MiB). The vCPU count is restricted to the [1, 32] range. With SMT enabled, the vCPU count is required to be either 1 or an even number in the range. otherwise there are no restrictions regarding the vCPU count. If 2M hugetlbfs pages are specified, then `mem_size_mib` must be a multiple of 2. If any of the parameters has an incorrect value, the whole update fails. All parameters that are optional and are not specified are set to their default values (smt = false, track_dirty_pages = false, cpu_template = None, huge_pages = None).
*/
func (a *Client) PutMachineConfiguration(params *PutMachineConfigurationParams, opts ...ClientOption) (*PutMachineConfigurationNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutMachineConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "putMachineConfiguration",
		Method:             "PUT",
		PathPattern:        "/machine-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PutMachineConfigurationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutMachineConfigurationNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PutMachineConfigurationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PutMetrics initializes the metrics system by specifying a named pipe or a file for the metrics output
*/
func (a *Client) PutMetrics(params *PutMetricsParams, opts ...ClientOption) (*PutMetricsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutMetricsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "putMetrics",
		Method:             "PUT",
		PathPattern:        "/metrics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PutMetricsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutMetricsNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PutMetricsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PutMmds creates a m m d s microvm metadata service data store
*/
func (a *Client) PutMmds(params *PutMmdsParams, opts ...ClientOption) (*PutMmdsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutMmdsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "putMmds",
		Method:             "PUT",
		PathPattern:        "/mmds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PutMmdsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutMmdsNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PutMmdsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PutMmdsConfig sets m m d s configuration pre boot only

Configures MMDS version, IPv4 address used by the MMDS network stack and interfaces that allow MMDS requests.
*/
func (a *Client) PutMmdsConfig(params *PutMmdsConfigParams, opts ...ClientOption) (*PutMmdsConfigNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutMmdsConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "putMmdsConfig",
		Method:             "PUT",
		PathPattern:        "/mmds/config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PutMmdsConfigReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutMmdsConfigNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PutMmdsConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}



================================================
File: fc/client/operations/patch_balloon_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPatchBalloonParams creates a new PatchBalloonParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPatchBalloonParams() *PatchBalloonParams {
	return &PatchBalloonParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPatchBalloonParamsWithTimeout creates a new PatchBalloonParams object
// with the ability to set a timeout on a request.
func NewPatchBalloonParamsWithTimeout(timeout time.Duration) *PatchBalloonParams {
	return &PatchBalloonParams{
		timeout: timeout,
	}
}

// NewPatchBalloonParamsWithContext creates a new PatchBalloonParams object
// with the ability to set a context for a request.
func NewPatchBalloonParamsWithContext(ctx context.Context) *PatchBalloonParams {
	return &PatchBalloonParams{
		Context: ctx,
	}
}

// NewPatchBalloonParamsWithHTTPClient creates a new PatchBalloonParams object
// with the ability to set a custom HTTPClient for a request.
func NewPatchBalloonParamsWithHTTPClient(client *http.Client) *PatchBalloonParams {
	return &PatchBalloonParams{
		HTTPClient: client,
	}
}

/*
PatchBalloonParams contains all the parameters to send to the API endpoint

	for the patch balloon operation.

	Typically these are written to a http.Request.
*/
type PatchBalloonParams struct {

	/* Body.

	   Balloon properties
	*/
	Body *models.BalloonUpdate

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the patch balloon params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PatchBalloonParams) WithDefaults() *PatchBalloonParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the patch balloon params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PatchBalloonParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the patch balloon params
func (o *PatchBalloonParams) WithTimeout(timeout time.Duration) *PatchBalloonParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the patch balloon params
func (o *PatchBalloonParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the patch balloon params
func (o *PatchBalloonParams) WithContext(ctx context.Context) *PatchBalloonParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the patch balloon params
func (o *PatchBalloonParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the patch balloon params
func (o *PatchBalloonParams) WithHTTPClient(client *http.Client) *PatchBalloonParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the patch balloon params
func (o *PatchBalloonParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the patch balloon params
func (o *PatchBalloonParams) WithBody(body *models.BalloonUpdate) *PatchBalloonParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the patch balloon params
func (o *PatchBalloonParams) SetBody(body *models.BalloonUpdate) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *PatchBalloonParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/patch_balloon_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PatchBalloonReader is a Reader for the PatchBalloon structure.
type PatchBalloonReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PatchBalloonReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPatchBalloonNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPatchBalloonBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPatchBalloonDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPatchBalloonNoContent creates a PatchBalloonNoContent with default headers values
func NewPatchBalloonNoContent() *PatchBalloonNoContent {
	return &PatchBalloonNoContent{}
}

/*
PatchBalloonNoContent describes a response with status code 204, with default header values.

Balloon device updated
*/
type PatchBalloonNoContent struct {
}

// IsSuccess returns true when this patch balloon no content response has a 2xx status code
func (o *PatchBalloonNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this patch balloon no content response has a 3xx status code
func (o *PatchBalloonNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this patch balloon no content response has a 4xx status code
func (o *PatchBalloonNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this patch balloon no content response has a 5xx status code
func (o *PatchBalloonNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this patch balloon no content response a status code equal to that given
func (o *PatchBalloonNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the patch balloon no content response
func (o *PatchBalloonNoContent) Code() int {
	return 204
}

func (o *PatchBalloonNoContent) Error() string {
	return fmt.Sprintf("[PATCH /balloon][%d] patchBalloonNoContent ", 204)
}

func (o *PatchBalloonNoContent) String() string {
	return fmt.Sprintf("[PATCH /balloon][%d] patchBalloonNoContent ", 204)
}

func (o *PatchBalloonNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPatchBalloonBadRequest creates a PatchBalloonBadRequest with default headers values
func NewPatchBalloonBadRequest() *PatchBalloonBadRequest {
	return &PatchBalloonBadRequest{}
}

/*
PatchBalloonBadRequest describes a response with status code 400, with default header values.

Balloon device cannot be updated due to bad input
*/
type PatchBalloonBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this patch balloon bad request response has a 2xx status code
func (o *PatchBalloonBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this patch balloon bad request response has a 3xx status code
func (o *PatchBalloonBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this patch balloon bad request response has a 4xx status code
func (o *PatchBalloonBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this patch balloon bad request response has a 5xx status code
func (o *PatchBalloonBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this patch balloon bad request response a status code equal to that given
func (o *PatchBalloonBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the patch balloon bad request response
func (o *PatchBalloonBadRequest) Code() int {
	return 400
}

func (o *PatchBalloonBadRequest) Error() string {
	return fmt.Sprintf("[PATCH /balloon][%d] patchBalloonBadRequest  %+v", 400, o.Payload)
}

func (o *PatchBalloonBadRequest) String() string {
	return fmt.Sprintf("[PATCH /balloon][%d] patchBalloonBadRequest  %+v", 400, o.Payload)
}

func (o *PatchBalloonBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PatchBalloonBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchBalloonDefault creates a PatchBalloonDefault with default headers values
func NewPatchBalloonDefault(code int) *PatchBalloonDefault {
	return &PatchBalloonDefault{
		_statusCode: code,
	}
}

/*
PatchBalloonDefault describes a response with status code -1, with default header values.

Internal server error
*/
type PatchBalloonDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this patch balloon default response has a 2xx status code
func (o *PatchBalloonDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this patch balloon default response has a 3xx status code
func (o *PatchBalloonDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this patch balloon default response has a 4xx status code
func (o *PatchBalloonDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this patch balloon default response has a 5xx status code
func (o *PatchBalloonDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this patch balloon default response a status code equal to that given
func (o *PatchBalloonDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the patch balloon default response
func (o *PatchBalloonDefault) Code() int {
	return o._statusCode
}

func (o *PatchBalloonDefault) Error() string {
	return fmt.Sprintf("[PATCH /balloon][%d] patchBalloon default  %+v", o._statusCode, o.Payload)
}

func (o *PatchBalloonDefault) String() string {
	return fmt.Sprintf("[PATCH /balloon][%d] patchBalloon default  %+v", o._statusCode, o.Payload)
}

func (o *PatchBalloonDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PatchBalloonDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/patch_balloon_stats_interval_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPatchBalloonStatsIntervalParams creates a new PatchBalloonStatsIntervalParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPatchBalloonStatsIntervalParams() *PatchBalloonStatsIntervalParams {
	return &PatchBalloonStatsIntervalParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPatchBalloonStatsIntervalParamsWithTimeout creates a new PatchBalloonStatsIntervalParams object
// with the ability to set a timeout on a request.
func NewPatchBalloonStatsIntervalParamsWithTimeout(timeout time.Duration) *PatchBalloonStatsIntervalParams {
	return &PatchBalloonStatsIntervalParams{
		timeout: timeout,
	}
}

// NewPatchBalloonStatsIntervalParamsWithContext creates a new PatchBalloonStatsIntervalParams object
// with the ability to set a context for a request.
func NewPatchBalloonStatsIntervalParamsWithContext(ctx context.Context) *PatchBalloonStatsIntervalParams {
	return &PatchBalloonStatsIntervalParams{
		Context: ctx,
	}
}

// NewPatchBalloonStatsIntervalParamsWithHTTPClient creates a new PatchBalloonStatsIntervalParams object
// with the ability to set a custom HTTPClient for a request.
func NewPatchBalloonStatsIntervalParamsWithHTTPClient(client *http.Client) *PatchBalloonStatsIntervalParams {
	return &PatchBalloonStatsIntervalParams{
		HTTPClient: client,
	}
}

/*
PatchBalloonStatsIntervalParams contains all the parameters to send to the API endpoint

	for the patch balloon stats interval operation.

	Typically these are written to a http.Request.
*/
type PatchBalloonStatsIntervalParams struct {

	/* Body.

	   Balloon properties
	*/
	Body *models.BalloonStatsUpdate

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the patch balloon stats interval params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PatchBalloonStatsIntervalParams) WithDefaults() *PatchBalloonStatsIntervalParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the patch balloon stats interval params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PatchBalloonStatsIntervalParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the patch balloon stats interval params
func (o *PatchBalloonStatsIntervalParams) WithTimeout(timeout time.Duration) *PatchBalloonStatsIntervalParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the patch balloon stats interval params
func (o *PatchBalloonStatsIntervalParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the patch balloon stats interval params
func (o *PatchBalloonStatsIntervalParams) WithContext(ctx context.Context) *PatchBalloonStatsIntervalParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the patch balloon stats interval params
func (o *PatchBalloonStatsIntervalParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the patch balloon stats interval params
func (o *PatchBalloonStatsIntervalParams) WithHTTPClient(client *http.Client) *PatchBalloonStatsIntervalParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the patch balloon stats interval params
func (o *PatchBalloonStatsIntervalParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the patch balloon stats interval params
func (o *PatchBalloonStatsIntervalParams) WithBody(body *models.BalloonStatsUpdate) *PatchBalloonStatsIntervalParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the patch balloon stats interval params
func (o *PatchBalloonStatsIntervalParams) SetBody(body *models.BalloonStatsUpdate) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *PatchBalloonStatsIntervalParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/patch_balloon_stats_interval_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PatchBalloonStatsIntervalReader is a Reader for the PatchBalloonStatsInterval structure.
type PatchBalloonStatsIntervalReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PatchBalloonStatsIntervalReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPatchBalloonStatsIntervalNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPatchBalloonStatsIntervalBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPatchBalloonStatsIntervalDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPatchBalloonStatsIntervalNoContent creates a PatchBalloonStatsIntervalNoContent with default headers values
func NewPatchBalloonStatsIntervalNoContent() *PatchBalloonStatsIntervalNoContent {
	return &PatchBalloonStatsIntervalNoContent{}
}

/*
PatchBalloonStatsIntervalNoContent describes a response with status code 204, with default header values.

Balloon statistics interval updated
*/
type PatchBalloonStatsIntervalNoContent struct {
}

// IsSuccess returns true when this patch balloon stats interval no content response has a 2xx status code
func (o *PatchBalloonStatsIntervalNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this patch balloon stats interval no content response has a 3xx status code
func (o *PatchBalloonStatsIntervalNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this patch balloon stats interval no content response has a 4xx status code
func (o *PatchBalloonStatsIntervalNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this patch balloon stats interval no content response has a 5xx status code
func (o *PatchBalloonStatsIntervalNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this patch balloon stats interval no content response a status code equal to that given
func (o *PatchBalloonStatsIntervalNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the patch balloon stats interval no content response
func (o *PatchBalloonStatsIntervalNoContent) Code() int {
	return 204
}

func (o *PatchBalloonStatsIntervalNoContent) Error() string {
	return fmt.Sprintf("[PATCH /balloon/statistics][%d] patchBalloonStatsIntervalNoContent ", 204)
}

func (o *PatchBalloonStatsIntervalNoContent) String() string {
	return fmt.Sprintf("[PATCH /balloon/statistics][%d] patchBalloonStatsIntervalNoContent ", 204)
}

func (o *PatchBalloonStatsIntervalNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPatchBalloonStatsIntervalBadRequest creates a PatchBalloonStatsIntervalBadRequest with default headers values
func NewPatchBalloonStatsIntervalBadRequest() *PatchBalloonStatsIntervalBadRequest {
	return &PatchBalloonStatsIntervalBadRequest{}
}

/*
PatchBalloonStatsIntervalBadRequest describes a response with status code 400, with default header values.

Balloon statistics interval cannot be updated due to bad input
*/
type PatchBalloonStatsIntervalBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this patch balloon stats interval bad request response has a 2xx status code
func (o *PatchBalloonStatsIntervalBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this patch balloon stats interval bad request response has a 3xx status code
func (o *PatchBalloonStatsIntervalBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this patch balloon stats interval bad request response has a 4xx status code
func (o *PatchBalloonStatsIntervalBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this patch balloon stats interval bad request response has a 5xx status code
func (o *PatchBalloonStatsIntervalBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this patch balloon stats interval bad request response a status code equal to that given
func (o *PatchBalloonStatsIntervalBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the patch balloon stats interval bad request response
func (o *PatchBalloonStatsIntervalBadRequest) Code() int {
	return 400
}

func (o *PatchBalloonStatsIntervalBadRequest) Error() string {
	return fmt.Sprintf("[PATCH /balloon/statistics][%d] patchBalloonStatsIntervalBadRequest  %+v", 400, o.Payload)
}

func (o *PatchBalloonStatsIntervalBadRequest) String() string {
	return fmt.Sprintf("[PATCH /balloon/statistics][%d] patchBalloonStatsIntervalBadRequest  %+v", 400, o.Payload)
}

func (o *PatchBalloonStatsIntervalBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PatchBalloonStatsIntervalBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchBalloonStatsIntervalDefault creates a PatchBalloonStatsIntervalDefault with default headers values
func NewPatchBalloonStatsIntervalDefault(code int) *PatchBalloonStatsIntervalDefault {
	return &PatchBalloonStatsIntervalDefault{
		_statusCode: code,
	}
}

/*
PatchBalloonStatsIntervalDefault describes a response with status code -1, with default header values.

Internal server error
*/
type PatchBalloonStatsIntervalDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this patch balloon stats interval default response has a 2xx status code
func (o *PatchBalloonStatsIntervalDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this patch balloon stats interval default response has a 3xx status code
func (o *PatchBalloonStatsIntervalDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this patch balloon stats interval default response has a 4xx status code
func (o *PatchBalloonStatsIntervalDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this patch balloon stats interval default response has a 5xx status code
func (o *PatchBalloonStatsIntervalDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this patch balloon stats interval default response a status code equal to that given
func (o *PatchBalloonStatsIntervalDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the patch balloon stats interval default response
func (o *PatchBalloonStatsIntervalDefault) Code() int {
	return o._statusCode
}

func (o *PatchBalloonStatsIntervalDefault) Error() string {
	return fmt.Sprintf("[PATCH /balloon/statistics][%d] patchBalloonStatsInterval default  %+v", o._statusCode, o.Payload)
}

func (o *PatchBalloonStatsIntervalDefault) String() string {
	return fmt.Sprintf("[PATCH /balloon/statistics][%d] patchBalloonStatsInterval default  %+v", o._statusCode, o.Payload)
}

func (o *PatchBalloonStatsIntervalDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PatchBalloonStatsIntervalDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/patch_guest_drive_by_id_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPatchGuestDriveByIDParams creates a new PatchGuestDriveByIDParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPatchGuestDriveByIDParams() *PatchGuestDriveByIDParams {
	return &PatchGuestDriveByIDParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPatchGuestDriveByIDParamsWithTimeout creates a new PatchGuestDriveByIDParams object
// with the ability to set a timeout on a request.
func NewPatchGuestDriveByIDParamsWithTimeout(timeout time.Duration) *PatchGuestDriveByIDParams {
	return &PatchGuestDriveByIDParams{
		timeout: timeout,
	}
}

// NewPatchGuestDriveByIDParamsWithContext creates a new PatchGuestDriveByIDParams object
// with the ability to set a context for a request.
func NewPatchGuestDriveByIDParamsWithContext(ctx context.Context) *PatchGuestDriveByIDParams {
	return &PatchGuestDriveByIDParams{
		Context: ctx,
	}
}

// NewPatchGuestDriveByIDParamsWithHTTPClient creates a new PatchGuestDriveByIDParams object
// with the ability to set a custom HTTPClient for a request.
func NewPatchGuestDriveByIDParamsWithHTTPClient(client *http.Client) *PatchGuestDriveByIDParams {
	return &PatchGuestDriveByIDParams{
		HTTPClient: client,
	}
}

/*
PatchGuestDriveByIDParams contains all the parameters to send to the API endpoint

	for the patch guest drive by ID operation.

	Typically these are written to a http.Request.
*/
type PatchGuestDriveByIDParams struct {

	/* Body.

	   Guest drive properties
	*/
	Body *models.PartialDrive

	/* DriveID.

	   The id of the guest drive
	*/
	DriveID string

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the patch guest drive by ID params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PatchGuestDriveByIDParams) WithDefaults() *PatchGuestDriveByIDParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the patch guest drive by ID params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PatchGuestDriveByIDParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the patch guest drive by ID params
func (o *PatchGuestDriveByIDParams) WithTimeout(timeout time.Duration) *PatchGuestDriveByIDParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the patch guest drive by ID params
func (o *PatchGuestDriveByIDParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the patch guest drive by ID params
func (o *PatchGuestDriveByIDParams) WithContext(ctx context.Context) *PatchGuestDriveByIDParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the patch guest drive by ID params
func (o *PatchGuestDriveByIDParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the patch guest drive by ID params
func (o *PatchGuestDriveByIDParams) WithHTTPClient(client *http.Client) *PatchGuestDriveByIDParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the patch guest drive by ID params
func (o *PatchGuestDriveByIDParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the patch guest drive by ID params
func (o *PatchGuestDriveByIDParams) WithBody(body *models.PartialDrive) *PatchGuestDriveByIDParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the patch guest drive by ID params
func (o *PatchGuestDriveByIDParams) SetBody(body *models.PartialDrive) {
	o.Body = body
}

// WithDriveID adds the driveID to the patch guest drive by ID params
func (o *PatchGuestDriveByIDParams) WithDriveID(driveID string) *PatchGuestDriveByIDParams {
	o.SetDriveID(driveID)
	return o
}

// SetDriveID adds the driveId to the patch guest drive by ID params
func (o *PatchGuestDriveByIDParams) SetDriveID(driveID string) {
	o.DriveID = driveID
}

// WriteToRequest writes these params to a swagger request
func (o *PatchGuestDriveByIDParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	// path param drive_id
	if err := r.SetPathParam("drive_id", o.DriveID); err != nil {
		return err
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/patch_guest_drive_by_id_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PatchGuestDriveByIDReader is a Reader for the PatchGuestDriveByID structure.
type PatchGuestDriveByIDReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PatchGuestDriveByIDReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPatchGuestDriveByIDNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPatchGuestDriveByIDBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPatchGuestDriveByIDDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPatchGuestDriveByIDNoContent creates a PatchGuestDriveByIDNoContent with default headers values
func NewPatchGuestDriveByIDNoContent() *PatchGuestDriveByIDNoContent {
	return &PatchGuestDriveByIDNoContent{}
}

/*
PatchGuestDriveByIDNoContent describes a response with status code 204, with default header values.

Drive updated
*/
type PatchGuestDriveByIDNoContent struct {
}

// IsSuccess returns true when this patch guest drive by Id no content response has a 2xx status code
func (o *PatchGuestDriveByIDNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this patch guest drive by Id no content response has a 3xx status code
func (o *PatchGuestDriveByIDNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this patch guest drive by Id no content response has a 4xx status code
func (o *PatchGuestDriveByIDNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this patch guest drive by Id no content response has a 5xx status code
func (o *PatchGuestDriveByIDNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this patch guest drive by Id no content response a status code equal to that given
func (o *PatchGuestDriveByIDNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the patch guest drive by Id no content response
func (o *PatchGuestDriveByIDNoContent) Code() int {
	return 204
}

func (o *PatchGuestDriveByIDNoContent) Error() string {
	return fmt.Sprintf("[PATCH /drives/{drive_id}][%d] patchGuestDriveByIdNoContent ", 204)
}

func (o *PatchGuestDriveByIDNoContent) String() string {
	return fmt.Sprintf("[PATCH /drives/{drive_id}][%d] patchGuestDriveByIdNoContent ", 204)
}

func (o *PatchGuestDriveByIDNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPatchGuestDriveByIDBadRequest creates a PatchGuestDriveByIDBadRequest with default headers values
func NewPatchGuestDriveByIDBadRequest() *PatchGuestDriveByIDBadRequest {
	return &PatchGuestDriveByIDBadRequest{}
}

/*
PatchGuestDriveByIDBadRequest describes a response with status code 400, with default header values.

Drive cannot be updated due to bad input
*/
type PatchGuestDriveByIDBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this patch guest drive by Id bad request response has a 2xx status code
func (o *PatchGuestDriveByIDBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this patch guest drive by Id bad request response has a 3xx status code
func (o *PatchGuestDriveByIDBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this patch guest drive by Id bad request response has a 4xx status code
func (o *PatchGuestDriveByIDBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this patch guest drive by Id bad request response has a 5xx status code
func (o *PatchGuestDriveByIDBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this patch guest drive by Id bad request response a status code equal to that given
func (o *PatchGuestDriveByIDBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the patch guest drive by Id bad request response
func (o *PatchGuestDriveByIDBadRequest) Code() int {
	return 400
}

func (o *PatchGuestDriveByIDBadRequest) Error() string {
	return fmt.Sprintf("[PATCH /drives/{drive_id}][%d] patchGuestDriveByIdBadRequest  %+v", 400, o.Payload)
}

func (o *PatchGuestDriveByIDBadRequest) String() string {
	return fmt.Sprintf("[PATCH /drives/{drive_id}][%d] patchGuestDriveByIdBadRequest  %+v", 400, o.Payload)
}

func (o *PatchGuestDriveByIDBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PatchGuestDriveByIDBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchGuestDriveByIDDefault creates a PatchGuestDriveByIDDefault with default headers values
func NewPatchGuestDriveByIDDefault(code int) *PatchGuestDriveByIDDefault {
	return &PatchGuestDriveByIDDefault{
		_statusCode: code,
	}
}

/*
PatchGuestDriveByIDDefault describes a response with status code -1, with default header values.

Internal server error.
*/
type PatchGuestDriveByIDDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this patch guest drive by ID default response has a 2xx status code
func (o *PatchGuestDriveByIDDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this patch guest drive by ID default response has a 3xx status code
func (o *PatchGuestDriveByIDDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this patch guest drive by ID default response has a 4xx status code
func (o *PatchGuestDriveByIDDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this patch guest drive by ID default response has a 5xx status code
func (o *PatchGuestDriveByIDDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this patch guest drive by ID default response a status code equal to that given
func (o *PatchGuestDriveByIDDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the patch guest drive by ID default response
func (o *PatchGuestDriveByIDDefault) Code() int {
	return o._statusCode
}

func (o *PatchGuestDriveByIDDefault) Error() string {
	return fmt.Sprintf("[PATCH /drives/{drive_id}][%d] patchGuestDriveByID default  %+v", o._statusCode, o.Payload)
}

func (o *PatchGuestDriveByIDDefault) String() string {
	return fmt.Sprintf("[PATCH /drives/{drive_id}][%d] patchGuestDriveByID default  %+v", o._statusCode, o.Payload)
}

func (o *PatchGuestDriveByIDDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PatchGuestDriveByIDDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/patch_guest_network_interface_by_id_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPatchGuestNetworkInterfaceByIDParams creates a new PatchGuestNetworkInterfaceByIDParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPatchGuestNetworkInterfaceByIDParams() *PatchGuestNetworkInterfaceByIDParams {
	return &PatchGuestNetworkInterfaceByIDParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPatchGuestNetworkInterfaceByIDParamsWithTimeout creates a new PatchGuestNetworkInterfaceByIDParams object
// with the ability to set a timeout on a request.
func NewPatchGuestNetworkInterfaceByIDParamsWithTimeout(timeout time.Duration) *PatchGuestNetworkInterfaceByIDParams {
	return &PatchGuestNetworkInterfaceByIDParams{
		timeout: timeout,
	}
}

// NewPatchGuestNetworkInterfaceByIDParamsWithContext creates a new PatchGuestNetworkInterfaceByIDParams object
// with the ability to set a context for a request.
func NewPatchGuestNetworkInterfaceByIDParamsWithContext(ctx context.Context) *PatchGuestNetworkInterfaceByIDParams {
	return &PatchGuestNetworkInterfaceByIDParams{
		Context: ctx,
	}
}

// NewPatchGuestNetworkInterfaceByIDParamsWithHTTPClient creates a new PatchGuestNetworkInterfaceByIDParams object
// with the ability to set a custom HTTPClient for a request.
func NewPatchGuestNetworkInterfaceByIDParamsWithHTTPClient(client *http.Client) *PatchGuestNetworkInterfaceByIDParams {
	return &PatchGuestNetworkInterfaceByIDParams{
		HTTPClient: client,
	}
}

/*
PatchGuestNetworkInterfaceByIDParams contains all the parameters to send to the API endpoint

	for the patch guest network interface by ID operation.

	Typically these are written to a http.Request.
*/
type PatchGuestNetworkInterfaceByIDParams struct {

	/* Body.

	   A subset of the guest network interface properties
	*/
	Body *models.PartialNetworkInterface

	/* IfaceID.

	   The id of the guest network interface
	*/
	IfaceID string

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the patch guest network interface by ID params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PatchGuestNetworkInterfaceByIDParams) WithDefaults() *PatchGuestNetworkInterfaceByIDParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the patch guest network interface by ID params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PatchGuestNetworkInterfaceByIDParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the patch guest network interface by ID params
func (o *PatchGuestNetworkInterfaceByIDParams) WithTimeout(timeout time.Duration) *PatchGuestNetworkInterfaceByIDParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the patch guest network interface by ID params
func (o *PatchGuestNetworkInterfaceByIDParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the patch guest network interface by ID params
func (o *PatchGuestNetworkInterfaceByIDParams) WithContext(ctx context.Context) *PatchGuestNetworkInterfaceByIDParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the patch guest network interface by ID params
func (o *PatchGuestNetworkInterfaceByIDParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the patch guest network interface by ID params
func (o *PatchGuestNetworkInterfaceByIDParams) WithHTTPClient(client *http.Client) *PatchGuestNetworkInterfaceByIDParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the patch guest network interface by ID params
func (o *PatchGuestNetworkInterfaceByIDParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the patch guest network interface by ID params
func (o *PatchGuestNetworkInterfaceByIDParams) WithBody(body *models.PartialNetworkInterface) *PatchGuestNetworkInterfaceByIDParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the patch guest network interface by ID params
func (o *PatchGuestNetworkInterfaceByIDParams) SetBody(body *models.PartialNetworkInterface) {
	o.Body = body
}

// WithIfaceID adds the ifaceID to the patch guest network interface by ID params
func (o *PatchGuestNetworkInterfaceByIDParams) WithIfaceID(ifaceID string) *PatchGuestNetworkInterfaceByIDParams {
	o.SetIfaceID(ifaceID)
	return o
}

// SetIfaceID adds the ifaceId to the patch guest network interface by ID params
func (o *PatchGuestNetworkInterfaceByIDParams) SetIfaceID(ifaceID string) {
	o.IfaceID = ifaceID
}

// WriteToRequest writes these params to a swagger request
func (o *PatchGuestNetworkInterfaceByIDParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	// path param iface_id
	if err := r.SetPathParam("iface_id", o.IfaceID); err != nil {
		return err
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/patch_guest_network_interface_by_id_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PatchGuestNetworkInterfaceByIDReader is a Reader for the PatchGuestNetworkInterfaceByID structure.
type PatchGuestNetworkInterfaceByIDReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PatchGuestNetworkInterfaceByIDReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPatchGuestNetworkInterfaceByIDNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPatchGuestNetworkInterfaceByIDBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPatchGuestNetworkInterfaceByIDDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPatchGuestNetworkInterfaceByIDNoContent creates a PatchGuestNetworkInterfaceByIDNoContent with default headers values
func NewPatchGuestNetworkInterfaceByIDNoContent() *PatchGuestNetworkInterfaceByIDNoContent {
	return &PatchGuestNetworkInterfaceByIDNoContent{}
}

/*
PatchGuestNetworkInterfaceByIDNoContent describes a response with status code 204, with default header values.

Network interface updated
*/
type PatchGuestNetworkInterfaceByIDNoContent struct {
}

// IsSuccess returns true when this patch guest network interface by Id no content response has a 2xx status code
func (o *PatchGuestNetworkInterfaceByIDNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this patch guest network interface by Id no content response has a 3xx status code
func (o *PatchGuestNetworkInterfaceByIDNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this patch guest network interface by Id no content response has a 4xx status code
func (o *PatchGuestNetworkInterfaceByIDNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this patch guest network interface by Id no content response has a 5xx status code
func (o *PatchGuestNetworkInterfaceByIDNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this patch guest network interface by Id no content response a status code equal to that given
func (o *PatchGuestNetworkInterfaceByIDNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the patch guest network interface by Id no content response
func (o *PatchGuestNetworkInterfaceByIDNoContent) Code() int {
	return 204
}

func (o *PatchGuestNetworkInterfaceByIDNoContent) Error() string {
	return fmt.Sprintf("[PATCH /network-interfaces/{iface_id}][%d] patchGuestNetworkInterfaceByIdNoContent ", 204)
}

func (o *PatchGuestNetworkInterfaceByIDNoContent) String() string {
	return fmt.Sprintf("[PATCH /network-interfaces/{iface_id}][%d] patchGuestNetworkInterfaceByIdNoContent ", 204)
}

func (o *PatchGuestNetworkInterfaceByIDNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPatchGuestNetworkInterfaceByIDBadRequest creates a PatchGuestNetworkInterfaceByIDBadRequest with default headers values
func NewPatchGuestNetworkInterfaceByIDBadRequest() *PatchGuestNetworkInterfaceByIDBadRequest {
	return &PatchGuestNetworkInterfaceByIDBadRequest{}
}

/*
PatchGuestNetworkInterfaceByIDBadRequest describes a response with status code 400, with default header values.

Network interface cannot be updated due to bad input
*/
type PatchGuestNetworkInterfaceByIDBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this patch guest network interface by Id bad request response has a 2xx status code
func (o *PatchGuestNetworkInterfaceByIDBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this patch guest network interface by Id bad request response has a 3xx status code
func (o *PatchGuestNetworkInterfaceByIDBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this patch guest network interface by Id bad request response has a 4xx status code
func (o *PatchGuestNetworkInterfaceByIDBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this patch guest network interface by Id bad request response has a 5xx status code
func (o *PatchGuestNetworkInterfaceByIDBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this patch guest network interface by Id bad request response a status code equal to that given
func (o *PatchGuestNetworkInterfaceByIDBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the patch guest network interface by Id bad request response
func (o *PatchGuestNetworkInterfaceByIDBadRequest) Code() int {
	return 400
}

func (o *PatchGuestNetworkInterfaceByIDBadRequest) Error() string {
	return fmt.Sprintf("[PATCH /network-interfaces/{iface_id}][%d] patchGuestNetworkInterfaceByIdBadRequest  %+v", 400, o.Payload)
}

func (o *PatchGuestNetworkInterfaceByIDBadRequest) String() string {
	return fmt.Sprintf("[PATCH /network-interfaces/{iface_id}][%d] patchGuestNetworkInterfaceByIdBadRequest  %+v", 400, o.Payload)
}

func (o *PatchGuestNetworkInterfaceByIDBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PatchGuestNetworkInterfaceByIDBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchGuestNetworkInterfaceByIDDefault creates a PatchGuestNetworkInterfaceByIDDefault with default headers values
func NewPatchGuestNetworkInterfaceByIDDefault(code int) *PatchGuestNetworkInterfaceByIDDefault {
	return &PatchGuestNetworkInterfaceByIDDefault{
		_statusCode: code,
	}
}

/*
PatchGuestNetworkInterfaceByIDDefault describes a response with status code -1, with default header values.

Internal server error
*/
type PatchGuestNetworkInterfaceByIDDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this patch guest network interface by ID default response has a 2xx status code
func (o *PatchGuestNetworkInterfaceByIDDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this patch guest network interface by ID default response has a 3xx status code
func (o *PatchGuestNetworkInterfaceByIDDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this patch guest network interface by ID default response has a 4xx status code
func (o *PatchGuestNetworkInterfaceByIDDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this patch guest network interface by ID default response has a 5xx status code
func (o *PatchGuestNetworkInterfaceByIDDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this patch guest network interface by ID default response a status code equal to that given
func (o *PatchGuestNetworkInterfaceByIDDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the patch guest network interface by ID default response
func (o *PatchGuestNetworkInterfaceByIDDefault) Code() int {
	return o._statusCode
}

func (o *PatchGuestNetworkInterfaceByIDDefault) Error() string {
	return fmt.Sprintf("[PATCH /network-interfaces/{iface_id}][%d] patchGuestNetworkInterfaceByID default  %+v", o._statusCode, o.Payload)
}

func (o *PatchGuestNetworkInterfaceByIDDefault) String() string {
	return fmt.Sprintf("[PATCH /network-interfaces/{iface_id}][%d] patchGuestNetworkInterfaceByID default  %+v", o._statusCode, o.Payload)
}

func (o *PatchGuestNetworkInterfaceByIDDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PatchGuestNetworkInterfaceByIDDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/patch_machine_configuration_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPatchMachineConfigurationParams creates a new PatchMachineConfigurationParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPatchMachineConfigurationParams() *PatchMachineConfigurationParams {
	return &PatchMachineConfigurationParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPatchMachineConfigurationParamsWithTimeout creates a new PatchMachineConfigurationParams object
// with the ability to set a timeout on a request.
func NewPatchMachineConfigurationParamsWithTimeout(timeout time.Duration) *PatchMachineConfigurationParams {
	return &PatchMachineConfigurationParams{
		timeout: timeout,
	}
}

// NewPatchMachineConfigurationParamsWithContext creates a new PatchMachineConfigurationParams object
// with the ability to set a context for a request.
func NewPatchMachineConfigurationParamsWithContext(ctx context.Context) *PatchMachineConfigurationParams {
	return &PatchMachineConfigurationParams{
		Context: ctx,
	}
}

// NewPatchMachineConfigurationParamsWithHTTPClient creates a new PatchMachineConfigurationParams object
// with the ability to set a custom HTTPClient for a request.
func NewPatchMachineConfigurationParamsWithHTTPClient(client *http.Client) *PatchMachineConfigurationParams {
	return &PatchMachineConfigurationParams{
		HTTPClient: client,
	}
}

/*
PatchMachineConfigurationParams contains all the parameters to send to the API endpoint

	for the patch machine configuration operation.

	Typically these are written to a http.Request.
*/
type PatchMachineConfigurationParams struct {

	/* Body.

	   A subset of Machine Configuration Parameters
	*/
	Body *models.MachineConfiguration

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the patch machine configuration params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PatchMachineConfigurationParams) WithDefaults() *PatchMachineConfigurationParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the patch machine configuration params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PatchMachineConfigurationParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the patch machine configuration params
func (o *PatchMachineConfigurationParams) WithTimeout(timeout time.Duration) *PatchMachineConfigurationParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the patch machine configuration params
func (o *PatchMachineConfigurationParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the patch machine configuration params
func (o *PatchMachineConfigurationParams) WithContext(ctx context.Context) *PatchMachineConfigurationParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the patch machine configuration params
func (o *PatchMachineConfigurationParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the patch machine configuration params
func (o *PatchMachineConfigurationParams) WithHTTPClient(client *http.Client) *PatchMachineConfigurationParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the patch machine configuration params
func (o *PatchMachineConfigurationParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the patch machine configuration params
func (o *PatchMachineConfigurationParams) WithBody(body *models.MachineConfiguration) *PatchMachineConfigurationParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the patch machine configuration params
func (o *PatchMachineConfigurationParams) SetBody(body *models.MachineConfiguration) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *PatchMachineConfigurationParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/patch_machine_configuration_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PatchMachineConfigurationReader is a Reader for the PatchMachineConfiguration structure.
type PatchMachineConfigurationReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PatchMachineConfigurationReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPatchMachineConfigurationNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPatchMachineConfigurationBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPatchMachineConfigurationDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPatchMachineConfigurationNoContent creates a PatchMachineConfigurationNoContent with default headers values
func NewPatchMachineConfigurationNoContent() *PatchMachineConfigurationNoContent {
	return &PatchMachineConfigurationNoContent{}
}

/*
PatchMachineConfigurationNoContent describes a response with status code 204, with default header values.

Machine Configuration created/updated
*/
type PatchMachineConfigurationNoContent struct {
}

// IsSuccess returns true when this patch machine configuration no content response has a 2xx status code
func (o *PatchMachineConfigurationNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this patch machine configuration no content response has a 3xx status code
func (o *PatchMachineConfigurationNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this patch machine configuration no content response has a 4xx status code
func (o *PatchMachineConfigurationNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this patch machine configuration no content response has a 5xx status code
func (o *PatchMachineConfigurationNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this patch machine configuration no content response a status code equal to that given
func (o *PatchMachineConfigurationNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the patch machine configuration no content response
func (o *PatchMachineConfigurationNoContent) Code() int {
	return 204
}

func (o *PatchMachineConfigurationNoContent) Error() string {
	return fmt.Sprintf("[PATCH /machine-config][%d] patchMachineConfigurationNoContent ", 204)
}

func (o *PatchMachineConfigurationNoContent) String() string {
	return fmt.Sprintf("[PATCH /machine-config][%d] patchMachineConfigurationNoContent ", 204)
}

func (o *PatchMachineConfigurationNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPatchMachineConfigurationBadRequest creates a PatchMachineConfigurationBadRequest with default headers values
func NewPatchMachineConfigurationBadRequest() *PatchMachineConfigurationBadRequest {
	return &PatchMachineConfigurationBadRequest{}
}

/*
PatchMachineConfigurationBadRequest describes a response with status code 400, with default header values.

Machine Configuration cannot be updated due to bad input
*/
type PatchMachineConfigurationBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this patch machine configuration bad request response has a 2xx status code
func (o *PatchMachineConfigurationBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this patch machine configuration bad request response has a 3xx status code
func (o *PatchMachineConfigurationBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this patch machine configuration bad request response has a 4xx status code
func (o *PatchMachineConfigurationBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this patch machine configuration bad request response has a 5xx status code
func (o *PatchMachineConfigurationBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this patch machine configuration bad request response a status code equal to that given
func (o *PatchMachineConfigurationBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the patch machine configuration bad request response
func (o *PatchMachineConfigurationBadRequest) Code() int {
	return 400
}

func (o *PatchMachineConfigurationBadRequest) Error() string {
	return fmt.Sprintf("[PATCH /machine-config][%d] patchMachineConfigurationBadRequest  %+v", 400, o.Payload)
}

func (o *PatchMachineConfigurationBadRequest) String() string {
	return fmt.Sprintf("[PATCH /machine-config][%d] patchMachineConfigurationBadRequest  %+v", 400, o.Payload)
}

func (o *PatchMachineConfigurationBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PatchMachineConfigurationBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchMachineConfigurationDefault creates a PatchMachineConfigurationDefault with default headers values
func NewPatchMachineConfigurationDefault(code int) *PatchMachineConfigurationDefault {
	return &PatchMachineConfigurationDefault{
		_statusCode: code,
	}
}

/*
PatchMachineConfigurationDefault describes a response with status code -1, with default header values.

Internal server error
*/
type PatchMachineConfigurationDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this patch machine configuration default response has a 2xx status code
func (o *PatchMachineConfigurationDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this patch machine configuration default response has a 3xx status code
func (o *PatchMachineConfigurationDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this patch machine configuration default response has a 4xx status code
func (o *PatchMachineConfigurationDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this patch machine configuration default response has a 5xx status code
func (o *PatchMachineConfigurationDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this patch machine configuration default response a status code equal to that given
func (o *PatchMachineConfigurationDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the patch machine configuration default response
func (o *PatchMachineConfigurationDefault) Code() int {
	return o._statusCode
}

func (o *PatchMachineConfigurationDefault) Error() string {
	return fmt.Sprintf("[PATCH /machine-config][%d] patchMachineConfiguration default  %+v", o._statusCode, o.Payload)
}

func (o *PatchMachineConfigurationDefault) String() string {
	return fmt.Sprintf("[PATCH /machine-config][%d] patchMachineConfiguration default  %+v", o._statusCode, o.Payload)
}

func (o *PatchMachineConfigurationDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PatchMachineConfigurationDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/patch_mmds_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPatchMmdsParams creates a new PatchMmdsParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPatchMmdsParams() *PatchMmdsParams {
	return &PatchMmdsParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPatchMmdsParamsWithTimeout creates a new PatchMmdsParams object
// with the ability to set a timeout on a request.
func NewPatchMmdsParamsWithTimeout(timeout time.Duration) *PatchMmdsParams {
	return &PatchMmdsParams{
		timeout: timeout,
	}
}

// NewPatchMmdsParamsWithContext creates a new PatchMmdsParams object
// with the ability to set a context for a request.
func NewPatchMmdsParamsWithContext(ctx context.Context) *PatchMmdsParams {
	return &PatchMmdsParams{
		Context: ctx,
	}
}

// NewPatchMmdsParamsWithHTTPClient creates a new PatchMmdsParams object
// with the ability to set a custom HTTPClient for a request.
func NewPatchMmdsParamsWithHTTPClient(client *http.Client) *PatchMmdsParams {
	return &PatchMmdsParams{
		HTTPClient: client,
	}
}

/*
PatchMmdsParams contains all the parameters to send to the API endpoint

	for the patch mmds operation.

	Typically these are written to a http.Request.
*/
type PatchMmdsParams struct {

	/* Body.

	   The MMDS data store patch JSON.
	*/
	Body models.MmdsContentsObject

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the patch mmds params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PatchMmdsParams) WithDefaults() *PatchMmdsParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the patch mmds params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PatchMmdsParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the patch mmds params
func (o *PatchMmdsParams) WithTimeout(timeout time.Duration) *PatchMmdsParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the patch mmds params
func (o *PatchMmdsParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the patch mmds params
func (o *PatchMmdsParams) WithContext(ctx context.Context) *PatchMmdsParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the patch mmds params
func (o *PatchMmdsParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the patch mmds params
func (o *PatchMmdsParams) WithHTTPClient(client *http.Client) *PatchMmdsParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the patch mmds params
func (o *PatchMmdsParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the patch mmds params
func (o *PatchMmdsParams) WithBody(body models.MmdsContentsObject) *PatchMmdsParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the patch mmds params
func (o *PatchMmdsParams) SetBody(body models.MmdsContentsObject) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *PatchMmdsParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/patch_mmds_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PatchMmdsReader is a Reader for the PatchMmds structure.
type PatchMmdsReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PatchMmdsReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPatchMmdsNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPatchMmdsBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPatchMmdsDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPatchMmdsNoContent creates a PatchMmdsNoContent with default headers values
func NewPatchMmdsNoContent() *PatchMmdsNoContent {
	return &PatchMmdsNoContent{}
}

/*
PatchMmdsNoContent describes a response with status code 204, with default header values.

MMDS data store updated.
*/
type PatchMmdsNoContent struct {
}

// IsSuccess returns true when this patch mmds no content response has a 2xx status code
func (o *PatchMmdsNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this patch mmds no content response has a 3xx status code
func (o *PatchMmdsNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this patch mmds no content response has a 4xx status code
func (o *PatchMmdsNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this patch mmds no content response has a 5xx status code
func (o *PatchMmdsNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this patch mmds no content response a status code equal to that given
func (o *PatchMmdsNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the patch mmds no content response
func (o *PatchMmdsNoContent) Code() int {
	return 204
}

func (o *PatchMmdsNoContent) Error() string {
	return fmt.Sprintf("[PATCH /mmds][%d] patchMmdsNoContent ", 204)
}

func (o *PatchMmdsNoContent) String() string {
	return fmt.Sprintf("[PATCH /mmds][%d] patchMmdsNoContent ", 204)
}

func (o *PatchMmdsNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPatchMmdsBadRequest creates a PatchMmdsBadRequest with default headers values
func NewPatchMmdsBadRequest() *PatchMmdsBadRequest {
	return &PatchMmdsBadRequest{}
}

/*
PatchMmdsBadRequest describes a response with status code 400, with default header values.

MMDS data store cannot be updated due to bad input.
*/
type PatchMmdsBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this patch mmds bad request response has a 2xx status code
func (o *PatchMmdsBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this patch mmds bad request response has a 3xx status code
func (o *PatchMmdsBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this patch mmds bad request response has a 4xx status code
func (o *PatchMmdsBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this patch mmds bad request response has a 5xx status code
func (o *PatchMmdsBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this patch mmds bad request response a status code equal to that given
func (o *PatchMmdsBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the patch mmds bad request response
func (o *PatchMmdsBadRequest) Code() int {
	return 400
}

func (o *PatchMmdsBadRequest) Error() string {
	return fmt.Sprintf("[PATCH /mmds][%d] patchMmdsBadRequest  %+v", 400, o.Payload)
}

func (o *PatchMmdsBadRequest) String() string {
	return fmt.Sprintf("[PATCH /mmds][%d] patchMmdsBadRequest  %+v", 400, o.Payload)
}

func (o *PatchMmdsBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PatchMmdsBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchMmdsDefault creates a PatchMmdsDefault with default headers values
func NewPatchMmdsDefault(code int) *PatchMmdsDefault {
	return &PatchMmdsDefault{
		_statusCode: code,
	}
}

/*
PatchMmdsDefault describes a response with status code -1, with default header values.

Internal server error
*/
type PatchMmdsDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this patch mmds default response has a 2xx status code
func (o *PatchMmdsDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this patch mmds default response has a 3xx status code
func (o *PatchMmdsDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this patch mmds default response has a 4xx status code
func (o *PatchMmdsDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this patch mmds default response has a 5xx status code
func (o *PatchMmdsDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this patch mmds default response a status code equal to that given
func (o *PatchMmdsDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the patch mmds default response
func (o *PatchMmdsDefault) Code() int {
	return o._statusCode
}

func (o *PatchMmdsDefault) Error() string {
	return fmt.Sprintf("[PATCH /mmds][%d] patchMmds default  %+v", o._statusCode, o.Payload)
}

func (o *PatchMmdsDefault) String() string {
	return fmt.Sprintf("[PATCH /mmds][%d] patchMmds default  %+v", o._statusCode, o.Payload)
}

func (o *PatchMmdsDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PatchMmdsDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/patch_vm_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPatchVMParams creates a new PatchVMParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPatchVMParams() *PatchVMParams {
	return &PatchVMParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPatchVMParamsWithTimeout creates a new PatchVMParams object
// with the ability to set a timeout on a request.
func NewPatchVMParamsWithTimeout(timeout time.Duration) *PatchVMParams {
	return &PatchVMParams{
		timeout: timeout,
	}
}

// NewPatchVMParamsWithContext creates a new PatchVMParams object
// with the ability to set a context for a request.
func NewPatchVMParamsWithContext(ctx context.Context) *PatchVMParams {
	return &PatchVMParams{
		Context: ctx,
	}
}

// NewPatchVMParamsWithHTTPClient creates a new PatchVMParams object
// with the ability to set a custom HTTPClient for a request.
func NewPatchVMParamsWithHTTPClient(client *http.Client) *PatchVMParams {
	return &PatchVMParams{
		HTTPClient: client,
	}
}

/*
PatchVMParams contains all the parameters to send to the API endpoint

	for the patch Vm operation.

	Typically these are written to a http.Request.
*/
type PatchVMParams struct {

	/* Body.

	   The microVM state
	*/
	Body *models.VM

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the patch Vm params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PatchVMParams) WithDefaults() *PatchVMParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the patch Vm params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PatchVMParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the patch Vm params
func (o *PatchVMParams) WithTimeout(timeout time.Duration) *PatchVMParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the patch Vm params
func (o *PatchVMParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the patch Vm params
func (o *PatchVMParams) WithContext(ctx context.Context) *PatchVMParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the patch Vm params
func (o *PatchVMParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the patch Vm params
func (o *PatchVMParams) WithHTTPClient(client *http.Client) *PatchVMParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the patch Vm params
func (o *PatchVMParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the patch Vm params
func (o *PatchVMParams) WithBody(body *models.VM) *PatchVMParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the patch Vm params
func (o *PatchVMParams) SetBody(body *models.VM) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *PatchVMParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/patch_vm_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PatchVMReader is a Reader for the PatchVM structure.
type PatchVMReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PatchVMReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPatchVMNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPatchVMBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPatchVMDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPatchVMNoContent creates a PatchVMNoContent with default headers values
func NewPatchVMNoContent() *PatchVMNoContent {
	return &PatchVMNoContent{}
}

/*
PatchVMNoContent describes a response with status code 204, with default header values.

Vm state updated
*/
type PatchVMNoContent struct {
}

// IsSuccess returns true when this patch Vm no content response has a 2xx status code
func (o *PatchVMNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this patch Vm no content response has a 3xx status code
func (o *PatchVMNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this patch Vm no content response has a 4xx status code
func (o *PatchVMNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this patch Vm no content response has a 5xx status code
func (o *PatchVMNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this patch Vm no content response a status code equal to that given
func (o *PatchVMNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the patch Vm no content response
func (o *PatchVMNoContent) Code() int {
	return 204
}

func (o *PatchVMNoContent) Error() string {
	return fmt.Sprintf("[PATCH /vm][%d] patchVmNoContent ", 204)
}

func (o *PatchVMNoContent) String() string {
	return fmt.Sprintf("[PATCH /vm][%d] patchVmNoContent ", 204)
}

func (o *PatchVMNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPatchVMBadRequest creates a PatchVMBadRequest with default headers values
func NewPatchVMBadRequest() *PatchVMBadRequest {
	return &PatchVMBadRequest{}
}

/*
PatchVMBadRequest describes a response with status code 400, with default header values.

Vm state cannot be updated due to bad input
*/
type PatchVMBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this patch Vm bad request response has a 2xx status code
func (o *PatchVMBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this patch Vm bad request response has a 3xx status code
func (o *PatchVMBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this patch Vm bad request response has a 4xx status code
func (o *PatchVMBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this patch Vm bad request response has a 5xx status code
func (o *PatchVMBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this patch Vm bad request response a status code equal to that given
func (o *PatchVMBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the patch Vm bad request response
func (o *PatchVMBadRequest) Code() int {
	return 400
}

func (o *PatchVMBadRequest) Error() string {
	return fmt.Sprintf("[PATCH /vm][%d] patchVmBadRequest  %+v", 400, o.Payload)
}

func (o *PatchVMBadRequest) String() string {
	return fmt.Sprintf("[PATCH /vm][%d] patchVmBadRequest  %+v", 400, o.Payload)
}

func (o *PatchVMBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PatchVMBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchVMDefault creates a PatchVMDefault with default headers values
func NewPatchVMDefault(code int) *PatchVMDefault {
	return &PatchVMDefault{
		_statusCode: code,
	}
}

/*
PatchVMDefault describes a response with status code -1, with default header values.

Internal server error
*/
type PatchVMDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this patch Vm default response has a 2xx status code
func (o *PatchVMDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this patch Vm default response has a 3xx status code
func (o *PatchVMDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this patch Vm default response has a 4xx status code
func (o *PatchVMDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this patch Vm default response has a 5xx status code
func (o *PatchVMDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this patch Vm default response a status code equal to that given
func (o *PatchVMDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the patch Vm default response
func (o *PatchVMDefault) Code() int {
	return o._statusCode
}

func (o *PatchVMDefault) Error() string {
	return fmt.Sprintf("[PATCH /vm][%d] patchVm default  %+v", o._statusCode, o.Payload)
}

func (o *PatchVMDefault) String() string {
	return fmt.Sprintf("[PATCH /vm][%d] patchVm default  %+v", o._statusCode, o.Payload)
}

func (o *PatchVMDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PatchVMDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/put_balloon_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPutBalloonParams creates a new PutBalloonParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPutBalloonParams() *PutBalloonParams {
	return &PutBalloonParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPutBalloonParamsWithTimeout creates a new PutBalloonParams object
// with the ability to set a timeout on a request.
func NewPutBalloonParamsWithTimeout(timeout time.Duration) *PutBalloonParams {
	return &PutBalloonParams{
		timeout: timeout,
	}
}

// NewPutBalloonParamsWithContext creates a new PutBalloonParams object
// with the ability to set a context for a request.
func NewPutBalloonParamsWithContext(ctx context.Context) *PutBalloonParams {
	return &PutBalloonParams{
		Context: ctx,
	}
}

// NewPutBalloonParamsWithHTTPClient creates a new PutBalloonParams object
// with the ability to set a custom HTTPClient for a request.
func NewPutBalloonParamsWithHTTPClient(client *http.Client) *PutBalloonParams {
	return &PutBalloonParams{
		HTTPClient: client,
	}
}

/*
PutBalloonParams contains all the parameters to send to the API endpoint

	for the put balloon operation.

	Typically these are written to a http.Request.
*/
type PutBalloonParams struct {

	/* Body.

	   Balloon properties
	*/
	Body *models.Balloon

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the put balloon params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutBalloonParams) WithDefaults() *PutBalloonParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the put balloon params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutBalloonParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the put balloon params
func (o *PutBalloonParams) WithTimeout(timeout time.Duration) *PutBalloonParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the put balloon params
func (o *PutBalloonParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the put balloon params
func (o *PutBalloonParams) WithContext(ctx context.Context) *PutBalloonParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the put balloon params
func (o *PutBalloonParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the put balloon params
func (o *PutBalloonParams) WithHTTPClient(client *http.Client) *PutBalloonParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the put balloon params
func (o *PutBalloonParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the put balloon params
func (o *PutBalloonParams) WithBody(body *models.Balloon) *PutBalloonParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the put balloon params
func (o *PutBalloonParams) SetBody(body *models.Balloon) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *PutBalloonParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/put_balloon_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PutBalloonReader is a Reader for the PutBalloon structure.
type PutBalloonReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PutBalloonReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPutBalloonNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPutBalloonBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPutBalloonDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPutBalloonNoContent creates a PutBalloonNoContent with default headers values
func NewPutBalloonNoContent() *PutBalloonNoContent {
	return &PutBalloonNoContent{}
}

/*
PutBalloonNoContent describes a response with status code 204, with default header values.

Balloon device created/updated
*/
type PutBalloonNoContent struct {
}

// IsSuccess returns true when this put balloon no content response has a 2xx status code
func (o *PutBalloonNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this put balloon no content response has a 3xx status code
func (o *PutBalloonNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put balloon no content response has a 4xx status code
func (o *PutBalloonNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this put balloon no content response has a 5xx status code
func (o *PutBalloonNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this put balloon no content response a status code equal to that given
func (o *PutBalloonNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the put balloon no content response
func (o *PutBalloonNoContent) Code() int {
	return 204
}

func (o *PutBalloonNoContent) Error() string {
	return fmt.Sprintf("[PUT /balloon][%d] putBalloonNoContent ", 204)
}

func (o *PutBalloonNoContent) String() string {
	return fmt.Sprintf("[PUT /balloon][%d] putBalloonNoContent ", 204)
}

func (o *PutBalloonNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPutBalloonBadRequest creates a PutBalloonBadRequest with default headers values
func NewPutBalloonBadRequest() *PutBalloonBadRequest {
	return &PutBalloonBadRequest{}
}

/*
PutBalloonBadRequest describes a response with status code 400, with default header values.

Balloon device cannot be created/updated due to bad input
*/
type PutBalloonBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this put balloon bad request response has a 2xx status code
func (o *PutBalloonBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this put balloon bad request response has a 3xx status code
func (o *PutBalloonBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put balloon bad request response has a 4xx status code
func (o *PutBalloonBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this put balloon bad request response has a 5xx status code
func (o *PutBalloonBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this put balloon bad request response a status code equal to that given
func (o *PutBalloonBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the put balloon bad request response
func (o *PutBalloonBadRequest) Code() int {
	return 400
}

func (o *PutBalloonBadRequest) Error() string {
	return fmt.Sprintf("[PUT /balloon][%d] putBalloonBadRequest  %+v", 400, o.Payload)
}

func (o *PutBalloonBadRequest) String() string {
	return fmt.Sprintf("[PUT /balloon][%d] putBalloonBadRequest  %+v", 400, o.Payload)
}

func (o *PutBalloonBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutBalloonBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPutBalloonDefault creates a PutBalloonDefault with default headers values
func NewPutBalloonDefault(code int) *PutBalloonDefault {
	return &PutBalloonDefault{
		_statusCode: code,
	}
}

/*
PutBalloonDefault describes a response with status code -1, with default header values.

Internal server error
*/
type PutBalloonDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this put balloon default response has a 2xx status code
func (o *PutBalloonDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this put balloon default response has a 3xx status code
func (o *PutBalloonDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this put balloon default response has a 4xx status code
func (o *PutBalloonDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this put balloon default response has a 5xx status code
func (o *PutBalloonDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this put balloon default response a status code equal to that given
func (o *PutBalloonDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the put balloon default response
func (o *PutBalloonDefault) Code() int {
	return o._statusCode
}

func (o *PutBalloonDefault) Error() string {
	return fmt.Sprintf("[PUT /balloon][%d] putBalloon default  %+v", o._statusCode, o.Payload)
}

func (o *PutBalloonDefault) String() string {
	return fmt.Sprintf("[PUT /balloon][%d] putBalloon default  %+v", o._statusCode, o.Payload)
}

func (o *PutBalloonDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutBalloonDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/put_cpu_configuration_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPutCPUConfigurationParams creates a new PutCPUConfigurationParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPutCPUConfigurationParams() *PutCPUConfigurationParams {
	return &PutCPUConfigurationParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPutCPUConfigurationParamsWithTimeout creates a new PutCPUConfigurationParams object
// with the ability to set a timeout on a request.
func NewPutCPUConfigurationParamsWithTimeout(timeout time.Duration) *PutCPUConfigurationParams {
	return &PutCPUConfigurationParams{
		timeout: timeout,
	}
}

// NewPutCPUConfigurationParamsWithContext creates a new PutCPUConfigurationParams object
// with the ability to set a context for a request.
func NewPutCPUConfigurationParamsWithContext(ctx context.Context) *PutCPUConfigurationParams {
	return &PutCPUConfigurationParams{
		Context: ctx,
	}
}

// NewPutCPUConfigurationParamsWithHTTPClient creates a new PutCPUConfigurationParams object
// with the ability to set a custom HTTPClient for a request.
func NewPutCPUConfigurationParamsWithHTTPClient(client *http.Client) *PutCPUConfigurationParams {
	return &PutCPUConfigurationParams{
		HTTPClient: client,
	}
}

/*
PutCPUConfigurationParams contains all the parameters to send to the API endpoint

	for the put Cpu configuration operation.

	Typically these are written to a http.Request.
*/
type PutCPUConfigurationParams struct {

	/* Body.

	   CPU configuration request
	*/
	Body *models.CPUConfig

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the put Cpu configuration params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutCPUConfigurationParams) WithDefaults() *PutCPUConfigurationParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the put Cpu configuration params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutCPUConfigurationParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the put Cpu configuration params
func (o *PutCPUConfigurationParams) WithTimeout(timeout time.Duration) *PutCPUConfigurationParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the put Cpu configuration params
func (o *PutCPUConfigurationParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the put Cpu configuration params
func (o *PutCPUConfigurationParams) WithContext(ctx context.Context) *PutCPUConfigurationParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the put Cpu configuration params
func (o *PutCPUConfigurationParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the put Cpu configuration params
func (o *PutCPUConfigurationParams) WithHTTPClient(client *http.Client) *PutCPUConfigurationParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the put Cpu configuration params
func (o *PutCPUConfigurationParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the put Cpu configuration params
func (o *PutCPUConfigurationParams) WithBody(body *models.CPUConfig) *PutCPUConfigurationParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the put Cpu configuration params
func (o *PutCPUConfigurationParams) SetBody(body *models.CPUConfig) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *PutCPUConfigurationParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/put_cpu_configuration_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PutCPUConfigurationReader is a Reader for the PutCPUConfiguration structure.
type PutCPUConfigurationReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PutCPUConfigurationReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPutCPUConfigurationNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPutCPUConfigurationBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPutCPUConfigurationDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPutCPUConfigurationNoContent creates a PutCPUConfigurationNoContent with default headers values
func NewPutCPUConfigurationNoContent() *PutCPUConfigurationNoContent {
	return &PutCPUConfigurationNoContent{}
}

/*
PutCPUConfigurationNoContent describes a response with status code 204, with default header values.

CPU configuration set successfully
*/
type PutCPUConfigurationNoContent struct {
}

// IsSuccess returns true when this put Cpu configuration no content response has a 2xx status code
func (o *PutCPUConfigurationNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this put Cpu configuration no content response has a 3xx status code
func (o *PutCPUConfigurationNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put Cpu configuration no content response has a 4xx status code
func (o *PutCPUConfigurationNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this put Cpu configuration no content response has a 5xx status code
func (o *PutCPUConfigurationNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this put Cpu configuration no content response a status code equal to that given
func (o *PutCPUConfigurationNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the put Cpu configuration no content response
func (o *PutCPUConfigurationNoContent) Code() int {
	return 204
}

func (o *PutCPUConfigurationNoContent) Error() string {
	return fmt.Sprintf("[PUT /cpu-config][%d] putCpuConfigurationNoContent ", 204)
}

func (o *PutCPUConfigurationNoContent) String() string {
	return fmt.Sprintf("[PUT /cpu-config][%d] putCpuConfigurationNoContent ", 204)
}

func (o *PutCPUConfigurationNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPutCPUConfigurationBadRequest creates a PutCPUConfigurationBadRequest with default headers values
func NewPutCPUConfigurationBadRequest() *PutCPUConfigurationBadRequest {
	return &PutCPUConfigurationBadRequest{}
}

/*
PutCPUConfigurationBadRequest describes a response with status code 400, with default header values.

CPU configuration cannot be updated due to invalid input format
*/
type PutCPUConfigurationBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this put Cpu configuration bad request response has a 2xx status code
func (o *PutCPUConfigurationBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this put Cpu configuration bad request response has a 3xx status code
func (o *PutCPUConfigurationBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put Cpu configuration bad request response has a 4xx status code
func (o *PutCPUConfigurationBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this put Cpu configuration bad request response has a 5xx status code
func (o *PutCPUConfigurationBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this put Cpu configuration bad request response a status code equal to that given
func (o *PutCPUConfigurationBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the put Cpu configuration bad request response
func (o *PutCPUConfigurationBadRequest) Code() int {
	return 400
}

func (o *PutCPUConfigurationBadRequest) Error() string {
	return fmt.Sprintf("[PUT /cpu-config][%d] putCpuConfigurationBadRequest  %+v", 400, o.Payload)
}

func (o *PutCPUConfigurationBadRequest) String() string {
	return fmt.Sprintf("[PUT /cpu-config][%d] putCpuConfigurationBadRequest  %+v", 400, o.Payload)
}

func (o *PutCPUConfigurationBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutCPUConfigurationBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPutCPUConfigurationDefault creates a PutCPUConfigurationDefault with default headers values
func NewPutCPUConfigurationDefault(code int) *PutCPUConfigurationDefault {
	return &PutCPUConfigurationDefault{
		_statusCode: code,
	}
}

/*
PutCPUConfigurationDefault describes a response with status code -1, with default header values.

Internal server error
*/
type PutCPUConfigurationDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this put Cpu configuration default response has a 2xx status code
func (o *PutCPUConfigurationDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this put Cpu configuration default response has a 3xx status code
func (o *PutCPUConfigurationDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this put Cpu configuration default response has a 4xx status code
func (o *PutCPUConfigurationDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this put Cpu configuration default response has a 5xx status code
func (o *PutCPUConfigurationDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this put Cpu configuration default response a status code equal to that given
func (o *PutCPUConfigurationDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the put Cpu configuration default response
func (o *PutCPUConfigurationDefault) Code() int {
	return o._statusCode
}

func (o *PutCPUConfigurationDefault) Error() string {
	return fmt.Sprintf("[PUT /cpu-config][%d] putCpuConfiguration default  %+v", o._statusCode, o.Payload)
}

func (o *PutCPUConfigurationDefault) String() string {
	return fmt.Sprintf("[PUT /cpu-config][%d] putCpuConfiguration default  %+v", o._statusCode, o.Payload)
}

func (o *PutCPUConfigurationDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutCPUConfigurationDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/put_entropy_device_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPutEntropyDeviceParams creates a new PutEntropyDeviceParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPutEntropyDeviceParams() *PutEntropyDeviceParams {
	return &PutEntropyDeviceParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPutEntropyDeviceParamsWithTimeout creates a new PutEntropyDeviceParams object
// with the ability to set a timeout on a request.
func NewPutEntropyDeviceParamsWithTimeout(timeout time.Duration) *PutEntropyDeviceParams {
	return &PutEntropyDeviceParams{
		timeout: timeout,
	}
}

// NewPutEntropyDeviceParamsWithContext creates a new PutEntropyDeviceParams object
// with the ability to set a context for a request.
func NewPutEntropyDeviceParamsWithContext(ctx context.Context) *PutEntropyDeviceParams {
	return &PutEntropyDeviceParams{
		Context: ctx,
	}
}

// NewPutEntropyDeviceParamsWithHTTPClient creates a new PutEntropyDeviceParams object
// with the ability to set a custom HTTPClient for a request.
func NewPutEntropyDeviceParamsWithHTTPClient(client *http.Client) *PutEntropyDeviceParams {
	return &PutEntropyDeviceParams{
		HTTPClient: client,
	}
}

/*
PutEntropyDeviceParams contains all the parameters to send to the API endpoint

	for the put entropy device operation.

	Typically these are written to a http.Request.
*/
type PutEntropyDeviceParams struct {

	/* Body.

	   Guest entropy device properties
	*/
	Body *models.EntropyDevice

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the put entropy device params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutEntropyDeviceParams) WithDefaults() *PutEntropyDeviceParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the put entropy device params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutEntropyDeviceParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the put entropy device params
func (o *PutEntropyDeviceParams) WithTimeout(timeout time.Duration) *PutEntropyDeviceParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the put entropy device params
func (o *PutEntropyDeviceParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the put entropy device params
func (o *PutEntropyDeviceParams) WithContext(ctx context.Context) *PutEntropyDeviceParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the put entropy device params
func (o *PutEntropyDeviceParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the put entropy device params
func (o *PutEntropyDeviceParams) WithHTTPClient(client *http.Client) *PutEntropyDeviceParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the put entropy device params
func (o *PutEntropyDeviceParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the put entropy device params
func (o *PutEntropyDeviceParams) WithBody(body *models.EntropyDevice) *PutEntropyDeviceParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the put entropy device params
func (o *PutEntropyDeviceParams) SetBody(body *models.EntropyDevice) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *PutEntropyDeviceParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/put_entropy_device_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PutEntropyDeviceReader is a Reader for the PutEntropyDevice structure.
type PutEntropyDeviceReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PutEntropyDeviceReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPutEntropyDeviceNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	default:
		result := NewPutEntropyDeviceDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPutEntropyDeviceNoContent creates a PutEntropyDeviceNoContent with default headers values
func NewPutEntropyDeviceNoContent() *PutEntropyDeviceNoContent {
	return &PutEntropyDeviceNoContent{}
}

/*
PutEntropyDeviceNoContent describes a response with status code 204, with default header values.

Entropy device created
*/
type PutEntropyDeviceNoContent struct {
}

// IsSuccess returns true when this put entropy device no content response has a 2xx status code
func (o *PutEntropyDeviceNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this put entropy device no content response has a 3xx status code
func (o *PutEntropyDeviceNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put entropy device no content response has a 4xx status code
func (o *PutEntropyDeviceNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this put entropy device no content response has a 5xx status code
func (o *PutEntropyDeviceNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this put entropy device no content response a status code equal to that given
func (o *PutEntropyDeviceNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the put entropy device no content response
func (o *PutEntropyDeviceNoContent) Code() int {
	return 204
}

func (o *PutEntropyDeviceNoContent) Error() string {
	return fmt.Sprintf("[PUT /entropy][%d] putEntropyDeviceNoContent ", 204)
}

func (o *PutEntropyDeviceNoContent) String() string {
	return fmt.Sprintf("[PUT /entropy][%d] putEntropyDeviceNoContent ", 204)
}

func (o *PutEntropyDeviceNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPutEntropyDeviceDefault creates a PutEntropyDeviceDefault with default headers values
func NewPutEntropyDeviceDefault(code int) *PutEntropyDeviceDefault {
	return &PutEntropyDeviceDefault{
		_statusCode: code,
	}
}

/*
PutEntropyDeviceDefault describes a response with status code -1, with default header values.

Internal server error
*/
type PutEntropyDeviceDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this put entropy device default response has a 2xx status code
func (o *PutEntropyDeviceDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this put entropy device default response has a 3xx status code
func (o *PutEntropyDeviceDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this put entropy device default response has a 4xx status code
func (o *PutEntropyDeviceDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this put entropy device default response has a 5xx status code
func (o *PutEntropyDeviceDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this put entropy device default response a status code equal to that given
func (o *PutEntropyDeviceDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the put entropy device default response
func (o *PutEntropyDeviceDefault) Code() int {
	return o._statusCode
}

func (o *PutEntropyDeviceDefault) Error() string {
	return fmt.Sprintf("[PUT /entropy][%d] putEntropyDevice default  %+v", o._statusCode, o.Payload)
}

func (o *PutEntropyDeviceDefault) String() string {
	return fmt.Sprintf("[PUT /entropy][%d] putEntropyDevice default  %+v", o._statusCode, o.Payload)
}

func (o *PutEntropyDeviceDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutEntropyDeviceDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/put_guest_boot_source_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPutGuestBootSourceParams creates a new PutGuestBootSourceParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPutGuestBootSourceParams() *PutGuestBootSourceParams {
	return &PutGuestBootSourceParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPutGuestBootSourceParamsWithTimeout creates a new PutGuestBootSourceParams object
// with the ability to set a timeout on a request.
func NewPutGuestBootSourceParamsWithTimeout(timeout time.Duration) *PutGuestBootSourceParams {
	return &PutGuestBootSourceParams{
		timeout: timeout,
	}
}

// NewPutGuestBootSourceParamsWithContext creates a new PutGuestBootSourceParams object
// with the ability to set a context for a request.
func NewPutGuestBootSourceParamsWithContext(ctx context.Context) *PutGuestBootSourceParams {
	return &PutGuestBootSourceParams{
		Context: ctx,
	}
}

// NewPutGuestBootSourceParamsWithHTTPClient creates a new PutGuestBootSourceParams object
// with the ability to set a custom HTTPClient for a request.
func NewPutGuestBootSourceParamsWithHTTPClient(client *http.Client) *PutGuestBootSourceParams {
	return &PutGuestBootSourceParams{
		HTTPClient: client,
	}
}

/*
PutGuestBootSourceParams contains all the parameters to send to the API endpoint

	for the put guest boot source operation.

	Typically these are written to a http.Request.
*/
type PutGuestBootSourceParams struct {

	/* Body.

	   Guest boot source properties
	*/
	Body *models.BootSource

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the put guest boot source params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutGuestBootSourceParams) WithDefaults() *PutGuestBootSourceParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the put guest boot source params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutGuestBootSourceParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the put guest boot source params
func (o *PutGuestBootSourceParams) WithTimeout(timeout time.Duration) *PutGuestBootSourceParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the put guest boot source params
func (o *PutGuestBootSourceParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the put guest boot source params
func (o *PutGuestBootSourceParams) WithContext(ctx context.Context) *PutGuestBootSourceParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the put guest boot source params
func (o *PutGuestBootSourceParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the put guest boot source params
func (o *PutGuestBootSourceParams) WithHTTPClient(client *http.Client) *PutGuestBootSourceParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the put guest boot source params
func (o *PutGuestBootSourceParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the put guest boot source params
func (o *PutGuestBootSourceParams) WithBody(body *models.BootSource) *PutGuestBootSourceParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the put guest boot source params
func (o *PutGuestBootSourceParams) SetBody(body *models.BootSource) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *PutGuestBootSourceParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/put_guest_boot_source_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PutGuestBootSourceReader is a Reader for the PutGuestBootSource structure.
type PutGuestBootSourceReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PutGuestBootSourceReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPutGuestBootSourceNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPutGuestBootSourceBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPutGuestBootSourceDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPutGuestBootSourceNoContent creates a PutGuestBootSourceNoContent with default headers values
func NewPutGuestBootSourceNoContent() *PutGuestBootSourceNoContent {
	return &PutGuestBootSourceNoContent{}
}

/*
PutGuestBootSourceNoContent describes a response with status code 204, with default header values.

Boot source created/updated
*/
type PutGuestBootSourceNoContent struct {
}

// IsSuccess returns true when this put guest boot source no content response has a 2xx status code
func (o *PutGuestBootSourceNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this put guest boot source no content response has a 3xx status code
func (o *PutGuestBootSourceNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put guest boot source no content response has a 4xx status code
func (o *PutGuestBootSourceNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this put guest boot source no content response has a 5xx status code
func (o *PutGuestBootSourceNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this put guest boot source no content response a status code equal to that given
func (o *PutGuestBootSourceNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the put guest boot source no content response
func (o *PutGuestBootSourceNoContent) Code() int {
	return 204
}

func (o *PutGuestBootSourceNoContent) Error() string {
	return fmt.Sprintf("[PUT /boot-source][%d] putGuestBootSourceNoContent ", 204)
}

func (o *PutGuestBootSourceNoContent) String() string {
	return fmt.Sprintf("[PUT /boot-source][%d] putGuestBootSourceNoContent ", 204)
}

func (o *PutGuestBootSourceNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPutGuestBootSourceBadRequest creates a PutGuestBootSourceBadRequest with default headers values
func NewPutGuestBootSourceBadRequest() *PutGuestBootSourceBadRequest {
	return &PutGuestBootSourceBadRequest{}
}

/*
PutGuestBootSourceBadRequest describes a response with status code 400, with default header values.

Boot source cannot be created due to bad input
*/
type PutGuestBootSourceBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this put guest boot source bad request response has a 2xx status code
func (o *PutGuestBootSourceBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this put guest boot source bad request response has a 3xx status code
func (o *PutGuestBootSourceBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put guest boot source bad request response has a 4xx status code
func (o *PutGuestBootSourceBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this put guest boot source bad request response has a 5xx status code
func (o *PutGuestBootSourceBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this put guest boot source bad request response a status code equal to that given
func (o *PutGuestBootSourceBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the put guest boot source bad request response
func (o *PutGuestBootSourceBadRequest) Code() int {
	return 400
}

func (o *PutGuestBootSourceBadRequest) Error() string {
	return fmt.Sprintf("[PUT /boot-source][%d] putGuestBootSourceBadRequest  %+v", 400, o.Payload)
}

func (o *PutGuestBootSourceBadRequest) String() string {
	return fmt.Sprintf("[PUT /boot-source][%d] putGuestBootSourceBadRequest  %+v", 400, o.Payload)
}

func (o *PutGuestBootSourceBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutGuestBootSourceBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPutGuestBootSourceDefault creates a PutGuestBootSourceDefault with default headers values
func NewPutGuestBootSourceDefault(code int) *PutGuestBootSourceDefault {
	return &PutGuestBootSourceDefault{
		_statusCode: code,
	}
}

/*
PutGuestBootSourceDefault describes a response with status code -1, with default header values.

Internal server error
*/
type PutGuestBootSourceDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this put guest boot source default response has a 2xx status code
func (o *PutGuestBootSourceDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this put guest boot source default response has a 3xx status code
func (o *PutGuestBootSourceDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this put guest boot source default response has a 4xx status code
func (o *PutGuestBootSourceDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this put guest boot source default response has a 5xx status code
func (o *PutGuestBootSourceDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this put guest boot source default response a status code equal to that given
func (o *PutGuestBootSourceDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the put guest boot source default response
func (o *PutGuestBootSourceDefault) Code() int {
	return o._statusCode
}

func (o *PutGuestBootSourceDefault) Error() string {
	return fmt.Sprintf("[PUT /boot-source][%d] putGuestBootSource default  %+v", o._statusCode, o.Payload)
}

func (o *PutGuestBootSourceDefault) String() string {
	return fmt.Sprintf("[PUT /boot-source][%d] putGuestBootSource default  %+v", o._statusCode, o.Payload)
}

func (o *PutGuestBootSourceDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutGuestBootSourceDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/put_guest_drive_by_id_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPutGuestDriveByIDParams creates a new PutGuestDriveByIDParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPutGuestDriveByIDParams() *PutGuestDriveByIDParams {
	return &PutGuestDriveByIDParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPutGuestDriveByIDParamsWithTimeout creates a new PutGuestDriveByIDParams object
// with the ability to set a timeout on a request.
func NewPutGuestDriveByIDParamsWithTimeout(timeout time.Duration) *PutGuestDriveByIDParams {
	return &PutGuestDriveByIDParams{
		timeout: timeout,
	}
}

// NewPutGuestDriveByIDParamsWithContext creates a new PutGuestDriveByIDParams object
// with the ability to set a context for a request.
func NewPutGuestDriveByIDParamsWithContext(ctx context.Context) *PutGuestDriveByIDParams {
	return &PutGuestDriveByIDParams{
		Context: ctx,
	}
}

// NewPutGuestDriveByIDParamsWithHTTPClient creates a new PutGuestDriveByIDParams object
// with the ability to set a custom HTTPClient for a request.
func NewPutGuestDriveByIDParamsWithHTTPClient(client *http.Client) *PutGuestDriveByIDParams {
	return &PutGuestDriveByIDParams{
		HTTPClient: client,
	}
}

/*
PutGuestDriveByIDParams contains all the parameters to send to the API endpoint

	for the put guest drive by ID operation.

	Typically these are written to a http.Request.
*/
type PutGuestDriveByIDParams struct {

	/* Body.

	   Guest drive properties
	*/
	Body *models.Drive

	/* DriveID.

	   The id of the guest drive
	*/
	DriveID string

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the put guest drive by ID params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutGuestDriveByIDParams) WithDefaults() *PutGuestDriveByIDParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the put guest drive by ID params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutGuestDriveByIDParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the put guest drive by ID params
func (o *PutGuestDriveByIDParams) WithTimeout(timeout time.Duration) *PutGuestDriveByIDParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the put guest drive by ID params
func (o *PutGuestDriveByIDParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the put guest drive by ID params
func (o *PutGuestDriveByIDParams) WithContext(ctx context.Context) *PutGuestDriveByIDParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the put guest drive by ID params
func (o *PutGuestDriveByIDParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the put guest drive by ID params
func (o *PutGuestDriveByIDParams) WithHTTPClient(client *http.Client) *PutGuestDriveByIDParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the put guest drive by ID params
func (o *PutGuestDriveByIDParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the put guest drive by ID params
func (o *PutGuestDriveByIDParams) WithBody(body *models.Drive) *PutGuestDriveByIDParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the put guest drive by ID params
func (o *PutGuestDriveByIDParams) SetBody(body *models.Drive) {
	o.Body = body
}

// WithDriveID adds the driveID to the put guest drive by ID params
func (o *PutGuestDriveByIDParams) WithDriveID(driveID string) *PutGuestDriveByIDParams {
	o.SetDriveID(driveID)
	return o
}

// SetDriveID adds the driveId to the put guest drive by ID params
func (o *PutGuestDriveByIDParams) SetDriveID(driveID string) {
	o.DriveID = driveID
}

// WriteToRequest writes these params to a swagger request
func (o *PutGuestDriveByIDParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	// path param drive_id
	if err := r.SetPathParam("drive_id", o.DriveID); err != nil {
		return err
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/put_guest_drive_by_id_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PutGuestDriveByIDReader is a Reader for the PutGuestDriveByID structure.
type PutGuestDriveByIDReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PutGuestDriveByIDReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPutGuestDriveByIDNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPutGuestDriveByIDBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPutGuestDriveByIDDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPutGuestDriveByIDNoContent creates a PutGuestDriveByIDNoContent with default headers values
func NewPutGuestDriveByIDNoContent() *PutGuestDriveByIDNoContent {
	return &PutGuestDriveByIDNoContent{}
}

/*
PutGuestDriveByIDNoContent describes a response with status code 204, with default header values.

Drive created/updated
*/
type PutGuestDriveByIDNoContent struct {
}

// IsSuccess returns true when this put guest drive by Id no content response has a 2xx status code
func (o *PutGuestDriveByIDNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this put guest drive by Id no content response has a 3xx status code
func (o *PutGuestDriveByIDNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put guest drive by Id no content response has a 4xx status code
func (o *PutGuestDriveByIDNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this put guest drive by Id no content response has a 5xx status code
func (o *PutGuestDriveByIDNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this put guest drive by Id no content response a status code equal to that given
func (o *PutGuestDriveByIDNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the put guest drive by Id no content response
func (o *PutGuestDriveByIDNoContent) Code() int {
	return 204
}

func (o *PutGuestDriveByIDNoContent) Error() string {
	return fmt.Sprintf("[PUT /drives/{drive_id}][%d] putGuestDriveByIdNoContent ", 204)
}

func (o *PutGuestDriveByIDNoContent) String() string {
	return fmt.Sprintf("[PUT /drives/{drive_id}][%d] putGuestDriveByIdNoContent ", 204)
}

func (o *PutGuestDriveByIDNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPutGuestDriveByIDBadRequest creates a PutGuestDriveByIDBadRequest with default headers values
func NewPutGuestDriveByIDBadRequest() *PutGuestDriveByIDBadRequest {
	return &PutGuestDriveByIDBadRequest{}
}

/*
PutGuestDriveByIDBadRequest describes a response with status code 400, with default header values.

Drive cannot be created/updated due to bad input
*/
type PutGuestDriveByIDBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this put guest drive by Id bad request response has a 2xx status code
func (o *PutGuestDriveByIDBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this put guest drive by Id bad request response has a 3xx status code
func (o *PutGuestDriveByIDBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put guest drive by Id bad request response has a 4xx status code
func (o *PutGuestDriveByIDBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this put guest drive by Id bad request response has a 5xx status code
func (o *PutGuestDriveByIDBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this put guest drive by Id bad request response a status code equal to that given
func (o *PutGuestDriveByIDBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the put guest drive by Id bad request response
func (o *PutGuestDriveByIDBadRequest) Code() int {
	return 400
}

func (o *PutGuestDriveByIDBadRequest) Error() string {
	return fmt.Sprintf("[PUT /drives/{drive_id}][%d] putGuestDriveByIdBadRequest  %+v", 400, o.Payload)
}

func (o *PutGuestDriveByIDBadRequest) String() string {
	return fmt.Sprintf("[PUT /drives/{drive_id}][%d] putGuestDriveByIdBadRequest  %+v", 400, o.Payload)
}

func (o *PutGuestDriveByIDBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutGuestDriveByIDBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPutGuestDriveByIDDefault creates a PutGuestDriveByIDDefault with default headers values
func NewPutGuestDriveByIDDefault(code int) *PutGuestDriveByIDDefault {
	return &PutGuestDriveByIDDefault{
		_statusCode: code,
	}
}

/*
PutGuestDriveByIDDefault describes a response with status code -1, with default header values.

Internal server error.
*/
type PutGuestDriveByIDDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this put guest drive by ID default response has a 2xx status code
func (o *PutGuestDriveByIDDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this put guest drive by ID default response has a 3xx status code
func (o *PutGuestDriveByIDDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this put guest drive by ID default response has a 4xx status code
func (o *PutGuestDriveByIDDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this put guest drive by ID default response has a 5xx status code
func (o *PutGuestDriveByIDDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this put guest drive by ID default response a status code equal to that given
func (o *PutGuestDriveByIDDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the put guest drive by ID default response
func (o *PutGuestDriveByIDDefault) Code() int {
	return o._statusCode
}

func (o *PutGuestDriveByIDDefault) Error() string {
	return fmt.Sprintf("[PUT /drives/{drive_id}][%d] putGuestDriveByID default  %+v", o._statusCode, o.Payload)
}

func (o *PutGuestDriveByIDDefault) String() string {
	return fmt.Sprintf("[PUT /drives/{drive_id}][%d] putGuestDriveByID default  %+v", o._statusCode, o.Payload)
}

func (o *PutGuestDriveByIDDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutGuestDriveByIDDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/put_guest_network_interface_by_id_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPutGuestNetworkInterfaceByIDParams creates a new PutGuestNetworkInterfaceByIDParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPutGuestNetworkInterfaceByIDParams() *PutGuestNetworkInterfaceByIDParams {
	return &PutGuestNetworkInterfaceByIDParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPutGuestNetworkInterfaceByIDParamsWithTimeout creates a new PutGuestNetworkInterfaceByIDParams object
// with the ability to set a timeout on a request.
func NewPutGuestNetworkInterfaceByIDParamsWithTimeout(timeout time.Duration) *PutGuestNetworkInterfaceByIDParams {
	return &PutGuestNetworkInterfaceByIDParams{
		timeout: timeout,
	}
}

// NewPutGuestNetworkInterfaceByIDParamsWithContext creates a new PutGuestNetworkInterfaceByIDParams object
// with the ability to set a context for a request.
func NewPutGuestNetworkInterfaceByIDParamsWithContext(ctx context.Context) *PutGuestNetworkInterfaceByIDParams {
	return &PutGuestNetworkInterfaceByIDParams{
		Context: ctx,
	}
}

// NewPutGuestNetworkInterfaceByIDParamsWithHTTPClient creates a new PutGuestNetworkInterfaceByIDParams object
// with the ability to set a custom HTTPClient for a request.
func NewPutGuestNetworkInterfaceByIDParamsWithHTTPClient(client *http.Client) *PutGuestNetworkInterfaceByIDParams {
	return &PutGuestNetworkInterfaceByIDParams{
		HTTPClient: client,
	}
}

/*
PutGuestNetworkInterfaceByIDParams contains all the parameters to send to the API endpoint

	for the put guest network interface by ID operation.

	Typically these are written to a http.Request.
*/
type PutGuestNetworkInterfaceByIDParams struct {

	/* Body.

	   Guest network interface properties
	*/
	Body *models.NetworkInterface

	/* IfaceID.

	   The id of the guest network interface
	*/
	IfaceID string

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the put guest network interface by ID params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutGuestNetworkInterfaceByIDParams) WithDefaults() *PutGuestNetworkInterfaceByIDParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the put guest network interface by ID params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutGuestNetworkInterfaceByIDParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the put guest network interface by ID params
func (o *PutGuestNetworkInterfaceByIDParams) WithTimeout(timeout time.Duration) *PutGuestNetworkInterfaceByIDParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the put guest network interface by ID params
func (o *PutGuestNetworkInterfaceByIDParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the put guest network interface by ID params
func (o *PutGuestNetworkInterfaceByIDParams) WithContext(ctx context.Context) *PutGuestNetworkInterfaceByIDParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the put guest network interface by ID params
func (o *PutGuestNetworkInterfaceByIDParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the put guest network interface by ID params
func (o *PutGuestNetworkInterfaceByIDParams) WithHTTPClient(client *http.Client) *PutGuestNetworkInterfaceByIDParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the put guest network interface by ID params
func (o *PutGuestNetworkInterfaceByIDParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the put guest network interface by ID params
func (o *PutGuestNetworkInterfaceByIDParams) WithBody(body *models.NetworkInterface) *PutGuestNetworkInterfaceByIDParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the put guest network interface by ID params
func (o *PutGuestNetworkInterfaceByIDParams) SetBody(body *models.NetworkInterface) {
	o.Body = body
}

// WithIfaceID adds the ifaceID to the put guest network interface by ID params
func (o *PutGuestNetworkInterfaceByIDParams) WithIfaceID(ifaceID string) *PutGuestNetworkInterfaceByIDParams {
	o.SetIfaceID(ifaceID)
	return o
}

// SetIfaceID adds the ifaceId to the put guest network interface by ID params
func (o *PutGuestNetworkInterfaceByIDParams) SetIfaceID(ifaceID string) {
	o.IfaceID = ifaceID
}

// WriteToRequest writes these params to a swagger request
func (o *PutGuestNetworkInterfaceByIDParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	// path param iface_id
	if err := r.SetPathParam("iface_id", o.IfaceID); err != nil {
		return err
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/put_guest_network_interface_by_id_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PutGuestNetworkInterfaceByIDReader is a Reader for the PutGuestNetworkInterfaceByID structure.
type PutGuestNetworkInterfaceByIDReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PutGuestNetworkInterfaceByIDReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPutGuestNetworkInterfaceByIDNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPutGuestNetworkInterfaceByIDBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPutGuestNetworkInterfaceByIDDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPutGuestNetworkInterfaceByIDNoContent creates a PutGuestNetworkInterfaceByIDNoContent with default headers values
func NewPutGuestNetworkInterfaceByIDNoContent() *PutGuestNetworkInterfaceByIDNoContent {
	return &PutGuestNetworkInterfaceByIDNoContent{}
}

/*
PutGuestNetworkInterfaceByIDNoContent describes a response with status code 204, with default header values.

Network interface created/updated
*/
type PutGuestNetworkInterfaceByIDNoContent struct {
}

// IsSuccess returns true when this put guest network interface by Id no content response has a 2xx status code
func (o *PutGuestNetworkInterfaceByIDNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this put guest network interface by Id no content response has a 3xx status code
func (o *PutGuestNetworkInterfaceByIDNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put guest network interface by Id no content response has a 4xx status code
func (o *PutGuestNetworkInterfaceByIDNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this put guest network interface by Id no content response has a 5xx status code
func (o *PutGuestNetworkInterfaceByIDNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this put guest network interface by Id no content response a status code equal to that given
func (o *PutGuestNetworkInterfaceByIDNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the put guest network interface by Id no content response
func (o *PutGuestNetworkInterfaceByIDNoContent) Code() int {
	return 204
}

func (o *PutGuestNetworkInterfaceByIDNoContent) Error() string {
	return fmt.Sprintf("[PUT /network-interfaces/{iface_id}][%d] putGuestNetworkInterfaceByIdNoContent ", 204)
}

func (o *PutGuestNetworkInterfaceByIDNoContent) String() string {
	return fmt.Sprintf("[PUT /network-interfaces/{iface_id}][%d] putGuestNetworkInterfaceByIdNoContent ", 204)
}

func (o *PutGuestNetworkInterfaceByIDNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPutGuestNetworkInterfaceByIDBadRequest creates a PutGuestNetworkInterfaceByIDBadRequest with default headers values
func NewPutGuestNetworkInterfaceByIDBadRequest() *PutGuestNetworkInterfaceByIDBadRequest {
	return &PutGuestNetworkInterfaceByIDBadRequest{}
}

/*
PutGuestNetworkInterfaceByIDBadRequest describes a response with status code 400, with default header values.

Network interface cannot be created due to bad input
*/
type PutGuestNetworkInterfaceByIDBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this put guest network interface by Id bad request response has a 2xx status code
func (o *PutGuestNetworkInterfaceByIDBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this put guest network interface by Id bad request response has a 3xx status code
func (o *PutGuestNetworkInterfaceByIDBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put guest network interface by Id bad request response has a 4xx status code
func (o *PutGuestNetworkInterfaceByIDBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this put guest network interface by Id bad request response has a 5xx status code
func (o *PutGuestNetworkInterfaceByIDBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this put guest network interface by Id bad request response a status code equal to that given
func (o *PutGuestNetworkInterfaceByIDBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the put guest network interface by Id bad request response
func (o *PutGuestNetworkInterfaceByIDBadRequest) Code() int {
	return 400
}

func (o *PutGuestNetworkInterfaceByIDBadRequest) Error() string {
	return fmt.Sprintf("[PUT /network-interfaces/{iface_id}][%d] putGuestNetworkInterfaceByIdBadRequest  %+v", 400, o.Payload)
}

func (o *PutGuestNetworkInterfaceByIDBadRequest) String() string {
	return fmt.Sprintf("[PUT /network-interfaces/{iface_id}][%d] putGuestNetworkInterfaceByIdBadRequest  %+v", 400, o.Payload)
}

func (o *PutGuestNetworkInterfaceByIDBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutGuestNetworkInterfaceByIDBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPutGuestNetworkInterfaceByIDDefault creates a PutGuestNetworkInterfaceByIDDefault with default headers values
func NewPutGuestNetworkInterfaceByIDDefault(code int) *PutGuestNetworkInterfaceByIDDefault {
	return &PutGuestNetworkInterfaceByIDDefault{
		_statusCode: code,
	}
}

/*
PutGuestNetworkInterfaceByIDDefault describes a response with status code -1, with default header values.

Internal server error
*/
type PutGuestNetworkInterfaceByIDDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this put guest network interface by ID default response has a 2xx status code
func (o *PutGuestNetworkInterfaceByIDDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this put guest network interface by ID default response has a 3xx status code
func (o *PutGuestNetworkInterfaceByIDDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this put guest network interface by ID default response has a 4xx status code
func (o *PutGuestNetworkInterfaceByIDDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this put guest network interface by ID default response has a 5xx status code
func (o *PutGuestNetworkInterfaceByIDDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this put guest network interface by ID default response a status code equal to that given
func (o *PutGuestNetworkInterfaceByIDDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the put guest network interface by ID default response
func (o *PutGuestNetworkInterfaceByIDDefault) Code() int {
	return o._statusCode
}

func (o *PutGuestNetworkInterfaceByIDDefault) Error() string {
	return fmt.Sprintf("[PUT /network-interfaces/{iface_id}][%d] putGuestNetworkInterfaceByID default  %+v", o._statusCode, o.Payload)
}

func (o *PutGuestNetworkInterfaceByIDDefault) String() string {
	return fmt.Sprintf("[PUT /network-interfaces/{iface_id}][%d] putGuestNetworkInterfaceByID default  %+v", o._statusCode, o.Payload)
}

func (o *PutGuestNetworkInterfaceByIDDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutGuestNetworkInterfaceByIDDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/put_guest_vsock_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPutGuestVsockParams creates a new PutGuestVsockParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPutGuestVsockParams() *PutGuestVsockParams {
	return &PutGuestVsockParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPutGuestVsockParamsWithTimeout creates a new PutGuestVsockParams object
// with the ability to set a timeout on a request.
func NewPutGuestVsockParamsWithTimeout(timeout time.Duration) *PutGuestVsockParams {
	return &PutGuestVsockParams{
		timeout: timeout,
	}
}

// NewPutGuestVsockParamsWithContext creates a new PutGuestVsockParams object
// with the ability to set a context for a request.
func NewPutGuestVsockParamsWithContext(ctx context.Context) *PutGuestVsockParams {
	return &PutGuestVsockParams{
		Context: ctx,
	}
}

// NewPutGuestVsockParamsWithHTTPClient creates a new PutGuestVsockParams object
// with the ability to set a custom HTTPClient for a request.
func NewPutGuestVsockParamsWithHTTPClient(client *http.Client) *PutGuestVsockParams {
	return &PutGuestVsockParams{
		HTTPClient: client,
	}
}

/*
PutGuestVsockParams contains all the parameters to send to the API endpoint

	for the put guest vsock operation.

	Typically these are written to a http.Request.
*/
type PutGuestVsockParams struct {

	/* Body.

	   Guest vsock properties
	*/
	Body *models.Vsock

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the put guest vsock params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutGuestVsockParams) WithDefaults() *PutGuestVsockParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the put guest vsock params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutGuestVsockParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the put guest vsock params
func (o *PutGuestVsockParams) WithTimeout(timeout time.Duration) *PutGuestVsockParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the put guest vsock params
func (o *PutGuestVsockParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the put guest vsock params
func (o *PutGuestVsockParams) WithContext(ctx context.Context) *PutGuestVsockParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the put guest vsock params
func (o *PutGuestVsockParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the put guest vsock params
func (o *PutGuestVsockParams) WithHTTPClient(client *http.Client) *PutGuestVsockParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the put guest vsock params
func (o *PutGuestVsockParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the put guest vsock params
func (o *PutGuestVsockParams) WithBody(body *models.Vsock) *PutGuestVsockParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the put guest vsock params
func (o *PutGuestVsockParams) SetBody(body *models.Vsock) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *PutGuestVsockParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/put_guest_vsock_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PutGuestVsockReader is a Reader for the PutGuestVsock structure.
type PutGuestVsockReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PutGuestVsockReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPutGuestVsockNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPutGuestVsockBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPutGuestVsockDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPutGuestVsockNoContent creates a PutGuestVsockNoContent with default headers values
func NewPutGuestVsockNoContent() *PutGuestVsockNoContent {
	return &PutGuestVsockNoContent{}
}

/*
PutGuestVsockNoContent describes a response with status code 204, with default header values.

Vsock created/updated
*/
type PutGuestVsockNoContent struct {
}

// IsSuccess returns true when this put guest vsock no content response has a 2xx status code
func (o *PutGuestVsockNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this put guest vsock no content response has a 3xx status code
func (o *PutGuestVsockNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put guest vsock no content response has a 4xx status code
func (o *PutGuestVsockNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this put guest vsock no content response has a 5xx status code
func (o *PutGuestVsockNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this put guest vsock no content response a status code equal to that given
func (o *PutGuestVsockNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the put guest vsock no content response
func (o *PutGuestVsockNoContent) Code() int {
	return 204
}

func (o *PutGuestVsockNoContent) Error() string {
	return fmt.Sprintf("[PUT /vsock][%d] putGuestVsockNoContent ", 204)
}

func (o *PutGuestVsockNoContent) String() string {
	return fmt.Sprintf("[PUT /vsock][%d] putGuestVsockNoContent ", 204)
}

func (o *PutGuestVsockNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPutGuestVsockBadRequest creates a PutGuestVsockBadRequest with default headers values
func NewPutGuestVsockBadRequest() *PutGuestVsockBadRequest {
	return &PutGuestVsockBadRequest{}
}

/*
PutGuestVsockBadRequest describes a response with status code 400, with default header values.

Vsock cannot be created due to bad input
*/
type PutGuestVsockBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this put guest vsock bad request response has a 2xx status code
func (o *PutGuestVsockBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this put guest vsock bad request response has a 3xx status code
func (o *PutGuestVsockBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put guest vsock bad request response has a 4xx status code
func (o *PutGuestVsockBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this put guest vsock bad request response has a 5xx status code
func (o *PutGuestVsockBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this put guest vsock bad request response a status code equal to that given
func (o *PutGuestVsockBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the put guest vsock bad request response
func (o *PutGuestVsockBadRequest) Code() int {
	return 400
}

func (o *PutGuestVsockBadRequest) Error() string {
	return fmt.Sprintf("[PUT /vsock][%d] putGuestVsockBadRequest  %+v", 400, o.Payload)
}

func (o *PutGuestVsockBadRequest) String() string {
	return fmt.Sprintf("[PUT /vsock][%d] putGuestVsockBadRequest  %+v", 400, o.Payload)
}

func (o *PutGuestVsockBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutGuestVsockBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPutGuestVsockDefault creates a PutGuestVsockDefault with default headers values
func NewPutGuestVsockDefault(code int) *PutGuestVsockDefault {
	return &PutGuestVsockDefault{
		_statusCode: code,
	}
}

/*
PutGuestVsockDefault describes a response with status code -1, with default header values.

Internal server error
*/
type PutGuestVsockDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this put guest vsock default response has a 2xx status code
func (o *PutGuestVsockDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this put guest vsock default response has a 3xx status code
func (o *PutGuestVsockDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this put guest vsock default response has a 4xx status code
func (o *PutGuestVsockDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this put guest vsock default response has a 5xx status code
func (o *PutGuestVsockDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this put guest vsock default response a status code equal to that given
func (o *PutGuestVsockDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the put guest vsock default response
func (o *PutGuestVsockDefault) Code() int {
	return o._statusCode
}

func (o *PutGuestVsockDefault) Error() string {
	return fmt.Sprintf("[PUT /vsock][%d] putGuestVsock default  %+v", o._statusCode, o.Payload)
}

func (o *PutGuestVsockDefault) String() string {
	return fmt.Sprintf("[PUT /vsock][%d] putGuestVsock default  %+v", o._statusCode, o.Payload)
}

func (o *PutGuestVsockDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutGuestVsockDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/put_logger_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPutLoggerParams creates a new PutLoggerParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPutLoggerParams() *PutLoggerParams {
	return &PutLoggerParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPutLoggerParamsWithTimeout creates a new PutLoggerParams object
// with the ability to set a timeout on a request.
func NewPutLoggerParamsWithTimeout(timeout time.Duration) *PutLoggerParams {
	return &PutLoggerParams{
		timeout: timeout,
	}
}

// NewPutLoggerParamsWithContext creates a new PutLoggerParams object
// with the ability to set a context for a request.
func NewPutLoggerParamsWithContext(ctx context.Context) *PutLoggerParams {
	return &PutLoggerParams{
		Context: ctx,
	}
}

// NewPutLoggerParamsWithHTTPClient creates a new PutLoggerParams object
// with the ability to set a custom HTTPClient for a request.
func NewPutLoggerParamsWithHTTPClient(client *http.Client) *PutLoggerParams {
	return &PutLoggerParams{
		HTTPClient: client,
	}
}

/*
PutLoggerParams contains all the parameters to send to the API endpoint

	for the put logger operation.

	Typically these are written to a http.Request.
*/
type PutLoggerParams struct {

	/* Body.

	   Logging system description
	*/
	Body *models.Logger

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the put logger params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutLoggerParams) WithDefaults() *PutLoggerParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the put logger params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutLoggerParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the put logger params
func (o *PutLoggerParams) WithTimeout(timeout time.Duration) *PutLoggerParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the put logger params
func (o *PutLoggerParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the put logger params
func (o *PutLoggerParams) WithContext(ctx context.Context) *PutLoggerParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the put logger params
func (o *PutLoggerParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the put logger params
func (o *PutLoggerParams) WithHTTPClient(client *http.Client) *PutLoggerParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the put logger params
func (o *PutLoggerParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the put logger params
func (o *PutLoggerParams) WithBody(body *models.Logger) *PutLoggerParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the put logger params
func (o *PutLoggerParams) SetBody(body *models.Logger) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *PutLoggerParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/put_logger_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PutLoggerReader is a Reader for the PutLogger structure.
type PutLoggerReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PutLoggerReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPutLoggerNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPutLoggerBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPutLoggerDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPutLoggerNoContent creates a PutLoggerNoContent with default headers values
func NewPutLoggerNoContent() *PutLoggerNoContent {
	return &PutLoggerNoContent{}
}

/*
PutLoggerNoContent describes a response with status code 204, with default header values.

Logger created.
*/
type PutLoggerNoContent struct {
}

// IsSuccess returns true when this put logger no content response has a 2xx status code
func (o *PutLoggerNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this put logger no content response has a 3xx status code
func (o *PutLoggerNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put logger no content response has a 4xx status code
func (o *PutLoggerNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this put logger no content response has a 5xx status code
func (o *PutLoggerNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this put logger no content response a status code equal to that given
func (o *PutLoggerNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the put logger no content response
func (o *PutLoggerNoContent) Code() int {
	return 204
}

func (o *PutLoggerNoContent) Error() string {
	return fmt.Sprintf("[PUT /logger][%d] putLoggerNoContent ", 204)
}

func (o *PutLoggerNoContent) String() string {
	return fmt.Sprintf("[PUT /logger][%d] putLoggerNoContent ", 204)
}

func (o *PutLoggerNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPutLoggerBadRequest creates a PutLoggerBadRequest with default headers values
func NewPutLoggerBadRequest() *PutLoggerBadRequest {
	return &PutLoggerBadRequest{}
}

/*
PutLoggerBadRequest describes a response with status code 400, with default header values.

Logger cannot be initialized due to bad input.
*/
type PutLoggerBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this put logger bad request response has a 2xx status code
func (o *PutLoggerBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this put logger bad request response has a 3xx status code
func (o *PutLoggerBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put logger bad request response has a 4xx status code
func (o *PutLoggerBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this put logger bad request response has a 5xx status code
func (o *PutLoggerBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this put logger bad request response a status code equal to that given
func (o *PutLoggerBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the put logger bad request response
func (o *PutLoggerBadRequest) Code() int {
	return 400
}

func (o *PutLoggerBadRequest) Error() string {
	return fmt.Sprintf("[PUT /logger][%d] putLoggerBadRequest  %+v", 400, o.Payload)
}

func (o *PutLoggerBadRequest) String() string {
	return fmt.Sprintf("[PUT /logger][%d] putLoggerBadRequest  %+v", 400, o.Payload)
}

func (o *PutLoggerBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutLoggerBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPutLoggerDefault creates a PutLoggerDefault with default headers values
func NewPutLoggerDefault(code int) *PutLoggerDefault {
	return &PutLoggerDefault{
		_statusCode: code,
	}
}

/*
PutLoggerDefault describes a response with status code -1, with default header values.

Internal server error.
*/
type PutLoggerDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this put logger default response has a 2xx status code
func (o *PutLoggerDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this put logger default response has a 3xx status code
func (o *PutLoggerDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this put logger default response has a 4xx status code
func (o *PutLoggerDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this put logger default response has a 5xx status code
func (o *PutLoggerDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this put logger default response a status code equal to that given
func (o *PutLoggerDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the put logger default response
func (o *PutLoggerDefault) Code() int {
	return o._statusCode
}

func (o *PutLoggerDefault) Error() string {
	return fmt.Sprintf("[PUT /logger][%d] putLogger default  %+v", o._statusCode, o.Payload)
}

func (o *PutLoggerDefault) String() string {
	return fmt.Sprintf("[PUT /logger][%d] putLogger default  %+v", o._statusCode, o.Payload)
}

func (o *PutLoggerDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutLoggerDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/put_machine_configuration_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPutMachineConfigurationParams creates a new PutMachineConfigurationParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPutMachineConfigurationParams() *PutMachineConfigurationParams {
	return &PutMachineConfigurationParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPutMachineConfigurationParamsWithTimeout creates a new PutMachineConfigurationParams object
// with the ability to set a timeout on a request.
func NewPutMachineConfigurationParamsWithTimeout(timeout time.Duration) *PutMachineConfigurationParams {
	return &PutMachineConfigurationParams{
		timeout: timeout,
	}
}

// NewPutMachineConfigurationParamsWithContext creates a new PutMachineConfigurationParams object
// with the ability to set a context for a request.
func NewPutMachineConfigurationParamsWithContext(ctx context.Context) *PutMachineConfigurationParams {
	return &PutMachineConfigurationParams{
		Context: ctx,
	}
}

// NewPutMachineConfigurationParamsWithHTTPClient creates a new PutMachineConfigurationParams object
// with the ability to set a custom HTTPClient for a request.
func NewPutMachineConfigurationParamsWithHTTPClient(client *http.Client) *PutMachineConfigurationParams {
	return &PutMachineConfigurationParams{
		HTTPClient: client,
	}
}

/*
PutMachineConfigurationParams contains all the parameters to send to the API endpoint

	for the put machine configuration operation.

	Typically these are written to a http.Request.
*/
type PutMachineConfigurationParams struct {

	/* Body.

	   Machine Configuration Parameters
	*/
	Body *models.MachineConfiguration

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the put machine configuration params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutMachineConfigurationParams) WithDefaults() *PutMachineConfigurationParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the put machine configuration params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutMachineConfigurationParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the put machine configuration params
func (o *PutMachineConfigurationParams) WithTimeout(timeout time.Duration) *PutMachineConfigurationParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the put machine configuration params
func (o *PutMachineConfigurationParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the put machine configuration params
func (o *PutMachineConfigurationParams) WithContext(ctx context.Context) *PutMachineConfigurationParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the put machine configuration params
func (o *PutMachineConfigurationParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the put machine configuration params
func (o *PutMachineConfigurationParams) WithHTTPClient(client *http.Client) *PutMachineConfigurationParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the put machine configuration params
func (o *PutMachineConfigurationParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the put machine configuration params
func (o *PutMachineConfigurationParams) WithBody(body *models.MachineConfiguration) *PutMachineConfigurationParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the put machine configuration params
func (o *PutMachineConfigurationParams) SetBody(body *models.MachineConfiguration) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *PutMachineConfigurationParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/put_machine_configuration_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PutMachineConfigurationReader is a Reader for the PutMachineConfiguration structure.
type PutMachineConfigurationReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PutMachineConfigurationReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPutMachineConfigurationNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPutMachineConfigurationBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPutMachineConfigurationDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPutMachineConfigurationNoContent creates a PutMachineConfigurationNoContent with default headers values
func NewPutMachineConfigurationNoContent() *PutMachineConfigurationNoContent {
	return &PutMachineConfigurationNoContent{}
}

/*
PutMachineConfigurationNoContent describes a response with status code 204, with default header values.

Machine Configuration created/updated
*/
type PutMachineConfigurationNoContent struct {
}

// IsSuccess returns true when this put machine configuration no content response has a 2xx status code
func (o *PutMachineConfigurationNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this put machine configuration no content response has a 3xx status code
func (o *PutMachineConfigurationNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put machine configuration no content response has a 4xx status code
func (o *PutMachineConfigurationNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this put machine configuration no content response has a 5xx status code
func (o *PutMachineConfigurationNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this put machine configuration no content response a status code equal to that given
func (o *PutMachineConfigurationNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the put machine configuration no content response
func (o *PutMachineConfigurationNoContent) Code() int {
	return 204
}

func (o *PutMachineConfigurationNoContent) Error() string {
	return fmt.Sprintf("[PUT /machine-config][%d] putMachineConfigurationNoContent ", 204)
}

func (o *PutMachineConfigurationNoContent) String() string {
	return fmt.Sprintf("[PUT /machine-config][%d] putMachineConfigurationNoContent ", 204)
}

func (o *PutMachineConfigurationNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPutMachineConfigurationBadRequest creates a PutMachineConfigurationBadRequest with default headers values
func NewPutMachineConfigurationBadRequest() *PutMachineConfigurationBadRequest {
	return &PutMachineConfigurationBadRequest{}
}

/*
PutMachineConfigurationBadRequest describes a response with status code 400, with default header values.

Machine Configuration cannot be updated due to bad input
*/
type PutMachineConfigurationBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this put machine configuration bad request response has a 2xx status code
func (o *PutMachineConfigurationBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this put machine configuration bad request response has a 3xx status code
func (o *PutMachineConfigurationBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put machine configuration bad request response has a 4xx status code
func (o *PutMachineConfigurationBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this put machine configuration bad request response has a 5xx status code
func (o *PutMachineConfigurationBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this put machine configuration bad request response a status code equal to that given
func (o *PutMachineConfigurationBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the put machine configuration bad request response
func (o *PutMachineConfigurationBadRequest) Code() int {
	return 400
}

func (o *PutMachineConfigurationBadRequest) Error() string {
	return fmt.Sprintf("[PUT /machine-config][%d] putMachineConfigurationBadRequest  %+v", 400, o.Payload)
}

func (o *PutMachineConfigurationBadRequest) String() string {
	return fmt.Sprintf("[PUT /machine-config][%d] putMachineConfigurationBadRequest  %+v", 400, o.Payload)
}

func (o *PutMachineConfigurationBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutMachineConfigurationBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPutMachineConfigurationDefault creates a PutMachineConfigurationDefault with default headers values
func NewPutMachineConfigurationDefault(code int) *PutMachineConfigurationDefault {
	return &PutMachineConfigurationDefault{
		_statusCode: code,
	}
}

/*
PutMachineConfigurationDefault describes a response with status code -1, with default header values.

Internal server error
*/
type PutMachineConfigurationDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this put machine configuration default response has a 2xx status code
func (o *PutMachineConfigurationDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this put machine configuration default response has a 3xx status code
func (o *PutMachineConfigurationDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this put machine configuration default response has a 4xx status code
func (o *PutMachineConfigurationDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this put machine configuration default response has a 5xx status code
func (o *PutMachineConfigurationDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this put machine configuration default response a status code equal to that given
func (o *PutMachineConfigurationDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the put machine configuration default response
func (o *PutMachineConfigurationDefault) Code() int {
	return o._statusCode
}

func (o *PutMachineConfigurationDefault) Error() string {
	return fmt.Sprintf("[PUT /machine-config][%d] putMachineConfiguration default  %+v", o._statusCode, o.Payload)
}

func (o *PutMachineConfigurationDefault) String() string {
	return fmt.Sprintf("[PUT /machine-config][%d] putMachineConfiguration default  %+v", o._statusCode, o.Payload)
}

func (o *PutMachineConfigurationDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutMachineConfigurationDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/put_metrics_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPutMetricsParams creates a new PutMetricsParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPutMetricsParams() *PutMetricsParams {
	return &PutMetricsParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPutMetricsParamsWithTimeout creates a new PutMetricsParams object
// with the ability to set a timeout on a request.
func NewPutMetricsParamsWithTimeout(timeout time.Duration) *PutMetricsParams {
	return &PutMetricsParams{
		timeout: timeout,
	}
}

// NewPutMetricsParamsWithContext creates a new PutMetricsParams object
// with the ability to set a context for a request.
func NewPutMetricsParamsWithContext(ctx context.Context) *PutMetricsParams {
	return &PutMetricsParams{
		Context: ctx,
	}
}

// NewPutMetricsParamsWithHTTPClient creates a new PutMetricsParams object
// with the ability to set a custom HTTPClient for a request.
func NewPutMetricsParamsWithHTTPClient(client *http.Client) *PutMetricsParams {
	return &PutMetricsParams{
		HTTPClient: client,
	}
}

/*
PutMetricsParams contains all the parameters to send to the API endpoint

	for the put metrics operation.

	Typically these are written to a http.Request.
*/
type PutMetricsParams struct {

	/* Body.

	   Metrics system description
	*/
	Body *models.Metrics

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the put metrics params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutMetricsParams) WithDefaults() *PutMetricsParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the put metrics params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutMetricsParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the put metrics params
func (o *PutMetricsParams) WithTimeout(timeout time.Duration) *PutMetricsParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the put metrics params
func (o *PutMetricsParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the put metrics params
func (o *PutMetricsParams) WithContext(ctx context.Context) *PutMetricsParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the put metrics params
func (o *PutMetricsParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the put metrics params
func (o *PutMetricsParams) WithHTTPClient(client *http.Client) *PutMetricsParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the put metrics params
func (o *PutMetricsParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the put metrics params
func (o *PutMetricsParams) WithBody(body *models.Metrics) *PutMetricsParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the put metrics params
func (o *PutMetricsParams) SetBody(body *models.Metrics) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *PutMetricsParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/put_metrics_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PutMetricsReader is a Reader for the PutMetrics structure.
type PutMetricsReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PutMetricsReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPutMetricsNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPutMetricsBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPutMetricsDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPutMetricsNoContent creates a PutMetricsNoContent with default headers values
func NewPutMetricsNoContent() *PutMetricsNoContent {
	return &PutMetricsNoContent{}
}

/*
PutMetricsNoContent describes a response with status code 204, with default header values.

Metrics system created.
*/
type PutMetricsNoContent struct {
}

// IsSuccess returns true when this put metrics no content response has a 2xx status code
func (o *PutMetricsNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this put metrics no content response has a 3xx status code
func (o *PutMetricsNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put metrics no content response has a 4xx status code
func (o *PutMetricsNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this put metrics no content response has a 5xx status code
func (o *PutMetricsNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this put metrics no content response a status code equal to that given
func (o *PutMetricsNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the put metrics no content response
func (o *PutMetricsNoContent) Code() int {
	return 204
}

func (o *PutMetricsNoContent) Error() string {
	return fmt.Sprintf("[PUT /metrics][%d] putMetricsNoContent ", 204)
}

func (o *PutMetricsNoContent) String() string {
	return fmt.Sprintf("[PUT /metrics][%d] putMetricsNoContent ", 204)
}

func (o *PutMetricsNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPutMetricsBadRequest creates a PutMetricsBadRequest with default headers values
func NewPutMetricsBadRequest() *PutMetricsBadRequest {
	return &PutMetricsBadRequest{}
}

/*
PutMetricsBadRequest describes a response with status code 400, with default header values.

Metrics system cannot be initialized due to bad input request or metrics system already initialized.
*/
type PutMetricsBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this put metrics bad request response has a 2xx status code
func (o *PutMetricsBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this put metrics bad request response has a 3xx status code
func (o *PutMetricsBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put metrics bad request response has a 4xx status code
func (o *PutMetricsBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this put metrics bad request response has a 5xx status code
func (o *PutMetricsBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this put metrics bad request response a status code equal to that given
func (o *PutMetricsBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the put metrics bad request response
func (o *PutMetricsBadRequest) Code() int {
	return 400
}

func (o *PutMetricsBadRequest) Error() string {
	return fmt.Sprintf("[PUT /metrics][%d] putMetricsBadRequest  %+v", 400, o.Payload)
}

func (o *PutMetricsBadRequest) String() string {
	return fmt.Sprintf("[PUT /metrics][%d] putMetricsBadRequest  %+v", 400, o.Payload)
}

func (o *PutMetricsBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutMetricsBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPutMetricsDefault creates a PutMetricsDefault with default headers values
func NewPutMetricsDefault(code int) *PutMetricsDefault {
	return &PutMetricsDefault{
		_statusCode: code,
	}
}

/*
PutMetricsDefault describes a response with status code -1, with default header values.

Internal server error.
*/
type PutMetricsDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this put metrics default response has a 2xx status code
func (o *PutMetricsDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this put metrics default response has a 3xx status code
func (o *PutMetricsDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this put metrics default response has a 4xx status code
func (o *PutMetricsDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this put metrics default response has a 5xx status code
func (o *PutMetricsDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this put metrics default response a status code equal to that given
func (o *PutMetricsDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the put metrics default response
func (o *PutMetricsDefault) Code() int {
	return o._statusCode
}

func (o *PutMetricsDefault) Error() string {
	return fmt.Sprintf("[PUT /metrics][%d] putMetrics default  %+v", o._statusCode, o.Payload)
}

func (o *PutMetricsDefault) String() string {
	return fmt.Sprintf("[PUT /metrics][%d] putMetrics default  %+v", o._statusCode, o.Payload)
}

func (o *PutMetricsDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutMetricsDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/put_mmds_config_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPutMmdsConfigParams creates a new PutMmdsConfigParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPutMmdsConfigParams() *PutMmdsConfigParams {
	return &PutMmdsConfigParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPutMmdsConfigParamsWithTimeout creates a new PutMmdsConfigParams object
// with the ability to set a timeout on a request.
func NewPutMmdsConfigParamsWithTimeout(timeout time.Duration) *PutMmdsConfigParams {
	return &PutMmdsConfigParams{
		timeout: timeout,
	}
}

// NewPutMmdsConfigParamsWithContext creates a new PutMmdsConfigParams object
// with the ability to set a context for a request.
func NewPutMmdsConfigParamsWithContext(ctx context.Context) *PutMmdsConfigParams {
	return &PutMmdsConfigParams{
		Context: ctx,
	}
}

// NewPutMmdsConfigParamsWithHTTPClient creates a new PutMmdsConfigParams object
// with the ability to set a custom HTTPClient for a request.
func NewPutMmdsConfigParamsWithHTTPClient(client *http.Client) *PutMmdsConfigParams {
	return &PutMmdsConfigParams{
		HTTPClient: client,
	}
}

/*
PutMmdsConfigParams contains all the parameters to send to the API endpoint

	for the put mmds config operation.

	Typically these are written to a http.Request.
*/
type PutMmdsConfigParams struct {

	/* Body.

	   The MMDS configuration as JSON.
	*/
	Body *models.MmdsConfig

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the put mmds config params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutMmdsConfigParams) WithDefaults() *PutMmdsConfigParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the put mmds config params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutMmdsConfigParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the put mmds config params
func (o *PutMmdsConfigParams) WithTimeout(timeout time.Duration) *PutMmdsConfigParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the put mmds config params
func (o *PutMmdsConfigParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the put mmds config params
func (o *PutMmdsConfigParams) WithContext(ctx context.Context) *PutMmdsConfigParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the put mmds config params
func (o *PutMmdsConfigParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the put mmds config params
func (o *PutMmdsConfigParams) WithHTTPClient(client *http.Client) *PutMmdsConfigParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the put mmds config params
func (o *PutMmdsConfigParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the put mmds config params
func (o *PutMmdsConfigParams) WithBody(body *models.MmdsConfig) *PutMmdsConfigParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the put mmds config params
func (o *PutMmdsConfigParams) SetBody(body *models.MmdsConfig) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *PutMmdsConfigParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/put_mmds_config_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PutMmdsConfigReader is a Reader for the PutMmdsConfig structure.
type PutMmdsConfigReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PutMmdsConfigReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPutMmdsConfigNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPutMmdsConfigBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPutMmdsConfigDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPutMmdsConfigNoContent creates a PutMmdsConfigNoContent with default headers values
func NewPutMmdsConfigNoContent() *PutMmdsConfigNoContent {
	return &PutMmdsConfigNoContent{}
}

/*
PutMmdsConfigNoContent describes a response with status code 204, with default header values.

MMDS configuration was created/updated.
*/
type PutMmdsConfigNoContent struct {
}

// IsSuccess returns true when this put mmds config no content response has a 2xx status code
func (o *PutMmdsConfigNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this put mmds config no content response has a 3xx status code
func (o *PutMmdsConfigNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put mmds config no content response has a 4xx status code
func (o *PutMmdsConfigNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this put mmds config no content response has a 5xx status code
func (o *PutMmdsConfigNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this put mmds config no content response a status code equal to that given
func (o *PutMmdsConfigNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the put mmds config no content response
func (o *PutMmdsConfigNoContent) Code() int {
	return 204
}

func (o *PutMmdsConfigNoContent) Error() string {
	return fmt.Sprintf("[PUT /mmds/config][%d] putMmdsConfigNoContent ", 204)
}

func (o *PutMmdsConfigNoContent) String() string {
	return fmt.Sprintf("[PUT /mmds/config][%d] putMmdsConfigNoContent ", 204)
}

func (o *PutMmdsConfigNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPutMmdsConfigBadRequest creates a PutMmdsConfigBadRequest with default headers values
func NewPutMmdsConfigBadRequest() *PutMmdsConfigBadRequest {
	return &PutMmdsConfigBadRequest{}
}

/*
PutMmdsConfigBadRequest describes a response with status code 400, with default header values.

MMDS configuration cannot be updated due to bad input.
*/
type PutMmdsConfigBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this put mmds config bad request response has a 2xx status code
func (o *PutMmdsConfigBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this put mmds config bad request response has a 3xx status code
func (o *PutMmdsConfigBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put mmds config bad request response has a 4xx status code
func (o *PutMmdsConfigBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this put mmds config bad request response has a 5xx status code
func (o *PutMmdsConfigBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this put mmds config bad request response a status code equal to that given
func (o *PutMmdsConfigBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the put mmds config bad request response
func (o *PutMmdsConfigBadRequest) Code() int {
	return 400
}

func (o *PutMmdsConfigBadRequest) Error() string {
	return fmt.Sprintf("[PUT /mmds/config][%d] putMmdsConfigBadRequest  %+v", 400, o.Payload)
}

func (o *PutMmdsConfigBadRequest) String() string {
	return fmt.Sprintf("[PUT /mmds/config][%d] putMmdsConfigBadRequest  %+v", 400, o.Payload)
}

func (o *PutMmdsConfigBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutMmdsConfigBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPutMmdsConfigDefault creates a PutMmdsConfigDefault with default headers values
func NewPutMmdsConfigDefault(code int) *PutMmdsConfigDefault {
	return &PutMmdsConfigDefault{
		_statusCode: code,
	}
}

/*
PutMmdsConfigDefault describes a response with status code -1, with default header values.

Internal server error
*/
type PutMmdsConfigDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this put mmds config default response has a 2xx status code
func (o *PutMmdsConfigDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this put mmds config default response has a 3xx status code
func (o *PutMmdsConfigDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this put mmds config default response has a 4xx status code
func (o *PutMmdsConfigDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this put mmds config default response has a 5xx status code
func (o *PutMmdsConfigDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this put mmds config default response a status code equal to that given
func (o *PutMmdsConfigDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the put mmds config default response
func (o *PutMmdsConfigDefault) Code() int {
	return o._statusCode
}

func (o *PutMmdsConfigDefault) Error() string {
	return fmt.Sprintf("[PUT /mmds/config][%d] putMmdsConfig default  %+v", o._statusCode, o.Payload)
}

func (o *PutMmdsConfigDefault) String() string {
	return fmt.Sprintf("[PUT /mmds/config][%d] putMmdsConfig default  %+v", o._statusCode, o.Payload)
}

func (o *PutMmdsConfigDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutMmdsConfigDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/client/operations/put_mmds_parameters.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"net/http"
	"time"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	cr "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// NewPutMmdsParams creates a new PutMmdsParams object,
// with the default timeout for this client.
//
// Default values are not hydrated, since defaults are normally applied by the API server side.
//
// To enforce default values in parameter, use SetDefaults or WithDefaults.
func NewPutMmdsParams() *PutMmdsParams {
	return &PutMmdsParams{
		timeout: cr.DefaultTimeout,
	}
}

// NewPutMmdsParamsWithTimeout creates a new PutMmdsParams object
// with the ability to set a timeout on a request.
func NewPutMmdsParamsWithTimeout(timeout time.Duration) *PutMmdsParams {
	return &PutMmdsParams{
		timeout: timeout,
	}
}

// NewPutMmdsParamsWithContext creates a new PutMmdsParams object
// with the ability to set a context for a request.
func NewPutMmdsParamsWithContext(ctx context.Context) *PutMmdsParams {
	return &PutMmdsParams{
		Context: ctx,
	}
}

// NewPutMmdsParamsWithHTTPClient creates a new PutMmdsParams object
// with the ability to set a custom HTTPClient for a request.
func NewPutMmdsParamsWithHTTPClient(client *http.Client) *PutMmdsParams {
	return &PutMmdsParams{
		HTTPClient: client,
	}
}

/*
PutMmdsParams contains all the parameters to send to the API endpoint

	for the put mmds operation.

	Typically these are written to a http.Request.
*/
type PutMmdsParams struct {

	/* Body.

	   The MMDS data store as JSON.
	*/
	Body models.MmdsContentsObject

	timeout    time.Duration
	Context    context.Context
	HTTPClient *http.Client
}

// WithDefaults hydrates default values in the put mmds params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutMmdsParams) WithDefaults() *PutMmdsParams {
	o.SetDefaults()
	return o
}

// SetDefaults hydrates default values in the put mmds params (not the query body).
//
// All values with no default are reset to their zero value.
func (o *PutMmdsParams) SetDefaults() {
	// no default values defined for this parameter
}

// WithTimeout adds the timeout to the put mmds params
func (o *PutMmdsParams) WithTimeout(timeout time.Duration) *PutMmdsParams {
	o.SetTimeout(timeout)
	return o
}

// SetTimeout adds the timeout to the put mmds params
func (o *PutMmdsParams) SetTimeout(timeout time.Duration) {
	o.timeout = timeout
}

// WithContext adds the context to the put mmds params
func (o *PutMmdsParams) WithContext(ctx context.Context) *PutMmdsParams {
	o.SetContext(ctx)
	return o
}

// SetContext adds the context to the put mmds params
func (o *PutMmdsParams) SetContext(ctx context.Context) {
	o.Context = ctx
}

// WithHTTPClient adds the HTTPClient to the put mmds params
func (o *PutMmdsParams) WithHTTPClient(client *http.Client) *PutMmdsParams {
	o.SetHTTPClient(client)
	return o
}

// SetHTTPClient adds the HTTPClient to the put mmds params
func (o *PutMmdsParams) SetHTTPClient(client *http.Client) {
	o.HTTPClient = client
}

// WithBody adds the body to the put mmds params
func (o *PutMmdsParams) WithBody(body models.MmdsContentsObject) *PutMmdsParams {
	o.SetBody(body)
	return o
}

// SetBody adds the body to the put mmds params
func (o *PutMmdsParams) SetBody(body models.MmdsContentsObject) {
	o.Body = body
}

// WriteToRequest writes these params to a swagger request
func (o *PutMmdsParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

	if err := r.SetTimeout(o.timeout); err != nil {
		return err
	}
	var res []error
	if o.Body != nil {
		if err := r.SetBodyParam(o.Body); err != nil {
			return err
		}
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}



================================================
File: fc/client/operations/put_mmds_responses.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/fc/models"
)

// PutMmdsReader is a Reader for the PutMmds structure.
type PutMmdsReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PutMmdsReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 204:
		result := NewPutMmdsNoContent()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPutMmdsBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewPutMmdsDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewPutMmdsNoContent creates a PutMmdsNoContent with default headers values
func NewPutMmdsNoContent() *PutMmdsNoContent {
	return &PutMmdsNoContent{}
}

/*
PutMmdsNoContent describes a response with status code 204, with default header values.

MMDS data store created/updated.
*/
type PutMmdsNoContent struct {
}

// IsSuccess returns true when this put mmds no content response has a 2xx status code
func (o *PutMmdsNoContent) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this put mmds no content response has a 3xx status code
func (o *PutMmdsNoContent) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put mmds no content response has a 4xx status code
func (o *PutMmdsNoContent) IsClientError() bool {
	return false
}

// IsServerError returns true when this put mmds no content response has a 5xx status code
func (o *PutMmdsNoContent) IsServerError() bool {
	return false
}

// IsCode returns true when this put mmds no content response a status code equal to that given
func (o *PutMmdsNoContent) IsCode(code int) bool {
	return code == 204
}

// Code gets the status code for the put mmds no content response
func (o *PutMmdsNoContent) Code() int {
	return 204
}

func (o *PutMmdsNoContent) Error() string {
	return fmt.Sprintf("[PUT /mmds][%d] putMmdsNoContent ", 204)
}

func (o *PutMmdsNoContent) String() string {
	return fmt.Sprintf("[PUT /mmds][%d] putMmdsNoContent ", 204)
}

func (o *PutMmdsNoContent) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewPutMmdsBadRequest creates a PutMmdsBadRequest with default headers values
func NewPutMmdsBadRequest() *PutMmdsBadRequest {
	return &PutMmdsBadRequest{}
}

/*
PutMmdsBadRequest describes a response with status code 400, with default header values.

MMDS data store cannot be created due to bad input.
*/
type PutMmdsBadRequest struct {
	Payload *models.Error
}

// IsSuccess returns true when this put mmds bad request response has a 2xx status code
func (o *PutMmdsBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this put mmds bad request response has a 3xx status code
func (o *PutMmdsBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this put mmds bad request response has a 4xx status code
func (o *PutMmdsBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this put mmds bad request response has a 5xx status code
func (o *PutMmdsBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this put mmds bad request response a status code equal to that given
func (o *PutMmdsBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the put mmds bad request response
func (o *PutMmdsBadRequest) Code() int {
	return 400
}

func (o *PutMmdsBadRequest) Error() string {
	return fmt.Sprintf("[PUT /mmds][%d] putMmdsBadRequest  %+v", 400, o.Payload)
}

func (o *PutMmdsBadRequest) String() string {
	return fmt.Sprintf("[PUT /mmds][%d] putMmdsBadRequest  %+v", 400, o.Payload)
}

func (o *PutMmdsBadRequest) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutMmdsBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPutMmdsDefault creates a PutMmdsDefault with default headers values
func NewPutMmdsDefault(code int) *PutMmdsDefault {
	return &PutMmdsDefault{
		_statusCode: code,
	}
}

/*
PutMmdsDefault describes a response with status code -1, with default header values.

Internal server error
*/
type PutMmdsDefault struct {
	_statusCode int

	Payload *models.Error
}

// IsSuccess returns true when this put mmds default response has a 2xx status code
func (o *PutMmdsDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this put mmds default response has a 3xx status code
func (o *PutMmdsDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this put mmds default response has a 4xx status code
func (o *PutMmdsDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this put mmds default response has a 5xx status code
func (o *PutMmdsDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this put mmds default response a status code equal to that given
func (o *PutMmdsDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the put mmds default response
func (o *PutMmdsDefault) Code() int {
	return o._statusCode
}

func (o *PutMmdsDefault) Error() string {
	return fmt.Sprintf("[PUT /mmds][%d] putMmds default  %+v", o._statusCode, o.Payload)
}

func (o *PutMmdsDefault) String() string {
	return fmt.Sprintf("[PUT /mmds][%d] putMmds default  %+v", o._statusCode, o.Payload)
}

func (o *PutMmdsDefault) GetPayload() *models.Error {
	return o.Payload
}

func (o *PutMmdsDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Error)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}



================================================
File: fc/models/balloon.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Balloon Balloon device descriptor.
//
// swagger:model Balloon
type Balloon struct {

	// Target balloon size in MiB.
	// Required: true
	AmountMib *int64 `json:"amount_mib"`

	// Whether the balloon should deflate when the guest has memory pressure.
	// Required: true
	DeflateOnOom *bool `json:"deflate_on_oom"`

	// Interval in seconds between refreshing statistics. A non-zero value will enable the statistics. Defaults to 0.
	StatsPollingIntervals int64 `json:"stats_polling_interval_s,omitempty"`
}

// Validate validates this balloon
func (m *Balloon) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmountMib(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeflateOnOom(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Balloon) validateAmountMib(formats strfmt.Registry) error {

	if err := validate.Required("amount_mib", "body", m.AmountMib); err != nil {
		return err
	}

	return nil
}

func (m *Balloon) validateDeflateOnOom(formats strfmt.Registry) error {

	if err := validate.Required("deflate_on_oom", "body", m.DeflateOnOom); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this balloon based on context it is used
func (m *Balloon) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *Balloon) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Balloon) UnmarshalBinary(b []byte) error {
	var res Balloon
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/balloon_stats.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BalloonStats Describes the balloon device statistics.
//
// swagger:model BalloonStats
type BalloonStats struct {

	// Actual amount of memory (in MiB) the device is holding.
	// Required: true
	ActualMib *int64 `json:"actual_mib"`

	// Actual number of pages the device is holding.
	// Required: true
	ActualPages *int64 `json:"actual_pages"`

	// An estimate of how much memory is available (in bytes) for starting new applications, without pushing the system to swap.
	AvailableMemory int64 `json:"available_memory,omitempty"`

	// The amount of memory, in bytes, that can be quickly reclaimed without additional I/O. Typically these pages are used for caching files from disk.
	DiskCaches int64 `json:"disk_caches,omitempty"`

	// The amount of memory not being used for any purpose (in bytes).
	FreeMemory int64 `json:"free_memory,omitempty"`

	// The number of successful hugetlb page allocations in the guest.
	HugetlbAllocations int64 `json:"hugetlb_allocations,omitempty"`

	// The number of failed hugetlb page allocations in the guest.
	HugetlbFailures int64 `json:"hugetlb_failures,omitempty"`

	// The number of major page faults that have occurred.
	MajorFaults int64 `json:"major_faults,omitempty"`

	// The number of minor page faults that have occurred.
	MinorFaults int64 `json:"minor_faults,omitempty"`

	// The amount of memory that has been swapped in (in bytes).
	SwapIn int64 `json:"swap_in,omitempty"`

	// The amount of memory that has been swapped out to disk (in bytes).
	SwapOut int64 `json:"swap_out,omitempty"`

	// Target amount of memory (in MiB) the device aims to hold.
	// Required: true
	TargetMib *int64 `json:"target_mib"`

	// Target number of pages the device aims to hold.
	// Required: true
	TargetPages *int64 `json:"target_pages"`

	// The total amount of memory available (in bytes).
	TotalMemory int64 `json:"total_memory,omitempty"`
}

// Validate validates this balloon stats
func (m *BalloonStats) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActualMib(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateActualPages(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetMib(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetPages(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BalloonStats) validateActualMib(formats strfmt.Registry) error {

	if err := validate.Required("actual_mib", "body", m.ActualMib); err != nil {
		return err
	}

	return nil
}

func (m *BalloonStats) validateActualPages(formats strfmt.Registry) error {

	if err := validate.Required("actual_pages", "body", m.ActualPages); err != nil {
		return err
	}

	return nil
}

func (m *BalloonStats) validateTargetMib(formats strfmt.Registry) error {

	if err := validate.Required("target_mib", "body", m.TargetMib); err != nil {
		return err
	}

	return nil
}

func (m *BalloonStats) validateTargetPages(formats strfmt.Registry) error {

	if err := validate.Required("target_pages", "body", m.TargetPages); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this balloon stats based on context it is used
func (m *BalloonStats) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *BalloonStats) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BalloonStats) UnmarshalBinary(b []byte) error {
	var res BalloonStats
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/balloon_stats_update.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BalloonStatsUpdate Update the statistics polling interval, with the first statistics update scheduled immediately. Statistics cannot be turned on/off after boot.
//
// swagger:model BalloonStatsUpdate
type BalloonStatsUpdate struct {

	// Interval in seconds between refreshing statistics.
	// Required: true
	StatsPollingIntervals *int64 `json:"stats_polling_interval_s"`
}

// Validate validates this balloon stats update
func (m *BalloonStatsUpdate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStatsPollingIntervals(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BalloonStatsUpdate) validateStatsPollingIntervals(formats strfmt.Registry) error {

	if err := validate.Required("stats_polling_interval_s", "body", m.StatsPollingIntervals); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this balloon stats update based on context it is used
func (m *BalloonStatsUpdate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *BalloonStatsUpdate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BalloonStatsUpdate) UnmarshalBinary(b []byte) error {
	var res BalloonStatsUpdate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/balloon_update.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BalloonUpdate Balloon device descriptor.
//
// swagger:model BalloonUpdate
type BalloonUpdate struct {

	// Target balloon size in MiB.
	// Required: true
	AmountMib *int64 `json:"amount_mib"`
}

// Validate validates this balloon update
func (m *BalloonUpdate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmountMib(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BalloonUpdate) validateAmountMib(formats strfmt.Registry) error {

	if err := validate.Required("amount_mib", "body", m.AmountMib); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this balloon update based on context it is used
func (m *BalloonUpdate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *BalloonUpdate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BalloonUpdate) UnmarshalBinary(b []byte) error {
	var res BalloonUpdate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/boot_source.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BootSource Boot source descriptor.
//
// swagger:model BootSource
type BootSource struct {

	// Kernel boot arguments
	BootArgs string `json:"boot_args,omitempty"`

	// Host level path to the initrd image used to boot the guest
	InitrdPath string `json:"initrd_path,omitempty"`

	// Host level path to the kernel image used to boot the guest
	// Required: true
	KernelImagePath *string `json:"kernel_image_path"`
}

// Validate validates this boot source
func (m *BootSource) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateKernelImagePath(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BootSource) validateKernelImagePath(formats strfmt.Registry) error {

	if err := validate.Required("kernel_image_path", "body", m.KernelImagePath); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this boot source based on context it is used
func (m *BootSource) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *BootSource) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BootSource) UnmarshalBinary(b []byte) error {
	var res BootSource
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/cpu_config.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
)

// CPUConfig The CPU configuration template defines a set of bit maps as modifiers of flags accessed by register to be disabled/enabled for the microvm.
//
// swagger:model CpuConfig
type CPUConfig string

// Validate validates this Cpu config
func (m CPUConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// ContextValidate validates this Cpu config based on context it is used
func (m CPUConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}



================================================
File: fc/models/cpu_template.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

// CPUTemplate The CPU Template defines a set of flags to be disabled from the microvm so that the features exposed to the guest are the same as in the selected instance type. This parameter has been deprecated and it will be removed in future Firecracker release.
//
// swagger:model CpuTemplate
type CPUTemplate string

func NewCPUTemplate(value CPUTemplate) *CPUTemplate {
	return &value
}

// Pointer returns a pointer to a freshly-allocated CPUTemplate.
func (m CPUTemplate) Pointer() *CPUTemplate {
	return &m
}

const (

	// CPUTemplateC3 captures enum value "C3"
	CPUTemplateC3 CPUTemplate = "C3"

	// CPUTemplateT2 captures enum value "T2"
	CPUTemplateT2 CPUTemplate = "T2"

	// CPUTemplateT2S captures enum value "T2S"
	CPUTemplateT2S CPUTemplate = "T2S"

	// CPUTemplateT2CL captures enum value "T2CL"
	CPUTemplateT2CL CPUTemplate = "T2CL"

	// CPUTemplateT2A captures enum value "T2A"
	CPUTemplateT2A CPUTemplate = "T2A"

	// CPUTemplateV1N1 captures enum value "V1N1"
	CPUTemplateV1N1 CPUTemplate = "V1N1"

	// CPUTemplateNone captures enum value "None"
	CPUTemplateNone CPUTemplate = "None"
)

// for schema
var cpuTemplateEnum []interface{}

func init() {
	var res []CPUTemplate
	if err := json.Unmarshal([]byte(`["C3","T2","T2S","T2CL","T2A","V1N1","None"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cpuTemplateEnum = append(cpuTemplateEnum, v)
	}
}

func (m CPUTemplate) validateCPUTemplateEnum(path, location string, value CPUTemplate) error {
	if err := validate.EnumCase(path, location, value, cpuTemplateEnum, true); err != nil {
		return err
	}
	return nil
}

// Validate validates this Cpu template
func (m CPUTemplate) Validate(formats strfmt.Registry) error {
	var res []error

	// value enum
	if err := m.validateCPUTemplateEnum("", "body", m); err != nil {
		return err
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// ContextValidate validates this Cpu template based on context it is used
func (m CPUTemplate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}



================================================
File: fc/models/drive.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Drive drive
//
// swagger:model Drive
type Drive struct {

	// Represents the caching strategy for the block device.
	// Enum: [Unsafe Writeback]
	CacheType *string `json:"cache_type,omitempty"`

	// drive id
	// Required: true
	DriveID *string `json:"drive_id"`

	// Type of the IO engine used by the device. "Async" is supported on host kernels newer than 5.10.51. This field is optional for virtio-block config and should be omitted for vhost-user-block configuration.
	// Enum: [Sync Async]
	IoEngine *string `json:"io_engine,omitempty"`

	// Is block read only. This field is required for virtio-block config and should be omitted for vhost-user-block configuration.
	IsReadOnly bool `json:"is_read_only,omitempty"`

	// is root device
	// Required: true
	IsRootDevice *bool `json:"is_root_device"`

	// Represents the unique id of the boot partition of this device. It is optional and it will be taken into account only if the is_root_device field is true.
	Partuuid string `json:"partuuid,omitempty"`

	// Host level path for the guest drive. This field is required for virtio-block config and should be omitted for vhost-user-block configuration.
	PathOnHost string `json:"path_on_host,omitempty"`

	// rate limiter
	RateLimiter *RateLimiter `json:"rate_limiter,omitempty"`

	// Path to the socket of vhost-user-block backend. This field is required for vhost-user-block config should be omitted for virtio-block configuration.
	Socket string `json:"socket,omitempty"`
}

// Validate validates this drive
func (m *Drive) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCacheType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDriveID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIoEngine(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsRootDevice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRateLimiter(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var driveTypeCacheTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Unsafe","Writeback"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		driveTypeCacheTypePropEnum = append(driveTypeCacheTypePropEnum, v)
	}
}

const (

	// DriveCacheTypeUnsafe captures enum value "Unsafe"
	DriveCacheTypeUnsafe string = "Unsafe"

	// DriveCacheTypeWriteback captures enum value "Writeback"
	DriveCacheTypeWriteback string = "Writeback"
)

// prop value enum
func (m *Drive) validateCacheTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, driveTypeCacheTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Drive) validateCacheType(formats strfmt.Registry) error {
	if swag.IsZero(m.CacheType) { // not required
		return nil
	}

	// value enum
	if err := m.validateCacheTypeEnum("cache_type", "body", *m.CacheType); err != nil {
		return err
	}

	return nil
}

func (m *Drive) validateDriveID(formats strfmt.Registry) error {

	if err := validate.Required("drive_id", "body", m.DriveID); err != nil {
		return err
	}

	return nil
}

var driveTypeIoEnginePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Sync","Async"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		driveTypeIoEnginePropEnum = append(driveTypeIoEnginePropEnum, v)
	}
}

const (

	// DriveIoEngineSync captures enum value "Sync"
	DriveIoEngineSync string = "Sync"

	// DriveIoEngineAsync captures enum value "Async"
	DriveIoEngineAsync string = "Async"
)

// prop value enum
func (m *Drive) validateIoEngineEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, driveTypeIoEnginePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Drive) validateIoEngine(formats strfmt.Registry) error {
	if swag.IsZero(m.IoEngine) { // not required
		return nil
	}

	// value enum
	if err := m.validateIoEngineEnum("io_engine", "body", *m.IoEngine); err != nil {
		return err
	}

	return nil
}

func (m *Drive) validateIsRootDevice(formats strfmt.Registry) error {

	if err := validate.Required("is_root_device", "body", m.IsRootDevice); err != nil {
		return err
	}

	return nil
}

func (m *Drive) validateRateLimiter(formats strfmt.Registry) error {
	if swag.IsZero(m.RateLimiter) { // not required
		return nil
	}

	if m.RateLimiter != nil {
		if err := m.RateLimiter.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rate_limiter")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rate_limiter")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this drive based on the context it is used
func (m *Drive) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateRateLimiter(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Drive) contextValidateRateLimiter(ctx context.Context, formats strfmt.Registry) error {

	if m.RateLimiter != nil {

		if swag.IsZero(m.RateLimiter) { // not required
			return nil
		}

		if err := m.RateLimiter.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rate_limiter")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rate_limiter")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Drive) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Drive) UnmarshalBinary(b []byte) error {
	var res Drive
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/entropy_device.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// EntropyDevice Defines an entropy device.
//
// swagger:model EntropyDevice
type EntropyDevice struct {

	// rate limiter
	RateLimiter *RateLimiter `json:"rate_limiter,omitempty"`
}

// Validate validates this entropy device
func (m *EntropyDevice) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRateLimiter(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EntropyDevice) validateRateLimiter(formats strfmt.Registry) error {
	if swag.IsZero(m.RateLimiter) { // not required
		return nil
	}

	if m.RateLimiter != nil {
		if err := m.RateLimiter.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rate_limiter")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rate_limiter")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this entropy device based on the context it is used
func (m *EntropyDevice) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateRateLimiter(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EntropyDevice) contextValidateRateLimiter(ctx context.Context, formats strfmt.Registry) error {

	if m.RateLimiter != nil {

		if swag.IsZero(m.RateLimiter) { // not required
			return nil
		}

		if err := m.RateLimiter.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rate_limiter")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rate_limiter")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EntropyDevice) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EntropyDevice) UnmarshalBinary(b []byte) error {
	var res EntropyDevice
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/error.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Error error
//
// swagger:model Error
type Error struct {

	// A description of the error condition
	// Read Only: true
	FaultMessage string `json:"fault_message,omitempty"`
}

// Validate validates this error
func (m *Error) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this error based on the context it is used
func (m *Error) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFaultMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Error) contextValidateFaultMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "fault_message", "body", string(m.FaultMessage)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Error) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Error) UnmarshalBinary(b []byte) error {
	var res Error
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/firecracker_version.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FirecrackerVersion Describes the Firecracker version.
//
// swagger:model FirecrackerVersion
type FirecrackerVersion struct {

	// Firecracker build version.
	// Required: true
	FirecrackerVersion *string `json:"firecracker_version"`
}

// Validate validates this firecracker version
func (m *FirecrackerVersion) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFirecrackerVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FirecrackerVersion) validateFirecrackerVersion(formats strfmt.Registry) error {

	if err := validate.Required("firecracker_version", "body", m.FirecrackerVersion); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this firecracker version based on context it is used
func (m *FirecrackerVersion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *FirecrackerVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FirecrackerVersion) UnmarshalBinary(b []byte) error {
	var res FirecrackerVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/full_vm_configuration.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// FullVMConfiguration full Vm configuration
//
// swagger:model FullVmConfiguration
type FullVMConfiguration struct {

	// balloon
	Balloon *Balloon `json:"balloon,omitempty"`

	// boot source
	BootSource *BootSource `json:"boot-source,omitempty"`

	// Configurations for all block devices.
	Drives []*Drive `json:"drives"`

	// logger
	Logger *Logger `json:"logger,omitempty"`

	// machine config
	MachineConfig *MachineConfiguration `json:"machine-config,omitempty"`

	// metrics
	Metrics *Metrics `json:"metrics,omitempty"`

	// mmds config
	MmdsConfig *MmdsConfig `json:"mmds-config,omitempty"`

	// Configurations for all net devices.
	NetworkInterfaces []*NetworkInterface `json:"network-interfaces"`

	// vsock
	Vsock *Vsock `json:"vsock,omitempty"`
}

// Validate validates this full Vm configuration
func (m *FullVMConfiguration) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBalloon(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBootSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDrives(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogger(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMachineConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetrics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMmdsConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVsock(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FullVMConfiguration) validateBalloon(formats strfmt.Registry) error {
	if swag.IsZero(m.Balloon) { // not required
		return nil
	}

	if m.Balloon != nil {
		if err := m.Balloon.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("balloon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("balloon")
			}
			return err
		}
	}

	return nil
}

func (m *FullVMConfiguration) validateBootSource(formats strfmt.Registry) error {
	if swag.IsZero(m.BootSource) { // not required
		return nil
	}

	if m.BootSource != nil {
		if err := m.BootSource.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("boot-source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("boot-source")
			}
			return err
		}
	}

	return nil
}

func (m *FullVMConfiguration) validateDrives(formats strfmt.Registry) error {
	if swag.IsZero(m.Drives) { // not required
		return nil
	}

	for i := 0; i < len(m.Drives); i++ {
		if swag.IsZero(m.Drives[i]) { // not required
			continue
		}

		if m.Drives[i] != nil {
			if err := m.Drives[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("drives" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("drives" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FullVMConfiguration) validateLogger(formats strfmt.Registry) error {
	if swag.IsZero(m.Logger) { // not required
		return nil
	}

	if m.Logger != nil {
		if err := m.Logger.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("logger")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("logger")
			}
			return err
		}
	}

	return nil
}

func (m *FullVMConfiguration) validateMachineConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.MachineConfig) { // not required
		return nil
	}

	if m.MachineConfig != nil {
		if err := m.MachineConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("machine-config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("machine-config")
			}
			return err
		}
	}

	return nil
}

func (m *FullVMConfiguration) validateMetrics(formats strfmt.Registry) error {
	if swag.IsZero(m.Metrics) { // not required
		return nil
	}

	if m.Metrics != nil {
		if err := m.Metrics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metrics")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metrics")
			}
			return err
		}
	}

	return nil
}

func (m *FullVMConfiguration) validateMmdsConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.MmdsConfig) { // not required
		return nil
	}

	if m.MmdsConfig != nil {
		if err := m.MmdsConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mmds-config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mmds-config")
			}
			return err
		}
	}

	return nil
}

func (m *FullVMConfiguration) validateNetworkInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkInterfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.NetworkInterfaces); i++ {
		if swag.IsZero(m.NetworkInterfaces[i]) { // not required
			continue
		}

		if m.NetworkInterfaces[i] != nil {
			if err := m.NetworkInterfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("network-interfaces" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("network-interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FullVMConfiguration) validateVsock(formats strfmt.Registry) error {
	if swag.IsZero(m.Vsock) { // not required
		return nil
	}

	if m.Vsock != nil {
		if err := m.Vsock.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vsock")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vsock")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this full Vm configuration based on the context it is used
func (m *FullVMConfiguration) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBalloon(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBootSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDrives(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLogger(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMachineConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMetrics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMmdsConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVsock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FullVMConfiguration) contextValidateBalloon(ctx context.Context, formats strfmt.Registry) error {

	if m.Balloon != nil {

		if swag.IsZero(m.Balloon) { // not required
			return nil
		}

		if err := m.Balloon.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("balloon")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("balloon")
			}
			return err
		}
	}

	return nil
}

func (m *FullVMConfiguration) contextValidateBootSource(ctx context.Context, formats strfmt.Registry) error {

	if m.BootSource != nil {

		if swag.IsZero(m.BootSource) { // not required
			return nil
		}

		if err := m.BootSource.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("boot-source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("boot-source")
			}
			return err
		}
	}

	return nil
}

func (m *FullVMConfiguration) contextValidateDrives(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Drives); i++ {

		if m.Drives[i] != nil {

			if swag.IsZero(m.Drives[i]) { // not required
				return nil
			}

			if err := m.Drives[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("drives" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("drives" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FullVMConfiguration) contextValidateLogger(ctx context.Context, formats strfmt.Registry) error {

	if m.Logger != nil {

		if swag.IsZero(m.Logger) { // not required
			return nil
		}

		if err := m.Logger.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("logger")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("logger")
			}
			return err
		}
	}

	return nil
}

func (m *FullVMConfiguration) contextValidateMachineConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.MachineConfig != nil {

		if swag.IsZero(m.MachineConfig) { // not required
			return nil
		}

		if err := m.MachineConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("machine-config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("machine-config")
			}
			return err
		}
	}

	return nil
}

func (m *FullVMConfiguration) contextValidateMetrics(ctx context.Context, formats strfmt.Registry) error {

	if m.Metrics != nil {

		if swag.IsZero(m.Metrics) { // not required
			return nil
		}

		if err := m.Metrics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metrics")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metrics")
			}
			return err
		}
	}

	return nil
}

func (m *FullVMConfiguration) contextValidateMmdsConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.MmdsConfig != nil {

		if swag.IsZero(m.MmdsConfig) { // not required
			return nil
		}

		if err := m.MmdsConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mmds-config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mmds-config")
			}
			return err
		}
	}

	return nil
}

func (m *FullVMConfiguration) contextValidateNetworkInterfaces(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetworkInterfaces); i++ {

		if m.NetworkInterfaces[i] != nil {

			if swag.IsZero(m.NetworkInterfaces[i]) { // not required
				return nil
			}

			if err := m.NetworkInterfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("network-interfaces" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("network-interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FullVMConfiguration) contextValidateVsock(ctx context.Context, formats strfmt.Registry) error {

	if m.Vsock != nil {

		if swag.IsZero(m.Vsock) { // not required
			return nil
		}

		if err := m.Vsock.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vsock")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vsock")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FullVMConfiguration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FullVMConfiguration) UnmarshalBinary(b []byte) error {
	var res FullVMConfiguration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/instance_action_info.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// InstanceActionInfo Variant wrapper containing the real action.
//
// swagger:model InstanceActionInfo
type InstanceActionInfo struct {

	// Enumeration indicating what type of action is contained in the payload
	// Required: true
	// Enum: [FlushMetrics InstanceStart SendCtrlAltDel]
	ActionType *string `json:"action_type"`
}

// Validate validates this instance action info
func (m *InstanceActionInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var instanceActionInfoTypeActionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["FlushMetrics","InstanceStart","SendCtrlAltDel"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		instanceActionInfoTypeActionTypePropEnum = append(instanceActionInfoTypeActionTypePropEnum, v)
	}
}

const (

	// InstanceActionInfoActionTypeFlushMetrics captures enum value "FlushMetrics"
	InstanceActionInfoActionTypeFlushMetrics string = "FlushMetrics"

	// InstanceActionInfoActionTypeInstanceStart captures enum value "InstanceStart"
	InstanceActionInfoActionTypeInstanceStart string = "InstanceStart"

	// InstanceActionInfoActionTypeSendCtrlAltDel captures enum value "SendCtrlAltDel"
	InstanceActionInfoActionTypeSendCtrlAltDel string = "SendCtrlAltDel"
)

// prop value enum
func (m *InstanceActionInfo) validateActionTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, instanceActionInfoTypeActionTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *InstanceActionInfo) validateActionType(formats strfmt.Registry) error {

	if err := validate.Required("action_type", "body", m.ActionType); err != nil {
		return err
	}

	// value enum
	if err := m.validateActionTypeEnum("action_type", "body", *m.ActionType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this instance action info based on context it is used
func (m *InstanceActionInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *InstanceActionInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *InstanceActionInfo) UnmarshalBinary(b []byte) error {
	var res InstanceActionInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/instance_info.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// InstanceInfo Describes MicroVM instance information.
//
// swagger:model InstanceInfo
type InstanceInfo struct {

	// Application name.
	// Required: true
	AppName *string `json:"app_name"`

	// MicroVM / instance ID.
	// Required: true
	ID *string `json:"id"`

	// The current detailed state (Not started, Running, Paused) of the Firecracker instance. This value is read-only for the control-plane.
	// Required: true
	// Enum: [Not started Running Paused]
	State *string `json:"state"`

	// MicroVM hypervisor build version.
	// Required: true
	VmmVersion *string `json:"vmm_version"`
}

// Validate validates this instance info
func (m *InstanceInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAppName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVmmVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *InstanceInfo) validateAppName(formats strfmt.Registry) error {

	if err := validate.Required("app_name", "body", m.AppName); err != nil {
		return err
	}

	return nil
}

func (m *InstanceInfo) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

var instanceInfoTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Not started","Running","Paused"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		instanceInfoTypeStatePropEnum = append(instanceInfoTypeStatePropEnum, v)
	}
}

const (

	// InstanceInfoStateNotStarted captures enum value "Not started"
	InstanceInfoStateNotStarted string = "Not started"

	// InstanceInfoStateRunning captures enum value "Running"
	InstanceInfoStateRunning string = "Running"

	// InstanceInfoStatePaused captures enum value "Paused"
	InstanceInfoStatePaused string = "Paused"
)

// prop value enum
func (m *InstanceInfo) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, instanceInfoTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *InstanceInfo) validateState(formats strfmt.Registry) error {

	if err := validate.Required("state", "body", m.State); err != nil {
		return err
	}

	// value enum
	if err := m.validateStateEnum("state", "body", *m.State); err != nil {
		return err
	}

	return nil
}

func (m *InstanceInfo) validateVmmVersion(formats strfmt.Registry) error {

	if err := validate.Required("vmm_version", "body", m.VmmVersion); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this instance info based on context it is used
func (m *InstanceInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *InstanceInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *InstanceInfo) UnmarshalBinary(b []byte) error {
	var res InstanceInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/logger.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Logger Describes the configuration option for the logging capability.
//
// swagger:model Logger
type Logger struct {

	// Set the level. The possible values are case-insensitive.
	// Enum: [Error Warning Info Debug Trace Off]
	Level *string `json:"level,omitempty"`

	// Path to the named pipe or file for the human readable log output.
	LogPath string `json:"log_path,omitempty"`

	// The module path to filter log messages by.
	// Example: api_server::request
	Module string `json:"module,omitempty"`

	// Whether or not to output the level in the logs.
	ShowLevel *bool `json:"show_level,omitempty"`

	// Whether or not to include the file path and line number of the log's origin.
	ShowLogOrigin *bool `json:"show_log_origin,omitempty"`
}

// Validate validates this logger
func (m *Logger) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLevel(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var loggerTypeLevelPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Error","Warning","Info","Debug","Trace","Off"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		loggerTypeLevelPropEnum = append(loggerTypeLevelPropEnum, v)
	}
}

const (

	// LoggerLevelError captures enum value "Error"
	LoggerLevelError string = "Error"

	// LoggerLevelWarning captures enum value "Warning"
	LoggerLevelWarning string = "Warning"

	// LoggerLevelInfo captures enum value "Info"
	LoggerLevelInfo string = "Info"

	// LoggerLevelDebug captures enum value "Debug"
	LoggerLevelDebug string = "Debug"

	// LoggerLevelTrace captures enum value "Trace"
	LoggerLevelTrace string = "Trace"

	// LoggerLevelOff captures enum value "Off"
	LoggerLevelOff string = "Off"
)

// prop value enum
func (m *Logger) validateLevelEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, loggerTypeLevelPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Logger) validateLevel(formats strfmt.Registry) error {
	if swag.IsZero(m.Level) { // not required
		return nil
	}

	// value enum
	if err := m.validateLevelEnum("level", "body", *m.Level); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this logger based on context it is used
func (m *Logger) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *Logger) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Logger) UnmarshalBinary(b []byte) error {
	var res Logger
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/machine_configuration.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MachineConfiguration Describes the number of vCPUs, memory size, SMT capabilities, huge page configuration and the CPU template.
//
// swagger:model MachineConfiguration
type MachineConfiguration struct {

	// cpu template
	CPUTemplate *CPUTemplate `json:"cpu_template,omitempty"`

	// Which huge pages configuration (if any) should be used to back guest memory.
	// Enum: [None 2M]
	HugePages string `json:"huge_pages,omitempty"`

	// Memory size of VM
	// Required: true
	MemSizeMib *int64 `json:"mem_size_mib"`

	// Flag for enabling/disabling simultaneous multithreading. Can be enabled only on x86.
	Smt *bool `json:"smt,omitempty"`

	// Enable dirty page tracking. If this is enabled, then incremental guest memory snapshots can be created. These belong to diff snapshots, which contain, besides the microVM state, only the memory dirtied since a previous snapshot. Full snapshots each contain a full copy of the guest memory.
	TrackDirtyPages *bool `json:"track_dirty_pages,omitempty"`

	// Number of vCPUs (either 1 or an even number)
	// Required: true
	// Maximum: 32
	// Minimum: 1
	VcpuCount *int64 `json:"vcpu_count"`
}

// Validate validates this machine configuration
func (m *MachineConfiguration) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCPUTemplate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHugePages(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMemSizeMib(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcpuCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MachineConfiguration) validateCPUTemplate(formats strfmt.Registry) error {
	if swag.IsZero(m.CPUTemplate) { // not required
		return nil
	}

	if m.CPUTemplate != nil {
		if err := m.CPUTemplate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cpu_template")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cpu_template")
			}
			return err
		}
	}

	return nil
}

var machineConfigurationTypeHugePagesPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["None","2M"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		machineConfigurationTypeHugePagesPropEnum = append(machineConfigurationTypeHugePagesPropEnum, v)
	}
}

const (

	// MachineConfigurationHugePagesNone captures enum value "None"
	MachineConfigurationHugePagesNone string = "None"

	// MachineConfigurationHugePagesNr2M captures enum value "2M"
	MachineConfigurationHugePagesNr2M string = "2M"
)

// prop value enum
func (m *MachineConfiguration) validateHugePagesEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, machineConfigurationTypeHugePagesPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MachineConfiguration) validateHugePages(formats strfmt.Registry) error {
	if swag.IsZero(m.HugePages) { // not required
		return nil
	}

	// value enum
	if err := m.validateHugePagesEnum("huge_pages", "body", m.HugePages); err != nil {
		return err
	}

	return nil
}

func (m *MachineConfiguration) validateMemSizeMib(formats strfmt.Registry) error {

	if err := validate.Required("mem_size_mib", "body", m.MemSizeMib); err != nil {
		return err
	}

	return nil
}

func (m *MachineConfiguration) validateVcpuCount(formats strfmt.Registry) error {

	if err := validate.Required("vcpu_count", "body", m.VcpuCount); err != nil {
		return err
	}

	if err := validate.MinimumInt("vcpu_count", "body", *m.VcpuCount, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("vcpu_count", "body", *m.VcpuCount, 32, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this machine configuration based on the context it is used
func (m *MachineConfiguration) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCPUTemplate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MachineConfiguration) contextValidateCPUTemplate(ctx context.Context, formats strfmt.Registry) error {

	if m.CPUTemplate != nil {

		if swag.IsZero(m.CPUTemplate) { // not required
			return nil
		}

		if err := m.CPUTemplate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cpu_template")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("cpu_template")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MachineConfiguration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MachineConfiguration) UnmarshalBinary(b []byte) error {
	var res MachineConfiguration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/memory_backend.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MemoryBackend memory backend
//
// swagger:model MemoryBackend
type MemoryBackend struct {

	// Based on 'backend_type' it is either 1) Path to the file that contains the guest memory to be loaded 2) Path to the UDS where a process is listening for a UFFD initialization control payload and open file descriptor that it can use to serve this process's guest memory page faults
	// Required: true
	BackendPath *string `json:"backend_path"`

	// backend type
	// Required: true
	// Enum: [File Uffd]
	BackendType *string `json:"backend_type"`
}

// Validate validates this memory backend
func (m *MemoryBackend) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBackendPath(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBackendType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MemoryBackend) validateBackendPath(formats strfmt.Registry) error {

	if err := validate.Required("backend_path", "body", m.BackendPath); err != nil {
		return err
	}

	return nil
}

var memoryBackendTypeBackendTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["File","Uffd"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		memoryBackendTypeBackendTypePropEnum = append(memoryBackendTypeBackendTypePropEnum, v)
	}
}

const (

	// MemoryBackendBackendTypeFile captures enum value "File"
	MemoryBackendBackendTypeFile string = "File"

	// MemoryBackendBackendTypeUffd captures enum value "Uffd"
	MemoryBackendBackendTypeUffd string = "Uffd"
)

// prop value enum
func (m *MemoryBackend) validateBackendTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, memoryBackendTypeBackendTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MemoryBackend) validateBackendType(formats strfmt.Registry) error {

	if err := validate.Required("backend_type", "body", m.BackendType); err != nil {
		return err
	}

	// value enum
	if err := m.validateBackendTypeEnum("backend_type", "body", *m.BackendType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this memory backend based on context it is used
func (m *MemoryBackend) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *MemoryBackend) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MemoryBackend) UnmarshalBinary(b []byte) error {
	var res MemoryBackend
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/metrics.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Metrics Describes the configuration option for the metrics capability.
//
// swagger:model Metrics
type Metrics struct {

	// Path to the named pipe or file where the JSON-formatted metrics are flushed.
	// Required: true
	MetricsPath *string `json:"metrics_path"`
}

// Validate validates this metrics
func (m *Metrics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMetricsPath(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Metrics) validateMetricsPath(formats strfmt.Registry) error {

	if err := validate.Required("metrics_path", "body", m.MetricsPath); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this metrics based on context it is used
func (m *Metrics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *Metrics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Metrics) UnmarshalBinary(b []byte) error {
	var res Metrics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/mmds_config.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MmdsConfig Defines the MMDS configuration.
//
// swagger:model MmdsConfig
type MmdsConfig struct {

	// A valid IPv4 link-local address.
	IPV4Address *string `json:"ipv4_address,omitempty"`

	// List of the network interface IDs capable of forwarding packets to the MMDS. Network interface IDs mentioned must be valid at the time of this request. The net device model will reply to HTTP GET requests sent to the MMDS address via the interfaces mentioned. In this case, both ARP requests and TCP segments heading to `ipv4_address` are intercepted by the device model, and do not reach the associated TAP device.
	// Required: true
	NetworkInterfaces []string `json:"network_interfaces"`

	// Enumeration indicating the MMDS version to be configured.
	// Enum: [V1 V2]
	Version *string `json:"version,omitempty"`
}

// Validate validates this mmds config
func (m *MmdsConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateNetworkInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MmdsConfig) validateNetworkInterfaces(formats strfmt.Registry) error {

	if err := validate.Required("network_interfaces", "body", m.NetworkInterfaces); err != nil {
		return err
	}

	return nil
}

var mmdsConfigTypeVersionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["V1","V2"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		mmdsConfigTypeVersionPropEnum = append(mmdsConfigTypeVersionPropEnum, v)
	}
}

const (

	// MmdsConfigVersionV1 captures enum value "V1"
	MmdsConfigVersionV1 string = "V1"

	// MmdsConfigVersionV2 captures enum value "V2"
	MmdsConfigVersionV2 string = "V2"
)

// prop value enum
func (m *MmdsConfig) validateVersionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, mmdsConfigTypeVersionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MmdsConfig) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	// value enum
	if err := m.validateVersionEnum("version", "body", *m.Version); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this mmds config based on context it is used
func (m *MmdsConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *MmdsConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MmdsConfig) UnmarshalBinary(b []byte) error {
	var res MmdsConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/mmds_contents_object.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

// MmdsContentsObject Describes the contents of MMDS in JSON format.
//
// swagger:model MmdsContentsObject
type MmdsContentsObject interface{}



================================================
File: fc/models/network_interface.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NetworkInterface Defines a network interface.
//
// swagger:model NetworkInterface
type NetworkInterface struct {

	// guest mac
	GuestMac string `json:"guest_mac,omitempty"`

	// Host level path for the guest network interface
	// Required: true
	HostDevName *string `json:"host_dev_name"`

	// iface id
	// Required: true
	IfaceID *string `json:"iface_id"`

	// rx rate limiter
	RxRateLimiter *RateLimiter `json:"rx_rate_limiter,omitempty"`

	// tx rate limiter
	TxRateLimiter *RateLimiter `json:"tx_rate_limiter,omitempty"`
}

// Validate validates this network interface
func (m *NetworkInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHostDevName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIfaceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRxRateLimiter(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxRateLimiter(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NetworkInterface) validateHostDevName(formats strfmt.Registry) error {

	if err := validate.Required("host_dev_name", "body", m.HostDevName); err != nil {
		return err
	}

	return nil
}

func (m *NetworkInterface) validateIfaceID(formats strfmt.Registry) error {

	if err := validate.Required("iface_id", "body", m.IfaceID); err != nil {
		return err
	}

	return nil
}

func (m *NetworkInterface) validateRxRateLimiter(formats strfmt.Registry) error {
	if swag.IsZero(m.RxRateLimiter) { // not required
		return nil
	}

	if m.RxRateLimiter != nil {
		if err := m.RxRateLimiter.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rx_rate_limiter")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rx_rate_limiter")
			}
			return err
		}
	}

	return nil
}

func (m *NetworkInterface) validateTxRateLimiter(formats strfmt.Registry) error {
	if swag.IsZero(m.TxRateLimiter) { // not required
		return nil
	}

	if m.TxRateLimiter != nil {
		if err := m.TxRateLimiter.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tx_rate_limiter")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tx_rate_limiter")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this network interface based on the context it is used
func (m *NetworkInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateRxRateLimiter(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTxRateLimiter(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NetworkInterface) contextValidateRxRateLimiter(ctx context.Context, formats strfmt.Registry) error {

	if m.RxRateLimiter != nil {

		if swag.IsZero(m.RxRateLimiter) { // not required
			return nil
		}

		if err := m.RxRateLimiter.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rx_rate_limiter")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rx_rate_limiter")
			}
			return err
		}
	}

	return nil
}

func (m *NetworkInterface) contextValidateTxRateLimiter(ctx context.Context, formats strfmt.Registry) error {

	if m.TxRateLimiter != nil {

		if swag.IsZero(m.TxRateLimiter) { // not required
			return nil
		}

		if err := m.TxRateLimiter.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tx_rate_limiter")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tx_rate_limiter")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NetworkInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NetworkInterface) UnmarshalBinary(b []byte) error {
	var res NetworkInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/partial_drive.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PartialDrive partial drive
//
// swagger:model PartialDrive
type PartialDrive struct {

	// drive id
	// Required: true
	DriveID *string `json:"drive_id"`

	// Host level path for the guest drive. This field is optional for virtio-block config and should be omitted for vhost-user-block configuration.
	PathOnHost string `json:"path_on_host,omitempty"`

	// rate limiter
	RateLimiter *RateLimiter `json:"rate_limiter,omitempty"`
}

// Validate validates this partial drive
func (m *PartialDrive) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDriveID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRateLimiter(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PartialDrive) validateDriveID(formats strfmt.Registry) error {

	if err := validate.Required("drive_id", "body", m.DriveID); err != nil {
		return err
	}

	return nil
}

func (m *PartialDrive) validateRateLimiter(formats strfmt.Registry) error {
	if swag.IsZero(m.RateLimiter) { // not required
		return nil
	}

	if m.RateLimiter != nil {
		if err := m.RateLimiter.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rate_limiter")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rate_limiter")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this partial drive based on the context it is used
func (m *PartialDrive) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateRateLimiter(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PartialDrive) contextValidateRateLimiter(ctx context.Context, formats strfmt.Registry) error {

	if m.RateLimiter != nil {

		if swag.IsZero(m.RateLimiter) { // not required
			return nil
		}

		if err := m.RateLimiter.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rate_limiter")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rate_limiter")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PartialDrive) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PartialDrive) UnmarshalBinary(b []byte) error {
	var res PartialDrive
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/partial_network_interface.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PartialNetworkInterface Defines a partial network interface structure, used to update the rate limiters for that interface, after microvm start.
//
// swagger:model PartialNetworkInterface
type PartialNetworkInterface struct {

	// iface id
	// Required: true
	IfaceID *string `json:"iface_id"`

	// rx rate limiter
	RxRateLimiter *RateLimiter `json:"rx_rate_limiter,omitempty"`

	// tx rate limiter
	TxRateLimiter *RateLimiter `json:"tx_rate_limiter,omitempty"`
}

// Validate validates this partial network interface
func (m *PartialNetworkInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateIfaceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRxRateLimiter(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxRateLimiter(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PartialNetworkInterface) validateIfaceID(formats strfmt.Registry) error {

	if err := validate.Required("iface_id", "body", m.IfaceID); err != nil {
		return err
	}

	return nil
}

func (m *PartialNetworkInterface) validateRxRateLimiter(formats strfmt.Registry) error {
	if swag.IsZero(m.RxRateLimiter) { // not required
		return nil
	}

	if m.RxRateLimiter != nil {
		if err := m.RxRateLimiter.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rx_rate_limiter")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rx_rate_limiter")
			}
			return err
		}
	}

	return nil
}

func (m *PartialNetworkInterface) validateTxRateLimiter(formats strfmt.Registry) error {
	if swag.IsZero(m.TxRateLimiter) { // not required
		return nil
	}

	if m.TxRateLimiter != nil {
		if err := m.TxRateLimiter.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tx_rate_limiter")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tx_rate_limiter")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this partial network interface based on the context it is used
func (m *PartialNetworkInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateRxRateLimiter(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTxRateLimiter(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PartialNetworkInterface) contextValidateRxRateLimiter(ctx context.Context, formats strfmt.Registry) error {

	if m.RxRateLimiter != nil {

		if swag.IsZero(m.RxRateLimiter) { // not required
			return nil
		}

		if err := m.RxRateLimiter.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rx_rate_limiter")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rx_rate_limiter")
			}
			return err
		}
	}

	return nil
}

func (m *PartialNetworkInterface) contextValidateTxRateLimiter(ctx context.Context, formats strfmt.Registry) error {

	if m.TxRateLimiter != nil {

		if swag.IsZero(m.TxRateLimiter) { // not required
			return nil
		}

		if err := m.TxRateLimiter.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tx_rate_limiter")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("tx_rate_limiter")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PartialNetworkInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PartialNetworkInterface) UnmarshalBinary(b []byte) error {
	var res PartialNetworkInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/rate_limiter.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// RateLimiter Defines an IO rate limiter with independent bytes/s and ops/s limits. Limits are defined by configuring each of the _bandwidth_ and _ops_ token buckets. This field is optional for virtio-block config and should be omitted for vhost-user-block configuration.
//
// swagger:model RateLimiter
type RateLimiter struct {

	// Token bucket with bytes as tokens
	Bandwidth *TokenBucket `json:"bandwidth,omitempty"`

	// Token bucket with operations as tokens
	Ops *TokenBucket `json:"ops,omitempty"`
}

// Validate validates this rate limiter
func (m *RateLimiter) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBandwidth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOps(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RateLimiter) validateBandwidth(formats strfmt.Registry) error {
	if swag.IsZero(m.Bandwidth) { // not required
		return nil
	}

	if m.Bandwidth != nil {
		if err := m.Bandwidth.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bandwidth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("bandwidth")
			}
			return err
		}
	}

	return nil
}

func (m *RateLimiter) validateOps(formats strfmt.Registry) error {
	if swag.IsZero(m.Ops) { // not required
		return nil
	}

	if m.Ops != nil {
		if err := m.Ops.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ops")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ops")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this rate limiter based on the context it is used
func (m *RateLimiter) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBandwidth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOps(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RateLimiter) contextValidateBandwidth(ctx context.Context, formats strfmt.Registry) error {

	if m.Bandwidth != nil {

		if swag.IsZero(m.Bandwidth) { // not required
			return nil
		}

		if err := m.Bandwidth.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bandwidth")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("bandwidth")
			}
			return err
		}
	}

	return nil
}

func (m *RateLimiter) contextValidateOps(ctx context.Context, formats strfmt.Registry) error {

	if m.Ops != nil {

		if swag.IsZero(m.Ops) { // not required
			return nil
		}

		if err := m.Ops.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ops")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ops")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RateLimiter) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RateLimiter) UnmarshalBinary(b []byte) error {
	var res RateLimiter
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/snapshot_create_params.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SnapshotCreateParams snapshot create params
//
// swagger:model SnapshotCreateParams
type SnapshotCreateParams struct {

	// Path to the file that will contain the guest memory.
	// Required: true
	MemFilePath *string `json:"mem_file_path"`

	// Path to the file that will contain the microVM state.
	// Required: true
	SnapshotPath *string `json:"snapshot_path"`

	// Type of snapshot to create. It is optional and by default, a full snapshot is created.
	// Enum: [Full Diff]
	SnapshotType string `json:"snapshot_type,omitempty"`
}

// Validate validates this snapshot create params
func (m *SnapshotCreateParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMemFilePath(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotPath(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SnapshotCreateParams) validateMemFilePath(formats strfmt.Registry) error {

	if err := validate.Required("mem_file_path", "body", m.MemFilePath); err != nil {
		return err
	}

	return nil
}

func (m *SnapshotCreateParams) validateSnapshotPath(formats strfmt.Registry) error {

	if err := validate.Required("snapshot_path", "body", m.SnapshotPath); err != nil {
		return err
	}

	return nil
}

var snapshotCreateParamsTypeSnapshotTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Full","Diff"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		snapshotCreateParamsTypeSnapshotTypePropEnum = append(snapshotCreateParamsTypeSnapshotTypePropEnum, v)
	}
}

const (

	// SnapshotCreateParamsSnapshotTypeFull captures enum value "Full"
	SnapshotCreateParamsSnapshotTypeFull string = "Full"

	// SnapshotCreateParamsSnapshotTypeDiff captures enum value "Diff"
	SnapshotCreateParamsSnapshotTypeDiff string = "Diff"
)

// prop value enum
func (m *SnapshotCreateParams) validateSnapshotTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, snapshotCreateParamsTypeSnapshotTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SnapshotCreateParams) validateSnapshotType(formats strfmt.Registry) error {
	if swag.IsZero(m.SnapshotType) { // not required
		return nil
	}

	// value enum
	if err := m.validateSnapshotTypeEnum("snapshot_type", "body", m.SnapshotType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this snapshot create params based on context it is used
func (m *SnapshotCreateParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SnapshotCreateParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SnapshotCreateParams) UnmarshalBinary(b []byte) error {
	var res SnapshotCreateParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/snapshot_load_params.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SnapshotLoadParams Defines the configuration used for handling snapshot resume. Exactly one of the two `mem_*` fields must be present in the body of the request.
//
// swagger:model SnapshotLoadParams
type SnapshotLoadParams struct {

	// Enable support for incremental (diff) snapshots by tracking dirty guest pages.
	EnableDiffSnapshots bool `json:"enable_diff_snapshots,omitempty"`

	// Configuration for the backend that handles memory load. If this field is specified, `mem_file_path` is forbidden. Either `mem_backend` or `mem_file_path` must be present at a time.
	MemBackend *MemoryBackend `json:"mem_backend,omitempty"`

	// Path to the file that contains the guest memory to be loaded. It is only allowed if `mem_backend` is not present. This parameter has been deprecated and it will be removed in future Firecracker release.
	MemFilePath string `json:"mem_file_path,omitempty"`

	// When set to true, the vm is also resumed if the snapshot load is successful.
	ResumeVM bool `json:"resume_vm,omitempty"`

	// Path to the file that contains the microVM state to be loaded.
	// Required: true
	SnapshotPath *string `json:"snapshot_path"`
}

// Validate validates this snapshot load params
func (m *SnapshotLoadParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMemBackend(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSnapshotPath(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SnapshotLoadParams) validateMemBackend(formats strfmt.Registry) error {
	if swag.IsZero(m.MemBackend) { // not required
		return nil
	}

	if m.MemBackend != nil {
		if err := m.MemBackend.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mem_backend")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mem_backend")
			}
			return err
		}
	}

	return nil
}

func (m *SnapshotLoadParams) validateSnapshotPath(formats strfmt.Registry) error {

	if err := validate.Required("snapshot_path", "body", m.SnapshotPath); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this snapshot load params based on the context it is used
func (m *SnapshotLoadParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMemBackend(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SnapshotLoadParams) contextValidateMemBackend(ctx context.Context, formats strfmt.Registry) error {

	if m.MemBackend != nil {

		if swag.IsZero(m.MemBackend) { // not required
			return nil
		}

		if err := m.MemBackend.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mem_backend")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("mem_backend")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SnapshotLoadParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SnapshotLoadParams) UnmarshalBinary(b []byte) error {
	var res SnapshotLoadParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/token_bucket.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TokenBucket Defines a token bucket with a maximum capacity (size), an initial burst size (one_time_burst) and an interval for refilling purposes (refill_time). The refill-rate is derived from size and refill_time, and it is the constant rate at which the tokens replenish. The refill process only starts happening after the initial burst budget is consumed. Consumption from the token bucket is unbounded in speed which allows for bursts bound in size by the amount of tokens available. Once the token bucket is empty, consumption speed is bound by the refill_rate.
//
// swagger:model TokenBucket
type TokenBucket struct {

	// The initial size of a token bucket.
	// Minimum: 0
	OneTimeBurst *int64 `json:"one_time_burst,omitempty"`

	// The amount of milliseconds it takes for the bucket to refill.
	// Required: true
	// Minimum: 0
	RefillTime *int64 `json:"refill_time"`

	// The total number of tokens this bucket can hold.
	// Required: true
	// Minimum: 0
	Size *int64 `json:"size"`
}

// Validate validates this token bucket
func (m *TokenBucket) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateOneTimeBurst(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRefillTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TokenBucket) validateOneTimeBurst(formats strfmt.Registry) error {
	if swag.IsZero(m.OneTimeBurst) { // not required
		return nil
	}

	if err := validate.MinimumInt("one_time_burst", "body", *m.OneTimeBurst, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *TokenBucket) validateRefillTime(formats strfmt.Registry) error {

	if err := validate.Required("refill_time", "body", m.RefillTime); err != nil {
		return err
	}

	if err := validate.MinimumInt("refill_time", "body", *m.RefillTime, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *TokenBucket) validateSize(formats strfmt.Registry) error {

	if err := validate.Required("size", "body", m.Size); err != nil {
		return err
	}

	if err := validate.MinimumInt("size", "body", *m.Size, 0, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this token bucket based on context it is used
func (m *TokenBucket) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TokenBucket) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TokenBucket) UnmarshalBinary(b []byte) error {
	var res TokenBucket
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/vm.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// VM Defines the microVM running state. It is especially useful in the snapshotting context.
//
// swagger:model Vm
type VM struct {

	// state
	// Required: true
	// Enum: [Paused Resumed]
	State *string `json:"state"`
}

// Validate validates this Vm
func (m *VM) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var vmTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Paused","Resumed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vmTypeStatePropEnum = append(vmTypeStatePropEnum, v)
	}
}

const (

	// VMStatePaused captures enum value "Paused"
	VMStatePaused string = "Paused"

	// VMStateResumed captures enum value "Resumed"
	VMStateResumed string = "Resumed"
)

// prop value enum
func (m *VM) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vmTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *VM) validateState(formats strfmt.Registry) error {

	if err := validate.Required("state", "body", m.State); err != nil {
		return err
	}

	// value enum
	if err := m.validateStateEnum("state", "body", *m.State); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this Vm based on context it is used
func (m *VM) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *VM) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *VM) UnmarshalBinary(b []byte) error {
	var res VM
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: fc/models/vsock.go
================================================
// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Vsock Defines a vsock device, backed by a set of Unix Domain Sockets, on the host side. For host-initiated connections, Firecracker will be listening on the Unix socket identified by the path `uds_path`. Firecracker will create this socket, bind and listen on it. Host-initiated connections will be performed by connection to this socket and issuing a connection forwarding request to the desired guest-side vsock port (i.e. `CONNECT 52\n`, to connect to port 52). For guest-initiated connections, Firecracker will expect host software to be bound and listening on Unix sockets at `uds_path_<PORT>`. E.g. "/path/to/host_vsock.sock_52" for port number 52.
//
// swagger:model Vsock
type Vsock struct {

	// Guest Vsock CID
	// Required: true
	// Minimum: 3
	GuestCid *int64 `json:"guest_cid"`

	// Path to UNIX domain socket, used to proxy vsock connections.
	// Required: true
	UdsPath *string `json:"uds_path"`

	// This parameter has been deprecated and it will be removed in future Firecracker release.
	VsockID string `json:"vsock_id,omitempty"`
}

// Validate validates this vsock
func (m *Vsock) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGuestCid(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUdsPath(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Vsock) validateGuestCid(formats strfmt.Registry) error {

	if err := validate.Required("guest_cid", "body", m.GuestCid); err != nil {
		return err
	}

	if err := validate.MinimumInt("guest_cid", "body", *m.GuestCid, 3, false); err != nil {
		return err
	}

	return nil
}

func (m *Vsock) validateUdsPath(formats strfmt.Registry) error {

	if err := validate.Required("uds_path", "body", m.UdsPath); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this vsock based on context it is used
func (m *Vsock) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *Vsock) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Vsock) UnmarshalBinary(b []byte) error {
	var res Vsock
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}



================================================
File: gin_utils/middleware/exclude.go
================================================
package middleware

import (
	"strings"

	"github.com/gin-gonic/gin"
)

func ExcludeRoutes(middleware gin.HandlerFunc, notlogged ...string) gin.HandlerFunc {
	return func(c *gin.Context) {
		path := c.Request.URL.Path

		if !shouldSkip(path, notlogged) {
			middleware(c)
		} else {
			c.Next()
		}
	}
}

func IncludeRoutes(middleware gin.HandlerFunc, included ...string) gin.HandlerFunc {
	return func(c *gin.Context) {
		path := c.Request.URL.Path

		if shouldInclude(path, included) {
			middleware(c)
		} else {
			c.Next()
		}
	}
}

func shouldInclude(path string, patterns []string) bool {
	for _, pattern := range patterns {
		if matchPattern(path, pattern) {
			return true
		}
	}
	return false
}

func shouldSkip(path string, patterns []string) bool {
	for _, pattern := range patterns {
		if matchPattern(path, pattern) {
			return true
		}
	}

	return false
}

func matchPattern(path, pattern string) bool {
	pathSegments := strings.Split(path, "/")
	patternSegments := strings.Split(pattern, "/")

	if len(pathSegments) != len(patternSegments) {
		return false
	}

	for i := range pathSegments {
		if patternSegments[i] != pathSegments[i] && !strings.HasPrefix(patternSegments[i], ":") {
			return false
		}
	}

	return true
}



================================================
File: gin_utils/middleware/otel/metrics/config.go
================================================
package metrics

import (
	"net/http"

	"go.opentelemetry.io/otel/attribute"
	semconv "go.opentelemetry.io/otel/semconv/v1.7.0"
)

type config struct {
	recordInFlight bool
	recordSize     bool
	recordDuration bool
	groupedStatus  bool
	recorder       Recorder
	attributes     func(serverName, route string, request *http.Request) []attribute.KeyValue
	shouldRecord   func(serverName, route string, request *http.Request) bool
}

func defaultConfig() *config {
	return &config{
		recordInFlight: true,
		recordDuration: true,
		recordSize:     true,
		groupedStatus:  true,
		attributes:     DefaultAttributes,
		shouldRecord: func(_, _ string, _ *http.Request) bool {
			return true
		},
	}
}

var DefaultAttributes = func(serverName, route string, request *http.Request) []attribute.KeyValue {
	attrs := []attribute.KeyValue{
		semconv.HTTPMethodKey.String(request.Method),
	}

	if route != "" {
		attrs = append(attrs, semconv.HTTPRouteKey.String(route))
	}

	return attrs
}



================================================
File: gin_utils/middleware/otel/metrics/middleware.go
================================================
package metrics

import (
	"time"

	"github.com/gin-gonic/gin"
	semconv "go.opentelemetry.io/otel/semconv/v1.7.0"
)

// Middleware returns middleware that will trace incoming requests.
// The service parameter should describe the name of the (virtual)
// server handling the request.
func Middleware(service string, options ...Option) gin.HandlerFunc {
	cfg := defaultConfig()
	for _, option := range options {
		option.apply(cfg)
	}

	recorder := cfg.recorder
	if recorder == nil {
		recorder = GetRecorder(service)
	}

	return func(ginCtx *gin.Context) {
		ctx := ginCtx.Request.Context()

		route := ginCtx.FullPath()
		if len(route) <= 0 {
			route = "nonconfigured"
		}

		if !cfg.shouldRecord(service, route, ginCtx.Request) {
			ginCtx.Next()

			return
		}

		start := time.Now()
		reqAttributes := cfg.attributes(service, route, ginCtx.Request)

		defer func() {
			resAttributes := append(
				reqAttributes[0:0],
				reqAttributes...,
			)

			if cfg.groupedStatus {
				code := int(ginCtx.Writer.Status()/100) * 100
				resAttributes = append(resAttributes, semconv.HTTPStatusCodeKey.Int(code))
			} else {
				resAttributes = append(resAttributes, semconv.HTTPAttributesFromHTTPStatusCode(ginCtx.Writer.Status())...)
			}

			duration := time.Since(start)
			recorder.ObserveHTTPRequestDuration(ctx, duration, resAttributes)
		}()

		ginCtx.Next()
	}
}



================================================
File: gin_utils/middleware/otel/metrics/option.go
================================================
package metrics

import (
	"net/http"

	"go.opentelemetry.io/otel/attribute"
)

// Option applies a configuration to the given config
type Option interface {
	apply(cfg *config)
}

type optionFunc func(cfg *config)

func (fn optionFunc) apply(cfg *config) {
	fn(cfg)
}

// WithAttributes sets a func using which what attributes to be recorded can be specified.
// By default the DefaultAttributes is used
func WithAttributes(attributes func(serverName, route string, request *http.Request) []attribute.KeyValue) Option {
	return optionFunc(func(cfg *config) {
		cfg.attributes = attributes
	})
}

// WithRecordInFlight determines whether to record In Flight Requests or not
// By default the recordInFlight is true
func WithRecordInFlightDisabled() Option {
	return optionFunc(func(cfg *config) {
		cfg.recordInFlight = false
	})
}

// WithRecordDuration determines whether to record Duration of Requests or not
// By default the recordDuration is true
func WithRecordDurationDisabled() Option {
	return optionFunc(func(cfg *config) {
		cfg.recordDuration = false
	})
}

// WithRecordSize determines whether to record Size of Requests and Responses or not
// By default the recordSize is true
func WithRecordSizeDisabled() Option {
	return optionFunc(func(cfg *config) {
		cfg.recordSize = false
	})
}

// WithGroupedStatus determines whether to group the response status codes or not. If true 2xx, 3xx will be stored
// By default the groupedStatus is true
func WithGroupedStatusDisabled() Option {
	return optionFunc(func(cfg *config) {
		cfg.groupedStatus = false
	})
}

// WithRecorder sets a recorder for recording requests
// By default the open telemetry recorder is used
func WithRecorder(recorder Recorder) Option {
	return optionFunc(func(cfg *config) {
		cfg.recorder = recorder
	})
}

// WithShouldRecordFunc sets a func using which whether a record should be recorded
// By default the all api calls are recorded
func WithShouldRecordFunc(shouldRecord func(serverName, route string, request *http.Request) bool) Option {
	return optionFunc(func(cfg *config) {
		cfg.shouldRecord = shouldRecord
	})
}



================================================
File: gin_utils/middleware/otel/metrics/otelrecorder.go
================================================
package metrics

import (
	"context"
	"time"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
)

// Recorder knows how to record and measure the metrics. This
// has the required methods to be used with the HTTP
// middlewares.
type otelRecorder struct {
	totalDuration metric.Float64Histogram
}

func GetRecorder(metricsPrefix string) Recorder {
	metricName := func(metricName string) string {
		if len(metricsPrefix) > 0 {
			return metricsPrefix + "." + metricName
		}

		return metricName
	}

	meter := otel.Meter("api-metrics", metric.WithInstrumentationVersion(SemVersion()))

	totalDuration, _ := meter.Float64Histogram(
		metricName("http.server.duration"),
		metric.WithDescription("Time Taken by request"),
		metric.WithUnit("ms"),
	)

	return &otelRecorder{
		totalDuration: totalDuration,
	}
}

// ObserveHTTPRequestDuration measures the duration of an HTTP request.
func (r *otelRecorder) ObserveHTTPRequestDuration(ctx context.Context, duration time.Duration, attributes []attribute.KeyValue) {
	r.totalDuration.Record(ctx, float64(duration/time.Millisecond), metric.WithAttributes(attributes...))
}



================================================
File: gin_utils/middleware/otel/metrics/recorder.go
================================================
package metrics

import (
	"context"
	"time"

	"go.opentelemetry.io/otel/attribute"
)

type Recorder interface {
	// ObserveHTTPRequestDuration measures the duration of an HTTP request.
	ObserveHTTPRequestDuration(ctx context.Context, duration time.Duration, attributes []attribute.KeyValue)
}



================================================
File: gin_utils/middleware/otel/metrics/version.go
================================================
package metrics

// Version is the current release version of the gin instrumentation.
func Version() string {
	return "1.0.0"
}

// SemVersion is the semantic version to be supplied to tracer/meter creation.
func SemVersion() string {
	return "semver:" + Version()
}



================================================
File: gin_utils/middleware/otel/tracing/middleware.go
================================================
// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Based on https://github.com/DataDog/dd-trace-go/blob/8fb554ff7cf694267f9077ae35e27ce4689ed8b6/contrib/gin-gonic/gin/gintrace.go

package tracing // import "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"

import (
	"fmt"

	"github.com/gin-gonic/gin"
	"go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/propagation"
	semconv "go.opentelemetry.io/otel/semconv/v1.12.0"
	oteltrace "go.opentelemetry.io/otel/trace"
)

const (
	tracerKey  = "otel-go-contrib-tracer"
	tracerName = "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
)

type config struct {
	TracerProvider oteltrace.TracerProvider
	Propagators    propagation.TextMapPropagator
}

// Middleware returns middleware that will trace incoming requests.
// The service parameter should describe the name of the (virtual)
// server handling the request.
func Middleware(service string) gin.HandlerFunc {
	cfg := config{}
	if cfg.TracerProvider == nil {
		cfg.TracerProvider = otel.GetTracerProvider()
	}
	tracer := cfg.TracerProvider.Tracer(
		tracerName,
		oteltrace.WithInstrumentationVersion(otelgin.Version()),
	)
	if cfg.Propagators == nil {
		cfg.Propagators = otel.GetTextMapPropagator()
	}
	return func(c *gin.Context) {
		c.Set(tracerKey, tracer)
		savedCtx := c.Request.Context()
		defer func() {
			c.Request = c.Request.WithContext(savedCtx)
		}()
		ctx := cfg.Propagators.Extract(savedCtx, propagation.HeaderCarrier(c.Request.Header))
		opts := []oteltrace.SpanStartOption{
			oteltrace.WithAttributes(semconv.NetAttributesFromHTTPRequest("tcp", c.Request)...),
			oteltrace.WithAttributes(semconv.EndUserAttributesFromHTTPRequest(c.Request)...),
			oteltrace.WithAttributes(semconv.HTTPServerAttributesFromHTTPRequest(service, c.FullPath(), c.Request)...),
			oteltrace.WithSpanKind(oteltrace.SpanKindServer),
		}
		spanName := c.FullPath()
		if spanName == "" {
			spanName = fmt.Sprintf("HTTP %s route not found", c.Request.Method)
		}
		ctx, span := tracer.Start(ctx, spanName, opts...)
		defer span.End()

		// pass the span through the request context
		c.Request = c.Request.WithContext(ctx)

		// serve the request to the next middleware
		c.Next()

		status := c.Writer.Status()
		attrs := semconv.HTTPAttributesFromHTTPStatusCode(status)
		spanStatus, spanMessage := semconv.SpanStatusFromHTTPStatusCode(status)
		span.SetAttributes(attrs...)
		span.SetStatus(spanStatus, spanMessage)
		if len(c.Errors) > 0 {
			span.SetAttributes(attribute.String("gin.errors", c.Errors.String()))
		}
	}
}



================================================
File: grpc/connection.go
================================================
package grpc

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"regexp"
	"strings"

	"google.golang.org/grpc"
	"google.golang.org/grpc/backoff"
	"google.golang.org/grpc/connectivity"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/credentials/insecure"
)

var regex = regexp.MustCompile(`http[s]?://`)

type ClientConnInterface interface {
	Invoke(ctx context.Context, method string, args any, reply any, opts ...grpc.CallOption) error
	GetState() connectivity.State
	NewStream(ctx context.Context, desc *grpc.StreamDesc, method string, opts ...grpc.CallOption) (grpc.ClientStream, error)
	Close() error
}

// TODO: Fix Host <-> Url
func GetConnection(host string, safe bool, options ...grpc.DialOption) (ClientConnInterface, error) {
	if strings.TrimSpace(host) == "" {
		fmt.Println("Host for gRPC not set, using dummy connection")

		return &DummyConn{}, nil
	}

	options = append(options, grpc.WithConnectParams(grpc.ConnectParams{Backoff: backoff.DefaultConfig}))

	host = regex.ReplaceAllString(host, "")
	if strings.HasPrefix(host, "localhost") || !safe {
		options = append(options, grpc.WithTransportCredentials(insecure.NewCredentials()))
		conn, err := grpc.Dial(host, options...)
		if err != nil {
			return nil, fmt.Errorf("failed to dial: %w", err)
		}

		return conn, nil
	}

	systemRoots, err := x509.SystemCertPool()
	if err != nil {
		errMsg := fmt.Errorf("failed to read system root certificate pool: %w", err)

		return nil, errMsg
	}

	cred := credentials.NewTLS(&tls.Config{
		RootCAs:    systemRoots,
		MinVersion: tls.VersionTLS13,
	})

	options = append(options, grpc.WithAuthority(host), grpc.WithTransportCredentials(cred))
	conn, err := grpc.Dial(host+":443", options...)

	if err != nil {
		return nil, fmt.Errorf("failed to dial: %w", err)
	}

	return conn, nil
}



================================================
File: grpc/dummy_client.go
================================================
package grpc

import (
	"context"

	"google.golang.org/grpc"
	"google.golang.org/grpc/connectivity"
)

type DummyConn struct{}

func (dc *DummyConn) Invoke(_ context.Context, _ string, _ any, _ any, _ ...grpc.CallOption) error {
	return nil
}

func (dc *DummyConn) GetState() connectivity.State {
	return connectivity.Ready
}

func (dc *DummyConn) NewStream(_ context.Context, _ *grpc.StreamDesc, _ string, _ ...grpc.CallOption) (grpc.ClientStream, error) {
	return nil, nil
}

func (dc *DummyConn) Close() error {
	return nil
}



================================================
File: grpc/filter.go
================================================
package grpc

import (
	"context"

	"google.golang.org/grpc/stats"
)

type noTraceKey struct{}

var noTrace = struct{}{}

// statsWrapper wraps grpc stats.Handler and removes healthchecks from tracing.
type statsWrapper struct {
	statsHandler stats.Handler
}

// NewStatsWrapper wraps grpc stats.Handler and removes healthchecks from tracing.
func NewStatsWrapper(statsHandler stats.Handler) stats.Handler {
	return &statsWrapper{statsHandler: statsHandler}
}

// HandleConn exists to satisfy gRPC stats.Handler.
func (s *statsWrapper) HandleConn(ctx context.Context, cs stats.ConnStats) {
	// no-op
}

// TagConn exists to satisfy gRPC stats.Handler.
func (s *statsWrapper) TagConn(ctx context.Context, cti *stats.ConnTagInfo) context.Context {
	// no-op
	return ctx
}

// HandleRPC implements per-RPC tracing and stats instrumentation.
func (s *statsWrapper) HandleRPC(ctx context.Context, rs stats.RPCStats) {
	// Check if the context contains noTraceKey, and trace only when its
	// not present.
	_, ok := ctx.Value(noTraceKey{}).(struct{})
	if !ok {
		s.statsHandler.HandleRPC(ctx, rs)
	}
}

// TagRPC implements per-RPC context management.
func (s *statsWrapper) TagRPC(ctx context.Context, rti *stats.RPCTagInfo) context.Context {
	if rti.FullMethodName == "/grpc.health.v1.Health/Check" {
		// Add to context we don't want to trace this.
		return context.WithValue(ctx, noTraceKey{}, noTrace)
	}
	return s.statsHandler.TagRPC(ctx, rti)
}



================================================
File: grpc/orchestrator/orchestrator.pb.go
================================================
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.1
// 	protoc        v5.29.3
// source: orchestrator.proto

package orchestrator

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type SandboxConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Data required for creating a new sandbox.
	TemplateId         string            `protobuf:"bytes,1,opt,name=template_id,json=templateId,proto3" json:"template_id,omitempty"`
	BuildId            string            `protobuf:"bytes,2,opt,name=build_id,json=buildId,proto3" json:"build_id,omitempty"`
	KernelVersion      string            `protobuf:"bytes,3,opt,name=kernel_version,json=kernelVersion,proto3" json:"kernel_version,omitempty"`
	FirecrackerVersion string            `protobuf:"bytes,4,opt,name=firecracker_version,json=firecrackerVersion,proto3" json:"firecracker_version,omitempty"`
	HugePages          bool              `protobuf:"varint,5,opt,name=huge_pages,json=hugePages,proto3" json:"huge_pages,omitempty"`
	SandboxId          string            `protobuf:"bytes,6,opt,name=sandbox_id,json=sandboxId,proto3" json:"sandbox_id,omitempty"`
	EnvVars            map[string]string `protobuf:"bytes,7,rep,name=env_vars,json=envVars,proto3" json:"env_vars,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Metadata about the sandbox.
	Metadata    map[string]string `protobuf:"bytes,8,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Alias       *string           `protobuf:"bytes,9,opt,name=alias,proto3,oneof" json:"alias,omitempty"`
	EnvdVersion string            `protobuf:"bytes,10,opt,name=envd_version,json=envdVersion,proto3" json:"envd_version,omitempty"`
	Vcpu        int64             `protobuf:"varint,11,opt,name=vcpu,proto3" json:"vcpu,omitempty"`
	RamMb       int64             `protobuf:"varint,12,opt,name=ram_mb,json=ramMb,proto3" json:"ram_mb,omitempty"`
	TeamId      string            `protobuf:"bytes,13,opt,name=team_id,json=teamId,proto3" json:"team_id,omitempty"`
	// Maximum length of the sandbox in Hours.
	MaxSandboxLength int64  `protobuf:"varint,14,opt,name=max_sandbox_length,json=maxSandboxLength,proto3" json:"max_sandbox_length,omitempty"`
	TotalDiskSizeMb  int64  `protobuf:"varint,15,opt,name=total_disk_size_mb,json=totalDiskSizeMb,proto3" json:"total_disk_size_mb,omitempty"`
	Snapshot         bool   `protobuf:"varint,16,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	BaseTemplateId   string `protobuf:"bytes,17,opt,name=base_template_id,json=baseTemplateId,proto3" json:"base_template_id,omitempty"`
	AutoPause        *bool  `protobuf:"varint,18,opt,name=auto_pause,json=autoPause,proto3,oneof" json:"auto_pause,omitempty"`
}

func (x *SandboxConfig) Reset() {
	*x = SandboxConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_orchestrator_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SandboxConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SandboxConfig) ProtoMessage() {}

func (x *SandboxConfig) ProtoReflect() protoreflect.Message {
	mi := &file_orchestrator_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SandboxConfig.ProtoReflect.Descriptor instead.
func (*SandboxConfig) Descriptor() ([]byte, []int) {
	return file_orchestrator_proto_rawDescGZIP(), []int{0}
}

func (x *SandboxConfig) GetTemplateId() string {
	if x != nil {
		return x.TemplateId
	}
	return ""
}

func (x *SandboxConfig) GetBuildId() string {
	if x != nil {
		return x.BuildId
	}
	return ""
}

func (x *SandboxConfig) GetKernelVersion() string {
	if x != nil {
		return x.KernelVersion
	}
	return ""
}

func (x *SandboxConfig) GetFirecrackerVersion() string {
	if x != nil {
		return x.FirecrackerVersion
	}
	return ""
}

func (x *SandboxConfig) GetHugePages() bool {
	if x != nil {
		return x.HugePages
	}
	return false
}

func (x *SandboxConfig) GetSandboxId() string {
	if x != nil {
		return x.SandboxId
	}
	return ""
}

func (x *SandboxConfig) GetEnvVars() map[string]string {
	if x != nil {
		return x.EnvVars
	}
	return nil
}

func (x *SandboxConfig) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *SandboxConfig) GetAlias() string {
	if x != nil && x.Alias != nil {
		return *x.Alias
	}
	return ""
}

func (x *SandboxConfig) GetEnvdVersion() string {
	if x != nil {
		return x.EnvdVersion
	}
	return ""
}

func (x *SandboxConfig) GetVcpu() int64 {
	if x != nil {
		return x.Vcpu
	}
	return 0
}

func (x *SandboxConfig) GetRamMb() int64 {
	if x != nil {
		return x.RamMb
	}
	return 0
}

func (x *SandboxConfig) GetTeamId() string {
	if x != nil {
		return x.TeamId
	}
	return ""
}

func (x *SandboxConfig) GetMaxSandboxLength() int64 {
	if x != nil {
		return x.MaxSandboxLength
	}
	return 0
}

func (x *SandboxConfig) GetTotalDiskSizeMb() int64 {
	if x != nil {
		return x.TotalDiskSizeMb
	}
	return 0
}

func (x *SandboxConfig) GetSnapshot() bool {
	if x != nil {
		return x.Snapshot
	}
	return false
}

func (x *SandboxConfig) GetBaseTemplateId() string {
	if x != nil {
		return x.BaseTemplateId
	}
	return ""
}

func (x *SandboxConfig) GetAutoPause() bool {
	if x != nil && x.AutoPause != nil {
		return *x.AutoPause
	}
	return false
}

type SandboxCreateRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Sandbox   *SandboxConfig         `protobuf:"bytes,1,opt,name=sandbox,proto3" json:"sandbox,omitempty"`
	StartTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (x *SandboxCreateRequest) Reset() {
	*x = SandboxCreateRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_orchestrator_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SandboxCreateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SandboxCreateRequest) ProtoMessage() {}

func (x *SandboxCreateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_orchestrator_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SandboxCreateRequest.ProtoReflect.Descriptor instead.
func (*SandboxCreateRequest) Descriptor() ([]byte, []int) {
	return file_orchestrator_proto_rawDescGZIP(), []int{1}
}

func (x *SandboxCreateRequest) GetSandbox() *SandboxConfig {
	if x != nil {
		return x.Sandbox
	}
	return nil
}

func (x *SandboxCreateRequest) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *SandboxCreateRequest) GetEndTime() *timestamppb.Timestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

type SandboxCreateResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ClientId string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
}

func (x *SandboxCreateResponse) Reset() {
	*x = SandboxCreateResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_orchestrator_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SandboxCreateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SandboxCreateResponse) ProtoMessage() {}

func (x *SandboxCreateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_orchestrator_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SandboxCreateResponse.ProtoReflect.Descriptor instead.
func (*SandboxCreateResponse) Descriptor() ([]byte, []int) {
	return file_orchestrator_proto_rawDescGZIP(), []int{2}
}

func (x *SandboxCreateResponse) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

type SandboxUpdateRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SandboxId string                 `protobuf:"bytes,1,opt,name=sandbox_id,json=sandboxId,proto3" json:"sandbox_id,omitempty"`
	EndTime   *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (x *SandboxUpdateRequest) Reset() {
	*x = SandboxUpdateRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_orchestrator_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SandboxUpdateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SandboxUpdateRequest) ProtoMessage() {}

func (x *SandboxUpdateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_orchestrator_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SandboxUpdateRequest.ProtoReflect.Descriptor instead.
func (*SandboxUpdateRequest) Descriptor() ([]byte, []int) {
	return file_orchestrator_proto_rawDescGZIP(), []int{3}
}

func (x *SandboxUpdateRequest) GetSandboxId() string {
	if x != nil {
		return x.SandboxId
	}
	return ""
}

func (x *SandboxUpdateRequest) GetEndTime() *timestamppb.Timestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

type SandboxDeleteRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SandboxId string `protobuf:"bytes,1,opt,name=sandbox_id,json=sandboxId,proto3" json:"sandbox_id,omitempty"`
}

func (x *SandboxDeleteRequest) Reset() {
	*x = SandboxDeleteRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_orchestrator_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SandboxDeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SandboxDeleteRequest) ProtoMessage() {}

func (x *SandboxDeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_orchestrator_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SandboxDeleteRequest.ProtoReflect.Descriptor instead.
func (*SandboxDeleteRequest) Descriptor() ([]byte, []int) {
	return file_orchestrator_proto_rawDescGZIP(), []int{4}
}

func (x *SandboxDeleteRequest) GetSandboxId() string {
	if x != nil {
		return x.SandboxId
	}
	return ""
}

type SandboxPauseRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	SandboxId  string `protobuf:"bytes,1,opt,name=sandbox_id,json=sandboxId,proto3" json:"sandbox_id,omitempty"`
	TemplateId string `protobuf:"bytes,2,opt,name=template_id,json=templateId,proto3" json:"template_id,omitempty"`
	BuildId    string `protobuf:"bytes,3,opt,name=build_id,json=buildId,proto3" json:"build_id,omitempty"`
}

func (x *SandboxPauseRequest) Reset() {
	*x = SandboxPauseRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_orchestrator_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SandboxPauseRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SandboxPauseRequest) ProtoMessage() {}

func (x *SandboxPauseRequest) ProtoReflect() protoreflect.Message {
	mi := &file_orchestrator_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SandboxPauseRequest.ProtoReflect.Descriptor instead.
func (*SandboxPauseRequest) Descriptor() ([]byte, []int) {
	return file_orchestrator_proto_rawDescGZIP(), []int{5}
}

func (x *SandboxPauseRequest) GetSandboxId() string {
	if x != nil {
		return x.SandboxId
	}
	return ""
}

func (x *SandboxPauseRequest) GetTemplateId() string {
	if x != nil {
		return x.TemplateId
	}
	return ""
}

func (x *SandboxPauseRequest) GetBuildId() string {
	if x != nil {
		return x.BuildId
	}
	return ""
}

type RunningSandbox struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Config    *SandboxConfig         `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	ClientId  string                 `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	StartTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (x *RunningSandbox) Reset() {
	*x = RunningSandbox{}
	if protoimpl.UnsafeEnabled {
		mi := &file_orchestrator_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RunningSandbox) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RunningSandbox) ProtoMessage() {}

func (x *RunningSandbox) ProtoReflect() protoreflect.Message {
	mi := &file_orchestrator_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RunningSandbox.ProtoReflect.Descriptor instead.
func (*RunningSandbox) Descriptor() ([]byte, []int) {
	return file_orchestrator_proto_rawDescGZIP(), []int{6}
}

func (x *RunningSandbox) GetConfig() *SandboxConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *RunningSandbox) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *RunningSandbox) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *RunningSandbox) GetEndTime() *timestamppb.Timestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

type SandboxListResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Sandboxes []*RunningSandbox `protobuf:"bytes,1,rep,name=sandboxes,proto3" json:"sandboxes,omitempty"`
}

func (x *SandboxListResponse) Reset() {
	*x = SandboxListResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_orchestrator_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SandboxListResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SandboxListResponse) ProtoMessage() {}

func (x *SandboxListResponse) ProtoReflect() protoreflect.Message {
	mi := &file_orchestrator_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SandboxListResponse.ProtoReflect.Descriptor instead.
func (*SandboxListResponse) Descriptor() ([]byte, []int) {
	return file_orchestrator_proto_rawDescGZIP(), []int{7}
}

func (x *SandboxListResponse) GetSandboxes() []*RunningSandbox {
	if x != nil {
		return x.Sandboxes
	}
	return nil
}

type CachedBuildInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	BuildId        string                 `protobuf:"bytes,1,opt,name=build_id,json=buildId,proto3" json:"build_id,omitempty"`
	ExpirationTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=expiration_time,json=expirationTime,proto3" json:"expiration_time,omitempty"`
}

func (x *CachedBuildInfo) Reset() {
	*x = CachedBuildInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_orchestrator_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CachedBuildInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CachedBuildInfo) ProtoMessage() {}

func (x *CachedBuildInfo) ProtoReflect() protoreflect.Message {
	mi := &file_orchestrator_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CachedBuildInfo.ProtoReflect.Descriptor instead.
func (*CachedBuildInfo) Descriptor() ([]byte, []int) {
	return file_orchestrator_proto_rawDescGZIP(), []int{8}
}

func (x *CachedBuildInfo) GetBuildId() string {
	if x != nil {
		return x.BuildId
	}
	return ""
}

func (x *CachedBuildInfo) GetExpirationTime() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpirationTime
	}
	return nil
}

type SandboxListCachedBuildsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Builds []*CachedBuildInfo `protobuf:"bytes,1,rep,name=builds,proto3" json:"builds,omitempty"`
}

func (x *SandboxListCachedBuildsResponse) Reset() {
	*x = SandboxListCachedBuildsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_orchestrator_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SandboxListCachedBuildsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SandboxListCachedBuildsResponse) ProtoMessage() {}

func (x *SandboxListCachedBuildsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_orchestrator_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SandboxListCachedBuildsResponse.ProtoReflect.Descriptor instead.
func (*SandboxListCachedBuildsResponse) Descriptor() ([]byte, []int) {
	return file_orchestrator_proto_rawDescGZIP(), []int{9}
}

func (x *SandboxListCachedBuildsResponse) GetBuilds() []*CachedBuildInfo {
	if x != nil {
		return x.Builds
	}
	return nil
}

var File_orchestrator_proto protoreflect.FileDescriptor

var file_orchestrator_proto_rawDesc = []byte{
	0x0a, 0x12, 0x6f, 0x72, 0x63, 0x68, 0x65, 0x73, 0x74, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1b, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x22, 0xac, 0x06, 0x0a, 0x0d, 0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x43, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x12, 0x1f, 0x0a, 0x0b, 0x74, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65,
	0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x74, 0x65, 0x6d, 0x70, 0x6c,
	0x61, 0x74, 0x65, 0x49, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x62, 0x75, 0x69, 0x6c, 0x64, 0x5f, 0x69,
	0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x62, 0x75, 0x69, 0x6c, 0x64, 0x49, 0x64,
	0x12, 0x25, 0x0a, 0x0e, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69,
	0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c,
	0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x2f, 0x0a, 0x13, 0x66, 0x69, 0x72, 0x65, 0x63,
	0x72, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x66, 0x69, 0x72, 0x65, 0x63, 0x72, 0x61, 0x63, 0x6b, 0x65,
	0x72, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x68, 0x75, 0x67, 0x65,
	0x5f, 0x70, 0x61, 0x67, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x68, 0x75,
	0x67, 0x65, 0x50, 0x61, 0x67, 0x65, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x61, 0x6e, 0x64, 0x62,
	0x6f, 0x78, 0x5f, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x73, 0x61, 0x6e,
	0x64, 0x62, 0x6f, 0x78, 0x49, 0x64, 0x12, 0x36, 0x0a, 0x08, 0x65, 0x6e, 0x76, 0x5f, 0x76, 0x61,
	0x72, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x53, 0x61, 0x6e, 0x64, 0x62,
	0x6f, 0x78, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x45, 0x6e, 0x76, 0x56, 0x61, 0x72, 0x73,
	0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x07, 0x65, 0x6e, 0x76, 0x56, 0x61, 0x72, 0x73, 0x12, 0x38,
	0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x1c, 0x2e, 0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x2e, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x08,
	0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x19, 0x0a, 0x05, 0x61, 0x6c, 0x69, 0x61,
	0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x05, 0x61, 0x6c, 0x69, 0x61, 0x73,
	0x88, 0x01, 0x01, 0x12, 0x21, 0x0a, 0x0c, 0x65, 0x6e, 0x76, 0x64, 0x5f, 0x76, 0x65, 0x72, 0x73,
	0x69, 0x6f, 0x6e, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x65, 0x6e, 0x76, 0x64, 0x56,
	0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x76, 0x63, 0x70, 0x75, 0x18, 0x0b,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x04, 0x76, 0x63, 0x70, 0x75, 0x12, 0x15, 0x0a, 0x06, 0x72, 0x61,
	0x6d, 0x5f, 0x6d, 0x62, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x72, 0x61, 0x6d, 0x4d,
	0x62, 0x12, 0x17, 0x0a, 0x07, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x18, 0x0d, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x06, 0x74, 0x65, 0x61, 0x6d, 0x49, 0x64, 0x12, 0x2c, 0x0a, 0x12, 0x6d, 0x61,
	0x78, 0x5f, 0x73, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x5f, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68,
	0x18, 0x0e, 0x20, 0x01, 0x28, 0x03, 0x52, 0x10, 0x6d, 0x61, 0x78, 0x53, 0x61, 0x6e, 0x64, 0x62,
	0x6f, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x12, 0x2b, 0x0a, 0x12, 0x74, 0x6f, 0x74, 0x61,
	0x6c, 0x5f, 0x64, 0x69, 0x73, 0x6b, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x5f, 0x6d, 0x62, 0x18, 0x0f,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x0f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x44, 0x69, 0x73, 0x6b, 0x53,
	0x69, 0x7a, 0x65, 0x4d, 0x62, 0x12, 0x1a, 0x0a, 0x08, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f,
	0x74, 0x18, 0x10, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f,
	0x74, 0x12, 0x28, 0x0a, 0x10, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x74, 0x65, 0x6d, 0x70, 0x6c, 0x61,
	0x74, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x11, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x62, 0x61, 0x73,
	0x65, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x49, 0x64, 0x12, 0x22, 0x0a, 0x0a, 0x61,
	0x75, 0x74, 0x6f, 0x5f, 0x70, 0x61, 0x75, 0x73, 0x65, 0x18, 0x12, 0x20, 0x01, 0x28, 0x08, 0x48,
	0x01, 0x52, 0x09, 0x61, 0x75, 0x74, 0x6f, 0x50, 0x61, 0x75, 0x73, 0x65, 0x88, 0x01, 0x01, 0x1a,
	0x3a, 0x0a, 0x0c, 0x45, 0x6e, 0x76, 0x56, 0x61, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12,
	0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65,
	0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x3b, 0x0a, 0x0d, 0x4d,
	0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03,
	0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14,
	0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x42, 0x08, 0x0a, 0x06, 0x5f, 0x61, 0x6c, 0x69,
	0x61, 0x73, 0x42, 0x0d, 0x0a, 0x0b, 0x5f, 0x61, 0x75, 0x74, 0x6f, 0x5f, 0x70, 0x61, 0x75, 0x73,
	0x65, 0x22, 0xb2, 0x01, 0x0a, 0x14, 0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x43, 0x72, 0x65,
	0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x28, 0x0a, 0x07, 0x73, 0x61,
	0x6e, 0x64, 0x62, 0x6f, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x53, 0x61,
	0x6e, 0x64, 0x62, 0x6f, 0x78, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x07, 0x73, 0x61, 0x6e,
	0x64, 0x62, 0x6f, 0x78, 0x12, 0x39, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x74, 0x69,
	0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73,
	0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x12,
	0x35, 0x0a, 0x08, 0x65, 0x6e, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x07, 0x65,
	0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x22, 0x34, 0x0a, 0x15, 0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f,
	0x78, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
	0x1b, 0x0a, 0x09, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x08, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x22, 0x6c, 0x0a, 0x14,
	0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x5f,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x73, 0x61, 0x6e, 0x64, 0x62, 0x6f,
	0x78, 0x49, 0x64, 0x12, 0x35, 0x0a, 0x08, 0x65, 0x6e, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
	0x70, 0x52, 0x07, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x22, 0x35, 0x0a, 0x14, 0x53, 0x61,
	0x6e, 0x64, 0x62, 0x6f, 0x78, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x5f, 0x69, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x73, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x49,
	0x64, 0x22, 0x70, 0x0a, 0x13, 0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x50, 0x61, 0x75, 0x73,
	0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x61, 0x6e, 0x64,
	0x62, 0x6f, 0x78, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x73, 0x61,
	0x6e, 0x64, 0x62, 0x6f, 0x78, 0x49, 0x64, 0x12, 0x1f, 0x0a, 0x0b, 0x74, 0x65, 0x6d, 0x70, 0x6c,
	0x61, 0x74, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x74, 0x65,
	0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x49, 0x64, 0x12, 0x19, 0x0a, 0x08, 0x62, 0x75, 0x69, 0x6c,
	0x64, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x62, 0x75, 0x69, 0x6c,
	0x64, 0x49, 0x64, 0x22, 0xc7, 0x01, 0x0a, 0x0e, 0x52, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x53,
	0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x12, 0x26, 0x0a, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78,
	0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1b,
	0x0a, 0x09, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x08, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x64, 0x12, 0x39, 0x0a, 0x0a, 0x73,
	0x74, 0x61, 0x72, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
	0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x73, 0x74, 0x61,
	0x72, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x35, 0x0a, 0x08, 0x65, 0x6e, 0x64, 0x5f, 0x74, 0x69,
	0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73,
	0x74, 0x61, 0x6d, 0x70, 0x52, 0x07, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x22, 0x44, 0x0a,
	0x13, 0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2d, 0x0a, 0x09, 0x73, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x65,
	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x52, 0x75, 0x6e, 0x6e, 0x69, 0x6e,
	0x67, 0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x52, 0x09, 0x73, 0x61, 0x6e, 0x64, 0x62, 0x6f,
	0x78, 0x65, 0x73, 0x22, 0x71, 0x0a, 0x0f, 0x43, 0x61, 0x63, 0x68, 0x65, 0x64, 0x42, 0x75, 0x69,
	0x6c, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x19, 0x0a, 0x08, 0x62, 0x75, 0x69, 0x6c, 0x64, 0x5f,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x62, 0x75, 0x69, 0x6c, 0x64, 0x49,
	0x64, 0x12, 0x43, 0x0a, 0x0f, 0x65, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x74, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f,
	0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d,
	0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x0e, 0x65, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x54, 0x69, 0x6d, 0x65, 0x22, 0x4b, 0x0a, 0x1f, 0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f,
	0x78, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x61, 0x63, 0x68, 0x65, 0x64, 0x42, 0x75, 0x69, 0x6c, 0x64,
	0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x28, 0x0a, 0x06, 0x62, 0x75, 0x69,
	0x6c, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x43, 0x61, 0x63, 0x68,
	0x65, 0x64, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x06, 0x62, 0x75, 0x69,
	0x6c, 0x64, 0x73, 0x32, 0xf6, 0x02, 0x0a, 0x0e, 0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x53,
	0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x37, 0x0a, 0x06, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x12, 0x15, 0x2e, 0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f,
	0x78, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
	0x37, 0x0a, 0x06, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x12, 0x15, 0x2e, 0x53, 0x61, 0x6e, 0x64,
	0x62, 0x6f, 0x78, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x34, 0x0a, 0x04, 0x4c, 0x69, 0x73, 0x74,
	0x12, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x14, 0x2e, 0x53, 0x61, 0x6e, 0x64, 0x62,
	0x6f, 0x78, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x37,
	0x0a, 0x06, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x12, 0x15, 0x2e, 0x53, 0x61, 0x6e, 0x64, 0x62,
	0x6f, 0x78, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
	0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x35, 0x0a, 0x05, 0x50, 0x61, 0x75, 0x73, 0x65,
	0x12, 0x14, 0x2e, 0x53, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x50, 0x61, 0x75, 0x73, 0x65, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x4c,
	0x0a, 0x10, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x61, 0x63, 0x68, 0x65, 0x64, 0x42, 0x75, 0x69, 0x6c,
	0x64, 0x73, 0x12, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x20, 0x2e, 0x53, 0x61, 0x6e,
	0x64, 0x62, 0x6f, 0x78, 0x4c, 0x69, 0x73, 0x74, 0x43, 0x61, 0x63, 0x68, 0x65, 0x64, 0x42, 0x75,
	0x69, 0x6c, 0x64, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x2f, 0x5a, 0x2d,
	0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x65, 0x32, 0x62, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x69, 0x6e, 0x66, 0x72, 0x61,
	0x2f, 0x6f, 0x72, 0x63, 0x68, 0x65, 0x73, 0x74, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x62, 0x06, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_orchestrator_proto_rawDescOnce sync.Once
	file_orchestrator_proto_rawDescData = file_orchestrator_proto_rawDesc
)

func file_orchestrator_proto_rawDescGZIP() []byte {
	file_orchestrator_proto_rawDescOnce.Do(func() {
		file_orchestrator_proto_rawDescData = protoimpl.X.CompressGZIP(file_orchestrator_proto_rawDescData)
	})
	return file_orchestrator_proto_rawDescData
}

var file_orchestrator_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_orchestrator_proto_goTypes = []interface{}{
	(*SandboxConfig)(nil),                   // 0: SandboxConfig
	(*SandboxCreateRequest)(nil),            // 1: SandboxCreateRequest
	(*SandboxCreateResponse)(nil),           // 2: SandboxCreateResponse
	(*SandboxUpdateRequest)(nil),            // 3: SandboxUpdateRequest
	(*SandboxDeleteRequest)(nil),            // 4: SandboxDeleteRequest
	(*SandboxPauseRequest)(nil),             // 5: SandboxPauseRequest
	(*RunningSandbox)(nil),                  // 6: RunningSandbox
	(*SandboxListResponse)(nil),             // 7: SandboxListResponse
	(*CachedBuildInfo)(nil),                 // 8: CachedBuildInfo
	(*SandboxListCachedBuildsResponse)(nil), // 9: SandboxListCachedBuildsResponse
	nil,                                     // 10: SandboxConfig.EnvVarsEntry
	nil,                                     // 11: SandboxConfig.MetadataEntry
	(*timestamppb.Timestamp)(nil),           // 12: google.protobuf.Timestamp
	(*emptypb.Empty)(nil),                   // 13: google.protobuf.Empty
}
var file_orchestrator_proto_depIdxs = []int32{
	10, // 0: SandboxConfig.env_vars:type_name -> SandboxConfig.EnvVarsEntry
	11, // 1: SandboxConfig.metadata:type_name -> SandboxConfig.MetadataEntry
	0,  // 2: SandboxCreateRequest.sandbox:type_name -> SandboxConfig
	12, // 3: SandboxCreateRequest.start_time:type_name -> google.protobuf.Timestamp
	12, // 4: SandboxCreateRequest.end_time:type_name -> google.protobuf.Timestamp
	12, // 5: SandboxUpdateRequest.end_time:type_name -> google.protobuf.Timestamp
	0,  // 6: RunningSandbox.config:type_name -> SandboxConfig
	12, // 7: RunningSandbox.start_time:type_name -> google.protobuf.Timestamp
	12, // 8: RunningSandbox.end_time:type_name -> google.protobuf.Timestamp
	6,  // 9: SandboxListResponse.sandboxes:type_name -> RunningSandbox
	12, // 10: CachedBuildInfo.expiration_time:type_name -> google.protobuf.Timestamp
	8,  // 11: SandboxListCachedBuildsResponse.builds:type_name -> CachedBuildInfo
	1,  // 12: SandboxService.Create:input_type -> SandboxCreateRequest
	3,  // 13: SandboxService.Update:input_type -> SandboxUpdateRequest
	13, // 14: SandboxService.List:input_type -> google.protobuf.Empty
	4,  // 15: SandboxService.Delete:input_type -> SandboxDeleteRequest
	5,  // 16: SandboxService.Pause:input_type -> SandboxPauseRequest
	13, // 17: SandboxService.ListCachedBuilds:input_type -> google.protobuf.Empty
	2,  // 18: SandboxService.Create:output_type -> SandboxCreateResponse
	13, // 19: SandboxService.Update:output_type -> google.protobuf.Empty
	7,  // 20: SandboxService.List:output_type -> SandboxListResponse
	13, // 21: SandboxService.Delete:output_type -> google.protobuf.Empty
	13, // 22: SandboxService.Pause:output_type -> google.protobuf.Empty
	9,  // 23: SandboxService.ListCachedBuilds:output_type -> SandboxListCachedBuildsResponse
	18, // [18:24] is the sub-list for method output_type
	12, // [12:18] is the sub-list for method input_type
	12, // [12:12] is the sub-list for extension type_name
	12, // [12:12] is the sub-list for extension extendee
	0,  // [0:12] is the sub-list for field type_name
}

func init() { file_orchestrator_proto_init() }
func file_orchestrator_proto_init() {
	if File_orchestrator_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_orchestrator_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SandboxConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_orchestrator_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SandboxCreateRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_orchestrator_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SandboxCreateResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_orchestrator_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SandboxUpdateRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_orchestrator_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SandboxDeleteRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_orchestrator_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SandboxPauseRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_orchestrator_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RunningSandbox); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_orchestrator_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SandboxListResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_orchestrator_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CachedBuildInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_orchestrator_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SandboxListCachedBuildsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_orchestrator_proto_msgTypes[0].OneofWrappers = []interface{}{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_orchestrator_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_orchestrator_proto_goTypes,
		DependencyIndexes: file_orchestrator_proto_depIdxs,
		MessageInfos:      file_orchestrator_proto_msgTypes,
	}.Build()
	File_orchestrator_proto = out.File
	file_orchestrator_proto_rawDesc = nil
	file_orchestrator_proto_goTypes = nil
	file_orchestrator_proto_depIdxs = nil
}



================================================
File: grpc/orchestrator/orchestrator_grpc.pb.go
================================================
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v5.29.3
// source: orchestrator.proto

package orchestrator

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// SandboxServiceClient is the client API for SandboxService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SandboxServiceClient interface {
	Create(ctx context.Context, in *SandboxCreateRequest, opts ...grpc.CallOption) (*SandboxCreateResponse, error)
	Update(ctx context.Context, in *SandboxUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	List(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SandboxListResponse, error)
	Delete(ctx context.Context, in *SandboxDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Pause(ctx context.Context, in *SandboxPauseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListCachedBuilds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SandboxListCachedBuildsResponse, error)
}

type sandboxServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSandboxServiceClient(cc grpc.ClientConnInterface) SandboxServiceClient {
	return &sandboxServiceClient{cc}
}

func (c *sandboxServiceClient) Create(ctx context.Context, in *SandboxCreateRequest, opts ...grpc.CallOption) (*SandboxCreateResponse, error) {
	out := new(SandboxCreateResponse)
	err := c.cc.Invoke(ctx, "/SandboxService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sandboxServiceClient) Update(ctx context.Context, in *SandboxUpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/SandboxService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sandboxServiceClient) List(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SandboxListResponse, error) {
	out := new(SandboxListResponse)
	err := c.cc.Invoke(ctx, "/SandboxService/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sandboxServiceClient) Delete(ctx context.Context, in *SandboxDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/SandboxService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sandboxServiceClient) Pause(ctx context.Context, in *SandboxPauseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/SandboxService/Pause", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sandboxServiceClient) ListCachedBuilds(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SandboxListCachedBuildsResponse, error) {
	out := new(SandboxListCachedBuildsResponse)
	err := c.cc.Invoke(ctx, "/SandboxService/ListCachedBuilds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SandboxServiceServer is the server API for SandboxService service.
// All implementations must embed UnimplementedSandboxServiceServer
// for forward compatibility
type SandboxServiceServer interface {
	Create(context.Context, *SandboxCreateRequest) (*SandboxCreateResponse, error)
	Update(context.Context, *SandboxUpdateRequest) (*emptypb.Empty, error)
	List(context.Context, *emptypb.Empty) (*SandboxListResponse, error)
	Delete(context.Context, *SandboxDeleteRequest) (*emptypb.Empty, error)
	Pause(context.Context, *SandboxPauseRequest) (*emptypb.Empty, error)
	ListCachedBuilds(context.Context, *emptypb.Empty) (*SandboxListCachedBuildsResponse, error)
	mustEmbedUnimplementedSandboxServiceServer()
}

// UnimplementedSandboxServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSandboxServiceServer struct {
}

func (UnimplementedSandboxServiceServer) Create(context.Context, *SandboxCreateRequest) (*SandboxCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedSandboxServiceServer) Update(context.Context, *SandboxUpdateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedSandboxServiceServer) List(context.Context, *emptypb.Empty) (*SandboxListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedSandboxServiceServer) Delete(context.Context, *SandboxDeleteRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedSandboxServiceServer) Pause(context.Context, *SandboxPauseRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pause not implemented")
}
func (UnimplementedSandboxServiceServer) ListCachedBuilds(context.Context, *emptypb.Empty) (*SandboxListCachedBuildsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCachedBuilds not implemented")
}
func (UnimplementedSandboxServiceServer) mustEmbedUnimplementedSandboxServiceServer() {}

// UnsafeSandboxServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SandboxServiceServer will
// result in compilation errors.
type UnsafeSandboxServiceServer interface {
	mustEmbedUnimplementedSandboxServiceServer()
}

func RegisterSandboxServiceServer(s grpc.ServiceRegistrar, srv SandboxServiceServer) {
	s.RegisterService(&SandboxService_ServiceDesc, srv)
}

func _SandboxService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SandboxCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SandboxServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/SandboxService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SandboxServiceServer).Create(ctx, req.(*SandboxCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SandboxService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SandboxUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SandboxServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/SandboxService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SandboxServiceServer).Update(ctx, req.(*SandboxUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SandboxService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SandboxServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/SandboxService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SandboxServiceServer).List(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SandboxService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SandboxDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SandboxServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/SandboxService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SandboxServiceServer).Delete(ctx, req.(*SandboxDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SandboxService_Pause_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SandboxPauseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SandboxServiceServer).Pause(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/SandboxService/Pause",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SandboxServiceServer).Pause(ctx, req.(*SandboxPauseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SandboxService_ListCachedBuilds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SandboxServiceServer).ListCachedBuilds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/SandboxService/ListCachedBuilds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SandboxServiceServer).ListCachedBuilds(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// SandboxService_ServiceDesc is the grpc.ServiceDesc for SandboxService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SandboxService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "SandboxService",
	HandlerType: (*SandboxServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _SandboxService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _SandboxService_Update_Handler,
		},
		{
			MethodName: "List",
			Handler:    _SandboxService_List_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _SandboxService_Delete_Handler,
		},
		{
			MethodName: "Pause",
			Handler:    _SandboxService_Pause_Handler,
		},
		{
			MethodName: "ListCachedBuilds",
			Handler:    _SandboxService_ListCachedBuilds_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "orchestrator.proto",
}



================================================
File: grpc/template-manager/template-manager.pb.go
================================================
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.1
// 	protoc        v5.29.3
// source: template-manager.proto

package template_manager

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TemplateConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TemplateID         string `protobuf:"bytes,1,opt,name=templateID,proto3" json:"templateID,omitempty"`
	BuildID            string `protobuf:"bytes,2,opt,name=buildID,proto3" json:"buildID,omitempty"`
	MemoryMB           int32  `protobuf:"varint,3,opt,name=memoryMB,proto3" json:"memoryMB,omitempty"`
	VCpuCount          int32  `protobuf:"varint,4,opt,name=vCpuCount,proto3" json:"vCpuCount,omitempty"`
	DiskSizeMB         int32  `protobuf:"varint,5,opt,name=diskSizeMB,proto3" json:"diskSizeMB,omitempty"`
	KernelVersion      string `protobuf:"bytes,6,opt,name=kernelVersion,proto3" json:"kernelVersion,omitempty"`
	FirecrackerVersion string `protobuf:"bytes,7,opt,name=firecrackerVersion,proto3" json:"firecrackerVersion,omitempty"`
	StartCommand       string `protobuf:"bytes,8,opt,name=startCommand,proto3" json:"startCommand,omitempty"`
	HugePages          bool   `protobuf:"varint,9,opt,name=hugePages,proto3" json:"hugePages,omitempty"`
}

func (x *TemplateConfig) Reset() {
	*x = TemplateConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_template_manager_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TemplateConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TemplateConfig) ProtoMessage() {}

func (x *TemplateConfig) ProtoReflect() protoreflect.Message {
	mi := &file_template_manager_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TemplateConfig.ProtoReflect.Descriptor instead.
func (*TemplateConfig) Descriptor() ([]byte, []int) {
	return file_template_manager_proto_rawDescGZIP(), []int{0}
}

func (x *TemplateConfig) GetTemplateID() string {
	if x != nil {
		return x.TemplateID
	}
	return ""
}

func (x *TemplateConfig) GetBuildID() string {
	if x != nil {
		return x.BuildID
	}
	return ""
}

func (x *TemplateConfig) GetMemoryMB() int32 {
	if x != nil {
		return x.MemoryMB
	}
	return 0
}

func (x *TemplateConfig) GetVCpuCount() int32 {
	if x != nil {
		return x.VCpuCount
	}
	return 0
}

func (x *TemplateConfig) GetDiskSizeMB() int32 {
	if x != nil {
		return x.DiskSizeMB
	}
	return 0
}

func (x *TemplateConfig) GetKernelVersion() string {
	if x != nil {
		return x.KernelVersion
	}
	return ""
}

func (x *TemplateConfig) GetFirecrackerVersion() string {
	if x != nil {
		return x.FirecrackerVersion
	}
	return ""
}

func (x *TemplateConfig) GetStartCommand() string {
	if x != nil {
		return x.StartCommand
	}
	return ""
}

func (x *TemplateConfig) GetHugePages() bool {
	if x != nil {
		return x.HugePages
	}
	return false
}

type TemplateCreateRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Template *TemplateConfig `protobuf:"bytes,1,opt,name=template,proto3" json:"template,omitempty"`
}

func (x *TemplateCreateRequest) Reset() {
	*x = TemplateCreateRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_template_manager_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TemplateCreateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TemplateCreateRequest) ProtoMessage() {}

func (x *TemplateCreateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_template_manager_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TemplateCreateRequest.ProtoReflect.Descriptor instead.
func (*TemplateCreateRequest) Descriptor() ([]byte, []int) {
	return file_template_manager_proto_rawDescGZIP(), []int{1}
}

func (x *TemplateCreateRequest) GetTemplate() *TemplateConfig {
	if x != nil {
		return x.Template
	}
	return nil
}

// Data required for deleting a template.
type TemplateBuildDeleteRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	BuildID string `protobuf:"bytes,1,opt,name=buildID,proto3" json:"buildID,omitempty"`
}

func (x *TemplateBuildDeleteRequest) Reset() {
	*x = TemplateBuildDeleteRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_template_manager_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TemplateBuildDeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TemplateBuildDeleteRequest) ProtoMessage() {}

func (x *TemplateBuildDeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_template_manager_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TemplateBuildDeleteRequest.ProtoReflect.Descriptor instead.
func (*TemplateBuildDeleteRequest) Descriptor() ([]byte, []int) {
	return file_template_manager_proto_rawDescGZIP(), []int{2}
}

func (x *TemplateBuildDeleteRequest) GetBuildID() string {
	if x != nil {
		return x.BuildID
	}
	return ""
}

// Logs from template build
type TemplateBuildLog struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Log string `protobuf:"bytes,1,opt,name=log,proto3" json:"log,omitempty"`
}

func (x *TemplateBuildLog) Reset() {
	*x = TemplateBuildLog{}
	if protoimpl.UnsafeEnabled {
		mi := &file_template_manager_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TemplateBuildLog) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TemplateBuildLog) ProtoMessage() {}

func (x *TemplateBuildLog) ProtoReflect() protoreflect.Message {
	mi := &file_template_manager_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TemplateBuildLog.ProtoReflect.Descriptor instead.
func (*TemplateBuildLog) Descriptor() ([]byte, []int) {
	return file_template_manager_proto_rawDescGZIP(), []int{3}
}

func (x *TemplateBuildLog) GetLog() string {
	if x != nil {
		return x.Log
	}
	return ""
}

var File_template_manager_proto protoreflect.FileDescriptor

var file_template_manager_proto_rawDesc = []byte{
	0x0a, 0x16, 0x74, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x2d, 0x6d, 0x61, 0x6e, 0x61, 0x67,
	0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1b, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
	0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xbc, 0x02, 0x0a, 0x0e, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61,
	0x74, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1e, 0x0a, 0x0a, 0x74, 0x65, 0x6d, 0x70,
	0x6c, 0x61, 0x74, 0x65, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x74, 0x65,
	0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x49, 0x44, 0x12, 0x18, 0x0a, 0x07, 0x62, 0x75, 0x69, 0x6c,
	0x64, 0x49, 0x44, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x62, 0x75, 0x69, 0x6c, 0x64,
	0x49, 0x44, 0x12, 0x1a, 0x0a, 0x08, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x4d, 0x42, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x4d, 0x42, 0x12, 0x1c,
	0x0a, 0x09, 0x76, 0x43, 0x70, 0x75, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x09, 0x76, 0x43, 0x70, 0x75, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1e, 0x0a, 0x0a,
	0x64, 0x69, 0x73, 0x6b, 0x53, 0x69, 0x7a, 0x65, 0x4d, 0x42, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x0a, 0x64, 0x69, 0x73, 0x6b, 0x53, 0x69, 0x7a, 0x65, 0x4d, 0x42, 0x12, 0x24, 0x0a, 0x0d,
	0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0d, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x56, 0x65, 0x72, 0x73, 0x69,
	0x6f, 0x6e, 0x12, 0x2e, 0x0a, 0x12, 0x66, 0x69, 0x72, 0x65, 0x63, 0x72, 0x61, 0x63, 0x6b, 0x65,
	0x72, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12,
	0x66, 0x69, 0x72, 0x65, 0x63, 0x72, 0x61, 0x63, 0x6b, 0x65, 0x72, 0x56, 0x65, 0x72, 0x73, 0x69,
	0x6f, 0x6e, 0x12, 0x22, 0x0a, 0x0c, 0x73, 0x74, 0x61, 0x72, 0x74, 0x43, 0x6f, 0x6d, 0x6d, 0x61,
	0x6e, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x73, 0x74, 0x61, 0x72, 0x74, 0x43,
	0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x68, 0x75, 0x67, 0x65, 0x50, 0x61,
	0x67, 0x65, 0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x68, 0x75, 0x67, 0x65, 0x50,
	0x61, 0x67, 0x65, 0x73, 0x22, 0x44, 0x0a, 0x15, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65,
	0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x2b, 0x0a,
	0x08, 0x74, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x0f, 0x2e, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x52, 0x08, 0x74, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x22, 0x36, 0x0a, 0x1a, 0x54, 0x65,
	0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x44, 0x65, 0x6c, 0x65, 0x74,
	0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x62, 0x75, 0x69, 0x6c,
	0x64, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x62, 0x75, 0x69, 0x6c, 0x64,
	0x49, 0x44, 0x22, 0x24, 0x0a, 0x10, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x42, 0x75,
	0x69, 0x6c, 0x64, 0x4c, 0x6f, 0x67, 0x12, 0x10, 0x0a, 0x03, 0x6c, 0x6f, 0x67, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x03, 0x6c, 0x6f, 0x67, 0x32, 0x9c, 0x01, 0x0a, 0x0f, 0x54, 0x65, 0x6d,
	0x70, 0x6c, 0x61, 0x74, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x3d, 0x0a, 0x0e,
	0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x12, 0x16,
	0x2e, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x11, 0x2e, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74,
	0x65, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x4c, 0x6f, 0x67, 0x30, 0x01, 0x12, 0x4a, 0x0a, 0x13, 0x54,
	0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x42, 0x75, 0x69, 0x6c, 0x64, 0x44, 0x65, 0x6c, 0x65,
	0x74, 0x65, 0x12, 0x1b, 0x2e, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65, 0x42, 0x75, 0x69,
	0x6c, 0x64, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
	0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x42, 0x33, 0x5a, 0x31, 0x68, 0x74, 0x74, 0x70, 0x73,
	0x3a, 0x2f, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x65, 0x32,
	0x62, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x69, 0x6e, 0x66, 0x72, 0x61, 0x2f, 0x74, 0x65, 0x6d, 0x70,
	0x6c, 0x61, 0x74, 0x65, 0x2d, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x62, 0x06, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_template_manager_proto_rawDescOnce sync.Once
	file_template_manager_proto_rawDescData = file_template_manager_proto_rawDesc
)

func file_template_manager_proto_rawDescGZIP() []byte {
	file_template_manager_proto_rawDescOnce.Do(func() {
		file_template_manager_proto_rawDescData = protoimpl.X.CompressGZIP(file_template_manager_proto_rawDescData)
	})
	return file_template_manager_proto_rawDescData
}

var file_template_manager_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_template_manager_proto_goTypes = []interface{}{
	(*TemplateConfig)(nil),             // 0: TemplateConfig
	(*TemplateCreateRequest)(nil),      // 1: TemplateCreateRequest
	(*TemplateBuildDeleteRequest)(nil), // 2: TemplateBuildDeleteRequest
	(*TemplateBuildLog)(nil),           // 3: TemplateBuildLog
	(*emptypb.Empty)(nil),              // 4: google.protobuf.Empty
}
var file_template_manager_proto_depIdxs = []int32{
	0, // 0: TemplateCreateRequest.template:type_name -> TemplateConfig
	1, // 1: TemplateService.TemplateCreate:input_type -> TemplateCreateRequest
	2, // 2: TemplateService.TemplateBuildDelete:input_type -> TemplateBuildDeleteRequest
	3, // 3: TemplateService.TemplateCreate:output_type -> TemplateBuildLog
	4, // 4: TemplateService.TemplateBuildDelete:output_type -> google.protobuf.Empty
	3, // [3:5] is the sub-list for method output_type
	1, // [1:3] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_template_manager_proto_init() }
func file_template_manager_proto_init() {
	if File_template_manager_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_template_manager_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TemplateConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_template_manager_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TemplateCreateRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_template_manager_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TemplateBuildDeleteRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_template_manager_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TemplateBuildLog); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_template_manager_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_template_manager_proto_goTypes,
		DependencyIndexes: file_template_manager_proto_depIdxs,
		MessageInfos:      file_template_manager_proto_msgTypes,
	}.Build()
	File_template_manager_proto = out.File
	file_template_manager_proto_rawDesc = nil
	file_template_manager_proto_goTypes = nil
	file_template_manager_proto_depIdxs = nil
}



================================================
File: grpc/template-manager/template-manager_grpc.pb.go
================================================
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v5.29.3
// source: template-manager.proto

package template_manager

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TemplateServiceClient is the client API for TemplateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TemplateServiceClient interface {
	// TemplateCreate is a gRPC service that creates a new template
	TemplateCreate(ctx context.Context, in *TemplateCreateRequest, opts ...grpc.CallOption) (TemplateService_TemplateCreateClient, error)
	// EnvBuildDelete is a gRPC service that deletes files associated with a template build
	TemplateBuildDelete(ctx context.Context, in *TemplateBuildDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type templateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTemplateServiceClient(cc grpc.ClientConnInterface) TemplateServiceClient {
	return &templateServiceClient{cc}
}

func (c *templateServiceClient) TemplateCreate(ctx context.Context, in *TemplateCreateRequest, opts ...grpc.CallOption) (TemplateService_TemplateCreateClient, error) {
	stream, err := c.cc.NewStream(ctx, &TemplateService_ServiceDesc.Streams[0], "/TemplateService/TemplateCreate", opts...)
	if err != nil {
		return nil, err
	}
	x := &templateServiceTemplateCreateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TemplateService_TemplateCreateClient interface {
	Recv() (*TemplateBuildLog, error)
	grpc.ClientStream
}

type templateServiceTemplateCreateClient struct {
	grpc.ClientStream
}

func (x *templateServiceTemplateCreateClient) Recv() (*TemplateBuildLog, error) {
	m := new(TemplateBuildLog)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *templateServiceClient) TemplateBuildDelete(ctx context.Context, in *TemplateBuildDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/TemplateService/TemplateBuildDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TemplateServiceServer is the server API for TemplateService service.
// All implementations must embed UnimplementedTemplateServiceServer
// for forward compatibility
type TemplateServiceServer interface {
	// TemplateCreate is a gRPC service that creates a new template
	TemplateCreate(*TemplateCreateRequest, TemplateService_TemplateCreateServer) error
	// EnvBuildDelete is a gRPC service that deletes files associated with a template build
	TemplateBuildDelete(context.Context, *TemplateBuildDeleteRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedTemplateServiceServer()
}

// UnimplementedTemplateServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTemplateServiceServer struct {
}

func (UnimplementedTemplateServiceServer) TemplateCreate(*TemplateCreateRequest, TemplateService_TemplateCreateServer) error {
	return status.Errorf(codes.Unimplemented, "method TemplateCreate not implemented")
}
func (UnimplementedTemplateServiceServer) TemplateBuildDelete(context.Context, *TemplateBuildDeleteRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TemplateBuildDelete not implemented")
}
func (UnimplementedTemplateServiceServer) mustEmbedUnimplementedTemplateServiceServer() {}

// UnsafeTemplateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TemplateServiceServer will
// result in compilation errors.
type UnsafeTemplateServiceServer interface {
	mustEmbedUnimplementedTemplateServiceServer()
}

func RegisterTemplateServiceServer(s grpc.ServiceRegistrar, srv TemplateServiceServer) {
	s.RegisterService(&TemplateService_ServiceDesc, srv)
}

func _TemplateService_TemplateCreate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TemplateCreateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TemplateServiceServer).TemplateCreate(m, &templateServiceTemplateCreateServer{stream})
}

type TemplateService_TemplateCreateServer interface {
	Send(*TemplateBuildLog) error
	grpc.ServerStream
}

type templateServiceTemplateCreateServer struct {
	grpc.ServerStream
}

func (x *templateServiceTemplateCreateServer) Send(m *TemplateBuildLog) error {
	return x.ServerStream.SendMsg(m)
}

func _TemplateService_TemplateBuildDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TemplateBuildDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateServiceServer).TemplateBuildDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TemplateService/TemplateBuildDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateServiceServer).TemplateBuildDelete(ctx, req.(*TemplateBuildDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TemplateService_ServiceDesc is the grpc.ServiceDesc for TemplateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TemplateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "TemplateService",
	HandlerType: (*TemplateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TemplateBuildDelete",
			Handler:    _TemplateService_TemplateBuildDelete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TemplateCreate",
			Handler:       _TemplateService_TemplateCreate_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "template-manager.proto",
}



================================================
File: id/id.go
================================================
package id

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/dchest/uniuri"
)

var caseInsensitiveAlphabet = []byte("abcdefghijklmnopqrstuvwxyz1234567890")

func Generate() string {
	return uniuri.NewLenChars(uniuri.UUIDLen, caseInsensitiveAlphabet)
}

func CleanEnvID(envID string) (string, error) {
	cleanedEnvID := strings.ToLower(strings.TrimSpace(envID))
	ok, err := regexp.MatchString("^[a-z0-9-_]+$", cleanedEnvID)
	if err != nil {
		return "", err
	}

	if !ok {
		return "", fmt.Errorf("invalid env ID: %s", envID)
	}

	return cleanedEnvID, nil
}



================================================
File: logger/exporter.go
================================================
package logger

import (
	"bytes"
	"context"
	"fmt"
	"log"
	"net/http"
	"sync"
	"time"

	"go.uber.org/zap/zapcore"
)

type HTTPWriter struct {
	ctx        context.Context
	url        string
	httpClient *http.Client
	wg         sync.WaitGroup
}

func NewHTTPWriter(ctx context.Context, endpoint string) zapcore.WriteSyncer {
	return &HTTPWriter{
		ctx: ctx,
		url: endpoint,
		httpClient: &http.Client{
			Timeout: 10 * time.Second,
		},
		wg: sync.WaitGroup{},
	}
}

func NewBufferedHTTPWriter(ctx context.Context, endpoint string) zapcore.WriteSyncer {
	httpWriter := &zapcore.BufferedWriteSyncer{
		WS:            NewHTTPWriter(ctx, endpoint),
		Size:          256 * 1024, // 256 kB
		FlushInterval: 5 * time.Second,
	}

	go func() {
		select {
		case <-ctx.Done():
			if err := httpWriter.Stop(); err != nil {
				fmt.Printf("Error stopping HTTP writer: %v\n", err)
			}
		}
	}()

	return httpWriter
}

func (h *HTTPWriter) Write(source []byte) (n int, err error) {
	h.wg.Add(1)

	// zap is reusing the buffer, so since we're processing it in a Go routine, we need to make a copy.
	p := make([]byte, len(source))
	copy(p, source)

	// Run in a goroutine to avoid blocking the main thread
	go func() {
		defer h.wg.Done()

		start := 0
		for i, b := range p {
			if b == '\n' {
				if start < i { // Ignore empty lines
					line := p[start:i]
					if err := h.sendLogLine(line); err != nil {
						log.Printf("Failed to send a log line: %s\n", line)
						return
					}
				}
				start = i + 1 // Move start to the next line
			}
		}

		// Handle the last line if there’s no trailing newline
		if start < len(p) {
			line := p[start:]
			if err := h.sendLogLine(line); err != nil {
				log.Printf("Failed to send a log line: %s\n", line)
				return
			}
		}
	}()

	return len(p), nil
}

func (h *HTTPWriter) Sync() error {
	h.wg.Wait()
	return nil
}

// sendLogLine handles sending ONE log line as an HTTP request
func (h *HTTPWriter) sendLogLine(line []byte) error {
	request, err := http.NewRequestWithContext(h.ctx, http.MethodPost, h.url, bytes.NewReader(line))
	if err != nil {
		return fmt.Errorf("error sending logs: %w", err)
	}

	request.Header.Set("Content-Type", "application/json")

	response, err := h.httpClient.Do(request)
	if err != nil {
		return fmt.Errorf("error sending logs: %w", err)
	}

	err = response.Body.Close()
	if err != nil {
		return fmt.Errorf("error closing response body: %w", err)
	}
	return nil
}



================================================
File: logger/grpc.go
================================================
package logger

import (
	"context"
	"fmt"

	"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors"
	"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
	"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/selector"
	"go.uber.org/zap"
)

func GRPCLogger(l *zap.Logger) logging.Logger {
	return logging.LoggerFunc(func(ctx context.Context, lvl logging.Level, msg string, fields ...any) {
		f := make([]zap.Field, 0, len(fields)/2)

		methodFullNameMap := map[string]string{
			"grpc.service":     "...",
			"grpc.method":      "...",
			"grpc.method_type": "...",
			"grpc.code":        "-",
		}

		for i := 0; i < len(fields)-1; i += 2 {
			key := fields[i]
			value := fields[i+1]

			switch v := value.(type) {
			case string:
				f = append(f, zap.String(key.(string), v))

				_, ok := methodFullNameMap[key.(string)]
				if ok {
					methodFullNameMap[key.(string)] = v
				}
			case int:
				f = append(f, zap.Int(key.(string), v))
			case bool:
				f = append(f, zap.Bool(key.(string), v))
			default:
				f = append(f, zap.Any(key.(string), v))
			}
		}

		logger := l.WithOptions(zap.AddCallerSkip(1)).With(f...)

		methodFullName := fmt.Sprintf("%s/%s/%s",
			methodFullNameMap["grpc.service"],
			methodFullNameMap["grpc.method"],
			methodFullNameMap["grpc.method_type"],
		)
		if msg == "finished call" || msg == "finished streaming call" {
			methodFullName = fmt.Sprintf("%s [%s]", methodFullName, methodFullNameMap["grpc.code"])
		}

		message := fmt.Sprintf("%s: %s", methodFullName, msg)

		switch lvl {
		case logging.LevelDebug:
			logger.Debug(message)
		case logging.LevelInfo:
			logger.Info(message)
		case logging.LevelWarn:
			logger.Warn(message)
		case logging.LevelError:
			logger.Error(message)
		default:
			panic(fmt.Sprintf("unknown level %v", lvl))
		}
	})
}

func WithoutHealthCheck() selector.Matcher {
	return selector.MatchFunc(func(_ context.Context, c interceptors.CallMeta) bool {
		return c.FullMethod() != "/grpc.health.v1.Health/Check"
	})
}



================================================
File: logger/logger.go
================================================
package logger

import (
	"context"
	"fmt"
	"os"

	"go.opentelemetry.io/contrib/bridges/otelzap"
	"go.opentelemetry.io/otel/log/global"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

type LoggerConfig struct {
	// ServiceName is the name of the service that the logger is being created for.
	// The service name is added to every log entry.
	ServiceName string
	// IsInternal differentiates between our (internal) logs, and user accessible (external) logs.
	IsInternal bool
	// IsDebug enables debug level logging, otherwise zap.InfoLevel level is used.
	IsDebug bool

	// InitialFields fields that are added to every log entry.
	InitialFields []zap.Field
	// Cores additional processing cores for the logger.
	Cores []zapcore.Core
}

func NewLogger(ctx context.Context, loggerConfig LoggerConfig) (*zap.Logger, error) {
	var level zap.AtomicLevel
	if loggerConfig.IsDebug {
		level = zap.NewAtomicLevelAt(zap.DebugLevel)
	} else {
		level = zap.NewAtomicLevelAt(zap.InfoLevel)
	}

	config := zap.Config{
		Level:             level,
		DisableStacktrace: false,
		// Taks stacktraces more liberally
		Development:   true,
		Sampling:      nil,
		Encoding:      "json",
		EncoderConfig: GetEncoderConfig(zapcore.DefaultLineEnding),
		OutputPaths: []string{
			"stdout",
		},
		ErrorOutputPaths: []string{
			"stderr",
		},
	}

	cores := make([]zapcore.Core, 0)
	cores = append(cores, loggerConfig.Cores...)

	logger, err := config.Build(
		zap.WrapCore(func(c zapcore.Core) zapcore.Core {
			cores = append(cores, c)

			return zapcore.NewTee(cores...)
		}),
		zap.Fields(
			zap.String("service", loggerConfig.ServiceName),
			zap.Bool("internal", loggerConfig.IsInternal),
			zap.Int("pid", os.Getpid()),
		),
		zap.Fields(loggerConfig.InitialFields...),
	)
	if err != nil {
		return nil, fmt.Errorf("error building logger: %w", err)
	}

	return logger, nil
}

func GetEncoderConfig(lineEnding string) zapcore.EncoderConfig {
	return zapcore.EncoderConfig{
		TimeKey:       "timestamp",
		MessageKey:    "message",
		LevelKey:      "level",
		EncodeLevel:   zapcore.LowercaseLevelEncoder,
		NameKey:       "logger",
		StacktraceKey: "stacktrace",
		EncodeTime:    zapcore.RFC3339NanoTimeEncoder,
		LineEnding:    lineEnding,
	}
}

func GetOTELCore(serviceName string) zapcore.Core {
	provider := global.GetLoggerProvider()

	return otelzap.NewCore(serviceName, otelzap.WithLoggerProvider(provider))
}



================================================
File: logger/sandbox/global.go
================================================
package sbxlogger

import "go.uber.org/zap"

var (
	sandboxLoggerInternal *zap.Logger = zap.NewNop()
	sandboxLoggerExternal *zap.Logger = zap.NewNop()
)

func SetSandboxLoggerInternal(logger *zap.Logger) {
	sandboxLoggerInternal = logger
}

func SetSandboxLoggerExternal(logger *zap.Logger) {
	sandboxLoggerExternal = logger
}

func I(m LoggerMetadata) *SandboxLogger {
	return &SandboxLogger{sandboxLoggerInternal.With(m.LoggerMetadata().Fields()...)}
}

func E(m LoggerMetadata) *SandboxLogger {
	return &SandboxLogger{sandboxLoggerExternal.With(m.LoggerMetadata().Fields()...)}
}



================================================
File: logger/sandbox/logger.go
================================================
package sbxlogger

import (
	"context"

	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"

	"github.com/e2b-dev/infra/packages/shared/pkg/logger"
)

type SandboxLoggerConfig struct {
	// ServiceName is the name of the service that the logger is being created for.
	// The service name is added to every log entry.
	ServiceName string
	// IsInternal differentiates between our (internal) logs, and user accessible (external) logs.
	IsInternal       bool
	CollectorAddress string
}

func NewLogger(ctx context.Context, config SandboxLoggerConfig) *zap.Logger {
	level := zap.NewAtomicLevelAt(zap.DebugLevel)

	core := zapcore.NewNopCore()
	if !config.IsInternal && config.CollectorAddress != "" {
		// Add Vector exporter to the core
		vectorEncoder := zapcore.NewJSONEncoder(logger.GetEncoderConfig(zapcore.DefaultLineEnding))
		httpWriter := logger.NewBufferedHTTPWriter(ctx, config.CollectorAddress)
		core = zapcore.NewCore(
			vectorEncoder,
			httpWriter,
			level,
		)
	} else {
		core = logger.GetOTELCore(config.ServiceName)
	}

	lg, err := logger.NewLogger(ctx, logger.LoggerConfig{
		ServiceName: config.ServiceName,
		IsInternal:  config.IsInternal,
		IsDebug:     true,
		InitialFields: []zap.Field{
			zap.String("logger", config.ServiceName),
		},
		Cores: []zapcore.Core{core},
	})
	if err != nil {
		panic(err)
	}

	return lg
}



================================================
File: logger/sandbox/metadata.go
================================================
package sbxlogger

import "go.uber.org/zap"

type SandboxMetadata struct {
	SandboxID  string
	TemplateID string
	TeamID     string
}

type LoggerMetadata interface {
	LoggerMetadata() SandboxMetadata
}

func (sm SandboxMetadata) LoggerMetadata() SandboxMetadata {
	return sm
}

func (sm SandboxMetadata) Fields() []zap.Field {
	return []zap.Field{
		zap.String("sandboxID", sm.SandboxID),
		zap.String("templateID", sm.TemplateID),
		zap.String("teamID", sm.TeamID),

		// Fields for Vector
		zap.String("instanceID", sm.SandboxID),
		zap.String("envID", sm.TemplateID),
	}
}



================================================
File: logger/sandbox/sandbox_logger.go
================================================
package sbxlogger

import "go.uber.org/zap"

type SandboxLogger struct {
	*zap.Logger
}

type HealthCheckAction int

const (
	Success HealthCheckAction = iota
	Fail
	ReportSuccess
	ReportFail
)

type SandboxMetricsFields struct {
	Timestamp      int64
	CPUCount       uint32
	CPUUsedPercent float32
	MemTotalMiB    uint64
	MemUsedMiB     uint64
}

func (sl *SandboxLogger) Metrics(metrics SandboxMetricsFields) {
	sl.Info(
		"",
		zap.String("category", "metrics"),
		zap.Float32("cpuUsedPct", metrics.CPUUsedPercent),
		zap.Uint32("cpuCount", metrics.CPUCount),
		zap.Uint64("memTotalMiB", metrics.MemTotalMiB),
		zap.Uint64("memUsedMiB", metrics.MemUsedMiB),
	)
}

func (sl *SandboxLogger) Healthcheck(action HealthCheckAction) {
	switch {
	case action == Success:
		sl.Info("Sandbox healthcheck recovered",
			zap.Bool("healthcheck", true))
	case action == Fail:
		sl.Error("Sandbox healthcheck started failing",
			zap.Bool("healthcheck", false))
	case action == ReportSuccess:
		sl.Info(
			"Control sandbox healthcheck was successful",
			zap.Bool("healthcheck", true))
	case action == ReportFail:
		sl.Error("Control sandbox healthcheck was unsuccessful",
			zap.Bool("healthcheck", false))
	}
}



================================================
File: meters/main.go
================================================
package meters

import (
	"sync"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/metric"
)

type CounterType string

const (
	SandboxCreateMeterName CounterType = "api.env.instance.started"
)

type UpDownCounterType string

const (
	SandboxCountMeterName                  UpDownCounterType = "api.env.instance.running"
	BuildCounterMeterName                                    = "api.env.build.running"
	NewNetworkSlotSPoolCounterMeterName                      = "orchestrator.network.slots_pool.new"
	ReusedNetworkSlotSPoolCounterMeterName                   = "orchestrator.network.slots_pool.reused"
	NBDkSlotSReadyPoolCounterMeterName                       = "orchestrator.nbd.slots_pool.read"
	ActiveConnectionsCounterMeterName                        = "client_proxy.connections.active"
)

var meter = otel.GetMeterProvider().Meter("nomad")
var meterLock = sync.Mutex{}
var counters = make(map[CounterType]metric.Int64Counter)
var upDownCounters = make(map[UpDownCounterType]metric.Int64UpDownCounter)

var counterDesc = map[CounterType]string{
	SandboxCreateMeterName: "Number of currently waiting requests to create a new sandbox",
}

var counterUnits = map[CounterType]string{
	SandboxCreateMeterName: "{sandbox}",
}

var upDownCounterDesc = map[UpDownCounterType]string{
	SandboxCountMeterName:                  "Counter of started instances.",
	BuildCounterMeterName:                  "Counter of running builds.",
	ReusedNetworkSlotSPoolCounterMeterName: "Number of reused network slots ready to be used.",
	NewNetworkSlotSPoolCounterMeterName:    "Number of new network slots ready to be used.",
	NBDkSlotSReadyPoolCounterMeterName:     "Number of nbd slots ready to be used.",
	ActiveConnectionsCounterMeterName:      "Number of active network connections in the client proxy.",
}

var upDownCounterUnits = map[UpDownCounterType]string{
	SandboxCountMeterName:                  "{sandbox}",
	BuildCounterMeterName:                  "{build}",
	ReusedNetworkSlotSPoolCounterMeterName: "{slot}",
	NewNetworkSlotSPoolCounterMeterName:    "{slot}",
	NBDkSlotSReadyPoolCounterMeterName:     "{slot}",
	ActiveConnectionsCounterMeterName:      "{connection}",
}

func GetCounter(name CounterType) (metric.Int64Counter, error) {
	meterLock.Lock()
	defer meterLock.Unlock()

	if counter, ok := counters[name]; ok {
		return counter, nil
	}

	counter, err := meter.Int64Counter(string(name), metric.WithDescription(counterDesc[name]), metric.WithUnit(counterUnits[name]))
	if err != nil {
		return nil, err
	}

	counters[name] = counter

	return counter, nil
}

func GetUpDownCounter(name UpDownCounterType) (metric.Int64UpDownCounter, error) {
	meterLock.Lock()
	defer meterLock.Unlock()

	if counter, ok := upDownCounters[name]; ok {
		return counter, nil
	}

	counter, err := meter.Int64UpDownCounter(string(name), metric.WithDescription(upDownCounterDesc[name]), metric.WithUnit(upDownCounterUnits[name]))
	if err != nil {
		return nil, err
	}

	upDownCounters[name] = counter

	return counter, nil
}



================================================
File: models/accesstoken.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/accesstoken"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/google/uuid"
)

// AccessToken is the model entity for the AccessToken schema.
type AccessToken struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// UserID holds the value of the "user_id" field.
	UserID uuid.UUID `json:"user_id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the AccessTokenQuery when eager-loading is set.
	Edges        AccessTokenEdges `json:"edges"`
	selectValues sql.SelectValues
}

// AccessTokenEdges holds the relations/edges for other nodes in the graph.
type AccessTokenEdges struct {
	// User holds the value of the user edge.
	User *User `json:"user,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// UserOrErr returns the User value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e AccessTokenEdges) UserOrErr() (*User, error) {
	if e.loadedTypes[0] {
		if e.User == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: user.Label}
		}
		return e.User, nil
	}
	return nil, &NotLoadedError{edge: "user"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*AccessToken) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case accesstoken.FieldID:
			values[i] = new(sql.NullString)
		case accesstoken.FieldCreatedAt:
			values[i] = new(sql.NullTime)
		case accesstoken.FieldUserID:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the AccessToken fields.
func (at *AccessToken) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case accesstoken.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				at.ID = value.String
			}
		case accesstoken.FieldUserID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field user_id", values[i])
			} else if value != nil {
				at.UserID = *value
			}
		case accesstoken.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				at.CreatedAt = value.Time
			}
		default:
			at.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the AccessToken.
// This includes values selected through modifiers, order, etc.
func (at *AccessToken) Value(name string) (ent.Value, error) {
	return at.selectValues.Get(name)
}

// QueryUser queries the "user" edge of the AccessToken entity.
func (at *AccessToken) QueryUser() *UserQuery {
	return NewAccessTokenClient(at.config).QueryUser(at)
}

// Update returns a builder for updating this AccessToken.
// Note that you need to call AccessToken.Unwrap() before calling this method if this AccessToken
// was returned from a transaction, and the transaction was committed or rolled back.
func (at *AccessToken) Update() *AccessTokenUpdateOne {
	return NewAccessTokenClient(at.config).UpdateOne(at)
}

// Unwrap unwraps the AccessToken entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (at *AccessToken) Unwrap() *AccessToken {
	_tx, ok := at.config.driver.(*txDriver)
	if !ok {
		panic("models: AccessToken is not a transactional entity")
	}
	at.config.driver = _tx.drv
	return at
}

// String implements the fmt.Stringer.
func (at *AccessToken) String() string {
	var builder strings.Builder
	builder.WriteString("AccessToken(")
	builder.WriteString(fmt.Sprintf("id=%v, ", at.ID))
	builder.WriteString("user_id=")
	builder.WriteString(fmt.Sprintf("%v", at.UserID))
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(at.CreatedAt.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// AccessTokens is a parsable slice of AccessToken.
type AccessTokens []*AccessToken



================================================
File: models/accesstoken_create.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/accesstoken"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/google/uuid"
)

// AccessTokenCreate is the builder for creating a AccessToken entity.
type AccessTokenCreate struct {
	config
	mutation *AccessTokenMutation
	hooks    []Hook
	conflict []sql.ConflictOption
}

// SetUserID sets the "user_id" field.
func (atc *AccessTokenCreate) SetUserID(u uuid.UUID) *AccessTokenCreate {
	atc.mutation.SetUserID(u)
	return atc
}

// SetCreatedAt sets the "created_at" field.
func (atc *AccessTokenCreate) SetCreatedAt(t time.Time) *AccessTokenCreate {
	atc.mutation.SetCreatedAt(t)
	return atc
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (atc *AccessTokenCreate) SetNillableCreatedAt(t *time.Time) *AccessTokenCreate {
	if t != nil {
		atc.SetCreatedAt(*t)
	}
	return atc
}

// SetID sets the "id" field.
func (atc *AccessTokenCreate) SetID(s string) *AccessTokenCreate {
	atc.mutation.SetID(s)
	return atc
}

// SetUser sets the "user" edge to the User entity.
func (atc *AccessTokenCreate) SetUser(u *User) *AccessTokenCreate {
	return atc.SetUserID(u.ID)
}

// Mutation returns the AccessTokenMutation object of the builder.
func (atc *AccessTokenCreate) Mutation() *AccessTokenMutation {
	return atc.mutation
}

// Save creates the AccessToken in the database.
func (atc *AccessTokenCreate) Save(ctx context.Context) (*AccessToken, error) {
	return withHooks(ctx, atc.sqlSave, atc.mutation, atc.hooks)
}

// SaveX calls Save and panics if Save returns an error.
func (atc *AccessTokenCreate) SaveX(ctx context.Context) *AccessToken {
	v, err := atc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (atc *AccessTokenCreate) Exec(ctx context.Context) error {
	_, err := atc.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (atc *AccessTokenCreate) ExecX(ctx context.Context) {
	if err := atc.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (atc *AccessTokenCreate) check() error {
	if _, ok := atc.mutation.UserID(); !ok {
		return &ValidationError{Name: "user_id", err: errors.New(`models: missing required field "AccessToken.user_id"`)}
	}
	if _, ok := atc.mutation.UserID(); !ok {
		return &ValidationError{Name: "user", err: errors.New(`models: missing required edge "AccessToken.user"`)}
	}
	return nil
}

func (atc *AccessTokenCreate) sqlSave(ctx context.Context) (*AccessToken, error) {
	if err := atc.check(); err != nil {
		return nil, err
	}
	_node, _spec := atc.createSpec()
	if err := sqlgraph.CreateNode(ctx, atc.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	if _spec.ID.Value != nil {
		if id, ok := _spec.ID.Value.(string); ok {
			_node.ID = id
		} else {
			return nil, fmt.Errorf("unexpected AccessToken.ID type: %T", _spec.ID.Value)
		}
	}
	atc.mutation.id = &_node.ID
	atc.mutation.done = true
	return _node, nil
}

func (atc *AccessTokenCreate) createSpec() (*AccessToken, *sqlgraph.CreateSpec) {
	var (
		_node = &AccessToken{config: atc.config}
		_spec = sqlgraph.NewCreateSpec(accesstoken.Table, sqlgraph.NewFieldSpec(accesstoken.FieldID, field.TypeString))
	)
	_spec.Schema = atc.schemaConfig.AccessToken
	_spec.OnConflict = atc.conflict
	if id, ok := atc.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = id
	}
	if value, ok := atc.mutation.CreatedAt(); ok {
		_spec.SetField(accesstoken.FieldCreatedAt, field.TypeTime, value)
		_node.CreatedAt = value
	}
	if nodes := atc.mutation.UserIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   accesstoken.UserTable,
			Columns: []string{accesstoken.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = atc.schemaConfig.AccessToken
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.UserID = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.AccessToken.Create().
//		SetUserID(v).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.AccessTokenUpsert) {
//			SetUserID(v+v).
//		}).
//		Exec(ctx)
func (atc *AccessTokenCreate) OnConflict(opts ...sql.ConflictOption) *AccessTokenUpsertOne {
	atc.conflict = opts
	return &AccessTokenUpsertOne{
		create: atc,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.AccessToken.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (atc *AccessTokenCreate) OnConflictColumns(columns ...string) *AccessTokenUpsertOne {
	atc.conflict = append(atc.conflict, sql.ConflictColumns(columns...))
	return &AccessTokenUpsertOne{
		create: atc,
	}
}

type (
	// AccessTokenUpsertOne is the builder for "upsert"-ing
	//  one AccessToken node.
	AccessTokenUpsertOne struct {
		create *AccessTokenCreate
	}

	// AccessTokenUpsert is the "OnConflict" setter.
	AccessTokenUpsert struct {
		*sql.UpdateSet
	}
)

// SetUserID sets the "user_id" field.
func (u *AccessTokenUpsert) SetUserID(v uuid.UUID) *AccessTokenUpsert {
	u.Set(accesstoken.FieldUserID, v)
	return u
}

// UpdateUserID sets the "user_id" field to the value that was provided on create.
func (u *AccessTokenUpsert) UpdateUserID() *AccessTokenUpsert {
	u.SetExcluded(accesstoken.FieldUserID)
	return u
}

// UpdateNewValues updates the mutable fields using the new values that were set on create except the ID field.
// Using this option is equivalent to using:
//
//	client.AccessToken.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(accesstoken.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *AccessTokenUpsertOne) UpdateNewValues() *AccessTokenUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		if _, exists := u.create.mutation.ID(); exists {
			s.SetIgnore(accesstoken.FieldID)
		}
		if _, exists := u.create.mutation.CreatedAt(); exists {
			s.SetIgnore(accesstoken.FieldCreatedAt)
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.AccessToken.Create().
//	    OnConflict(sql.ResolveWithIgnore()).
//	    Exec(ctx)
func (u *AccessTokenUpsertOne) Ignore() *AccessTokenUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *AccessTokenUpsertOne) DoNothing() *AccessTokenUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the AccessTokenCreate.OnConflict
// documentation for more info.
func (u *AccessTokenUpsertOne) Update(set func(*AccessTokenUpsert)) *AccessTokenUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&AccessTokenUpsert{UpdateSet: update})
	}))
	return u
}

// SetUserID sets the "user_id" field.
func (u *AccessTokenUpsertOne) SetUserID(v uuid.UUID) *AccessTokenUpsertOne {
	return u.Update(func(s *AccessTokenUpsert) {
		s.SetUserID(v)
	})
}

// UpdateUserID sets the "user_id" field to the value that was provided on create.
func (u *AccessTokenUpsertOne) UpdateUserID() *AccessTokenUpsertOne {
	return u.Update(func(s *AccessTokenUpsert) {
		s.UpdateUserID()
	})
}

// Exec executes the query.
func (u *AccessTokenUpsertOne) Exec(ctx context.Context) error {
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for AccessTokenCreate.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *AccessTokenUpsertOne) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}

// Exec executes the UPSERT query and returns the inserted/updated ID.
func (u *AccessTokenUpsertOne) ID(ctx context.Context) (id string, err error) {
	if u.create.driver.Dialect() == dialect.MySQL {
		// In case of "ON CONFLICT", there is no way to get back non-numeric ID
		// fields from the database since MySQL does not support the RETURNING clause.
		return id, errors.New("models: AccessTokenUpsertOne.ID is not supported by MySQL driver. Use AccessTokenUpsertOne.Exec instead")
	}
	node, err := u.create.Save(ctx)
	if err != nil {
		return id, err
	}
	return node.ID, nil
}

// IDX is like ID, but panics if an error occurs.
func (u *AccessTokenUpsertOne) IDX(ctx context.Context) string {
	id, err := u.ID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// AccessTokenCreateBulk is the builder for creating many AccessToken entities in bulk.
type AccessTokenCreateBulk struct {
	config
	err      error
	builders []*AccessTokenCreate
	conflict []sql.ConflictOption
}

// Save creates the AccessToken entities in the database.
func (atcb *AccessTokenCreateBulk) Save(ctx context.Context) ([]*AccessToken, error) {
	if atcb.err != nil {
		return nil, atcb.err
	}
	specs := make([]*sqlgraph.CreateSpec, len(atcb.builders))
	nodes := make([]*AccessToken, len(atcb.builders))
	mutators := make([]Mutator, len(atcb.builders))
	for i := range atcb.builders {
		func(i int, root context.Context) {
			builder := atcb.builders[i]
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*AccessTokenMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				var err error
				nodes[i], specs[i] = builder.createSpec()
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, atcb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					spec.OnConflict = atcb.conflict
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, atcb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{msg: err.Error(), wrap: err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, atcb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (atcb *AccessTokenCreateBulk) SaveX(ctx context.Context) []*AccessToken {
	v, err := atcb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (atcb *AccessTokenCreateBulk) Exec(ctx context.Context) error {
	_, err := atcb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (atcb *AccessTokenCreateBulk) ExecX(ctx context.Context) {
	if err := atcb.Exec(ctx); err != nil {
		panic(err)
	}
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.AccessToken.CreateBulk(builders...).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.AccessTokenUpsert) {
//			SetUserID(v+v).
//		}).
//		Exec(ctx)
func (atcb *AccessTokenCreateBulk) OnConflict(opts ...sql.ConflictOption) *AccessTokenUpsertBulk {
	atcb.conflict = opts
	return &AccessTokenUpsertBulk{
		create: atcb,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.AccessToken.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (atcb *AccessTokenCreateBulk) OnConflictColumns(columns ...string) *AccessTokenUpsertBulk {
	atcb.conflict = append(atcb.conflict, sql.ConflictColumns(columns...))
	return &AccessTokenUpsertBulk{
		create: atcb,
	}
}

// AccessTokenUpsertBulk is the builder for "upsert"-ing
// a bulk of AccessToken nodes.
type AccessTokenUpsertBulk struct {
	create *AccessTokenCreateBulk
}

// UpdateNewValues updates the mutable fields using the new values that
// were set on create. Using this option is equivalent to using:
//
//	client.AccessToken.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(accesstoken.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *AccessTokenUpsertBulk) UpdateNewValues() *AccessTokenUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		for _, b := range u.create.builders {
			if _, exists := b.mutation.ID(); exists {
				s.SetIgnore(accesstoken.FieldID)
			}
			if _, exists := b.mutation.CreatedAt(); exists {
				s.SetIgnore(accesstoken.FieldCreatedAt)
			}
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.AccessToken.Create().
//		OnConflict(sql.ResolveWithIgnore()).
//		Exec(ctx)
func (u *AccessTokenUpsertBulk) Ignore() *AccessTokenUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *AccessTokenUpsertBulk) DoNothing() *AccessTokenUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the AccessTokenCreateBulk.OnConflict
// documentation for more info.
func (u *AccessTokenUpsertBulk) Update(set func(*AccessTokenUpsert)) *AccessTokenUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&AccessTokenUpsert{UpdateSet: update})
	}))
	return u
}

// SetUserID sets the "user_id" field.
func (u *AccessTokenUpsertBulk) SetUserID(v uuid.UUID) *AccessTokenUpsertBulk {
	return u.Update(func(s *AccessTokenUpsert) {
		s.SetUserID(v)
	})
}

// UpdateUserID sets the "user_id" field to the value that was provided on create.
func (u *AccessTokenUpsertBulk) UpdateUserID() *AccessTokenUpsertBulk {
	return u.Update(func(s *AccessTokenUpsert) {
		s.UpdateUserID()
	})
}

// Exec executes the query.
func (u *AccessTokenUpsertBulk) Exec(ctx context.Context) error {
	if u.create.err != nil {
		return u.create.err
	}
	for i, b := range u.create.builders {
		if len(b.conflict) != 0 {
			return fmt.Errorf("models: OnConflict was set for builder %d. Set it on the AccessTokenCreateBulk instead", i)
		}
	}
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for AccessTokenCreateBulk.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *AccessTokenUpsertBulk) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/accesstoken_delete.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/accesstoken"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
)

// AccessTokenDelete is the builder for deleting a AccessToken entity.
type AccessTokenDelete struct {
	config
	hooks    []Hook
	mutation *AccessTokenMutation
}

// Where appends a list predicates to the AccessTokenDelete builder.
func (atd *AccessTokenDelete) Where(ps ...predicate.AccessToken) *AccessTokenDelete {
	atd.mutation.Where(ps...)
	return atd
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (atd *AccessTokenDelete) Exec(ctx context.Context) (int, error) {
	return withHooks(ctx, atd.sqlExec, atd.mutation, atd.hooks)
}

// ExecX is like Exec, but panics if an error occurs.
func (atd *AccessTokenDelete) ExecX(ctx context.Context) int {
	n, err := atd.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (atd *AccessTokenDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := sqlgraph.NewDeleteSpec(accesstoken.Table, sqlgraph.NewFieldSpec(accesstoken.FieldID, field.TypeString))
	_spec.Node.Schema = atd.schemaConfig.AccessToken
	ctx = internal.NewSchemaConfigContext(ctx, atd.schemaConfig)
	if ps := atd.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	affected, err := sqlgraph.DeleteNodes(ctx, atd.driver, _spec)
	if err != nil && sqlgraph.IsConstraintError(err) {
		err = &ConstraintError{msg: err.Error(), wrap: err}
	}
	atd.mutation.done = true
	return affected, err
}

// AccessTokenDeleteOne is the builder for deleting a single AccessToken entity.
type AccessTokenDeleteOne struct {
	atd *AccessTokenDelete
}

// Where appends a list predicates to the AccessTokenDelete builder.
func (atdo *AccessTokenDeleteOne) Where(ps ...predicate.AccessToken) *AccessTokenDeleteOne {
	atdo.atd.mutation.Where(ps...)
	return atdo
}

// Exec executes the deletion query.
func (atdo *AccessTokenDeleteOne) Exec(ctx context.Context) error {
	n, err := atdo.atd.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{accesstoken.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (atdo *AccessTokenDeleteOne) ExecX(ctx context.Context) {
	if err := atdo.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/accesstoken_query.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"fmt"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/accesstoken"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/google/uuid"
)

// AccessTokenQuery is the builder for querying AccessToken entities.
type AccessTokenQuery struct {
	config
	ctx        *QueryContext
	order      []accesstoken.OrderOption
	inters     []Interceptor
	predicates []predicate.AccessToken
	withUser   *UserQuery
	modifiers  []func(*sql.Selector)
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the AccessTokenQuery builder.
func (atq *AccessTokenQuery) Where(ps ...predicate.AccessToken) *AccessTokenQuery {
	atq.predicates = append(atq.predicates, ps...)
	return atq
}

// Limit the number of records to be returned by this query.
func (atq *AccessTokenQuery) Limit(limit int) *AccessTokenQuery {
	atq.ctx.Limit = &limit
	return atq
}

// Offset to start from.
func (atq *AccessTokenQuery) Offset(offset int) *AccessTokenQuery {
	atq.ctx.Offset = &offset
	return atq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (atq *AccessTokenQuery) Unique(unique bool) *AccessTokenQuery {
	atq.ctx.Unique = &unique
	return atq
}

// Order specifies how the records should be ordered.
func (atq *AccessTokenQuery) Order(o ...accesstoken.OrderOption) *AccessTokenQuery {
	atq.order = append(atq.order, o...)
	return atq
}

// QueryUser chains the current query on the "user" edge.
func (atq *AccessTokenQuery) QueryUser() *UserQuery {
	query := (&UserClient{config: atq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := atq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := atq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(accesstoken.Table, accesstoken.FieldID, selector),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, accesstoken.UserTable, accesstoken.UserColumn),
		)
		schemaConfig := atq.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.AccessToken
		fromU = sqlgraph.SetNeighbors(atq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first AccessToken entity from the query.
// Returns a *NotFoundError when no AccessToken was found.
func (atq *AccessTokenQuery) First(ctx context.Context) (*AccessToken, error) {
	nodes, err := atq.Limit(1).All(setContextOp(ctx, atq.ctx, "First"))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{accesstoken.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (atq *AccessTokenQuery) FirstX(ctx context.Context) *AccessToken {
	node, err := atq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first AccessToken ID from the query.
// Returns a *NotFoundError when no AccessToken ID was found.
func (atq *AccessTokenQuery) FirstID(ctx context.Context) (id string, err error) {
	var ids []string
	if ids, err = atq.Limit(1).IDs(setContextOp(ctx, atq.ctx, "FirstID")); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{accesstoken.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (atq *AccessTokenQuery) FirstIDX(ctx context.Context) string {
	id, err := atq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single AccessToken entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one AccessToken entity is found.
// Returns a *NotFoundError when no AccessToken entities are found.
func (atq *AccessTokenQuery) Only(ctx context.Context) (*AccessToken, error) {
	nodes, err := atq.Limit(2).All(setContextOp(ctx, atq.ctx, "Only"))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{accesstoken.Label}
	default:
		return nil, &NotSingularError{accesstoken.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (atq *AccessTokenQuery) OnlyX(ctx context.Context) *AccessToken {
	node, err := atq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only AccessToken ID in the query.
// Returns a *NotSingularError when more than one AccessToken ID is found.
// Returns a *NotFoundError when no entities are found.
func (atq *AccessTokenQuery) OnlyID(ctx context.Context) (id string, err error) {
	var ids []string
	if ids, err = atq.Limit(2).IDs(setContextOp(ctx, atq.ctx, "OnlyID")); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{accesstoken.Label}
	default:
		err = &NotSingularError{accesstoken.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (atq *AccessTokenQuery) OnlyIDX(ctx context.Context) string {
	id, err := atq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of AccessTokens.
func (atq *AccessTokenQuery) All(ctx context.Context) ([]*AccessToken, error) {
	ctx = setContextOp(ctx, atq.ctx, "All")
	if err := atq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*AccessToken, *AccessTokenQuery]()
	return withInterceptors[[]*AccessToken](ctx, atq, qr, atq.inters)
}

// AllX is like All, but panics if an error occurs.
func (atq *AccessTokenQuery) AllX(ctx context.Context) []*AccessToken {
	nodes, err := atq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of AccessToken IDs.
func (atq *AccessTokenQuery) IDs(ctx context.Context) (ids []string, err error) {
	if atq.ctx.Unique == nil && atq.path != nil {
		atq.Unique(true)
	}
	ctx = setContextOp(ctx, atq.ctx, "IDs")
	if err = atq.Select(accesstoken.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (atq *AccessTokenQuery) IDsX(ctx context.Context) []string {
	ids, err := atq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (atq *AccessTokenQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, atq.ctx, "Count")
	if err := atq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, atq, querierCount[*AccessTokenQuery](), atq.inters)
}

// CountX is like Count, but panics if an error occurs.
func (atq *AccessTokenQuery) CountX(ctx context.Context) int {
	count, err := atq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (atq *AccessTokenQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, atq.ctx, "Exist")
	switch _, err := atq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("models: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (atq *AccessTokenQuery) ExistX(ctx context.Context) bool {
	exist, err := atq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the AccessTokenQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (atq *AccessTokenQuery) Clone() *AccessTokenQuery {
	if atq == nil {
		return nil
	}
	return &AccessTokenQuery{
		config:     atq.config,
		ctx:        atq.ctx.Clone(),
		order:      append([]accesstoken.OrderOption{}, atq.order...),
		inters:     append([]Interceptor{}, atq.inters...),
		predicates: append([]predicate.AccessToken{}, atq.predicates...),
		withUser:   atq.withUser.Clone(),
		// clone intermediate query.
		sql:  atq.sql.Clone(),
		path: atq.path,
	}
}

// WithUser tells the query-builder to eager-load the nodes that are connected to
// the "user" edge. The optional arguments are used to configure the query builder of the edge.
func (atq *AccessTokenQuery) WithUser(opts ...func(*UserQuery)) *AccessTokenQuery {
	query := (&UserClient{config: atq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	atq.withUser = query
	return atq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		UserID uuid.UUID `json:"user_id,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.AccessToken.Query().
//		GroupBy(accesstoken.FieldUserID).
//		Aggregate(models.Count()).
//		Scan(ctx, &v)
func (atq *AccessTokenQuery) GroupBy(field string, fields ...string) *AccessTokenGroupBy {
	atq.ctx.Fields = append([]string{field}, fields...)
	grbuild := &AccessTokenGroupBy{build: atq}
	grbuild.flds = &atq.ctx.Fields
	grbuild.label = accesstoken.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		UserID uuid.UUID `json:"user_id,omitempty"`
//	}
//
//	client.AccessToken.Query().
//		Select(accesstoken.FieldUserID).
//		Scan(ctx, &v)
func (atq *AccessTokenQuery) Select(fields ...string) *AccessTokenSelect {
	atq.ctx.Fields = append(atq.ctx.Fields, fields...)
	sbuild := &AccessTokenSelect{AccessTokenQuery: atq}
	sbuild.label = accesstoken.Label
	sbuild.flds, sbuild.scan = &atq.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a AccessTokenSelect configured with the given aggregations.
func (atq *AccessTokenQuery) Aggregate(fns ...AggregateFunc) *AccessTokenSelect {
	return atq.Select().Aggregate(fns...)
}

func (atq *AccessTokenQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range atq.inters {
		if inter == nil {
			return fmt.Errorf("models: uninitialized interceptor (forgotten import models/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, atq); err != nil {
				return err
			}
		}
	}
	for _, f := range atq.ctx.Fields {
		if !accesstoken.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
		}
	}
	if atq.path != nil {
		prev, err := atq.path(ctx)
		if err != nil {
			return err
		}
		atq.sql = prev
	}
	return nil
}

func (atq *AccessTokenQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*AccessToken, error) {
	var (
		nodes       = []*AccessToken{}
		_spec       = atq.querySpec()
		loadedTypes = [1]bool{
			atq.withUser != nil,
		}
	)
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*AccessToken).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &AccessToken{config: atq.config}
		nodes = append(nodes, node)
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	_spec.Node.Schema = atq.schemaConfig.AccessToken
	ctx = internal.NewSchemaConfigContext(ctx, atq.schemaConfig)
	if len(atq.modifiers) > 0 {
		_spec.Modifiers = atq.modifiers
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, atq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	if query := atq.withUser; query != nil {
		if err := atq.loadUser(ctx, query, nodes, nil,
			func(n *AccessToken, e *User) { n.Edges.User = e }); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

func (atq *AccessTokenQuery) loadUser(ctx context.Context, query *UserQuery, nodes []*AccessToken, init func(*AccessToken), assign func(*AccessToken, *User)) error {
	ids := make([]uuid.UUID, 0, len(nodes))
	nodeids := make(map[uuid.UUID][]*AccessToken)
	for i := range nodes {
		fk := nodes[i].UserID
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(user.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "user_id" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}

func (atq *AccessTokenQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := atq.querySpec()
	_spec.Node.Schema = atq.schemaConfig.AccessToken
	ctx = internal.NewSchemaConfigContext(ctx, atq.schemaConfig)
	if len(atq.modifiers) > 0 {
		_spec.Modifiers = atq.modifiers
	}
	_spec.Node.Columns = atq.ctx.Fields
	if len(atq.ctx.Fields) > 0 {
		_spec.Unique = atq.ctx.Unique != nil && *atq.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, atq.driver, _spec)
}

func (atq *AccessTokenQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(accesstoken.Table, accesstoken.Columns, sqlgraph.NewFieldSpec(accesstoken.FieldID, field.TypeString))
	_spec.From = atq.sql
	if unique := atq.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if atq.path != nil {
		_spec.Unique = true
	}
	if fields := atq.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, accesstoken.FieldID)
		for i := range fields {
			if fields[i] != accesstoken.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
		if atq.withUser != nil {
			_spec.Node.AddColumnOnce(accesstoken.FieldUserID)
		}
	}
	if ps := atq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := atq.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := atq.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := atq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (atq *AccessTokenQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(atq.driver.Dialect())
	t1 := builder.Table(accesstoken.Table)
	columns := atq.ctx.Fields
	if len(columns) == 0 {
		columns = accesstoken.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if atq.sql != nil {
		selector = atq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if atq.ctx.Unique != nil && *atq.ctx.Unique {
		selector.Distinct()
	}
	t1.Schema(atq.schemaConfig.AccessToken)
	ctx = internal.NewSchemaConfigContext(ctx, atq.schemaConfig)
	selector.WithContext(ctx)
	for _, m := range atq.modifiers {
		m(selector)
	}
	for _, p := range atq.predicates {
		p(selector)
	}
	for _, p := range atq.order {
		p(selector)
	}
	if offset := atq.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := atq.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// Modify adds a query modifier for attaching custom logic to queries.
func (atq *AccessTokenQuery) Modify(modifiers ...func(s *sql.Selector)) *AccessTokenSelect {
	atq.modifiers = append(atq.modifiers, modifiers...)
	return atq.Select()
}

// AccessTokenGroupBy is the group-by builder for AccessToken entities.
type AccessTokenGroupBy struct {
	selector
	build *AccessTokenQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (atgb *AccessTokenGroupBy) Aggregate(fns ...AggregateFunc) *AccessTokenGroupBy {
	atgb.fns = append(atgb.fns, fns...)
	return atgb
}

// Scan applies the selector query and scans the result into the given value.
func (atgb *AccessTokenGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, atgb.build.ctx, "GroupBy")
	if err := atgb.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*AccessTokenQuery, *AccessTokenGroupBy](ctx, atgb.build, atgb, atgb.build.inters, v)
}

func (atgb *AccessTokenGroupBy) sqlScan(ctx context.Context, root *AccessTokenQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(atgb.fns))
	for _, fn := range atgb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*atgb.flds)+len(atgb.fns))
		for _, f := range *atgb.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*atgb.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := atgb.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// AccessTokenSelect is the builder for selecting fields of AccessToken entities.
type AccessTokenSelect struct {
	*AccessTokenQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (ats *AccessTokenSelect) Aggregate(fns ...AggregateFunc) *AccessTokenSelect {
	ats.fns = append(ats.fns, fns...)
	return ats
}

// Scan applies the selector query and scans the result into the given value.
func (ats *AccessTokenSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, ats.ctx, "Select")
	if err := ats.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*AccessTokenQuery, *AccessTokenSelect](ctx, ats.AccessTokenQuery, ats, ats.inters, v)
}

func (ats *AccessTokenSelect) sqlScan(ctx context.Context, root *AccessTokenQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(ats.fns))
	for _, fn := range ats.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*ats.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := ats.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// Modify adds a query modifier for attaching custom logic to queries.
func (ats *AccessTokenSelect) Modify(modifiers ...func(s *sql.Selector)) *AccessTokenSelect {
	ats.modifiers = append(ats.modifiers, modifiers...)
	return ats
}



================================================
File: models/accesstoken_update.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/accesstoken"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/google/uuid"
)

// AccessTokenUpdate is the builder for updating AccessToken entities.
type AccessTokenUpdate struct {
	config
	hooks     []Hook
	mutation  *AccessTokenMutation
	modifiers []func(*sql.UpdateBuilder)
}

// Where appends a list predicates to the AccessTokenUpdate builder.
func (atu *AccessTokenUpdate) Where(ps ...predicate.AccessToken) *AccessTokenUpdate {
	atu.mutation.Where(ps...)
	return atu
}

// SetUserID sets the "user_id" field.
func (atu *AccessTokenUpdate) SetUserID(u uuid.UUID) *AccessTokenUpdate {
	atu.mutation.SetUserID(u)
	return atu
}

// SetNillableUserID sets the "user_id" field if the given value is not nil.
func (atu *AccessTokenUpdate) SetNillableUserID(u *uuid.UUID) *AccessTokenUpdate {
	if u != nil {
		atu.SetUserID(*u)
	}
	return atu
}

// SetUser sets the "user" edge to the User entity.
func (atu *AccessTokenUpdate) SetUser(u *User) *AccessTokenUpdate {
	return atu.SetUserID(u.ID)
}

// Mutation returns the AccessTokenMutation object of the builder.
func (atu *AccessTokenUpdate) Mutation() *AccessTokenMutation {
	return atu.mutation
}

// ClearUser clears the "user" edge to the User entity.
func (atu *AccessTokenUpdate) ClearUser() *AccessTokenUpdate {
	atu.mutation.ClearUser()
	return atu
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (atu *AccessTokenUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, atu.sqlSave, atu.mutation, atu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (atu *AccessTokenUpdate) SaveX(ctx context.Context) int {
	affected, err := atu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (atu *AccessTokenUpdate) Exec(ctx context.Context) error {
	_, err := atu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (atu *AccessTokenUpdate) ExecX(ctx context.Context) {
	if err := atu.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (atu *AccessTokenUpdate) check() error {
	if _, ok := atu.mutation.UserID(); atu.mutation.UserCleared() && !ok {
		return errors.New(`models: clearing a required unique edge "AccessToken.user"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (atu *AccessTokenUpdate) Modify(modifiers ...func(u *sql.UpdateBuilder)) *AccessTokenUpdate {
	atu.modifiers = append(atu.modifiers, modifiers...)
	return atu
}

func (atu *AccessTokenUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := atu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(accesstoken.Table, accesstoken.Columns, sqlgraph.NewFieldSpec(accesstoken.FieldID, field.TypeString))
	if ps := atu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if atu.mutation.CreatedAtCleared() {
		_spec.ClearField(accesstoken.FieldCreatedAt, field.TypeTime)
	}
	if atu.mutation.UserCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   accesstoken.UserTable,
			Columns: []string{accesstoken.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = atu.schemaConfig.AccessToken
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := atu.mutation.UserIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   accesstoken.UserTable,
			Columns: []string{accesstoken.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = atu.schemaConfig.AccessToken
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = atu.schemaConfig.AccessToken
	ctx = internal.NewSchemaConfigContext(ctx, atu.schemaConfig)
	_spec.AddModifiers(atu.modifiers...)
	if n, err = sqlgraph.UpdateNodes(ctx, atu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{accesstoken.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	atu.mutation.done = true
	return n, nil
}

// AccessTokenUpdateOne is the builder for updating a single AccessToken entity.
type AccessTokenUpdateOne struct {
	config
	fields    []string
	hooks     []Hook
	mutation  *AccessTokenMutation
	modifiers []func(*sql.UpdateBuilder)
}

// SetUserID sets the "user_id" field.
func (atuo *AccessTokenUpdateOne) SetUserID(u uuid.UUID) *AccessTokenUpdateOne {
	atuo.mutation.SetUserID(u)
	return atuo
}

// SetNillableUserID sets the "user_id" field if the given value is not nil.
func (atuo *AccessTokenUpdateOne) SetNillableUserID(u *uuid.UUID) *AccessTokenUpdateOne {
	if u != nil {
		atuo.SetUserID(*u)
	}
	return atuo
}

// SetUser sets the "user" edge to the User entity.
func (atuo *AccessTokenUpdateOne) SetUser(u *User) *AccessTokenUpdateOne {
	return atuo.SetUserID(u.ID)
}

// Mutation returns the AccessTokenMutation object of the builder.
func (atuo *AccessTokenUpdateOne) Mutation() *AccessTokenMutation {
	return atuo.mutation
}

// ClearUser clears the "user" edge to the User entity.
func (atuo *AccessTokenUpdateOne) ClearUser() *AccessTokenUpdateOne {
	atuo.mutation.ClearUser()
	return atuo
}

// Where appends a list predicates to the AccessTokenUpdate builder.
func (atuo *AccessTokenUpdateOne) Where(ps ...predicate.AccessToken) *AccessTokenUpdateOne {
	atuo.mutation.Where(ps...)
	return atuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (atuo *AccessTokenUpdateOne) Select(field string, fields ...string) *AccessTokenUpdateOne {
	atuo.fields = append([]string{field}, fields...)
	return atuo
}

// Save executes the query and returns the updated AccessToken entity.
func (atuo *AccessTokenUpdateOne) Save(ctx context.Context) (*AccessToken, error) {
	return withHooks(ctx, atuo.sqlSave, atuo.mutation, atuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (atuo *AccessTokenUpdateOne) SaveX(ctx context.Context) *AccessToken {
	node, err := atuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (atuo *AccessTokenUpdateOne) Exec(ctx context.Context) error {
	_, err := atuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (atuo *AccessTokenUpdateOne) ExecX(ctx context.Context) {
	if err := atuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (atuo *AccessTokenUpdateOne) check() error {
	if _, ok := atuo.mutation.UserID(); atuo.mutation.UserCleared() && !ok {
		return errors.New(`models: clearing a required unique edge "AccessToken.user"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (atuo *AccessTokenUpdateOne) Modify(modifiers ...func(u *sql.UpdateBuilder)) *AccessTokenUpdateOne {
	atuo.modifiers = append(atuo.modifiers, modifiers...)
	return atuo
}

func (atuo *AccessTokenUpdateOne) sqlSave(ctx context.Context) (_node *AccessToken, err error) {
	if err := atuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(accesstoken.Table, accesstoken.Columns, sqlgraph.NewFieldSpec(accesstoken.FieldID, field.TypeString))
	id, ok := atuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`models: missing "AccessToken.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := atuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, accesstoken.FieldID)
		for _, f := range fields {
			if !accesstoken.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
			}
			if f != accesstoken.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := atuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if atuo.mutation.CreatedAtCleared() {
		_spec.ClearField(accesstoken.FieldCreatedAt, field.TypeTime)
	}
	if atuo.mutation.UserCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   accesstoken.UserTable,
			Columns: []string{accesstoken.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = atuo.schemaConfig.AccessToken
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := atuo.mutation.UserIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   accesstoken.UserTable,
			Columns: []string{accesstoken.UserColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = atuo.schemaConfig.AccessToken
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = atuo.schemaConfig.AccessToken
	ctx = internal.NewSchemaConfigContext(ctx, atuo.schemaConfig)
	_spec.AddModifiers(atuo.modifiers...)
	_node = &AccessToken{config: atuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, atuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{accesstoken.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	atuo.mutation.done = true
	return _node, nil
}



================================================
File: models/client.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/e2b-dev/infra/packages/shared/pkg/models/migrate"
	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/accesstoken"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envalias"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envbuild"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/snapshot"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/teamapikey"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/tier"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"

	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AccessToken is the client for interacting with the AccessToken builders.
	AccessToken *AccessTokenClient
	// Env is the client for interacting with the Env builders.
	Env *EnvClient
	// EnvAlias is the client for interacting with the EnvAlias builders.
	EnvAlias *EnvAliasClient
	// EnvBuild is the client for interacting with the EnvBuild builders.
	EnvBuild *EnvBuildClient
	// Snapshot is the client for interacting with the Snapshot builders.
	Snapshot *SnapshotClient
	// Team is the client for interacting with the Team builders.
	Team *TeamClient
	// TeamAPIKey is the client for interacting with the TeamAPIKey builders.
	TeamAPIKey *TeamAPIKeyClient
	// Tier is the client for interacting with the Tier builders.
	Tier *TierClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UsersTeams is the client for interacting with the UsersTeams builders.
	UsersTeams *UsersTeamsClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AccessToken = NewAccessTokenClient(c.config)
	c.Env = NewEnvClient(c.config)
	c.EnvAlias = NewEnvAliasClient(c.config)
	c.EnvBuild = NewEnvBuildClient(c.config)
	c.Snapshot = NewSnapshotClient(c.config)
	c.Team = NewTeamClient(c.config)
	c.TeamAPIKey = NewTeamAPIKeyClient(c.config)
	c.Tier = NewTierClient(c.config)
	c.User = NewUserClient(c.config)
	c.UsersTeams = NewUsersTeamsClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
		// schemaConfig contains alternative names for all tables.
		schemaConfig SchemaConfig
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.schemaConfig = DefaultSchemaConfig
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("models: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("models: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:         ctx,
		config:      cfg,
		AccessToken: NewAccessTokenClient(cfg),
		Env:         NewEnvClient(cfg),
		EnvAlias:    NewEnvAliasClient(cfg),
		EnvBuild:    NewEnvBuildClient(cfg),
		Snapshot:    NewSnapshotClient(cfg),
		Team:        NewTeamClient(cfg),
		TeamAPIKey:  NewTeamAPIKeyClient(cfg),
		Tier:        NewTierClient(cfg),
		User:        NewUserClient(cfg),
		UsersTeams:  NewUsersTeamsClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:         ctx,
		config:      cfg,
		AccessToken: NewAccessTokenClient(cfg),
		Env:         NewEnvClient(cfg),
		EnvAlias:    NewEnvAliasClient(cfg),
		EnvBuild:    NewEnvBuildClient(cfg),
		Snapshot:    NewSnapshotClient(cfg),
		Team:        NewTeamClient(cfg),
		TeamAPIKey:  NewTeamAPIKeyClient(cfg),
		Tier:        NewTierClient(cfg),
		User:        NewUserClient(cfg),
		UsersTeams:  NewUsersTeamsClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AccessToken.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AccessToken, c.Env, c.EnvAlias, c.EnvBuild, c.Snapshot, c.Team, c.TeamAPIKey,
		c.Tier, c.User, c.UsersTeams,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AccessToken, c.Env, c.EnvAlias, c.EnvBuild, c.Snapshot, c.Team, c.TeamAPIKey,
		c.Tier, c.User, c.UsersTeams,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AccessTokenMutation:
		return c.AccessToken.mutate(ctx, m)
	case *EnvMutation:
		return c.Env.mutate(ctx, m)
	case *EnvAliasMutation:
		return c.EnvAlias.mutate(ctx, m)
	case *EnvBuildMutation:
		return c.EnvBuild.mutate(ctx, m)
	case *SnapshotMutation:
		return c.Snapshot.mutate(ctx, m)
	case *TeamMutation:
		return c.Team.mutate(ctx, m)
	case *TeamAPIKeyMutation:
		return c.TeamAPIKey.mutate(ctx, m)
	case *TierMutation:
		return c.Tier.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UsersTeamsMutation:
		return c.UsersTeams.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("models: unknown mutation type %T", m)
	}
}

// AccessTokenClient is a client for the AccessToken schema.
type AccessTokenClient struct {
	config
}

// NewAccessTokenClient returns a client for the AccessToken from the given config.
func NewAccessTokenClient(c config) *AccessTokenClient {
	return &AccessTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `accesstoken.Hooks(f(g(h())))`.
func (c *AccessTokenClient) Use(hooks ...Hook) {
	c.hooks.AccessToken = append(c.hooks.AccessToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `accesstoken.Intercept(f(g(h())))`.
func (c *AccessTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.AccessToken = append(c.inters.AccessToken, interceptors...)
}

// Create returns a builder for creating a AccessToken entity.
func (c *AccessTokenClient) Create() *AccessTokenCreate {
	mutation := newAccessTokenMutation(c.config, OpCreate)
	return &AccessTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AccessToken entities.
func (c *AccessTokenClient) CreateBulk(builders ...*AccessTokenCreate) *AccessTokenCreateBulk {
	return &AccessTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccessTokenClient) MapCreateBulk(slice any, setFunc func(*AccessTokenCreate, int)) *AccessTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccessTokenCreateBulk{err: fmt.Errorf("calling to AccessTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccessTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccessTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AccessToken.
func (c *AccessTokenClient) Update() *AccessTokenUpdate {
	mutation := newAccessTokenMutation(c.config, OpUpdate)
	return &AccessTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccessTokenClient) UpdateOne(at *AccessToken) *AccessTokenUpdateOne {
	mutation := newAccessTokenMutation(c.config, OpUpdateOne, withAccessToken(at))
	return &AccessTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccessTokenClient) UpdateOneID(id string) *AccessTokenUpdateOne {
	mutation := newAccessTokenMutation(c.config, OpUpdateOne, withAccessTokenID(id))
	return &AccessTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AccessToken.
func (c *AccessTokenClient) Delete() *AccessTokenDelete {
	mutation := newAccessTokenMutation(c.config, OpDelete)
	return &AccessTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccessTokenClient) DeleteOne(at *AccessToken) *AccessTokenDeleteOne {
	return c.DeleteOneID(at.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccessTokenClient) DeleteOneID(id string) *AccessTokenDeleteOne {
	builder := c.Delete().Where(accesstoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccessTokenDeleteOne{builder}
}

// Query returns a query builder for AccessToken.
func (c *AccessTokenClient) Query() *AccessTokenQuery {
	return &AccessTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccessToken},
		inters: c.Interceptors(),
	}
}

// Get returns a AccessToken entity by its id.
func (c *AccessTokenClient) Get(ctx context.Context, id string) (*AccessToken, error) {
	return c.Query().Where(accesstoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccessTokenClient) GetX(ctx context.Context, id string) *AccessToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a AccessToken.
func (c *AccessTokenClient) QueryUser(at *AccessToken) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accesstoken.Table, accesstoken.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, accesstoken.UserTable, accesstoken.UserColumn),
		)
		schemaConfig := at.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.AccessToken
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccessTokenClient) Hooks() []Hook {
	return c.hooks.AccessToken
}

// Interceptors returns the client interceptors.
func (c *AccessTokenClient) Interceptors() []Interceptor {
	return c.inters.AccessToken
}

func (c *AccessTokenClient) mutate(ctx context.Context, m *AccessTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccessTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccessTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccessTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccessTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown AccessToken mutation op: %q", m.Op())
	}
}

// EnvClient is a client for the Env schema.
type EnvClient struct {
	config
}

// NewEnvClient returns a client for the Env from the given config.
func NewEnvClient(c config) *EnvClient {
	return &EnvClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `env.Hooks(f(g(h())))`.
func (c *EnvClient) Use(hooks ...Hook) {
	c.hooks.Env = append(c.hooks.Env, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `env.Intercept(f(g(h())))`.
func (c *EnvClient) Intercept(interceptors ...Interceptor) {
	c.inters.Env = append(c.inters.Env, interceptors...)
}

// Create returns a builder for creating a Env entity.
func (c *EnvClient) Create() *EnvCreate {
	mutation := newEnvMutation(c.config, OpCreate)
	return &EnvCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Env entities.
func (c *EnvClient) CreateBulk(builders ...*EnvCreate) *EnvCreateBulk {
	return &EnvCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnvClient) MapCreateBulk(slice any, setFunc func(*EnvCreate, int)) *EnvCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnvCreateBulk{err: fmt.Errorf("calling to EnvClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnvCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnvCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Env.
func (c *EnvClient) Update() *EnvUpdate {
	mutation := newEnvMutation(c.config, OpUpdate)
	return &EnvUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnvClient) UpdateOne(e *Env) *EnvUpdateOne {
	mutation := newEnvMutation(c.config, OpUpdateOne, withEnv(e))
	return &EnvUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnvClient) UpdateOneID(id string) *EnvUpdateOne {
	mutation := newEnvMutation(c.config, OpUpdateOne, withEnvID(id))
	return &EnvUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Env.
func (c *EnvClient) Delete() *EnvDelete {
	mutation := newEnvMutation(c.config, OpDelete)
	return &EnvDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnvClient) DeleteOne(e *Env) *EnvDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnvClient) DeleteOneID(id string) *EnvDeleteOne {
	builder := c.Delete().Where(env.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnvDeleteOne{builder}
}

// Query returns a query builder for Env.
func (c *EnvClient) Query() *EnvQuery {
	return &EnvQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnv},
		inters: c.Interceptors(),
	}
}

// Get returns a Env entity by its id.
func (c *EnvClient) Get(ctx context.Context, id string) (*Env, error) {
	return c.Query().Where(env.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnvClient) GetX(ctx context.Context, id string) *Env {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a Env.
func (c *EnvClient) QueryTeam(e *Env) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(env.Table, env.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, env.TeamTable, env.TeamColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.Env
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreator queries the creator edge of a Env.
func (c *EnvClient) QueryCreator(e *Env) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(env.Table, env.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, env.CreatorTable, env.CreatorColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.Env
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvAliases queries the env_aliases edge of a Env.
func (c *EnvClient) QueryEnvAliases(e *Env) *EnvAliasQuery {
	query := (&EnvAliasClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(env.Table, env.FieldID, id),
			sqlgraph.To(envalias.Table, envalias.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, env.EnvAliasesTable, env.EnvAliasesColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.EnvAlias
		step.Edge.Schema = schemaConfig.EnvAlias
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuilds queries the builds edge of a Env.
func (c *EnvClient) QueryBuilds(e *Env) *EnvBuildQuery {
	query := (&EnvBuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(env.Table, env.FieldID, id),
			sqlgraph.To(envbuild.Table, envbuild.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, env.BuildsTable, env.BuildsColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.EnvBuild
		step.Edge.Schema = schemaConfig.EnvBuild
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySnapshots queries the snapshots edge of a Env.
func (c *EnvClient) QuerySnapshots(e *Env) *SnapshotQuery {
	query := (&SnapshotClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(env.Table, env.FieldID, id),
			sqlgraph.To(snapshot.Table, snapshot.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, env.SnapshotsTable, env.SnapshotsColumn),
		)
		schemaConfig := e.schemaConfig
		step.To.Schema = schemaConfig.Snapshot
		step.Edge.Schema = schemaConfig.Snapshot
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EnvClient) Hooks() []Hook {
	return c.hooks.Env
}

// Interceptors returns the client interceptors.
func (c *EnvClient) Interceptors() []Interceptor {
	return c.inters.Env
}

func (c *EnvClient) mutate(ctx context.Context, m *EnvMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnvCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnvUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnvUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnvDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown Env mutation op: %q", m.Op())
	}
}

// EnvAliasClient is a client for the EnvAlias schema.
type EnvAliasClient struct {
	config
}

// NewEnvAliasClient returns a client for the EnvAlias from the given config.
func NewEnvAliasClient(c config) *EnvAliasClient {
	return &EnvAliasClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `envalias.Hooks(f(g(h())))`.
func (c *EnvAliasClient) Use(hooks ...Hook) {
	c.hooks.EnvAlias = append(c.hooks.EnvAlias, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `envalias.Intercept(f(g(h())))`.
func (c *EnvAliasClient) Intercept(interceptors ...Interceptor) {
	c.inters.EnvAlias = append(c.inters.EnvAlias, interceptors...)
}

// Create returns a builder for creating a EnvAlias entity.
func (c *EnvAliasClient) Create() *EnvAliasCreate {
	mutation := newEnvAliasMutation(c.config, OpCreate)
	return &EnvAliasCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EnvAlias entities.
func (c *EnvAliasClient) CreateBulk(builders ...*EnvAliasCreate) *EnvAliasCreateBulk {
	return &EnvAliasCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnvAliasClient) MapCreateBulk(slice any, setFunc func(*EnvAliasCreate, int)) *EnvAliasCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnvAliasCreateBulk{err: fmt.Errorf("calling to EnvAliasClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnvAliasCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnvAliasCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EnvAlias.
func (c *EnvAliasClient) Update() *EnvAliasUpdate {
	mutation := newEnvAliasMutation(c.config, OpUpdate)
	return &EnvAliasUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnvAliasClient) UpdateOne(ea *EnvAlias) *EnvAliasUpdateOne {
	mutation := newEnvAliasMutation(c.config, OpUpdateOne, withEnvAlias(ea))
	return &EnvAliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnvAliasClient) UpdateOneID(id string) *EnvAliasUpdateOne {
	mutation := newEnvAliasMutation(c.config, OpUpdateOne, withEnvAliasID(id))
	return &EnvAliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EnvAlias.
func (c *EnvAliasClient) Delete() *EnvAliasDelete {
	mutation := newEnvAliasMutation(c.config, OpDelete)
	return &EnvAliasDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnvAliasClient) DeleteOne(ea *EnvAlias) *EnvAliasDeleteOne {
	return c.DeleteOneID(ea.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnvAliasClient) DeleteOneID(id string) *EnvAliasDeleteOne {
	builder := c.Delete().Where(envalias.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnvAliasDeleteOne{builder}
}

// Query returns a query builder for EnvAlias.
func (c *EnvAliasClient) Query() *EnvAliasQuery {
	return &EnvAliasQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnvAlias},
		inters: c.Interceptors(),
	}
}

// Get returns a EnvAlias entity by its id.
func (c *EnvAliasClient) Get(ctx context.Context, id string) (*EnvAlias, error) {
	return c.Query().Where(envalias.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnvAliasClient) GetX(ctx context.Context, id string) *EnvAlias {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnv queries the env edge of a EnvAlias.
func (c *EnvAliasClient) QueryEnv(ea *EnvAlias) *EnvQuery {
	query := (&EnvClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ea.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(envalias.Table, envalias.FieldID, id),
			sqlgraph.To(env.Table, env.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, envalias.EnvTable, envalias.EnvColumn),
		)
		schemaConfig := ea.schemaConfig
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.EnvAlias
		fromV = sqlgraph.Neighbors(ea.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EnvAliasClient) Hooks() []Hook {
	return c.hooks.EnvAlias
}

// Interceptors returns the client interceptors.
func (c *EnvAliasClient) Interceptors() []Interceptor {
	return c.inters.EnvAlias
}

func (c *EnvAliasClient) mutate(ctx context.Context, m *EnvAliasMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnvAliasCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnvAliasUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnvAliasUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnvAliasDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown EnvAlias mutation op: %q", m.Op())
	}
}

// EnvBuildClient is a client for the EnvBuild schema.
type EnvBuildClient struct {
	config
}

// NewEnvBuildClient returns a client for the EnvBuild from the given config.
func NewEnvBuildClient(c config) *EnvBuildClient {
	return &EnvBuildClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `envbuild.Hooks(f(g(h())))`.
func (c *EnvBuildClient) Use(hooks ...Hook) {
	c.hooks.EnvBuild = append(c.hooks.EnvBuild, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `envbuild.Intercept(f(g(h())))`.
func (c *EnvBuildClient) Intercept(interceptors ...Interceptor) {
	c.inters.EnvBuild = append(c.inters.EnvBuild, interceptors...)
}

// Create returns a builder for creating a EnvBuild entity.
func (c *EnvBuildClient) Create() *EnvBuildCreate {
	mutation := newEnvBuildMutation(c.config, OpCreate)
	return &EnvBuildCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EnvBuild entities.
func (c *EnvBuildClient) CreateBulk(builders ...*EnvBuildCreate) *EnvBuildCreateBulk {
	return &EnvBuildCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnvBuildClient) MapCreateBulk(slice any, setFunc func(*EnvBuildCreate, int)) *EnvBuildCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnvBuildCreateBulk{err: fmt.Errorf("calling to EnvBuildClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnvBuildCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnvBuildCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EnvBuild.
func (c *EnvBuildClient) Update() *EnvBuildUpdate {
	mutation := newEnvBuildMutation(c.config, OpUpdate)
	return &EnvBuildUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnvBuildClient) UpdateOne(eb *EnvBuild) *EnvBuildUpdateOne {
	mutation := newEnvBuildMutation(c.config, OpUpdateOne, withEnvBuild(eb))
	return &EnvBuildUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnvBuildClient) UpdateOneID(id uuid.UUID) *EnvBuildUpdateOne {
	mutation := newEnvBuildMutation(c.config, OpUpdateOne, withEnvBuildID(id))
	return &EnvBuildUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EnvBuild.
func (c *EnvBuildClient) Delete() *EnvBuildDelete {
	mutation := newEnvBuildMutation(c.config, OpDelete)
	return &EnvBuildDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnvBuildClient) DeleteOne(eb *EnvBuild) *EnvBuildDeleteOne {
	return c.DeleteOneID(eb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnvBuildClient) DeleteOneID(id uuid.UUID) *EnvBuildDeleteOne {
	builder := c.Delete().Where(envbuild.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnvBuildDeleteOne{builder}
}

// Query returns a query builder for EnvBuild.
func (c *EnvBuildClient) Query() *EnvBuildQuery {
	return &EnvBuildQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnvBuild},
		inters: c.Interceptors(),
	}
}

// Get returns a EnvBuild entity by its id.
func (c *EnvBuildClient) Get(ctx context.Context, id uuid.UUID) (*EnvBuild, error) {
	return c.Query().Where(envbuild.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnvBuildClient) GetX(ctx context.Context, id uuid.UUID) *EnvBuild {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnv queries the env edge of a EnvBuild.
func (c *EnvBuildClient) QueryEnv(eb *EnvBuild) *EnvQuery {
	query := (&EnvClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := eb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(envbuild.Table, envbuild.FieldID, id),
			sqlgraph.To(env.Table, env.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, envbuild.EnvTable, envbuild.EnvColumn),
		)
		schemaConfig := eb.schemaConfig
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.EnvBuild
		fromV = sqlgraph.Neighbors(eb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EnvBuildClient) Hooks() []Hook {
	return c.hooks.EnvBuild
}

// Interceptors returns the client interceptors.
func (c *EnvBuildClient) Interceptors() []Interceptor {
	return c.inters.EnvBuild
}

func (c *EnvBuildClient) mutate(ctx context.Context, m *EnvBuildMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnvBuildCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnvBuildUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnvBuildUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnvBuildDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown EnvBuild mutation op: %q", m.Op())
	}
}

// SnapshotClient is a client for the Snapshot schema.
type SnapshotClient struct {
	config
}

// NewSnapshotClient returns a client for the Snapshot from the given config.
func NewSnapshotClient(c config) *SnapshotClient {
	return &SnapshotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `snapshot.Hooks(f(g(h())))`.
func (c *SnapshotClient) Use(hooks ...Hook) {
	c.hooks.Snapshot = append(c.hooks.Snapshot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `snapshot.Intercept(f(g(h())))`.
func (c *SnapshotClient) Intercept(interceptors ...Interceptor) {
	c.inters.Snapshot = append(c.inters.Snapshot, interceptors...)
}

// Create returns a builder for creating a Snapshot entity.
func (c *SnapshotClient) Create() *SnapshotCreate {
	mutation := newSnapshotMutation(c.config, OpCreate)
	return &SnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Snapshot entities.
func (c *SnapshotClient) CreateBulk(builders ...*SnapshotCreate) *SnapshotCreateBulk {
	return &SnapshotCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SnapshotClient) MapCreateBulk(slice any, setFunc func(*SnapshotCreate, int)) *SnapshotCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SnapshotCreateBulk{err: fmt.Errorf("calling to SnapshotClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SnapshotCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SnapshotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Snapshot.
func (c *SnapshotClient) Update() *SnapshotUpdate {
	mutation := newSnapshotMutation(c.config, OpUpdate)
	return &SnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SnapshotClient) UpdateOne(s *Snapshot) *SnapshotUpdateOne {
	mutation := newSnapshotMutation(c.config, OpUpdateOne, withSnapshot(s))
	return &SnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SnapshotClient) UpdateOneID(id uuid.UUID) *SnapshotUpdateOne {
	mutation := newSnapshotMutation(c.config, OpUpdateOne, withSnapshotID(id))
	return &SnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Snapshot.
func (c *SnapshotClient) Delete() *SnapshotDelete {
	mutation := newSnapshotMutation(c.config, OpDelete)
	return &SnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SnapshotClient) DeleteOne(s *Snapshot) *SnapshotDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SnapshotClient) DeleteOneID(id uuid.UUID) *SnapshotDeleteOne {
	builder := c.Delete().Where(snapshot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SnapshotDeleteOne{builder}
}

// Query returns a query builder for Snapshot.
func (c *SnapshotClient) Query() *SnapshotQuery {
	return &SnapshotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSnapshot},
		inters: c.Interceptors(),
	}
}

// Get returns a Snapshot entity by its id.
func (c *SnapshotClient) Get(ctx context.Context, id uuid.UUID) (*Snapshot, error) {
	return c.Query().Where(snapshot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SnapshotClient) GetX(ctx context.Context, id uuid.UUID) *Snapshot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnv queries the env edge of a Snapshot.
func (c *SnapshotClient) QueryEnv(s *Snapshot) *EnvQuery {
	query := (&EnvClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(snapshot.Table, snapshot.FieldID, id),
			sqlgraph.To(env.Table, env.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, snapshot.EnvTable, snapshot.EnvColumn),
		)
		schemaConfig := s.schemaConfig
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.Snapshot
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SnapshotClient) Hooks() []Hook {
	return c.hooks.Snapshot
}

// Interceptors returns the client interceptors.
func (c *SnapshotClient) Interceptors() []Interceptor {
	return c.inters.Snapshot
}

func (c *SnapshotClient) mutate(ctx context.Context, m *SnapshotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown Snapshot mutation op: %q", m.Op())
	}
}

// TeamClient is a client for the Team schema.
type TeamClient struct {
	config
}

// NewTeamClient returns a client for the Team from the given config.
func NewTeamClient(c config) *TeamClient {
	return &TeamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `team.Hooks(f(g(h())))`.
func (c *TeamClient) Use(hooks ...Hook) {
	c.hooks.Team = append(c.hooks.Team, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `team.Intercept(f(g(h())))`.
func (c *TeamClient) Intercept(interceptors ...Interceptor) {
	c.inters.Team = append(c.inters.Team, interceptors...)
}

// Create returns a builder for creating a Team entity.
func (c *TeamClient) Create() *TeamCreate {
	mutation := newTeamMutation(c.config, OpCreate)
	return &TeamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Team entities.
func (c *TeamClient) CreateBulk(builders ...*TeamCreate) *TeamCreateBulk {
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TeamClient) MapCreateBulk(slice any, setFunc func(*TeamCreate, int)) *TeamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TeamCreateBulk{err: fmt.Errorf("calling to TeamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TeamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Team.
func (c *TeamClient) Update() *TeamUpdate {
	mutation := newTeamMutation(c.config, OpUpdate)
	return &TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TeamClient) UpdateOne(t *Team) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeam(t))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TeamClient) UpdateOneID(id uuid.UUID) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeamID(id))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Team.
func (c *TeamClient) Delete() *TeamDelete {
	mutation := newTeamMutation(c.config, OpDelete)
	return &TeamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TeamClient) DeleteOne(t *Team) *TeamDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TeamClient) DeleteOneID(id uuid.UUID) *TeamDeleteOne {
	builder := c.Delete().Where(team.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TeamDeleteOne{builder}
}

// Query returns a query builder for Team.
func (c *TeamClient) Query() *TeamQuery {
	return &TeamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTeam},
		inters: c.Interceptors(),
	}
}

// Get returns a Team entity by its id.
func (c *TeamClient) Get(ctx context.Context, id uuid.UUID) (*Team, error) {
	return c.Query().Where(team.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TeamClient) GetX(ctx context.Context, id uuid.UUID) *Team {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Team.
func (c *TeamClient) QueryUsers(t *Team) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, team.UsersTable, team.UsersPrimaryKey...),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.UsersTeams
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeamAPIKeys queries the team_api_keys edge of a Team.
func (c *TeamClient) QueryTeamAPIKeys(t *Team) *TeamAPIKeyQuery {
	query := (&TeamAPIKeyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(teamapikey.Table, teamapikey.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.TeamAPIKeysTable, team.TeamAPIKeysColumn),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.TeamAPIKey
		step.Edge.Schema = schemaConfig.TeamAPIKey
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeamTier queries the team_tier edge of a Team.
func (c *TeamClient) QueryTeamTier(t *Team) *TierQuery {
	query := (&TierClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tier.Table, tier.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, team.TeamTierTable, team.TeamTierColumn),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.Tier
		step.Edge.Schema = schemaConfig.Team
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvs queries the envs edge of a Team.
func (c *TeamClient) QueryEnvs(t *Team) *EnvQuery {
	query := (&EnvClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(env.Table, env.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.EnvsTable, team.EnvsColumn),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.Env
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsersTeams queries the users_teams edge of a Team.
func (c *TeamClient) QueryUsersTeams(t *Team) *UsersTeamsQuery {
	query := (&UsersTeamsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(usersteams.Table, usersteams.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, team.UsersTeamsTable, team.UsersTeamsColumn),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.UsersTeams
		step.Edge.Schema = schemaConfig.UsersTeams
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TeamClient) Hooks() []Hook {
	return c.hooks.Team
}

// Interceptors returns the client interceptors.
func (c *TeamClient) Interceptors() []Interceptor {
	return c.inters.Team
}

func (c *TeamClient) mutate(ctx context.Context, m *TeamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TeamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TeamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown Team mutation op: %q", m.Op())
	}
}

// TeamAPIKeyClient is a client for the TeamAPIKey schema.
type TeamAPIKeyClient struct {
	config
}

// NewTeamAPIKeyClient returns a client for the TeamAPIKey from the given config.
func NewTeamAPIKeyClient(c config) *TeamAPIKeyClient {
	return &TeamAPIKeyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `teamapikey.Hooks(f(g(h())))`.
func (c *TeamAPIKeyClient) Use(hooks ...Hook) {
	c.hooks.TeamAPIKey = append(c.hooks.TeamAPIKey, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `teamapikey.Intercept(f(g(h())))`.
func (c *TeamAPIKeyClient) Intercept(interceptors ...Interceptor) {
	c.inters.TeamAPIKey = append(c.inters.TeamAPIKey, interceptors...)
}

// Create returns a builder for creating a TeamAPIKey entity.
func (c *TeamAPIKeyClient) Create() *TeamAPIKeyCreate {
	mutation := newTeamAPIKeyMutation(c.config, OpCreate)
	return &TeamAPIKeyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TeamAPIKey entities.
func (c *TeamAPIKeyClient) CreateBulk(builders ...*TeamAPIKeyCreate) *TeamAPIKeyCreateBulk {
	return &TeamAPIKeyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TeamAPIKeyClient) MapCreateBulk(slice any, setFunc func(*TeamAPIKeyCreate, int)) *TeamAPIKeyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TeamAPIKeyCreateBulk{err: fmt.Errorf("calling to TeamAPIKeyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TeamAPIKeyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TeamAPIKeyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TeamAPIKey.
func (c *TeamAPIKeyClient) Update() *TeamAPIKeyUpdate {
	mutation := newTeamAPIKeyMutation(c.config, OpUpdate)
	return &TeamAPIKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TeamAPIKeyClient) UpdateOne(tak *TeamAPIKey) *TeamAPIKeyUpdateOne {
	mutation := newTeamAPIKeyMutation(c.config, OpUpdateOne, withTeamAPIKey(tak))
	return &TeamAPIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TeamAPIKeyClient) UpdateOneID(id uuid.UUID) *TeamAPIKeyUpdateOne {
	mutation := newTeamAPIKeyMutation(c.config, OpUpdateOne, withTeamAPIKeyID(id))
	return &TeamAPIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TeamAPIKey.
func (c *TeamAPIKeyClient) Delete() *TeamAPIKeyDelete {
	mutation := newTeamAPIKeyMutation(c.config, OpDelete)
	return &TeamAPIKeyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TeamAPIKeyClient) DeleteOne(tak *TeamAPIKey) *TeamAPIKeyDeleteOne {
	return c.DeleteOneID(tak.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TeamAPIKeyClient) DeleteOneID(id uuid.UUID) *TeamAPIKeyDeleteOne {
	builder := c.Delete().Where(teamapikey.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TeamAPIKeyDeleteOne{builder}
}

// Query returns a query builder for TeamAPIKey.
func (c *TeamAPIKeyClient) Query() *TeamAPIKeyQuery {
	return &TeamAPIKeyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTeamAPIKey},
		inters: c.Interceptors(),
	}
}

// Get returns a TeamAPIKey entity by its id.
func (c *TeamAPIKeyClient) Get(ctx context.Context, id uuid.UUID) (*TeamAPIKey, error) {
	return c.Query().Where(teamapikey.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TeamAPIKeyClient) GetX(ctx context.Context, id uuid.UUID) *TeamAPIKey {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TeamAPIKey.
func (c *TeamAPIKeyClient) QueryTeam(tak *TeamAPIKey) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tak.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(teamapikey.Table, teamapikey.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, teamapikey.TeamTable, teamapikey.TeamColumn),
		)
		schemaConfig := tak.schemaConfig
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.TeamAPIKey
		fromV = sqlgraph.Neighbors(tak.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreator queries the creator edge of a TeamAPIKey.
func (c *TeamAPIKeyClient) QueryCreator(tak *TeamAPIKey) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tak.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(teamapikey.Table, teamapikey.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, teamapikey.CreatorTable, teamapikey.CreatorColumn),
		)
		schemaConfig := tak.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.TeamAPIKey
		fromV = sqlgraph.Neighbors(tak.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TeamAPIKeyClient) Hooks() []Hook {
	return c.hooks.TeamAPIKey
}

// Interceptors returns the client interceptors.
func (c *TeamAPIKeyClient) Interceptors() []Interceptor {
	return c.inters.TeamAPIKey
}

func (c *TeamAPIKeyClient) mutate(ctx context.Context, m *TeamAPIKeyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TeamAPIKeyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TeamAPIKeyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TeamAPIKeyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TeamAPIKeyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown TeamAPIKey mutation op: %q", m.Op())
	}
}

// TierClient is a client for the Tier schema.
type TierClient struct {
	config
}

// NewTierClient returns a client for the Tier from the given config.
func NewTierClient(c config) *TierClient {
	return &TierClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tier.Hooks(f(g(h())))`.
func (c *TierClient) Use(hooks ...Hook) {
	c.hooks.Tier = append(c.hooks.Tier, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tier.Intercept(f(g(h())))`.
func (c *TierClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tier = append(c.inters.Tier, interceptors...)
}

// Create returns a builder for creating a Tier entity.
func (c *TierClient) Create() *TierCreate {
	mutation := newTierMutation(c.config, OpCreate)
	return &TierCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tier entities.
func (c *TierClient) CreateBulk(builders ...*TierCreate) *TierCreateBulk {
	return &TierCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TierClient) MapCreateBulk(slice any, setFunc func(*TierCreate, int)) *TierCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TierCreateBulk{err: fmt.Errorf("calling to TierClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TierCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TierCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tier.
func (c *TierClient) Update() *TierUpdate {
	mutation := newTierMutation(c.config, OpUpdate)
	return &TierUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TierClient) UpdateOne(t *Tier) *TierUpdateOne {
	mutation := newTierMutation(c.config, OpUpdateOne, withTier(t))
	return &TierUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TierClient) UpdateOneID(id string) *TierUpdateOne {
	mutation := newTierMutation(c.config, OpUpdateOne, withTierID(id))
	return &TierUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tier.
func (c *TierClient) Delete() *TierDelete {
	mutation := newTierMutation(c.config, OpDelete)
	return &TierDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TierClient) DeleteOne(t *Tier) *TierDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TierClient) DeleteOneID(id string) *TierDeleteOne {
	builder := c.Delete().Where(tier.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TierDeleteOne{builder}
}

// Query returns a query builder for Tier.
func (c *TierClient) Query() *TierQuery {
	return &TierQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTier},
		inters: c.Interceptors(),
	}
}

// Get returns a Tier entity by its id.
func (c *TierClient) Get(ctx context.Context, id string) (*Tier, error) {
	return c.Query().Where(tier.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TierClient) GetX(ctx context.Context, id string) *Tier {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeams queries the teams edge of a Tier.
func (c *TierClient) QueryTeams(t *Tier) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tier.Table, tier.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tier.TeamsTable, tier.TeamsColumn),
		)
		schemaConfig := t.schemaConfig
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.Team
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TierClient) Hooks() []Hook {
	return c.hooks.Tier
}

// Interceptors returns the client interceptors.
func (c *TierClient) Interceptors() []Interceptor {
	return c.inters.Tier
}

func (c *TierClient) mutate(ctx context.Context, m *TierMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TierCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TierUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TierUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TierDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown Tier mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeams queries the teams edge of a User.
func (c *UserClient) QueryTeams(u *User) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.TeamsTable, user.TeamsPrimaryKey...),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.UsersTeams
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedEnvs queries the created_envs edge of a User.
func (c *UserClient) QueryCreatedEnvs(u *User) *EnvQuery {
	query := (&EnvClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(env.Table, env.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedEnvsTable, user.CreatedEnvsColumn),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.Env
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccessTokens queries the access_tokens edge of a User.
func (c *UserClient) QueryAccessTokens(u *User) *AccessTokenQuery {
	query := (&AccessTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(accesstoken.Table, accesstoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AccessTokensTable, user.AccessTokensColumn),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.AccessToken
		step.Edge.Schema = schemaConfig.AccessToken
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedAPIKeys queries the created_api_keys edge of a User.
func (c *UserClient) QueryCreatedAPIKeys(u *User) *TeamAPIKeyQuery {
	query := (&TeamAPIKeyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(teamapikey.Table, teamapikey.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedAPIKeysTable, user.CreatedAPIKeysColumn),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.TeamAPIKey
		step.Edge.Schema = schemaConfig.TeamAPIKey
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsersTeams queries the users_teams edge of a User.
func (c *UserClient) QueryUsersTeams(u *User) *UsersTeamsQuery {
	query := (&UsersTeamsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usersteams.Table, usersteams.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.UsersTeamsTable, user.UsersTeamsColumn),
		)
		schemaConfig := u.schemaConfig
		step.To.Schema = schemaConfig.UsersTeams
		step.Edge.Schema = schemaConfig.UsersTeams
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown User mutation op: %q", m.Op())
	}
}

// UsersTeamsClient is a client for the UsersTeams schema.
type UsersTeamsClient struct {
	config
}

// NewUsersTeamsClient returns a client for the UsersTeams from the given config.
func NewUsersTeamsClient(c config) *UsersTeamsClient {
	return &UsersTeamsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usersteams.Hooks(f(g(h())))`.
func (c *UsersTeamsClient) Use(hooks ...Hook) {
	c.hooks.UsersTeams = append(c.hooks.UsersTeams, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usersteams.Intercept(f(g(h())))`.
func (c *UsersTeamsClient) Intercept(interceptors ...Interceptor) {
	c.inters.UsersTeams = append(c.inters.UsersTeams, interceptors...)
}

// Create returns a builder for creating a UsersTeams entity.
func (c *UsersTeamsClient) Create() *UsersTeamsCreate {
	mutation := newUsersTeamsMutation(c.config, OpCreate)
	return &UsersTeamsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UsersTeams entities.
func (c *UsersTeamsClient) CreateBulk(builders ...*UsersTeamsCreate) *UsersTeamsCreateBulk {
	return &UsersTeamsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UsersTeamsClient) MapCreateBulk(slice any, setFunc func(*UsersTeamsCreate, int)) *UsersTeamsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UsersTeamsCreateBulk{err: fmt.Errorf("calling to UsersTeamsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UsersTeamsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UsersTeamsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UsersTeams.
func (c *UsersTeamsClient) Update() *UsersTeamsUpdate {
	mutation := newUsersTeamsMutation(c.config, OpUpdate)
	return &UsersTeamsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UsersTeamsClient) UpdateOne(ut *UsersTeams) *UsersTeamsUpdateOne {
	mutation := newUsersTeamsMutation(c.config, OpUpdateOne, withUsersTeams(ut))
	return &UsersTeamsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UsersTeamsClient) UpdateOneID(id int) *UsersTeamsUpdateOne {
	mutation := newUsersTeamsMutation(c.config, OpUpdateOne, withUsersTeamsID(id))
	return &UsersTeamsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UsersTeams.
func (c *UsersTeamsClient) Delete() *UsersTeamsDelete {
	mutation := newUsersTeamsMutation(c.config, OpDelete)
	return &UsersTeamsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UsersTeamsClient) DeleteOne(ut *UsersTeams) *UsersTeamsDeleteOne {
	return c.DeleteOneID(ut.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UsersTeamsClient) DeleteOneID(id int) *UsersTeamsDeleteOne {
	builder := c.Delete().Where(usersteams.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UsersTeamsDeleteOne{builder}
}

// Query returns a query builder for UsersTeams.
func (c *UsersTeamsClient) Query() *UsersTeamsQuery {
	return &UsersTeamsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUsersTeams},
		inters: c.Interceptors(),
	}
}

// Get returns a UsersTeams entity by its id.
func (c *UsersTeamsClient) Get(ctx context.Context, id int) (*UsersTeams, error) {
	return c.Query().Where(usersteams.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UsersTeamsClient) GetX(ctx context.Context, id int) *UsersTeams {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a UsersTeams.
func (c *UsersTeamsClient) QueryUsers(ut *UsersTeams) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ut.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersteams.Table, usersteams.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, usersteams.UsersTable, usersteams.UsersColumn),
		)
		schemaConfig := ut.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.UsersTeams
		fromV = sqlgraph.Neighbors(ut.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeams queries the teams edge of a UsersTeams.
func (c *UsersTeamsClient) QueryTeams(ut *UsersTeams) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ut.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersteams.Table, usersteams.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, usersteams.TeamsTable, usersteams.TeamsColumn),
		)
		schemaConfig := ut.schemaConfig
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.UsersTeams
		fromV = sqlgraph.Neighbors(ut.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UsersTeamsClient) Hooks() []Hook {
	return c.hooks.UsersTeams
}

// Interceptors returns the client interceptors.
func (c *UsersTeamsClient) Interceptors() []Interceptor {
	return c.inters.UsersTeams
}

func (c *UsersTeamsClient) mutate(ctx context.Context, m *UsersTeamsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UsersTeamsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UsersTeamsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UsersTeamsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UsersTeamsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("models: unknown UsersTeams mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AccessToken, Env, EnvAlias, EnvBuild, Snapshot, Team, TeamAPIKey, Tier, User,
		UsersTeams []ent.Hook
	}
	inters struct {
		AccessToken, Env, EnvAlias, EnvBuild, Snapshot, Team, TeamAPIKey, Tier, User,
		UsersTeams []ent.Interceptor
	}
)

var (
	// DefaultSchemaConfig represents the default schema names for all tables as defined in ent/schema.
	DefaultSchemaConfig = SchemaConfig{
		AccessToken: tableSchemas[1],
		Env:         tableSchemas[1],
		EnvAlias:    tableSchemas[1],
		EnvBuild:    tableSchemas[1],
		Snapshot:    tableSchemas[1],
		Team:        tableSchemas[1],
		TeamAPIKey:  tableSchemas[1],
		Tier:        tableSchemas[1],
		User:        tableSchemas[0],
		UsersTeams:  tableSchemas[1],
	}
	tableSchemas = [...]string{"auth", "public"}
)

// SchemaConfig represents alternative schema names for all tables
// that can be passed at runtime.
type SchemaConfig = internal.SchemaConfig

// AlternateSchemas allows alternate schema names to be
// passed into ent operations.
func AlternateSchema(schemaConfig SchemaConfig) Option {
	return func(c *config) {
		c.schemaConfig = schemaConfig
	}
}



================================================
File: models/ent.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"
	"reflect"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/accesstoken"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envalias"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envbuild"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/snapshot"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/teamapikey"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/tier"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"
)

// ent aliases to avoid import conflicts in user's code.
type (
	Op            = ent.Op
	Hook          = ent.Hook
	Value         = ent.Value
	Query         = ent.Query
	QueryContext  = ent.QueryContext
	Querier       = ent.Querier
	QuerierFunc   = ent.QuerierFunc
	Interceptor   = ent.Interceptor
	InterceptFunc = ent.InterceptFunc
	Traverser     = ent.Traverser
	TraverseFunc  = ent.TraverseFunc
	Policy        = ent.Policy
	Mutator       = ent.Mutator
	Mutation      = ent.Mutation
	MutateFunc    = ent.MutateFunc
)

type clientCtxKey struct{}

// FromContext returns a Client stored inside a context, or nil if there isn't one.
func FromContext(ctx context.Context) *Client {
	c, _ := ctx.Value(clientCtxKey{}).(*Client)
	return c
}

// NewContext returns a new context with the given Client attached.
func NewContext(parent context.Context, c *Client) context.Context {
	return context.WithValue(parent, clientCtxKey{}, c)
}

type txCtxKey struct{}

// TxFromContext returns a Tx stored inside a context, or nil if there isn't one.
func TxFromContext(ctx context.Context) *Tx {
	tx, _ := ctx.Value(txCtxKey{}).(*Tx)
	return tx
}

// NewTxContext returns a new context with the given Tx attached.
func NewTxContext(parent context.Context, tx *Tx) context.Context {
	return context.WithValue(parent, txCtxKey{}, tx)
}

// OrderFunc applies an ordering on the sql selector.
// Deprecated: Use Asc/Desc functions or the package builders instead.
type OrderFunc func(*sql.Selector)

var (
	initCheck   sync.Once
	columnCheck sql.ColumnCheck
)

// columnChecker checks if the column exists in the given table.
func checkColumn(table, column string) error {
	initCheck.Do(func() {
		columnCheck = sql.NewColumnCheck(map[string]func(string) bool{
			accesstoken.Table: accesstoken.ValidColumn,
			env.Table:         env.ValidColumn,
			envalias.Table:    envalias.ValidColumn,
			envbuild.Table:    envbuild.ValidColumn,
			snapshot.Table:    snapshot.ValidColumn,
			team.Table:        team.ValidColumn,
			teamapikey.Table:  teamapikey.ValidColumn,
			tier.Table:        tier.ValidColumn,
			user.Table:        user.ValidColumn,
			usersteams.Table:  usersteams.ValidColumn,
		})
	})
	return columnCheck(table, column)
}

// Asc applies the given fields in ASC order.
func Asc(fields ...string) func(*sql.Selector) {
	return func(s *sql.Selector) {
		for _, f := range fields {
			if err := checkColumn(s.TableName(), f); err != nil {
				s.AddError(&ValidationError{Name: f, err: fmt.Errorf("models: %w", err)})
			}
			s.OrderBy(sql.Asc(s.C(f)))
		}
	}
}

// Desc applies the given fields in DESC order.
func Desc(fields ...string) func(*sql.Selector) {
	return func(s *sql.Selector) {
		for _, f := range fields {
			if err := checkColumn(s.TableName(), f); err != nil {
				s.AddError(&ValidationError{Name: f, err: fmt.Errorf("models: %w", err)})
			}
			s.OrderBy(sql.Desc(s.C(f)))
		}
	}
}

// AggregateFunc applies an aggregation step on the group-by traversal/selector.
type AggregateFunc func(*sql.Selector) string

// As is a pseudo aggregation function for renaming another other functions with custom names. For example:
//
//	GroupBy(field1, field2).
//	Aggregate(models.As(models.Sum(field1), "sum_field1"), (models.As(models.Sum(field2), "sum_field2")).
//	Scan(ctx, &v)
func As(fn AggregateFunc, end string) AggregateFunc {
	return func(s *sql.Selector) string {
		return sql.As(fn(s), end)
	}
}

// Count applies the "count" aggregation function on each group.
func Count() AggregateFunc {
	return func(s *sql.Selector) string {
		return sql.Count("*")
	}
}

// Max applies the "max" aggregation function on the given field of each group.
func Max(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		if err := checkColumn(s.TableName(), field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("models: %w", err)})
			return ""
		}
		return sql.Max(s.C(field))
	}
}

// Mean applies the "mean" aggregation function on the given field of each group.
func Mean(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		if err := checkColumn(s.TableName(), field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("models: %w", err)})
			return ""
		}
		return sql.Avg(s.C(field))
	}
}

// Min applies the "min" aggregation function on the given field of each group.
func Min(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		if err := checkColumn(s.TableName(), field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("models: %w", err)})
			return ""
		}
		return sql.Min(s.C(field))
	}
}

// Sum applies the "sum" aggregation function on the given field of each group.
func Sum(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		if err := checkColumn(s.TableName(), field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("models: %w", err)})
			return ""
		}
		return sql.Sum(s.C(field))
	}
}

// ValidationError returns when validating a field or edge fails.
type ValidationError struct {
	Name string // Field or edge name.
	err  error
}

// Error implements the error interface.
func (e *ValidationError) Error() string {
	return e.err.Error()
}

// Unwrap implements the errors.Wrapper interface.
func (e *ValidationError) Unwrap() error {
	return e.err
}

// IsValidationError returns a boolean indicating whether the error is a validation error.
func IsValidationError(err error) bool {
	if err == nil {
		return false
	}
	var e *ValidationError
	return errors.As(err, &e)
}

// NotFoundError returns when trying to fetch a specific entity and it was not found in the database.
type NotFoundError struct {
	label string
}

// Error implements the error interface.
func (e *NotFoundError) Error() string {
	return "models: " + e.label + " not found"
}

// IsNotFound returns a boolean indicating whether the error is a not found error.
func IsNotFound(err error) bool {
	if err == nil {
		return false
	}
	var e *NotFoundError
	return errors.As(err, &e)
}

// MaskNotFound masks not found error.
func MaskNotFound(err error) error {
	if IsNotFound(err) {
		return nil
	}
	return err
}

// NotSingularError returns when trying to fetch a singular entity and more then one was found in the database.
type NotSingularError struct {
	label string
}

// Error implements the error interface.
func (e *NotSingularError) Error() string {
	return "models: " + e.label + " not singular"
}

// IsNotSingular returns a boolean indicating whether the error is a not singular error.
func IsNotSingular(err error) bool {
	if err == nil {
		return false
	}
	var e *NotSingularError
	return errors.As(err, &e)
}

// NotLoadedError returns when trying to get a node that was not loaded by the query.
type NotLoadedError struct {
	edge string
}

// Error implements the error interface.
func (e *NotLoadedError) Error() string {
	return "models: " + e.edge + " edge was not loaded"
}

// IsNotLoaded returns a boolean indicating whether the error is a not loaded error.
func IsNotLoaded(err error) bool {
	if err == nil {
		return false
	}
	var e *NotLoadedError
	return errors.As(err, &e)
}

// ConstraintError returns when trying to create/update one or more entities and
// one or more of their constraints failed. For example, violation of edge or
// field uniqueness.
type ConstraintError struct {
	msg  string
	wrap error
}

// Error implements the error interface.
func (e ConstraintError) Error() string {
	return "models: constraint failed: " + e.msg
}

// Unwrap implements the errors.Wrapper interface.
func (e *ConstraintError) Unwrap() error {
	return e.wrap
}

// IsConstraintError returns a boolean indicating whether the error is a constraint failure.
func IsConstraintError(err error) bool {
	if err == nil {
		return false
	}
	var e *ConstraintError
	return errors.As(err, &e)
}

// selector embedded by the different Select/GroupBy builders.
type selector struct {
	label string
	flds  *[]string
	fns   []AggregateFunc
	scan  func(context.Context, any) error
}

// ScanX is like Scan, but panics if an error occurs.
func (s *selector) ScanX(ctx context.Context, v any) {
	if err := s.scan(ctx, v); err != nil {
		panic(err)
	}
}

// Strings returns list of strings from a selector. It is only allowed when selecting one field.
func (s *selector) Strings(ctx context.Context) ([]string, error) {
	if len(*s.flds) > 1 {
		return nil, errors.New("models: Strings is not achievable when selecting more than 1 field")
	}
	var v []string
	if err := s.scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// StringsX is like Strings, but panics if an error occurs.
func (s *selector) StringsX(ctx context.Context) []string {
	v, err := s.Strings(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// String returns a single string from a selector. It is only allowed when selecting one field.
func (s *selector) String(ctx context.Context) (_ string, err error) {
	var v []string
	if v, err = s.Strings(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{s.label}
	default:
		err = fmt.Errorf("models: Strings returned %d results when one was expected", len(v))
	}
	return
}

// StringX is like String, but panics if an error occurs.
func (s *selector) StringX(ctx context.Context) string {
	v, err := s.String(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Ints returns list of ints from a selector. It is only allowed when selecting one field.
func (s *selector) Ints(ctx context.Context) ([]int, error) {
	if len(*s.flds) > 1 {
		return nil, errors.New("models: Ints is not achievable when selecting more than 1 field")
	}
	var v []int
	if err := s.scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// IntsX is like Ints, but panics if an error occurs.
func (s *selector) IntsX(ctx context.Context) []int {
	v, err := s.Ints(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Int returns a single int from a selector. It is only allowed when selecting one field.
func (s *selector) Int(ctx context.Context) (_ int, err error) {
	var v []int
	if v, err = s.Ints(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{s.label}
	default:
		err = fmt.Errorf("models: Ints returned %d results when one was expected", len(v))
	}
	return
}

// IntX is like Int, but panics if an error occurs.
func (s *selector) IntX(ctx context.Context) int {
	v, err := s.Int(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64s returns list of float64s from a selector. It is only allowed when selecting one field.
func (s *selector) Float64s(ctx context.Context) ([]float64, error) {
	if len(*s.flds) > 1 {
		return nil, errors.New("models: Float64s is not achievable when selecting more than 1 field")
	}
	var v []float64
	if err := s.scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// Float64sX is like Float64s, but panics if an error occurs.
func (s *selector) Float64sX(ctx context.Context) []float64 {
	v, err := s.Float64s(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64 returns a single float64 from a selector. It is only allowed when selecting one field.
func (s *selector) Float64(ctx context.Context) (_ float64, err error) {
	var v []float64
	if v, err = s.Float64s(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{s.label}
	default:
		err = fmt.Errorf("models: Float64s returned %d results when one was expected", len(v))
	}
	return
}

// Float64X is like Float64, but panics if an error occurs.
func (s *selector) Float64X(ctx context.Context) float64 {
	v, err := s.Float64(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bools returns list of bools from a selector. It is only allowed when selecting one field.
func (s *selector) Bools(ctx context.Context) ([]bool, error) {
	if len(*s.flds) > 1 {
		return nil, errors.New("models: Bools is not achievable when selecting more than 1 field")
	}
	var v []bool
	if err := s.scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// BoolsX is like Bools, but panics if an error occurs.
func (s *selector) BoolsX(ctx context.Context) []bool {
	v, err := s.Bools(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bool returns a single bool from a selector. It is only allowed when selecting one field.
func (s *selector) Bool(ctx context.Context) (_ bool, err error) {
	var v []bool
	if v, err = s.Bools(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{s.label}
	default:
		err = fmt.Errorf("models: Bools returned %d results when one was expected", len(v))
	}
	return
}

// BoolX is like Bool, but panics if an error occurs.
func (s *selector) BoolX(ctx context.Context) bool {
	v, err := s.Bool(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// withHooks invokes the builder operation with the given hooks, if any.
func withHooks[V Value, M any, PM interface {
	*M
	Mutation
}](ctx context.Context, exec func(context.Context) (V, error), mutation PM, hooks []Hook) (value V, err error) {
	if len(hooks) == 0 {
		return exec(ctx)
	}
	var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
		mutationT, ok := any(m).(PM)
		if !ok {
			return nil, fmt.Errorf("unexpected mutation type %T", m)
		}
		// Set the mutation to the builder.
		*mutation = *mutationT
		return exec(ctx)
	})
	for i := len(hooks) - 1; i >= 0; i-- {
		if hooks[i] == nil {
			return value, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
		}
		mut = hooks[i](mut)
	}
	v, err := mut.Mutate(ctx, mutation)
	if err != nil {
		return value, err
	}
	nv, ok := v.(V)
	if !ok {
		return value, fmt.Errorf("unexpected node type %T returned from %T", v, mutation)
	}
	return nv, nil
}

// setContextOp returns a new context with the given QueryContext attached (including its op) in case it does not exist.
func setContextOp(ctx context.Context, qc *QueryContext, op string) context.Context {
	if ent.QueryFromContext(ctx) == nil {
		qc.Op = op
		ctx = ent.NewQueryContext(ctx, qc)
	}
	return ctx
}

func querierAll[V Value, Q interface {
	sqlAll(context.Context, ...queryHook) (V, error)
}]() Querier {
	return QuerierFunc(func(ctx context.Context, q Query) (Value, error) {
		query, ok := q.(Q)
		if !ok {
			return nil, fmt.Errorf("unexpected query type %T", q)
		}
		return query.sqlAll(ctx)
	})
}

func querierCount[Q interface {
	sqlCount(context.Context) (int, error)
}]() Querier {
	return QuerierFunc(func(ctx context.Context, q Query) (Value, error) {
		query, ok := q.(Q)
		if !ok {
			return nil, fmt.Errorf("unexpected query type %T", q)
		}
		return query.sqlCount(ctx)
	})
}

func withInterceptors[V Value](ctx context.Context, q Query, qr Querier, inters []Interceptor) (v V, err error) {
	for i := len(inters) - 1; i >= 0; i-- {
		qr = inters[i].Intercept(qr)
	}
	rv, err := qr.Query(ctx, q)
	if err != nil {
		return v, err
	}
	vt, ok := rv.(V)
	if !ok {
		return v, fmt.Errorf("unexpected type %T returned from %T. expected type: %T", vt, q, v)
	}
	return vt, nil
}

func scanWithInterceptors[Q1 ent.Query, Q2 interface {
	sqlScan(context.Context, Q1, any) error
}](ctx context.Context, rootQuery Q1, selectOrGroup Q2, inters []Interceptor, v any) error {
	rv := reflect.ValueOf(v)
	var qr Querier = QuerierFunc(func(ctx context.Context, q Query) (Value, error) {
		query, ok := q.(Q1)
		if !ok {
			return nil, fmt.Errorf("unexpected query type %T", q)
		}
		if err := selectOrGroup.sqlScan(ctx, query, v); err != nil {
			return nil, err
		}
		if k := rv.Kind(); k == reflect.Pointer && rv.Elem().CanInterface() {
			return rv.Elem().Interface(), nil
		}
		return v, nil
	})
	for i := len(inters) - 1; i >= 0; i-- {
		qr = inters[i].Intercept(qr)
	}
	vv, err := qr.Query(ctx, rootQuery)
	if err != nil {
		return err
	}
	switch rv2 := reflect.ValueOf(vv); {
	case rv.IsNil(), rv2.IsNil(), rv.Kind() != reflect.Pointer:
	case rv.Type() == rv2.Type():
		rv.Elem().Set(rv2.Elem())
	case rv.Elem().Type() == rv2.Type():
		rv.Elem().Set(rv2)
	}
	return nil
}

// queryHook describes an internal hook for the different sqlAll methods.
type queryHook func(context.Context, *sqlgraph.QuerySpec)



================================================
File: models/env.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/google/uuid"
)

// Env is the model entity for the Env schema.
type Env struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// TeamID holds the value of the "team_id" field.
	TeamID uuid.UUID `json:"team_id,omitempty"`
	// CreatedBy holds the value of the "created_by" field.
	CreatedBy *uuid.UUID `json:"created_by,omitempty"`
	// Public holds the value of the "public" field.
	Public bool `json:"public,omitempty"`
	// BuildCount holds the value of the "build_count" field.
	BuildCount int32 `json:"build_count,omitempty"`
	// Number of times the env was spawned
	SpawnCount int64 `json:"spawn_count,omitempty"`
	// Timestamp of the last time the env was spawned
	LastSpawnedAt time.Time `json:"last_spawned_at,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the EnvQuery when eager-loading is set.
	Edges        EnvEdges `json:"edges"`
	selectValues sql.SelectValues
}

// EnvEdges holds the relations/edges for other nodes in the graph.
type EnvEdges struct {
	// Team holds the value of the team edge.
	Team *Team `json:"team,omitempty"`
	// Creator holds the value of the creator edge.
	Creator *User `json:"creator,omitempty"`
	// EnvAliases holds the value of the env_aliases edge.
	EnvAliases []*EnvAlias `json:"env_aliases,omitempty"`
	// Builds holds the value of the builds edge.
	Builds []*EnvBuild `json:"builds,omitempty"`
	// Snapshots holds the value of the snapshots edge.
	Snapshots []*Snapshot `json:"snapshots,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [5]bool
}

// TeamOrErr returns the Team value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e EnvEdges) TeamOrErr() (*Team, error) {
	if e.loadedTypes[0] {
		if e.Team == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: team.Label}
		}
		return e.Team, nil
	}
	return nil, &NotLoadedError{edge: "team"}
}

// CreatorOrErr returns the Creator value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e EnvEdges) CreatorOrErr() (*User, error) {
	if e.loadedTypes[1] {
		if e.Creator == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: user.Label}
		}
		return e.Creator, nil
	}
	return nil, &NotLoadedError{edge: "creator"}
}

// EnvAliasesOrErr returns the EnvAliases value or an error if the edge
// was not loaded in eager-loading.
func (e EnvEdges) EnvAliasesOrErr() ([]*EnvAlias, error) {
	if e.loadedTypes[2] {
		return e.EnvAliases, nil
	}
	return nil, &NotLoadedError{edge: "env_aliases"}
}

// BuildsOrErr returns the Builds value or an error if the edge
// was not loaded in eager-loading.
func (e EnvEdges) BuildsOrErr() ([]*EnvBuild, error) {
	if e.loadedTypes[3] {
		return e.Builds, nil
	}
	return nil, &NotLoadedError{edge: "builds"}
}

// SnapshotsOrErr returns the Snapshots value or an error if the edge
// was not loaded in eager-loading.
func (e EnvEdges) SnapshotsOrErr() ([]*Snapshot, error) {
	if e.loadedTypes[4] {
		return e.Snapshots, nil
	}
	return nil, &NotLoadedError{edge: "snapshots"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Env) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case env.FieldCreatedBy:
			values[i] = &sql.NullScanner{S: new(uuid.UUID)}
		case env.FieldPublic:
			values[i] = new(sql.NullBool)
		case env.FieldBuildCount, env.FieldSpawnCount:
			values[i] = new(sql.NullInt64)
		case env.FieldID:
			values[i] = new(sql.NullString)
		case env.FieldCreatedAt, env.FieldUpdatedAt, env.FieldLastSpawnedAt:
			values[i] = new(sql.NullTime)
		case env.FieldTeamID:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Env fields.
func (e *Env) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case env.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				e.ID = value.String
			}
		case env.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				e.CreatedAt = value.Time
			}
		case env.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				e.UpdatedAt = value.Time
			}
		case env.FieldTeamID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field team_id", values[i])
			} else if value != nil {
				e.TeamID = *value
			}
		case env.FieldCreatedBy:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field created_by", values[i])
			} else if value.Valid {
				e.CreatedBy = new(uuid.UUID)
				*e.CreatedBy = *value.S.(*uuid.UUID)
			}
		case env.FieldPublic:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field public", values[i])
			} else if value.Valid {
				e.Public = value.Bool
			}
		case env.FieldBuildCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field build_count", values[i])
			} else if value.Valid {
				e.BuildCount = int32(value.Int64)
			}
		case env.FieldSpawnCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field spawn_count", values[i])
			} else if value.Valid {
				e.SpawnCount = value.Int64
			}
		case env.FieldLastSpawnedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field last_spawned_at", values[i])
			} else if value.Valid {
				e.LastSpawnedAt = value.Time
			}
		default:
			e.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Env.
// This includes values selected through modifiers, order, etc.
func (e *Env) Value(name string) (ent.Value, error) {
	return e.selectValues.Get(name)
}

// QueryTeam queries the "team" edge of the Env entity.
func (e *Env) QueryTeam() *TeamQuery {
	return NewEnvClient(e.config).QueryTeam(e)
}

// QueryCreator queries the "creator" edge of the Env entity.
func (e *Env) QueryCreator() *UserQuery {
	return NewEnvClient(e.config).QueryCreator(e)
}

// QueryEnvAliases queries the "env_aliases" edge of the Env entity.
func (e *Env) QueryEnvAliases() *EnvAliasQuery {
	return NewEnvClient(e.config).QueryEnvAliases(e)
}

// QueryBuilds queries the "builds" edge of the Env entity.
func (e *Env) QueryBuilds() *EnvBuildQuery {
	return NewEnvClient(e.config).QueryBuilds(e)
}

// QuerySnapshots queries the "snapshots" edge of the Env entity.
func (e *Env) QuerySnapshots() *SnapshotQuery {
	return NewEnvClient(e.config).QuerySnapshots(e)
}

// Update returns a builder for updating this Env.
// Note that you need to call Env.Unwrap() before calling this method if this Env
// was returned from a transaction, and the transaction was committed or rolled back.
func (e *Env) Update() *EnvUpdateOne {
	return NewEnvClient(e.config).UpdateOne(e)
}

// Unwrap unwraps the Env entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (e *Env) Unwrap() *Env {
	_tx, ok := e.config.driver.(*txDriver)
	if !ok {
		panic("models: Env is not a transactional entity")
	}
	e.config.driver = _tx.drv
	return e
}

// String implements the fmt.Stringer.
func (e *Env) String() string {
	var builder strings.Builder
	builder.WriteString("Env(")
	builder.WriteString(fmt.Sprintf("id=%v, ", e.ID))
	builder.WriteString("created_at=")
	builder.WriteString(e.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(e.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("team_id=")
	builder.WriteString(fmt.Sprintf("%v", e.TeamID))
	builder.WriteString(", ")
	if v := e.CreatedBy; v != nil {
		builder.WriteString("created_by=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("public=")
	builder.WriteString(fmt.Sprintf("%v", e.Public))
	builder.WriteString(", ")
	builder.WriteString("build_count=")
	builder.WriteString(fmt.Sprintf("%v", e.BuildCount))
	builder.WriteString(", ")
	builder.WriteString("spawn_count=")
	builder.WriteString(fmt.Sprintf("%v", e.SpawnCount))
	builder.WriteString(", ")
	builder.WriteString("last_spawned_at=")
	builder.WriteString(e.LastSpawnedAt.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// Envs is a parsable slice of Env.
type Envs []*Env



================================================
File: models/env_create.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envalias"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envbuild"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/snapshot"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/google/uuid"
)

// EnvCreate is the builder for creating a Env entity.
type EnvCreate struct {
	config
	mutation *EnvMutation
	hooks    []Hook
	conflict []sql.ConflictOption
}

// SetCreatedAt sets the "created_at" field.
func (ec *EnvCreate) SetCreatedAt(t time.Time) *EnvCreate {
	ec.mutation.SetCreatedAt(t)
	return ec
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (ec *EnvCreate) SetNillableCreatedAt(t *time.Time) *EnvCreate {
	if t != nil {
		ec.SetCreatedAt(*t)
	}
	return ec
}

// SetUpdatedAt sets the "updated_at" field.
func (ec *EnvCreate) SetUpdatedAt(t time.Time) *EnvCreate {
	ec.mutation.SetUpdatedAt(t)
	return ec
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (ec *EnvCreate) SetNillableUpdatedAt(t *time.Time) *EnvCreate {
	if t != nil {
		ec.SetUpdatedAt(*t)
	}
	return ec
}

// SetTeamID sets the "team_id" field.
func (ec *EnvCreate) SetTeamID(u uuid.UUID) *EnvCreate {
	ec.mutation.SetTeamID(u)
	return ec
}

// SetCreatedBy sets the "created_by" field.
func (ec *EnvCreate) SetCreatedBy(u uuid.UUID) *EnvCreate {
	ec.mutation.SetCreatedBy(u)
	return ec
}

// SetNillableCreatedBy sets the "created_by" field if the given value is not nil.
func (ec *EnvCreate) SetNillableCreatedBy(u *uuid.UUID) *EnvCreate {
	if u != nil {
		ec.SetCreatedBy(*u)
	}
	return ec
}

// SetPublic sets the "public" field.
func (ec *EnvCreate) SetPublic(b bool) *EnvCreate {
	ec.mutation.SetPublic(b)
	return ec
}

// SetBuildCount sets the "build_count" field.
func (ec *EnvCreate) SetBuildCount(i int32) *EnvCreate {
	ec.mutation.SetBuildCount(i)
	return ec
}

// SetNillableBuildCount sets the "build_count" field if the given value is not nil.
func (ec *EnvCreate) SetNillableBuildCount(i *int32) *EnvCreate {
	if i != nil {
		ec.SetBuildCount(*i)
	}
	return ec
}

// SetSpawnCount sets the "spawn_count" field.
func (ec *EnvCreate) SetSpawnCount(i int64) *EnvCreate {
	ec.mutation.SetSpawnCount(i)
	return ec
}

// SetNillableSpawnCount sets the "spawn_count" field if the given value is not nil.
func (ec *EnvCreate) SetNillableSpawnCount(i *int64) *EnvCreate {
	if i != nil {
		ec.SetSpawnCount(*i)
	}
	return ec
}

// SetLastSpawnedAt sets the "last_spawned_at" field.
func (ec *EnvCreate) SetLastSpawnedAt(t time.Time) *EnvCreate {
	ec.mutation.SetLastSpawnedAt(t)
	return ec
}

// SetNillableLastSpawnedAt sets the "last_spawned_at" field if the given value is not nil.
func (ec *EnvCreate) SetNillableLastSpawnedAt(t *time.Time) *EnvCreate {
	if t != nil {
		ec.SetLastSpawnedAt(*t)
	}
	return ec
}

// SetID sets the "id" field.
func (ec *EnvCreate) SetID(s string) *EnvCreate {
	ec.mutation.SetID(s)
	return ec
}

// SetTeam sets the "team" edge to the Team entity.
func (ec *EnvCreate) SetTeam(t *Team) *EnvCreate {
	return ec.SetTeamID(t.ID)
}

// SetCreatorID sets the "creator" edge to the User entity by ID.
func (ec *EnvCreate) SetCreatorID(id uuid.UUID) *EnvCreate {
	ec.mutation.SetCreatorID(id)
	return ec
}

// SetNillableCreatorID sets the "creator" edge to the User entity by ID if the given value is not nil.
func (ec *EnvCreate) SetNillableCreatorID(id *uuid.UUID) *EnvCreate {
	if id != nil {
		ec = ec.SetCreatorID(*id)
	}
	return ec
}

// SetCreator sets the "creator" edge to the User entity.
func (ec *EnvCreate) SetCreator(u *User) *EnvCreate {
	return ec.SetCreatorID(u.ID)
}

// AddEnvAliasIDs adds the "env_aliases" edge to the EnvAlias entity by IDs.
func (ec *EnvCreate) AddEnvAliasIDs(ids ...string) *EnvCreate {
	ec.mutation.AddEnvAliasIDs(ids...)
	return ec
}

// AddEnvAliases adds the "env_aliases" edges to the EnvAlias entity.
func (ec *EnvCreate) AddEnvAliases(e ...*EnvAlias) *EnvCreate {
	ids := make([]string, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return ec.AddEnvAliasIDs(ids...)
}

// AddBuildIDs adds the "builds" edge to the EnvBuild entity by IDs.
func (ec *EnvCreate) AddBuildIDs(ids ...uuid.UUID) *EnvCreate {
	ec.mutation.AddBuildIDs(ids...)
	return ec
}

// AddBuilds adds the "builds" edges to the EnvBuild entity.
func (ec *EnvCreate) AddBuilds(e ...*EnvBuild) *EnvCreate {
	ids := make([]uuid.UUID, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return ec.AddBuildIDs(ids...)
}

// AddSnapshotIDs adds the "snapshots" edge to the Snapshot entity by IDs.
func (ec *EnvCreate) AddSnapshotIDs(ids ...uuid.UUID) *EnvCreate {
	ec.mutation.AddSnapshotIDs(ids...)
	return ec
}

// AddSnapshots adds the "snapshots" edges to the Snapshot entity.
func (ec *EnvCreate) AddSnapshots(s ...*Snapshot) *EnvCreate {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return ec.AddSnapshotIDs(ids...)
}

// Mutation returns the EnvMutation object of the builder.
func (ec *EnvCreate) Mutation() *EnvMutation {
	return ec.mutation
}

// Save creates the Env in the database.
func (ec *EnvCreate) Save(ctx context.Context) (*Env, error) {
	ec.defaults()
	return withHooks(ctx, ec.sqlSave, ec.mutation, ec.hooks)
}

// SaveX calls Save and panics if Save returns an error.
func (ec *EnvCreate) SaveX(ctx context.Context) *Env {
	v, err := ec.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (ec *EnvCreate) Exec(ctx context.Context) error {
	_, err := ec.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ec *EnvCreate) ExecX(ctx context.Context) {
	if err := ec.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (ec *EnvCreate) defaults() {
	if _, ok := ec.mutation.CreatedAt(); !ok {
		v := env.DefaultCreatedAt()
		ec.mutation.SetCreatedAt(v)
	}
	if _, ok := ec.mutation.UpdatedAt(); !ok {
		v := env.DefaultUpdatedAt()
		ec.mutation.SetUpdatedAt(v)
	}
	if _, ok := ec.mutation.BuildCount(); !ok {
		v := env.DefaultBuildCount
		ec.mutation.SetBuildCount(v)
	}
	if _, ok := ec.mutation.SpawnCount(); !ok {
		v := env.DefaultSpawnCount
		ec.mutation.SetSpawnCount(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (ec *EnvCreate) check() error {
	if _, ok := ec.mutation.CreatedAt(); !ok {
		return &ValidationError{Name: "created_at", err: errors.New(`models: missing required field "Env.created_at"`)}
	}
	if _, ok := ec.mutation.UpdatedAt(); !ok {
		return &ValidationError{Name: "updated_at", err: errors.New(`models: missing required field "Env.updated_at"`)}
	}
	if _, ok := ec.mutation.TeamID(); !ok {
		return &ValidationError{Name: "team_id", err: errors.New(`models: missing required field "Env.team_id"`)}
	}
	if _, ok := ec.mutation.Public(); !ok {
		return &ValidationError{Name: "public", err: errors.New(`models: missing required field "Env.public"`)}
	}
	if _, ok := ec.mutation.BuildCount(); !ok {
		return &ValidationError{Name: "build_count", err: errors.New(`models: missing required field "Env.build_count"`)}
	}
	if _, ok := ec.mutation.SpawnCount(); !ok {
		return &ValidationError{Name: "spawn_count", err: errors.New(`models: missing required field "Env.spawn_count"`)}
	}
	if _, ok := ec.mutation.TeamID(); !ok {
		return &ValidationError{Name: "team", err: errors.New(`models: missing required edge "Env.team"`)}
	}
	return nil
}

func (ec *EnvCreate) sqlSave(ctx context.Context) (*Env, error) {
	if err := ec.check(); err != nil {
		return nil, err
	}
	_node, _spec := ec.createSpec()
	if err := sqlgraph.CreateNode(ctx, ec.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	if _spec.ID.Value != nil {
		if id, ok := _spec.ID.Value.(string); ok {
			_node.ID = id
		} else {
			return nil, fmt.Errorf("unexpected Env.ID type: %T", _spec.ID.Value)
		}
	}
	ec.mutation.id = &_node.ID
	ec.mutation.done = true
	return _node, nil
}

func (ec *EnvCreate) createSpec() (*Env, *sqlgraph.CreateSpec) {
	var (
		_node = &Env{config: ec.config}
		_spec = sqlgraph.NewCreateSpec(env.Table, sqlgraph.NewFieldSpec(env.FieldID, field.TypeString))
	)
	_spec.Schema = ec.schemaConfig.Env
	_spec.OnConflict = ec.conflict
	if id, ok := ec.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = id
	}
	if value, ok := ec.mutation.CreatedAt(); ok {
		_spec.SetField(env.FieldCreatedAt, field.TypeTime, value)
		_node.CreatedAt = value
	}
	if value, ok := ec.mutation.UpdatedAt(); ok {
		_spec.SetField(env.FieldUpdatedAt, field.TypeTime, value)
		_node.UpdatedAt = value
	}
	if value, ok := ec.mutation.Public(); ok {
		_spec.SetField(env.FieldPublic, field.TypeBool, value)
		_node.Public = value
	}
	if value, ok := ec.mutation.BuildCount(); ok {
		_spec.SetField(env.FieldBuildCount, field.TypeInt32, value)
		_node.BuildCount = value
	}
	if value, ok := ec.mutation.SpawnCount(); ok {
		_spec.SetField(env.FieldSpawnCount, field.TypeInt64, value)
		_node.SpawnCount = value
	}
	if value, ok := ec.mutation.LastSpawnedAt(); ok {
		_spec.SetField(env.FieldLastSpawnedAt, field.TypeTime, value)
		_node.LastSpawnedAt = value
	}
	if nodes := ec.mutation.TeamIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   env.TeamTable,
			Columns: []string{env.TeamColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = ec.schemaConfig.Env
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.TeamID = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := ec.mutation.CreatorIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   env.CreatorTable,
			Columns: []string{env.CreatorColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = ec.schemaConfig.Env
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.CreatedBy = &nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := ec.mutation.EnvAliasesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.EnvAliasesTable,
			Columns: []string{env.EnvAliasesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(envalias.FieldID, field.TypeString),
			},
		}
		edge.Schema = ec.schemaConfig.EnvAlias
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := ec.mutation.BuildsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.BuildsTable,
			Columns: []string{env.BuildsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(envbuild.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = ec.schemaConfig.EnvBuild
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := ec.mutation.SnapshotsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.SnapshotsTable,
			Columns: []string{env.SnapshotsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(snapshot.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = ec.schemaConfig.Snapshot
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.Env.Create().
//		SetCreatedAt(v).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.EnvUpsert) {
//			SetCreatedAt(v+v).
//		}).
//		Exec(ctx)
func (ec *EnvCreate) OnConflict(opts ...sql.ConflictOption) *EnvUpsertOne {
	ec.conflict = opts
	return &EnvUpsertOne{
		create: ec,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.Env.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (ec *EnvCreate) OnConflictColumns(columns ...string) *EnvUpsertOne {
	ec.conflict = append(ec.conflict, sql.ConflictColumns(columns...))
	return &EnvUpsertOne{
		create: ec,
	}
}

type (
	// EnvUpsertOne is the builder for "upsert"-ing
	//  one Env node.
	EnvUpsertOne struct {
		create *EnvCreate
	}

	// EnvUpsert is the "OnConflict" setter.
	EnvUpsert struct {
		*sql.UpdateSet
	}
)

// SetUpdatedAt sets the "updated_at" field.
func (u *EnvUpsert) SetUpdatedAt(v time.Time) *EnvUpsert {
	u.Set(env.FieldUpdatedAt, v)
	return u
}

// UpdateUpdatedAt sets the "updated_at" field to the value that was provided on create.
func (u *EnvUpsert) UpdateUpdatedAt() *EnvUpsert {
	u.SetExcluded(env.FieldUpdatedAt)
	return u
}

// SetTeamID sets the "team_id" field.
func (u *EnvUpsert) SetTeamID(v uuid.UUID) *EnvUpsert {
	u.Set(env.FieldTeamID, v)
	return u
}

// UpdateTeamID sets the "team_id" field to the value that was provided on create.
func (u *EnvUpsert) UpdateTeamID() *EnvUpsert {
	u.SetExcluded(env.FieldTeamID)
	return u
}

// SetCreatedBy sets the "created_by" field.
func (u *EnvUpsert) SetCreatedBy(v uuid.UUID) *EnvUpsert {
	u.Set(env.FieldCreatedBy, v)
	return u
}

// UpdateCreatedBy sets the "created_by" field to the value that was provided on create.
func (u *EnvUpsert) UpdateCreatedBy() *EnvUpsert {
	u.SetExcluded(env.FieldCreatedBy)
	return u
}

// ClearCreatedBy clears the value of the "created_by" field.
func (u *EnvUpsert) ClearCreatedBy() *EnvUpsert {
	u.SetNull(env.FieldCreatedBy)
	return u
}

// SetPublic sets the "public" field.
func (u *EnvUpsert) SetPublic(v bool) *EnvUpsert {
	u.Set(env.FieldPublic, v)
	return u
}

// UpdatePublic sets the "public" field to the value that was provided on create.
func (u *EnvUpsert) UpdatePublic() *EnvUpsert {
	u.SetExcluded(env.FieldPublic)
	return u
}

// SetBuildCount sets the "build_count" field.
func (u *EnvUpsert) SetBuildCount(v int32) *EnvUpsert {
	u.Set(env.FieldBuildCount, v)
	return u
}

// UpdateBuildCount sets the "build_count" field to the value that was provided on create.
func (u *EnvUpsert) UpdateBuildCount() *EnvUpsert {
	u.SetExcluded(env.FieldBuildCount)
	return u
}

// AddBuildCount adds v to the "build_count" field.
func (u *EnvUpsert) AddBuildCount(v int32) *EnvUpsert {
	u.Add(env.FieldBuildCount, v)
	return u
}

// SetSpawnCount sets the "spawn_count" field.
func (u *EnvUpsert) SetSpawnCount(v int64) *EnvUpsert {
	u.Set(env.FieldSpawnCount, v)
	return u
}

// UpdateSpawnCount sets the "spawn_count" field to the value that was provided on create.
func (u *EnvUpsert) UpdateSpawnCount() *EnvUpsert {
	u.SetExcluded(env.FieldSpawnCount)
	return u
}

// AddSpawnCount adds v to the "spawn_count" field.
func (u *EnvUpsert) AddSpawnCount(v int64) *EnvUpsert {
	u.Add(env.FieldSpawnCount, v)
	return u
}

// SetLastSpawnedAt sets the "last_spawned_at" field.
func (u *EnvUpsert) SetLastSpawnedAt(v time.Time) *EnvUpsert {
	u.Set(env.FieldLastSpawnedAt, v)
	return u
}

// UpdateLastSpawnedAt sets the "last_spawned_at" field to the value that was provided on create.
func (u *EnvUpsert) UpdateLastSpawnedAt() *EnvUpsert {
	u.SetExcluded(env.FieldLastSpawnedAt)
	return u
}

// ClearLastSpawnedAt clears the value of the "last_spawned_at" field.
func (u *EnvUpsert) ClearLastSpawnedAt() *EnvUpsert {
	u.SetNull(env.FieldLastSpawnedAt)
	return u
}

// UpdateNewValues updates the mutable fields using the new values that were set on create except the ID field.
// Using this option is equivalent to using:
//
//	client.Env.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(env.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *EnvUpsertOne) UpdateNewValues() *EnvUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		if _, exists := u.create.mutation.ID(); exists {
			s.SetIgnore(env.FieldID)
		}
		if _, exists := u.create.mutation.CreatedAt(); exists {
			s.SetIgnore(env.FieldCreatedAt)
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.Env.Create().
//	    OnConflict(sql.ResolveWithIgnore()).
//	    Exec(ctx)
func (u *EnvUpsertOne) Ignore() *EnvUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *EnvUpsertOne) DoNothing() *EnvUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the EnvCreate.OnConflict
// documentation for more info.
func (u *EnvUpsertOne) Update(set func(*EnvUpsert)) *EnvUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&EnvUpsert{UpdateSet: update})
	}))
	return u
}

// SetUpdatedAt sets the "updated_at" field.
func (u *EnvUpsertOne) SetUpdatedAt(v time.Time) *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.SetUpdatedAt(v)
	})
}

// UpdateUpdatedAt sets the "updated_at" field to the value that was provided on create.
func (u *EnvUpsertOne) UpdateUpdatedAt() *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.UpdateUpdatedAt()
	})
}

// SetTeamID sets the "team_id" field.
func (u *EnvUpsertOne) SetTeamID(v uuid.UUID) *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.SetTeamID(v)
	})
}

// UpdateTeamID sets the "team_id" field to the value that was provided on create.
func (u *EnvUpsertOne) UpdateTeamID() *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.UpdateTeamID()
	})
}

// SetCreatedBy sets the "created_by" field.
func (u *EnvUpsertOne) SetCreatedBy(v uuid.UUID) *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.SetCreatedBy(v)
	})
}

// UpdateCreatedBy sets the "created_by" field to the value that was provided on create.
func (u *EnvUpsertOne) UpdateCreatedBy() *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.UpdateCreatedBy()
	})
}

// ClearCreatedBy clears the value of the "created_by" field.
func (u *EnvUpsertOne) ClearCreatedBy() *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.ClearCreatedBy()
	})
}

// SetPublic sets the "public" field.
func (u *EnvUpsertOne) SetPublic(v bool) *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.SetPublic(v)
	})
}

// UpdatePublic sets the "public" field to the value that was provided on create.
func (u *EnvUpsertOne) UpdatePublic() *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.UpdatePublic()
	})
}

// SetBuildCount sets the "build_count" field.
func (u *EnvUpsertOne) SetBuildCount(v int32) *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.SetBuildCount(v)
	})
}

// AddBuildCount adds v to the "build_count" field.
func (u *EnvUpsertOne) AddBuildCount(v int32) *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.AddBuildCount(v)
	})
}

// UpdateBuildCount sets the "build_count" field to the value that was provided on create.
func (u *EnvUpsertOne) UpdateBuildCount() *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.UpdateBuildCount()
	})
}

// SetSpawnCount sets the "spawn_count" field.
func (u *EnvUpsertOne) SetSpawnCount(v int64) *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.SetSpawnCount(v)
	})
}

// AddSpawnCount adds v to the "spawn_count" field.
func (u *EnvUpsertOne) AddSpawnCount(v int64) *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.AddSpawnCount(v)
	})
}

// UpdateSpawnCount sets the "spawn_count" field to the value that was provided on create.
func (u *EnvUpsertOne) UpdateSpawnCount() *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.UpdateSpawnCount()
	})
}

// SetLastSpawnedAt sets the "last_spawned_at" field.
func (u *EnvUpsertOne) SetLastSpawnedAt(v time.Time) *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.SetLastSpawnedAt(v)
	})
}

// UpdateLastSpawnedAt sets the "last_spawned_at" field to the value that was provided on create.
func (u *EnvUpsertOne) UpdateLastSpawnedAt() *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.UpdateLastSpawnedAt()
	})
}

// ClearLastSpawnedAt clears the value of the "last_spawned_at" field.
func (u *EnvUpsertOne) ClearLastSpawnedAt() *EnvUpsertOne {
	return u.Update(func(s *EnvUpsert) {
		s.ClearLastSpawnedAt()
	})
}

// Exec executes the query.
func (u *EnvUpsertOne) Exec(ctx context.Context) error {
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for EnvCreate.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *EnvUpsertOne) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}

// Exec executes the UPSERT query and returns the inserted/updated ID.
func (u *EnvUpsertOne) ID(ctx context.Context) (id string, err error) {
	if u.create.driver.Dialect() == dialect.MySQL {
		// In case of "ON CONFLICT", there is no way to get back non-numeric ID
		// fields from the database since MySQL does not support the RETURNING clause.
		return id, errors.New("models: EnvUpsertOne.ID is not supported by MySQL driver. Use EnvUpsertOne.Exec instead")
	}
	node, err := u.create.Save(ctx)
	if err != nil {
		return id, err
	}
	return node.ID, nil
}

// IDX is like ID, but panics if an error occurs.
func (u *EnvUpsertOne) IDX(ctx context.Context) string {
	id, err := u.ID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// EnvCreateBulk is the builder for creating many Env entities in bulk.
type EnvCreateBulk struct {
	config
	err      error
	builders []*EnvCreate
	conflict []sql.ConflictOption
}

// Save creates the Env entities in the database.
func (ecb *EnvCreateBulk) Save(ctx context.Context) ([]*Env, error) {
	if ecb.err != nil {
		return nil, ecb.err
	}
	specs := make([]*sqlgraph.CreateSpec, len(ecb.builders))
	nodes := make([]*Env, len(ecb.builders))
	mutators := make([]Mutator, len(ecb.builders))
	for i := range ecb.builders {
		func(i int, root context.Context) {
			builder := ecb.builders[i]
			builder.defaults()
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*EnvMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				var err error
				nodes[i], specs[i] = builder.createSpec()
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, ecb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					spec.OnConflict = ecb.conflict
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, ecb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{msg: err.Error(), wrap: err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, ecb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (ecb *EnvCreateBulk) SaveX(ctx context.Context) []*Env {
	v, err := ecb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (ecb *EnvCreateBulk) Exec(ctx context.Context) error {
	_, err := ecb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ecb *EnvCreateBulk) ExecX(ctx context.Context) {
	if err := ecb.Exec(ctx); err != nil {
		panic(err)
	}
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.Env.CreateBulk(builders...).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.EnvUpsert) {
//			SetCreatedAt(v+v).
//		}).
//		Exec(ctx)
func (ecb *EnvCreateBulk) OnConflict(opts ...sql.ConflictOption) *EnvUpsertBulk {
	ecb.conflict = opts
	return &EnvUpsertBulk{
		create: ecb,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.Env.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (ecb *EnvCreateBulk) OnConflictColumns(columns ...string) *EnvUpsertBulk {
	ecb.conflict = append(ecb.conflict, sql.ConflictColumns(columns...))
	return &EnvUpsertBulk{
		create: ecb,
	}
}

// EnvUpsertBulk is the builder for "upsert"-ing
// a bulk of Env nodes.
type EnvUpsertBulk struct {
	create *EnvCreateBulk
}

// UpdateNewValues updates the mutable fields using the new values that
// were set on create. Using this option is equivalent to using:
//
//	client.Env.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(env.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *EnvUpsertBulk) UpdateNewValues() *EnvUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		for _, b := range u.create.builders {
			if _, exists := b.mutation.ID(); exists {
				s.SetIgnore(env.FieldID)
			}
			if _, exists := b.mutation.CreatedAt(); exists {
				s.SetIgnore(env.FieldCreatedAt)
			}
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.Env.Create().
//		OnConflict(sql.ResolveWithIgnore()).
//		Exec(ctx)
func (u *EnvUpsertBulk) Ignore() *EnvUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *EnvUpsertBulk) DoNothing() *EnvUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the EnvCreateBulk.OnConflict
// documentation for more info.
func (u *EnvUpsertBulk) Update(set func(*EnvUpsert)) *EnvUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&EnvUpsert{UpdateSet: update})
	}))
	return u
}

// SetUpdatedAt sets the "updated_at" field.
func (u *EnvUpsertBulk) SetUpdatedAt(v time.Time) *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.SetUpdatedAt(v)
	})
}

// UpdateUpdatedAt sets the "updated_at" field to the value that was provided on create.
func (u *EnvUpsertBulk) UpdateUpdatedAt() *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.UpdateUpdatedAt()
	})
}

// SetTeamID sets the "team_id" field.
func (u *EnvUpsertBulk) SetTeamID(v uuid.UUID) *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.SetTeamID(v)
	})
}

// UpdateTeamID sets the "team_id" field to the value that was provided on create.
func (u *EnvUpsertBulk) UpdateTeamID() *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.UpdateTeamID()
	})
}

// SetCreatedBy sets the "created_by" field.
func (u *EnvUpsertBulk) SetCreatedBy(v uuid.UUID) *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.SetCreatedBy(v)
	})
}

// UpdateCreatedBy sets the "created_by" field to the value that was provided on create.
func (u *EnvUpsertBulk) UpdateCreatedBy() *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.UpdateCreatedBy()
	})
}

// ClearCreatedBy clears the value of the "created_by" field.
func (u *EnvUpsertBulk) ClearCreatedBy() *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.ClearCreatedBy()
	})
}

// SetPublic sets the "public" field.
func (u *EnvUpsertBulk) SetPublic(v bool) *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.SetPublic(v)
	})
}

// UpdatePublic sets the "public" field to the value that was provided on create.
func (u *EnvUpsertBulk) UpdatePublic() *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.UpdatePublic()
	})
}

// SetBuildCount sets the "build_count" field.
func (u *EnvUpsertBulk) SetBuildCount(v int32) *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.SetBuildCount(v)
	})
}

// AddBuildCount adds v to the "build_count" field.
func (u *EnvUpsertBulk) AddBuildCount(v int32) *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.AddBuildCount(v)
	})
}

// UpdateBuildCount sets the "build_count" field to the value that was provided on create.
func (u *EnvUpsertBulk) UpdateBuildCount() *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.UpdateBuildCount()
	})
}

// SetSpawnCount sets the "spawn_count" field.
func (u *EnvUpsertBulk) SetSpawnCount(v int64) *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.SetSpawnCount(v)
	})
}

// AddSpawnCount adds v to the "spawn_count" field.
func (u *EnvUpsertBulk) AddSpawnCount(v int64) *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.AddSpawnCount(v)
	})
}

// UpdateSpawnCount sets the "spawn_count" field to the value that was provided on create.
func (u *EnvUpsertBulk) UpdateSpawnCount() *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.UpdateSpawnCount()
	})
}

// SetLastSpawnedAt sets the "last_spawned_at" field.
func (u *EnvUpsertBulk) SetLastSpawnedAt(v time.Time) *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.SetLastSpawnedAt(v)
	})
}

// UpdateLastSpawnedAt sets the "last_spawned_at" field to the value that was provided on create.
func (u *EnvUpsertBulk) UpdateLastSpawnedAt() *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.UpdateLastSpawnedAt()
	})
}

// ClearLastSpawnedAt clears the value of the "last_spawned_at" field.
func (u *EnvUpsertBulk) ClearLastSpawnedAt() *EnvUpsertBulk {
	return u.Update(func(s *EnvUpsert) {
		s.ClearLastSpawnedAt()
	})
}

// Exec executes the query.
func (u *EnvUpsertBulk) Exec(ctx context.Context) error {
	if u.create.err != nil {
		return u.create.err
	}
	for i, b := range u.create.builders {
		if len(b.conflict) != 0 {
			return fmt.Errorf("models: OnConflict was set for builder %d. Set it on the EnvCreateBulk instead", i)
		}
	}
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for EnvCreateBulk.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *EnvUpsertBulk) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/env_delete.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
)

// EnvDelete is the builder for deleting a Env entity.
type EnvDelete struct {
	config
	hooks    []Hook
	mutation *EnvMutation
}

// Where appends a list predicates to the EnvDelete builder.
func (ed *EnvDelete) Where(ps ...predicate.Env) *EnvDelete {
	ed.mutation.Where(ps...)
	return ed
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (ed *EnvDelete) Exec(ctx context.Context) (int, error) {
	return withHooks(ctx, ed.sqlExec, ed.mutation, ed.hooks)
}

// ExecX is like Exec, but panics if an error occurs.
func (ed *EnvDelete) ExecX(ctx context.Context) int {
	n, err := ed.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (ed *EnvDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := sqlgraph.NewDeleteSpec(env.Table, sqlgraph.NewFieldSpec(env.FieldID, field.TypeString))
	_spec.Node.Schema = ed.schemaConfig.Env
	ctx = internal.NewSchemaConfigContext(ctx, ed.schemaConfig)
	if ps := ed.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	affected, err := sqlgraph.DeleteNodes(ctx, ed.driver, _spec)
	if err != nil && sqlgraph.IsConstraintError(err) {
		err = &ConstraintError{msg: err.Error(), wrap: err}
	}
	ed.mutation.done = true
	return affected, err
}

// EnvDeleteOne is the builder for deleting a single Env entity.
type EnvDeleteOne struct {
	ed *EnvDelete
}

// Where appends a list predicates to the EnvDelete builder.
func (edo *EnvDeleteOne) Where(ps ...predicate.Env) *EnvDeleteOne {
	edo.ed.mutation.Where(ps...)
	return edo
}

// Exec executes the deletion query.
func (edo *EnvDeleteOne) Exec(ctx context.Context) error {
	n, err := edo.ed.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{env.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (edo *EnvDeleteOne) ExecX(ctx context.Context) {
	if err := edo.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/env_query.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"database/sql/driver"
	"fmt"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envalias"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envbuild"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/snapshot"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/google/uuid"
)

// EnvQuery is the builder for querying Env entities.
type EnvQuery struct {
	config
	ctx            *QueryContext
	order          []env.OrderOption
	inters         []Interceptor
	predicates     []predicate.Env
	withTeam       *TeamQuery
	withCreator    *UserQuery
	withEnvAliases *EnvAliasQuery
	withBuilds     *EnvBuildQuery
	withSnapshots  *SnapshotQuery
	modifiers      []func(*sql.Selector)
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the EnvQuery builder.
func (eq *EnvQuery) Where(ps ...predicate.Env) *EnvQuery {
	eq.predicates = append(eq.predicates, ps...)
	return eq
}

// Limit the number of records to be returned by this query.
func (eq *EnvQuery) Limit(limit int) *EnvQuery {
	eq.ctx.Limit = &limit
	return eq
}

// Offset to start from.
func (eq *EnvQuery) Offset(offset int) *EnvQuery {
	eq.ctx.Offset = &offset
	return eq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (eq *EnvQuery) Unique(unique bool) *EnvQuery {
	eq.ctx.Unique = &unique
	return eq
}

// Order specifies how the records should be ordered.
func (eq *EnvQuery) Order(o ...env.OrderOption) *EnvQuery {
	eq.order = append(eq.order, o...)
	return eq
}

// QueryTeam chains the current query on the "team" edge.
func (eq *EnvQuery) QueryTeam() *TeamQuery {
	query := (&TeamClient{config: eq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := eq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := eq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(env.Table, env.FieldID, selector),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, env.TeamTable, env.TeamColumn),
		)
		schemaConfig := eq.schemaConfig
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.Env
		fromU = sqlgraph.SetNeighbors(eq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCreator chains the current query on the "creator" edge.
func (eq *EnvQuery) QueryCreator() *UserQuery {
	query := (&UserClient{config: eq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := eq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := eq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(env.Table, env.FieldID, selector),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, env.CreatorTable, env.CreatorColumn),
		)
		schemaConfig := eq.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.Env
		fromU = sqlgraph.SetNeighbors(eq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryEnvAliases chains the current query on the "env_aliases" edge.
func (eq *EnvQuery) QueryEnvAliases() *EnvAliasQuery {
	query := (&EnvAliasClient{config: eq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := eq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := eq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(env.Table, env.FieldID, selector),
			sqlgraph.To(envalias.Table, envalias.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, env.EnvAliasesTable, env.EnvAliasesColumn),
		)
		schemaConfig := eq.schemaConfig
		step.To.Schema = schemaConfig.EnvAlias
		step.Edge.Schema = schemaConfig.EnvAlias
		fromU = sqlgraph.SetNeighbors(eq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryBuilds chains the current query on the "builds" edge.
func (eq *EnvQuery) QueryBuilds() *EnvBuildQuery {
	query := (&EnvBuildClient{config: eq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := eq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := eq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(env.Table, env.FieldID, selector),
			sqlgraph.To(envbuild.Table, envbuild.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, env.BuildsTable, env.BuildsColumn),
		)
		schemaConfig := eq.schemaConfig
		step.To.Schema = schemaConfig.EnvBuild
		step.Edge.Schema = schemaConfig.EnvBuild
		fromU = sqlgraph.SetNeighbors(eq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QuerySnapshots chains the current query on the "snapshots" edge.
func (eq *EnvQuery) QuerySnapshots() *SnapshotQuery {
	query := (&SnapshotClient{config: eq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := eq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := eq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(env.Table, env.FieldID, selector),
			sqlgraph.To(snapshot.Table, snapshot.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, env.SnapshotsTable, env.SnapshotsColumn),
		)
		schemaConfig := eq.schemaConfig
		step.To.Schema = schemaConfig.Snapshot
		step.Edge.Schema = schemaConfig.Snapshot
		fromU = sqlgraph.SetNeighbors(eq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first Env entity from the query.
// Returns a *NotFoundError when no Env was found.
func (eq *EnvQuery) First(ctx context.Context) (*Env, error) {
	nodes, err := eq.Limit(1).All(setContextOp(ctx, eq.ctx, "First"))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{env.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (eq *EnvQuery) FirstX(ctx context.Context) *Env {
	node, err := eq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first Env ID from the query.
// Returns a *NotFoundError when no Env ID was found.
func (eq *EnvQuery) FirstID(ctx context.Context) (id string, err error) {
	var ids []string
	if ids, err = eq.Limit(1).IDs(setContextOp(ctx, eq.ctx, "FirstID")); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{env.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (eq *EnvQuery) FirstIDX(ctx context.Context) string {
	id, err := eq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single Env entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one Env entity is found.
// Returns a *NotFoundError when no Env entities are found.
func (eq *EnvQuery) Only(ctx context.Context) (*Env, error) {
	nodes, err := eq.Limit(2).All(setContextOp(ctx, eq.ctx, "Only"))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{env.Label}
	default:
		return nil, &NotSingularError{env.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (eq *EnvQuery) OnlyX(ctx context.Context) *Env {
	node, err := eq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only Env ID in the query.
// Returns a *NotSingularError when more than one Env ID is found.
// Returns a *NotFoundError when no entities are found.
func (eq *EnvQuery) OnlyID(ctx context.Context) (id string, err error) {
	var ids []string
	if ids, err = eq.Limit(2).IDs(setContextOp(ctx, eq.ctx, "OnlyID")); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{env.Label}
	default:
		err = &NotSingularError{env.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (eq *EnvQuery) OnlyIDX(ctx context.Context) string {
	id, err := eq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of Envs.
func (eq *EnvQuery) All(ctx context.Context) ([]*Env, error) {
	ctx = setContextOp(ctx, eq.ctx, "All")
	if err := eq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*Env, *EnvQuery]()
	return withInterceptors[[]*Env](ctx, eq, qr, eq.inters)
}

// AllX is like All, but panics if an error occurs.
func (eq *EnvQuery) AllX(ctx context.Context) []*Env {
	nodes, err := eq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of Env IDs.
func (eq *EnvQuery) IDs(ctx context.Context) (ids []string, err error) {
	if eq.ctx.Unique == nil && eq.path != nil {
		eq.Unique(true)
	}
	ctx = setContextOp(ctx, eq.ctx, "IDs")
	if err = eq.Select(env.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (eq *EnvQuery) IDsX(ctx context.Context) []string {
	ids, err := eq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (eq *EnvQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, eq.ctx, "Count")
	if err := eq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, eq, querierCount[*EnvQuery](), eq.inters)
}

// CountX is like Count, but panics if an error occurs.
func (eq *EnvQuery) CountX(ctx context.Context) int {
	count, err := eq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (eq *EnvQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, eq.ctx, "Exist")
	switch _, err := eq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("models: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (eq *EnvQuery) ExistX(ctx context.Context) bool {
	exist, err := eq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the EnvQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (eq *EnvQuery) Clone() *EnvQuery {
	if eq == nil {
		return nil
	}
	return &EnvQuery{
		config:         eq.config,
		ctx:            eq.ctx.Clone(),
		order:          append([]env.OrderOption{}, eq.order...),
		inters:         append([]Interceptor{}, eq.inters...),
		predicates:     append([]predicate.Env{}, eq.predicates...),
		withTeam:       eq.withTeam.Clone(),
		withCreator:    eq.withCreator.Clone(),
		withEnvAliases: eq.withEnvAliases.Clone(),
		withBuilds:     eq.withBuilds.Clone(),
		withSnapshots:  eq.withSnapshots.Clone(),
		// clone intermediate query.
		sql:  eq.sql.Clone(),
		path: eq.path,
	}
}

// WithTeam tells the query-builder to eager-load the nodes that are connected to
// the "team" edge. The optional arguments are used to configure the query builder of the edge.
func (eq *EnvQuery) WithTeam(opts ...func(*TeamQuery)) *EnvQuery {
	query := (&TeamClient{config: eq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	eq.withTeam = query
	return eq
}

// WithCreator tells the query-builder to eager-load the nodes that are connected to
// the "creator" edge. The optional arguments are used to configure the query builder of the edge.
func (eq *EnvQuery) WithCreator(opts ...func(*UserQuery)) *EnvQuery {
	query := (&UserClient{config: eq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	eq.withCreator = query
	return eq
}

// WithEnvAliases tells the query-builder to eager-load the nodes that are connected to
// the "env_aliases" edge. The optional arguments are used to configure the query builder of the edge.
func (eq *EnvQuery) WithEnvAliases(opts ...func(*EnvAliasQuery)) *EnvQuery {
	query := (&EnvAliasClient{config: eq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	eq.withEnvAliases = query
	return eq
}

// WithBuilds tells the query-builder to eager-load the nodes that are connected to
// the "builds" edge. The optional arguments are used to configure the query builder of the edge.
func (eq *EnvQuery) WithBuilds(opts ...func(*EnvBuildQuery)) *EnvQuery {
	query := (&EnvBuildClient{config: eq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	eq.withBuilds = query
	return eq
}

// WithSnapshots tells the query-builder to eager-load the nodes that are connected to
// the "snapshots" edge. The optional arguments are used to configure the query builder of the edge.
func (eq *EnvQuery) WithSnapshots(opts ...func(*SnapshotQuery)) *EnvQuery {
	query := (&SnapshotClient{config: eq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	eq.withSnapshots = query
	return eq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		CreatedAt time.Time `json:"created_at,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.Env.Query().
//		GroupBy(env.FieldCreatedAt).
//		Aggregate(models.Count()).
//		Scan(ctx, &v)
func (eq *EnvQuery) GroupBy(field string, fields ...string) *EnvGroupBy {
	eq.ctx.Fields = append([]string{field}, fields...)
	grbuild := &EnvGroupBy{build: eq}
	grbuild.flds = &eq.ctx.Fields
	grbuild.label = env.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		CreatedAt time.Time `json:"created_at,omitempty"`
//	}
//
//	client.Env.Query().
//		Select(env.FieldCreatedAt).
//		Scan(ctx, &v)
func (eq *EnvQuery) Select(fields ...string) *EnvSelect {
	eq.ctx.Fields = append(eq.ctx.Fields, fields...)
	sbuild := &EnvSelect{EnvQuery: eq}
	sbuild.label = env.Label
	sbuild.flds, sbuild.scan = &eq.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a EnvSelect configured with the given aggregations.
func (eq *EnvQuery) Aggregate(fns ...AggregateFunc) *EnvSelect {
	return eq.Select().Aggregate(fns...)
}

func (eq *EnvQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range eq.inters {
		if inter == nil {
			return fmt.Errorf("models: uninitialized interceptor (forgotten import models/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, eq); err != nil {
				return err
			}
		}
	}
	for _, f := range eq.ctx.Fields {
		if !env.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
		}
	}
	if eq.path != nil {
		prev, err := eq.path(ctx)
		if err != nil {
			return err
		}
		eq.sql = prev
	}
	return nil
}

func (eq *EnvQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*Env, error) {
	var (
		nodes       = []*Env{}
		_spec       = eq.querySpec()
		loadedTypes = [5]bool{
			eq.withTeam != nil,
			eq.withCreator != nil,
			eq.withEnvAliases != nil,
			eq.withBuilds != nil,
			eq.withSnapshots != nil,
		}
	)
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*Env).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &Env{config: eq.config}
		nodes = append(nodes, node)
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	_spec.Node.Schema = eq.schemaConfig.Env
	ctx = internal.NewSchemaConfigContext(ctx, eq.schemaConfig)
	if len(eq.modifiers) > 0 {
		_spec.Modifiers = eq.modifiers
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, eq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	if query := eq.withTeam; query != nil {
		if err := eq.loadTeam(ctx, query, nodes, nil,
			func(n *Env, e *Team) { n.Edges.Team = e }); err != nil {
			return nil, err
		}
	}
	if query := eq.withCreator; query != nil {
		if err := eq.loadCreator(ctx, query, nodes, nil,
			func(n *Env, e *User) { n.Edges.Creator = e }); err != nil {
			return nil, err
		}
	}
	if query := eq.withEnvAliases; query != nil {
		if err := eq.loadEnvAliases(ctx, query, nodes,
			func(n *Env) { n.Edges.EnvAliases = []*EnvAlias{} },
			func(n *Env, e *EnvAlias) { n.Edges.EnvAliases = append(n.Edges.EnvAliases, e) }); err != nil {
			return nil, err
		}
	}
	if query := eq.withBuilds; query != nil {
		if err := eq.loadBuilds(ctx, query, nodes,
			func(n *Env) { n.Edges.Builds = []*EnvBuild{} },
			func(n *Env, e *EnvBuild) { n.Edges.Builds = append(n.Edges.Builds, e) }); err != nil {
			return nil, err
		}
	}
	if query := eq.withSnapshots; query != nil {
		if err := eq.loadSnapshots(ctx, query, nodes,
			func(n *Env) { n.Edges.Snapshots = []*Snapshot{} },
			func(n *Env, e *Snapshot) { n.Edges.Snapshots = append(n.Edges.Snapshots, e) }); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

func (eq *EnvQuery) loadTeam(ctx context.Context, query *TeamQuery, nodes []*Env, init func(*Env), assign func(*Env, *Team)) error {
	ids := make([]uuid.UUID, 0, len(nodes))
	nodeids := make(map[uuid.UUID][]*Env)
	for i := range nodes {
		fk := nodes[i].TeamID
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(team.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "team_id" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}
func (eq *EnvQuery) loadCreator(ctx context.Context, query *UserQuery, nodes []*Env, init func(*Env), assign func(*Env, *User)) error {
	ids := make([]uuid.UUID, 0, len(nodes))
	nodeids := make(map[uuid.UUID][]*Env)
	for i := range nodes {
		if nodes[i].CreatedBy == nil {
			continue
		}
		fk := *nodes[i].CreatedBy
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(user.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "created_by" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}
func (eq *EnvQuery) loadEnvAliases(ctx context.Context, query *EnvAliasQuery, nodes []*Env, init func(*Env), assign func(*Env, *EnvAlias)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*Env)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(envalias.FieldEnvID)
	}
	query.Where(predicate.EnvAlias(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(env.EnvAliasesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.EnvID
		node, ok := nodeids[fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "env_id" returned %v for node %v`, fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (eq *EnvQuery) loadBuilds(ctx context.Context, query *EnvBuildQuery, nodes []*Env, init func(*Env), assign func(*Env, *EnvBuild)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*Env)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(envbuild.FieldEnvID)
	}
	query.Where(predicate.EnvBuild(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(env.BuildsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.EnvID
		if fk == nil {
			return fmt.Errorf(`foreign-key "env_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "env_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (eq *EnvQuery) loadSnapshots(ctx context.Context, query *SnapshotQuery, nodes []*Env, init func(*Env), assign func(*Env, *Snapshot)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*Env)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(snapshot.FieldEnvID)
	}
	query.Where(predicate.Snapshot(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(env.SnapshotsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.EnvID
		node, ok := nodeids[fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "env_id" returned %v for node %v`, fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}

func (eq *EnvQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := eq.querySpec()
	_spec.Node.Schema = eq.schemaConfig.Env
	ctx = internal.NewSchemaConfigContext(ctx, eq.schemaConfig)
	if len(eq.modifiers) > 0 {
		_spec.Modifiers = eq.modifiers
	}
	_spec.Node.Columns = eq.ctx.Fields
	if len(eq.ctx.Fields) > 0 {
		_spec.Unique = eq.ctx.Unique != nil && *eq.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, eq.driver, _spec)
}

func (eq *EnvQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(env.Table, env.Columns, sqlgraph.NewFieldSpec(env.FieldID, field.TypeString))
	_spec.From = eq.sql
	if unique := eq.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if eq.path != nil {
		_spec.Unique = true
	}
	if fields := eq.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, env.FieldID)
		for i := range fields {
			if fields[i] != env.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
		if eq.withTeam != nil {
			_spec.Node.AddColumnOnce(env.FieldTeamID)
		}
		if eq.withCreator != nil {
			_spec.Node.AddColumnOnce(env.FieldCreatedBy)
		}
	}
	if ps := eq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := eq.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := eq.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := eq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (eq *EnvQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(eq.driver.Dialect())
	t1 := builder.Table(env.Table)
	columns := eq.ctx.Fields
	if len(columns) == 0 {
		columns = env.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if eq.sql != nil {
		selector = eq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if eq.ctx.Unique != nil && *eq.ctx.Unique {
		selector.Distinct()
	}
	t1.Schema(eq.schemaConfig.Env)
	ctx = internal.NewSchemaConfigContext(ctx, eq.schemaConfig)
	selector.WithContext(ctx)
	for _, m := range eq.modifiers {
		m(selector)
	}
	for _, p := range eq.predicates {
		p(selector)
	}
	for _, p := range eq.order {
		p(selector)
	}
	if offset := eq.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := eq.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// Modify adds a query modifier for attaching custom logic to queries.
func (eq *EnvQuery) Modify(modifiers ...func(s *sql.Selector)) *EnvSelect {
	eq.modifiers = append(eq.modifiers, modifiers...)
	return eq.Select()
}

// EnvGroupBy is the group-by builder for Env entities.
type EnvGroupBy struct {
	selector
	build *EnvQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (egb *EnvGroupBy) Aggregate(fns ...AggregateFunc) *EnvGroupBy {
	egb.fns = append(egb.fns, fns...)
	return egb
}

// Scan applies the selector query and scans the result into the given value.
func (egb *EnvGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, egb.build.ctx, "GroupBy")
	if err := egb.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*EnvQuery, *EnvGroupBy](ctx, egb.build, egb, egb.build.inters, v)
}

func (egb *EnvGroupBy) sqlScan(ctx context.Context, root *EnvQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(egb.fns))
	for _, fn := range egb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*egb.flds)+len(egb.fns))
		for _, f := range *egb.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*egb.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := egb.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// EnvSelect is the builder for selecting fields of Env entities.
type EnvSelect struct {
	*EnvQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (es *EnvSelect) Aggregate(fns ...AggregateFunc) *EnvSelect {
	es.fns = append(es.fns, fns...)
	return es
}

// Scan applies the selector query and scans the result into the given value.
func (es *EnvSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, es.ctx, "Select")
	if err := es.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*EnvQuery, *EnvSelect](ctx, es.EnvQuery, es, es.inters, v)
}

func (es *EnvSelect) sqlScan(ctx context.Context, root *EnvQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(es.fns))
	for _, fn := range es.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*es.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := es.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// Modify adds a query modifier for attaching custom logic to queries.
func (es *EnvSelect) Modify(modifiers ...func(s *sql.Selector)) *EnvSelect {
	es.modifiers = append(es.modifiers, modifiers...)
	return es
}



================================================
File: models/env_update.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envalias"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envbuild"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/snapshot"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/google/uuid"
)

// EnvUpdate is the builder for updating Env entities.
type EnvUpdate struct {
	config
	hooks     []Hook
	mutation  *EnvMutation
	modifiers []func(*sql.UpdateBuilder)
}

// Where appends a list predicates to the EnvUpdate builder.
func (eu *EnvUpdate) Where(ps ...predicate.Env) *EnvUpdate {
	eu.mutation.Where(ps...)
	return eu
}

// SetUpdatedAt sets the "updated_at" field.
func (eu *EnvUpdate) SetUpdatedAt(t time.Time) *EnvUpdate {
	eu.mutation.SetUpdatedAt(t)
	return eu
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (eu *EnvUpdate) SetNillableUpdatedAt(t *time.Time) *EnvUpdate {
	if t != nil {
		eu.SetUpdatedAt(*t)
	}
	return eu
}

// SetTeamID sets the "team_id" field.
func (eu *EnvUpdate) SetTeamID(u uuid.UUID) *EnvUpdate {
	eu.mutation.SetTeamID(u)
	return eu
}

// SetNillableTeamID sets the "team_id" field if the given value is not nil.
func (eu *EnvUpdate) SetNillableTeamID(u *uuid.UUID) *EnvUpdate {
	if u != nil {
		eu.SetTeamID(*u)
	}
	return eu
}

// SetCreatedBy sets the "created_by" field.
func (eu *EnvUpdate) SetCreatedBy(u uuid.UUID) *EnvUpdate {
	eu.mutation.SetCreatedBy(u)
	return eu
}

// SetNillableCreatedBy sets the "created_by" field if the given value is not nil.
func (eu *EnvUpdate) SetNillableCreatedBy(u *uuid.UUID) *EnvUpdate {
	if u != nil {
		eu.SetCreatedBy(*u)
	}
	return eu
}

// ClearCreatedBy clears the value of the "created_by" field.
func (eu *EnvUpdate) ClearCreatedBy() *EnvUpdate {
	eu.mutation.ClearCreatedBy()
	return eu
}

// SetPublic sets the "public" field.
func (eu *EnvUpdate) SetPublic(b bool) *EnvUpdate {
	eu.mutation.SetPublic(b)
	return eu
}

// SetNillablePublic sets the "public" field if the given value is not nil.
func (eu *EnvUpdate) SetNillablePublic(b *bool) *EnvUpdate {
	if b != nil {
		eu.SetPublic(*b)
	}
	return eu
}

// SetBuildCount sets the "build_count" field.
func (eu *EnvUpdate) SetBuildCount(i int32) *EnvUpdate {
	eu.mutation.ResetBuildCount()
	eu.mutation.SetBuildCount(i)
	return eu
}

// SetNillableBuildCount sets the "build_count" field if the given value is not nil.
func (eu *EnvUpdate) SetNillableBuildCount(i *int32) *EnvUpdate {
	if i != nil {
		eu.SetBuildCount(*i)
	}
	return eu
}

// AddBuildCount adds i to the "build_count" field.
func (eu *EnvUpdate) AddBuildCount(i int32) *EnvUpdate {
	eu.mutation.AddBuildCount(i)
	return eu
}

// SetSpawnCount sets the "spawn_count" field.
func (eu *EnvUpdate) SetSpawnCount(i int64) *EnvUpdate {
	eu.mutation.ResetSpawnCount()
	eu.mutation.SetSpawnCount(i)
	return eu
}

// SetNillableSpawnCount sets the "spawn_count" field if the given value is not nil.
func (eu *EnvUpdate) SetNillableSpawnCount(i *int64) *EnvUpdate {
	if i != nil {
		eu.SetSpawnCount(*i)
	}
	return eu
}

// AddSpawnCount adds i to the "spawn_count" field.
func (eu *EnvUpdate) AddSpawnCount(i int64) *EnvUpdate {
	eu.mutation.AddSpawnCount(i)
	return eu
}

// SetLastSpawnedAt sets the "last_spawned_at" field.
func (eu *EnvUpdate) SetLastSpawnedAt(t time.Time) *EnvUpdate {
	eu.mutation.SetLastSpawnedAt(t)
	return eu
}

// SetNillableLastSpawnedAt sets the "last_spawned_at" field if the given value is not nil.
func (eu *EnvUpdate) SetNillableLastSpawnedAt(t *time.Time) *EnvUpdate {
	if t != nil {
		eu.SetLastSpawnedAt(*t)
	}
	return eu
}

// ClearLastSpawnedAt clears the value of the "last_spawned_at" field.
func (eu *EnvUpdate) ClearLastSpawnedAt() *EnvUpdate {
	eu.mutation.ClearLastSpawnedAt()
	return eu
}

// SetTeam sets the "team" edge to the Team entity.
func (eu *EnvUpdate) SetTeam(t *Team) *EnvUpdate {
	return eu.SetTeamID(t.ID)
}

// SetCreatorID sets the "creator" edge to the User entity by ID.
func (eu *EnvUpdate) SetCreatorID(id uuid.UUID) *EnvUpdate {
	eu.mutation.SetCreatorID(id)
	return eu
}

// SetNillableCreatorID sets the "creator" edge to the User entity by ID if the given value is not nil.
func (eu *EnvUpdate) SetNillableCreatorID(id *uuid.UUID) *EnvUpdate {
	if id != nil {
		eu = eu.SetCreatorID(*id)
	}
	return eu
}

// SetCreator sets the "creator" edge to the User entity.
func (eu *EnvUpdate) SetCreator(u *User) *EnvUpdate {
	return eu.SetCreatorID(u.ID)
}

// AddEnvAliasIDs adds the "env_aliases" edge to the EnvAlias entity by IDs.
func (eu *EnvUpdate) AddEnvAliasIDs(ids ...string) *EnvUpdate {
	eu.mutation.AddEnvAliasIDs(ids...)
	return eu
}

// AddEnvAliases adds the "env_aliases" edges to the EnvAlias entity.
func (eu *EnvUpdate) AddEnvAliases(e ...*EnvAlias) *EnvUpdate {
	ids := make([]string, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return eu.AddEnvAliasIDs(ids...)
}

// AddBuildIDs adds the "builds" edge to the EnvBuild entity by IDs.
func (eu *EnvUpdate) AddBuildIDs(ids ...uuid.UUID) *EnvUpdate {
	eu.mutation.AddBuildIDs(ids...)
	return eu
}

// AddBuilds adds the "builds" edges to the EnvBuild entity.
func (eu *EnvUpdate) AddBuilds(e ...*EnvBuild) *EnvUpdate {
	ids := make([]uuid.UUID, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return eu.AddBuildIDs(ids...)
}

// AddSnapshotIDs adds the "snapshots" edge to the Snapshot entity by IDs.
func (eu *EnvUpdate) AddSnapshotIDs(ids ...uuid.UUID) *EnvUpdate {
	eu.mutation.AddSnapshotIDs(ids...)
	return eu
}

// AddSnapshots adds the "snapshots" edges to the Snapshot entity.
func (eu *EnvUpdate) AddSnapshots(s ...*Snapshot) *EnvUpdate {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return eu.AddSnapshotIDs(ids...)
}

// Mutation returns the EnvMutation object of the builder.
func (eu *EnvUpdate) Mutation() *EnvMutation {
	return eu.mutation
}

// ClearTeam clears the "team" edge to the Team entity.
func (eu *EnvUpdate) ClearTeam() *EnvUpdate {
	eu.mutation.ClearTeam()
	return eu
}

// ClearCreator clears the "creator" edge to the User entity.
func (eu *EnvUpdate) ClearCreator() *EnvUpdate {
	eu.mutation.ClearCreator()
	return eu
}

// ClearEnvAliases clears all "env_aliases" edges to the EnvAlias entity.
func (eu *EnvUpdate) ClearEnvAliases() *EnvUpdate {
	eu.mutation.ClearEnvAliases()
	return eu
}

// RemoveEnvAliasIDs removes the "env_aliases" edge to EnvAlias entities by IDs.
func (eu *EnvUpdate) RemoveEnvAliasIDs(ids ...string) *EnvUpdate {
	eu.mutation.RemoveEnvAliasIDs(ids...)
	return eu
}

// RemoveEnvAliases removes "env_aliases" edges to EnvAlias entities.
func (eu *EnvUpdate) RemoveEnvAliases(e ...*EnvAlias) *EnvUpdate {
	ids := make([]string, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return eu.RemoveEnvAliasIDs(ids...)
}

// ClearBuilds clears all "builds" edges to the EnvBuild entity.
func (eu *EnvUpdate) ClearBuilds() *EnvUpdate {
	eu.mutation.ClearBuilds()
	return eu
}

// RemoveBuildIDs removes the "builds" edge to EnvBuild entities by IDs.
func (eu *EnvUpdate) RemoveBuildIDs(ids ...uuid.UUID) *EnvUpdate {
	eu.mutation.RemoveBuildIDs(ids...)
	return eu
}

// RemoveBuilds removes "builds" edges to EnvBuild entities.
func (eu *EnvUpdate) RemoveBuilds(e ...*EnvBuild) *EnvUpdate {
	ids := make([]uuid.UUID, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return eu.RemoveBuildIDs(ids...)
}

// ClearSnapshots clears all "snapshots" edges to the Snapshot entity.
func (eu *EnvUpdate) ClearSnapshots() *EnvUpdate {
	eu.mutation.ClearSnapshots()
	return eu
}

// RemoveSnapshotIDs removes the "snapshots" edge to Snapshot entities by IDs.
func (eu *EnvUpdate) RemoveSnapshotIDs(ids ...uuid.UUID) *EnvUpdate {
	eu.mutation.RemoveSnapshotIDs(ids...)
	return eu
}

// RemoveSnapshots removes "snapshots" edges to Snapshot entities.
func (eu *EnvUpdate) RemoveSnapshots(s ...*Snapshot) *EnvUpdate {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return eu.RemoveSnapshotIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (eu *EnvUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, eu.sqlSave, eu.mutation, eu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (eu *EnvUpdate) SaveX(ctx context.Context) int {
	affected, err := eu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (eu *EnvUpdate) Exec(ctx context.Context) error {
	_, err := eu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (eu *EnvUpdate) ExecX(ctx context.Context) {
	if err := eu.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (eu *EnvUpdate) check() error {
	if _, ok := eu.mutation.TeamID(); eu.mutation.TeamCleared() && !ok {
		return errors.New(`models: clearing a required unique edge "Env.team"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (eu *EnvUpdate) Modify(modifiers ...func(u *sql.UpdateBuilder)) *EnvUpdate {
	eu.modifiers = append(eu.modifiers, modifiers...)
	return eu
}

func (eu *EnvUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := eu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(env.Table, env.Columns, sqlgraph.NewFieldSpec(env.FieldID, field.TypeString))
	if ps := eu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := eu.mutation.UpdatedAt(); ok {
		_spec.SetField(env.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := eu.mutation.Public(); ok {
		_spec.SetField(env.FieldPublic, field.TypeBool, value)
	}
	if value, ok := eu.mutation.BuildCount(); ok {
		_spec.SetField(env.FieldBuildCount, field.TypeInt32, value)
	}
	if value, ok := eu.mutation.AddedBuildCount(); ok {
		_spec.AddField(env.FieldBuildCount, field.TypeInt32, value)
	}
	if value, ok := eu.mutation.SpawnCount(); ok {
		_spec.SetField(env.FieldSpawnCount, field.TypeInt64, value)
	}
	if value, ok := eu.mutation.AddedSpawnCount(); ok {
		_spec.AddField(env.FieldSpawnCount, field.TypeInt64, value)
	}
	if value, ok := eu.mutation.LastSpawnedAt(); ok {
		_spec.SetField(env.FieldLastSpawnedAt, field.TypeTime, value)
	}
	if eu.mutation.LastSpawnedAtCleared() {
		_spec.ClearField(env.FieldLastSpawnedAt, field.TypeTime)
	}
	if eu.mutation.TeamCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   env.TeamTable,
			Columns: []string{env.TeamColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = eu.schemaConfig.Env
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.TeamIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   env.TeamTable,
			Columns: []string{env.TeamColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = eu.schemaConfig.Env
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if eu.mutation.CreatorCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   env.CreatorTable,
			Columns: []string{env.CreatorColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = eu.schemaConfig.Env
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.CreatorIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   env.CreatorTable,
			Columns: []string{env.CreatorColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = eu.schemaConfig.Env
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if eu.mutation.EnvAliasesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.EnvAliasesTable,
			Columns: []string{env.EnvAliasesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(envalias.FieldID, field.TypeString),
			},
		}
		edge.Schema = eu.schemaConfig.EnvAlias
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.RemovedEnvAliasesIDs(); len(nodes) > 0 && !eu.mutation.EnvAliasesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.EnvAliasesTable,
			Columns: []string{env.EnvAliasesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(envalias.FieldID, field.TypeString),
			},
		}
		edge.Schema = eu.schemaConfig.EnvAlias
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.EnvAliasesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.EnvAliasesTable,
			Columns: []string{env.EnvAliasesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(envalias.FieldID, field.TypeString),
			},
		}
		edge.Schema = eu.schemaConfig.EnvAlias
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if eu.mutation.BuildsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.BuildsTable,
			Columns: []string{env.BuildsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(envbuild.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = eu.schemaConfig.EnvBuild
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.RemovedBuildsIDs(); len(nodes) > 0 && !eu.mutation.BuildsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.BuildsTable,
			Columns: []string{env.BuildsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(envbuild.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = eu.schemaConfig.EnvBuild
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.BuildsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.BuildsTable,
			Columns: []string{env.BuildsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(envbuild.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = eu.schemaConfig.EnvBuild
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if eu.mutation.SnapshotsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.SnapshotsTable,
			Columns: []string{env.SnapshotsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(snapshot.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = eu.schemaConfig.Snapshot
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.RemovedSnapshotsIDs(); len(nodes) > 0 && !eu.mutation.SnapshotsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.SnapshotsTable,
			Columns: []string{env.SnapshotsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(snapshot.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = eu.schemaConfig.Snapshot
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.SnapshotsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.SnapshotsTable,
			Columns: []string{env.SnapshotsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(snapshot.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = eu.schemaConfig.Snapshot
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = eu.schemaConfig.Env
	ctx = internal.NewSchemaConfigContext(ctx, eu.schemaConfig)
	_spec.AddModifiers(eu.modifiers...)
	if n, err = sqlgraph.UpdateNodes(ctx, eu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{env.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	eu.mutation.done = true
	return n, nil
}

// EnvUpdateOne is the builder for updating a single Env entity.
type EnvUpdateOne struct {
	config
	fields    []string
	hooks     []Hook
	mutation  *EnvMutation
	modifiers []func(*sql.UpdateBuilder)
}

// SetUpdatedAt sets the "updated_at" field.
func (euo *EnvUpdateOne) SetUpdatedAt(t time.Time) *EnvUpdateOne {
	euo.mutation.SetUpdatedAt(t)
	return euo
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (euo *EnvUpdateOne) SetNillableUpdatedAt(t *time.Time) *EnvUpdateOne {
	if t != nil {
		euo.SetUpdatedAt(*t)
	}
	return euo
}

// SetTeamID sets the "team_id" field.
func (euo *EnvUpdateOne) SetTeamID(u uuid.UUID) *EnvUpdateOne {
	euo.mutation.SetTeamID(u)
	return euo
}

// SetNillableTeamID sets the "team_id" field if the given value is not nil.
func (euo *EnvUpdateOne) SetNillableTeamID(u *uuid.UUID) *EnvUpdateOne {
	if u != nil {
		euo.SetTeamID(*u)
	}
	return euo
}

// SetCreatedBy sets the "created_by" field.
func (euo *EnvUpdateOne) SetCreatedBy(u uuid.UUID) *EnvUpdateOne {
	euo.mutation.SetCreatedBy(u)
	return euo
}

// SetNillableCreatedBy sets the "created_by" field if the given value is not nil.
func (euo *EnvUpdateOne) SetNillableCreatedBy(u *uuid.UUID) *EnvUpdateOne {
	if u != nil {
		euo.SetCreatedBy(*u)
	}
	return euo
}

// ClearCreatedBy clears the value of the "created_by" field.
func (euo *EnvUpdateOne) ClearCreatedBy() *EnvUpdateOne {
	euo.mutation.ClearCreatedBy()
	return euo
}

// SetPublic sets the "public" field.
func (euo *EnvUpdateOne) SetPublic(b bool) *EnvUpdateOne {
	euo.mutation.SetPublic(b)
	return euo
}

// SetNillablePublic sets the "public" field if the given value is not nil.
func (euo *EnvUpdateOne) SetNillablePublic(b *bool) *EnvUpdateOne {
	if b != nil {
		euo.SetPublic(*b)
	}
	return euo
}

// SetBuildCount sets the "build_count" field.
func (euo *EnvUpdateOne) SetBuildCount(i int32) *EnvUpdateOne {
	euo.mutation.ResetBuildCount()
	euo.mutation.SetBuildCount(i)
	return euo
}

// SetNillableBuildCount sets the "build_count" field if the given value is not nil.
func (euo *EnvUpdateOne) SetNillableBuildCount(i *int32) *EnvUpdateOne {
	if i != nil {
		euo.SetBuildCount(*i)
	}
	return euo
}

// AddBuildCount adds i to the "build_count" field.
func (euo *EnvUpdateOne) AddBuildCount(i int32) *EnvUpdateOne {
	euo.mutation.AddBuildCount(i)
	return euo
}

// SetSpawnCount sets the "spawn_count" field.
func (euo *EnvUpdateOne) SetSpawnCount(i int64) *EnvUpdateOne {
	euo.mutation.ResetSpawnCount()
	euo.mutation.SetSpawnCount(i)
	return euo
}

// SetNillableSpawnCount sets the "spawn_count" field if the given value is not nil.
func (euo *EnvUpdateOne) SetNillableSpawnCount(i *int64) *EnvUpdateOne {
	if i != nil {
		euo.SetSpawnCount(*i)
	}
	return euo
}

// AddSpawnCount adds i to the "spawn_count" field.
func (euo *EnvUpdateOne) AddSpawnCount(i int64) *EnvUpdateOne {
	euo.mutation.AddSpawnCount(i)
	return euo
}

// SetLastSpawnedAt sets the "last_spawned_at" field.
func (euo *EnvUpdateOne) SetLastSpawnedAt(t time.Time) *EnvUpdateOne {
	euo.mutation.SetLastSpawnedAt(t)
	return euo
}

// SetNillableLastSpawnedAt sets the "last_spawned_at" field if the given value is not nil.
func (euo *EnvUpdateOne) SetNillableLastSpawnedAt(t *time.Time) *EnvUpdateOne {
	if t != nil {
		euo.SetLastSpawnedAt(*t)
	}
	return euo
}

// ClearLastSpawnedAt clears the value of the "last_spawned_at" field.
func (euo *EnvUpdateOne) ClearLastSpawnedAt() *EnvUpdateOne {
	euo.mutation.ClearLastSpawnedAt()
	return euo
}

// SetTeam sets the "team" edge to the Team entity.
func (euo *EnvUpdateOne) SetTeam(t *Team) *EnvUpdateOne {
	return euo.SetTeamID(t.ID)
}

// SetCreatorID sets the "creator" edge to the User entity by ID.
func (euo *EnvUpdateOne) SetCreatorID(id uuid.UUID) *EnvUpdateOne {
	euo.mutation.SetCreatorID(id)
	return euo
}

// SetNillableCreatorID sets the "creator" edge to the User entity by ID if the given value is not nil.
func (euo *EnvUpdateOne) SetNillableCreatorID(id *uuid.UUID) *EnvUpdateOne {
	if id != nil {
		euo = euo.SetCreatorID(*id)
	}
	return euo
}

// SetCreator sets the "creator" edge to the User entity.
func (euo *EnvUpdateOne) SetCreator(u *User) *EnvUpdateOne {
	return euo.SetCreatorID(u.ID)
}

// AddEnvAliasIDs adds the "env_aliases" edge to the EnvAlias entity by IDs.
func (euo *EnvUpdateOne) AddEnvAliasIDs(ids ...string) *EnvUpdateOne {
	euo.mutation.AddEnvAliasIDs(ids...)
	return euo
}

// AddEnvAliases adds the "env_aliases" edges to the EnvAlias entity.
func (euo *EnvUpdateOne) AddEnvAliases(e ...*EnvAlias) *EnvUpdateOne {
	ids := make([]string, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return euo.AddEnvAliasIDs(ids...)
}

// AddBuildIDs adds the "builds" edge to the EnvBuild entity by IDs.
func (euo *EnvUpdateOne) AddBuildIDs(ids ...uuid.UUID) *EnvUpdateOne {
	euo.mutation.AddBuildIDs(ids...)
	return euo
}

// AddBuilds adds the "builds" edges to the EnvBuild entity.
func (euo *EnvUpdateOne) AddBuilds(e ...*EnvBuild) *EnvUpdateOne {
	ids := make([]uuid.UUID, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return euo.AddBuildIDs(ids...)
}

// AddSnapshotIDs adds the "snapshots" edge to the Snapshot entity by IDs.
func (euo *EnvUpdateOne) AddSnapshotIDs(ids ...uuid.UUID) *EnvUpdateOne {
	euo.mutation.AddSnapshotIDs(ids...)
	return euo
}

// AddSnapshots adds the "snapshots" edges to the Snapshot entity.
func (euo *EnvUpdateOne) AddSnapshots(s ...*Snapshot) *EnvUpdateOne {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return euo.AddSnapshotIDs(ids...)
}

// Mutation returns the EnvMutation object of the builder.
func (euo *EnvUpdateOne) Mutation() *EnvMutation {
	return euo.mutation
}

// ClearTeam clears the "team" edge to the Team entity.
func (euo *EnvUpdateOne) ClearTeam() *EnvUpdateOne {
	euo.mutation.ClearTeam()
	return euo
}

// ClearCreator clears the "creator" edge to the User entity.
func (euo *EnvUpdateOne) ClearCreator() *EnvUpdateOne {
	euo.mutation.ClearCreator()
	return euo
}

// ClearEnvAliases clears all "env_aliases" edges to the EnvAlias entity.
func (euo *EnvUpdateOne) ClearEnvAliases() *EnvUpdateOne {
	euo.mutation.ClearEnvAliases()
	return euo
}

// RemoveEnvAliasIDs removes the "env_aliases" edge to EnvAlias entities by IDs.
func (euo *EnvUpdateOne) RemoveEnvAliasIDs(ids ...string) *EnvUpdateOne {
	euo.mutation.RemoveEnvAliasIDs(ids...)
	return euo
}

// RemoveEnvAliases removes "env_aliases" edges to EnvAlias entities.
func (euo *EnvUpdateOne) RemoveEnvAliases(e ...*EnvAlias) *EnvUpdateOne {
	ids := make([]string, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return euo.RemoveEnvAliasIDs(ids...)
}

// ClearBuilds clears all "builds" edges to the EnvBuild entity.
func (euo *EnvUpdateOne) ClearBuilds() *EnvUpdateOne {
	euo.mutation.ClearBuilds()
	return euo
}

// RemoveBuildIDs removes the "builds" edge to EnvBuild entities by IDs.
func (euo *EnvUpdateOne) RemoveBuildIDs(ids ...uuid.UUID) *EnvUpdateOne {
	euo.mutation.RemoveBuildIDs(ids...)
	return euo
}

// RemoveBuilds removes "builds" edges to EnvBuild entities.
func (euo *EnvUpdateOne) RemoveBuilds(e ...*EnvBuild) *EnvUpdateOne {
	ids := make([]uuid.UUID, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return euo.RemoveBuildIDs(ids...)
}

// ClearSnapshots clears all "snapshots" edges to the Snapshot entity.
func (euo *EnvUpdateOne) ClearSnapshots() *EnvUpdateOne {
	euo.mutation.ClearSnapshots()
	return euo
}

// RemoveSnapshotIDs removes the "snapshots" edge to Snapshot entities by IDs.
func (euo *EnvUpdateOne) RemoveSnapshotIDs(ids ...uuid.UUID) *EnvUpdateOne {
	euo.mutation.RemoveSnapshotIDs(ids...)
	return euo
}

// RemoveSnapshots removes "snapshots" edges to Snapshot entities.
func (euo *EnvUpdateOne) RemoveSnapshots(s ...*Snapshot) *EnvUpdateOne {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return euo.RemoveSnapshotIDs(ids...)
}

// Where appends a list predicates to the EnvUpdate builder.
func (euo *EnvUpdateOne) Where(ps ...predicate.Env) *EnvUpdateOne {
	euo.mutation.Where(ps...)
	return euo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (euo *EnvUpdateOne) Select(field string, fields ...string) *EnvUpdateOne {
	euo.fields = append([]string{field}, fields...)
	return euo
}

// Save executes the query and returns the updated Env entity.
func (euo *EnvUpdateOne) Save(ctx context.Context) (*Env, error) {
	return withHooks(ctx, euo.sqlSave, euo.mutation, euo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (euo *EnvUpdateOne) SaveX(ctx context.Context) *Env {
	node, err := euo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (euo *EnvUpdateOne) Exec(ctx context.Context) error {
	_, err := euo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (euo *EnvUpdateOne) ExecX(ctx context.Context) {
	if err := euo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (euo *EnvUpdateOne) check() error {
	if _, ok := euo.mutation.TeamID(); euo.mutation.TeamCleared() && !ok {
		return errors.New(`models: clearing a required unique edge "Env.team"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (euo *EnvUpdateOne) Modify(modifiers ...func(u *sql.UpdateBuilder)) *EnvUpdateOne {
	euo.modifiers = append(euo.modifiers, modifiers...)
	return euo
}

func (euo *EnvUpdateOne) sqlSave(ctx context.Context) (_node *Env, err error) {
	if err := euo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(env.Table, env.Columns, sqlgraph.NewFieldSpec(env.FieldID, field.TypeString))
	id, ok := euo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`models: missing "Env.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := euo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, env.FieldID)
		for _, f := range fields {
			if !env.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
			}
			if f != env.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := euo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := euo.mutation.UpdatedAt(); ok {
		_spec.SetField(env.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := euo.mutation.Public(); ok {
		_spec.SetField(env.FieldPublic, field.TypeBool, value)
	}
	if value, ok := euo.mutation.BuildCount(); ok {
		_spec.SetField(env.FieldBuildCount, field.TypeInt32, value)
	}
	if value, ok := euo.mutation.AddedBuildCount(); ok {
		_spec.AddField(env.FieldBuildCount, field.TypeInt32, value)
	}
	if value, ok := euo.mutation.SpawnCount(); ok {
		_spec.SetField(env.FieldSpawnCount, field.TypeInt64, value)
	}
	if value, ok := euo.mutation.AddedSpawnCount(); ok {
		_spec.AddField(env.FieldSpawnCount, field.TypeInt64, value)
	}
	if value, ok := euo.mutation.LastSpawnedAt(); ok {
		_spec.SetField(env.FieldLastSpawnedAt, field.TypeTime, value)
	}
	if euo.mutation.LastSpawnedAtCleared() {
		_spec.ClearField(env.FieldLastSpawnedAt, field.TypeTime)
	}
	if euo.mutation.TeamCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   env.TeamTable,
			Columns: []string{env.TeamColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = euo.schemaConfig.Env
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.TeamIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   env.TeamTable,
			Columns: []string{env.TeamColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = euo.schemaConfig.Env
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if euo.mutation.CreatorCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   env.CreatorTable,
			Columns: []string{env.CreatorColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = euo.schemaConfig.Env
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.CreatorIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   env.CreatorTable,
			Columns: []string{env.CreatorColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = euo.schemaConfig.Env
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if euo.mutation.EnvAliasesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.EnvAliasesTable,
			Columns: []string{env.EnvAliasesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(envalias.FieldID, field.TypeString),
			},
		}
		edge.Schema = euo.schemaConfig.EnvAlias
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.RemovedEnvAliasesIDs(); len(nodes) > 0 && !euo.mutation.EnvAliasesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.EnvAliasesTable,
			Columns: []string{env.EnvAliasesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(envalias.FieldID, field.TypeString),
			},
		}
		edge.Schema = euo.schemaConfig.EnvAlias
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.EnvAliasesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.EnvAliasesTable,
			Columns: []string{env.EnvAliasesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(envalias.FieldID, field.TypeString),
			},
		}
		edge.Schema = euo.schemaConfig.EnvAlias
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if euo.mutation.BuildsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.BuildsTable,
			Columns: []string{env.BuildsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(envbuild.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = euo.schemaConfig.EnvBuild
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.RemovedBuildsIDs(); len(nodes) > 0 && !euo.mutation.BuildsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.BuildsTable,
			Columns: []string{env.BuildsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(envbuild.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = euo.schemaConfig.EnvBuild
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.BuildsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.BuildsTable,
			Columns: []string{env.BuildsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(envbuild.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = euo.schemaConfig.EnvBuild
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if euo.mutation.SnapshotsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.SnapshotsTable,
			Columns: []string{env.SnapshotsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(snapshot.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = euo.schemaConfig.Snapshot
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.RemovedSnapshotsIDs(); len(nodes) > 0 && !euo.mutation.SnapshotsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.SnapshotsTable,
			Columns: []string{env.SnapshotsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(snapshot.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = euo.schemaConfig.Snapshot
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.SnapshotsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   env.SnapshotsTable,
			Columns: []string{env.SnapshotsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(snapshot.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = euo.schemaConfig.Snapshot
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = euo.schemaConfig.Env
	ctx = internal.NewSchemaConfigContext(ctx, euo.schemaConfig)
	_spec.AddModifiers(euo.modifiers...)
	_node = &Env{config: euo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, euo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{env.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	euo.mutation.done = true
	return _node, nil
}



================================================
File: models/envalias.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"fmt"
	"strings"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envalias"
)

// EnvAlias is the model entity for the EnvAlias schema.
type EnvAlias struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// EnvID holds the value of the "env_id" field.
	EnvID string `json:"env_id,omitempty"`
	// IsRenamable holds the value of the "is_renamable" field.
	IsRenamable bool `json:"is_renamable,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the EnvAliasQuery when eager-loading is set.
	Edges        EnvAliasEdges `json:"edges"`
	selectValues sql.SelectValues
}

// EnvAliasEdges holds the relations/edges for other nodes in the graph.
type EnvAliasEdges struct {
	// Env holds the value of the env edge.
	Env *Env `json:"env,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// EnvOrErr returns the Env value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e EnvAliasEdges) EnvOrErr() (*Env, error) {
	if e.loadedTypes[0] {
		if e.Env == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: env.Label}
		}
		return e.Env, nil
	}
	return nil, &NotLoadedError{edge: "env"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*EnvAlias) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case envalias.FieldIsRenamable:
			values[i] = new(sql.NullBool)
		case envalias.FieldID, envalias.FieldEnvID:
			values[i] = new(sql.NullString)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the EnvAlias fields.
func (ea *EnvAlias) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case envalias.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				ea.ID = value.String
			}
		case envalias.FieldEnvID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field env_id", values[i])
			} else if value.Valid {
				ea.EnvID = value.String
			}
		case envalias.FieldIsRenamable:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_renamable", values[i])
			} else if value.Valid {
				ea.IsRenamable = value.Bool
			}
		default:
			ea.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the EnvAlias.
// This includes values selected through modifiers, order, etc.
func (ea *EnvAlias) Value(name string) (ent.Value, error) {
	return ea.selectValues.Get(name)
}

// QueryEnv queries the "env" edge of the EnvAlias entity.
func (ea *EnvAlias) QueryEnv() *EnvQuery {
	return NewEnvAliasClient(ea.config).QueryEnv(ea)
}

// Update returns a builder for updating this EnvAlias.
// Note that you need to call EnvAlias.Unwrap() before calling this method if this EnvAlias
// was returned from a transaction, and the transaction was committed or rolled back.
func (ea *EnvAlias) Update() *EnvAliasUpdateOne {
	return NewEnvAliasClient(ea.config).UpdateOne(ea)
}

// Unwrap unwraps the EnvAlias entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (ea *EnvAlias) Unwrap() *EnvAlias {
	_tx, ok := ea.config.driver.(*txDriver)
	if !ok {
		panic("models: EnvAlias is not a transactional entity")
	}
	ea.config.driver = _tx.drv
	return ea
}

// String implements the fmt.Stringer.
func (ea *EnvAlias) String() string {
	var builder strings.Builder
	builder.WriteString("EnvAlias(")
	builder.WriteString(fmt.Sprintf("id=%v, ", ea.ID))
	builder.WriteString("env_id=")
	builder.WriteString(ea.EnvID)
	builder.WriteString(", ")
	builder.WriteString("is_renamable=")
	builder.WriteString(fmt.Sprintf("%v", ea.IsRenamable))
	builder.WriteByte(')')
	return builder.String()
}

// EnvAliasSlice is a parsable slice of EnvAlias.
type EnvAliasSlice []*EnvAlias



================================================
File: models/envalias_create.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envalias"
)

// EnvAliasCreate is the builder for creating a EnvAlias entity.
type EnvAliasCreate struct {
	config
	mutation *EnvAliasMutation
	hooks    []Hook
	conflict []sql.ConflictOption
}

// SetEnvID sets the "env_id" field.
func (eac *EnvAliasCreate) SetEnvID(s string) *EnvAliasCreate {
	eac.mutation.SetEnvID(s)
	return eac
}

// SetIsRenamable sets the "is_renamable" field.
func (eac *EnvAliasCreate) SetIsRenamable(b bool) *EnvAliasCreate {
	eac.mutation.SetIsRenamable(b)
	return eac
}

// SetNillableIsRenamable sets the "is_renamable" field if the given value is not nil.
func (eac *EnvAliasCreate) SetNillableIsRenamable(b *bool) *EnvAliasCreate {
	if b != nil {
		eac.SetIsRenamable(*b)
	}
	return eac
}

// SetID sets the "id" field.
func (eac *EnvAliasCreate) SetID(s string) *EnvAliasCreate {
	eac.mutation.SetID(s)
	return eac
}

// SetEnv sets the "env" edge to the Env entity.
func (eac *EnvAliasCreate) SetEnv(e *Env) *EnvAliasCreate {
	return eac.SetEnvID(e.ID)
}

// Mutation returns the EnvAliasMutation object of the builder.
func (eac *EnvAliasCreate) Mutation() *EnvAliasMutation {
	return eac.mutation
}

// Save creates the EnvAlias in the database.
func (eac *EnvAliasCreate) Save(ctx context.Context) (*EnvAlias, error) {
	eac.defaults()
	return withHooks(ctx, eac.sqlSave, eac.mutation, eac.hooks)
}

// SaveX calls Save and panics if Save returns an error.
func (eac *EnvAliasCreate) SaveX(ctx context.Context) *EnvAlias {
	v, err := eac.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (eac *EnvAliasCreate) Exec(ctx context.Context) error {
	_, err := eac.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (eac *EnvAliasCreate) ExecX(ctx context.Context) {
	if err := eac.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (eac *EnvAliasCreate) defaults() {
	if _, ok := eac.mutation.IsRenamable(); !ok {
		v := envalias.DefaultIsRenamable
		eac.mutation.SetIsRenamable(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (eac *EnvAliasCreate) check() error {
	if _, ok := eac.mutation.EnvID(); !ok {
		return &ValidationError{Name: "env_id", err: errors.New(`models: missing required field "EnvAlias.env_id"`)}
	}
	if _, ok := eac.mutation.IsRenamable(); !ok {
		return &ValidationError{Name: "is_renamable", err: errors.New(`models: missing required field "EnvAlias.is_renamable"`)}
	}
	if _, ok := eac.mutation.EnvID(); !ok {
		return &ValidationError{Name: "env", err: errors.New(`models: missing required edge "EnvAlias.env"`)}
	}
	return nil
}

func (eac *EnvAliasCreate) sqlSave(ctx context.Context) (*EnvAlias, error) {
	if err := eac.check(); err != nil {
		return nil, err
	}
	_node, _spec := eac.createSpec()
	if err := sqlgraph.CreateNode(ctx, eac.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	if _spec.ID.Value != nil {
		if id, ok := _spec.ID.Value.(string); ok {
			_node.ID = id
		} else {
			return nil, fmt.Errorf("unexpected EnvAlias.ID type: %T", _spec.ID.Value)
		}
	}
	eac.mutation.id = &_node.ID
	eac.mutation.done = true
	return _node, nil
}

func (eac *EnvAliasCreate) createSpec() (*EnvAlias, *sqlgraph.CreateSpec) {
	var (
		_node = &EnvAlias{config: eac.config}
		_spec = sqlgraph.NewCreateSpec(envalias.Table, sqlgraph.NewFieldSpec(envalias.FieldID, field.TypeString))
	)
	_spec.Schema = eac.schemaConfig.EnvAlias
	_spec.OnConflict = eac.conflict
	if id, ok := eac.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = id
	}
	if value, ok := eac.mutation.IsRenamable(); ok {
		_spec.SetField(envalias.FieldIsRenamable, field.TypeBool, value)
		_node.IsRenamable = value
	}
	if nodes := eac.mutation.EnvIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   envalias.EnvTable,
			Columns: []string{envalias.EnvColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = eac.schemaConfig.EnvAlias
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.EnvID = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.EnvAlias.Create().
//		SetEnvID(v).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.EnvAliasUpsert) {
//			SetEnvID(v+v).
//		}).
//		Exec(ctx)
func (eac *EnvAliasCreate) OnConflict(opts ...sql.ConflictOption) *EnvAliasUpsertOne {
	eac.conflict = opts
	return &EnvAliasUpsertOne{
		create: eac,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.EnvAlias.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (eac *EnvAliasCreate) OnConflictColumns(columns ...string) *EnvAliasUpsertOne {
	eac.conflict = append(eac.conflict, sql.ConflictColumns(columns...))
	return &EnvAliasUpsertOne{
		create: eac,
	}
}

type (
	// EnvAliasUpsertOne is the builder for "upsert"-ing
	//  one EnvAlias node.
	EnvAliasUpsertOne struct {
		create *EnvAliasCreate
	}

	// EnvAliasUpsert is the "OnConflict" setter.
	EnvAliasUpsert struct {
		*sql.UpdateSet
	}
)

// SetEnvID sets the "env_id" field.
func (u *EnvAliasUpsert) SetEnvID(v string) *EnvAliasUpsert {
	u.Set(envalias.FieldEnvID, v)
	return u
}

// UpdateEnvID sets the "env_id" field to the value that was provided on create.
func (u *EnvAliasUpsert) UpdateEnvID() *EnvAliasUpsert {
	u.SetExcluded(envalias.FieldEnvID)
	return u
}

// SetIsRenamable sets the "is_renamable" field.
func (u *EnvAliasUpsert) SetIsRenamable(v bool) *EnvAliasUpsert {
	u.Set(envalias.FieldIsRenamable, v)
	return u
}

// UpdateIsRenamable sets the "is_renamable" field to the value that was provided on create.
func (u *EnvAliasUpsert) UpdateIsRenamable() *EnvAliasUpsert {
	u.SetExcluded(envalias.FieldIsRenamable)
	return u
}

// UpdateNewValues updates the mutable fields using the new values that were set on create except the ID field.
// Using this option is equivalent to using:
//
//	client.EnvAlias.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(envalias.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *EnvAliasUpsertOne) UpdateNewValues() *EnvAliasUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		if _, exists := u.create.mutation.ID(); exists {
			s.SetIgnore(envalias.FieldID)
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.EnvAlias.Create().
//	    OnConflict(sql.ResolveWithIgnore()).
//	    Exec(ctx)
func (u *EnvAliasUpsertOne) Ignore() *EnvAliasUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *EnvAliasUpsertOne) DoNothing() *EnvAliasUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the EnvAliasCreate.OnConflict
// documentation for more info.
func (u *EnvAliasUpsertOne) Update(set func(*EnvAliasUpsert)) *EnvAliasUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&EnvAliasUpsert{UpdateSet: update})
	}))
	return u
}

// SetEnvID sets the "env_id" field.
func (u *EnvAliasUpsertOne) SetEnvID(v string) *EnvAliasUpsertOne {
	return u.Update(func(s *EnvAliasUpsert) {
		s.SetEnvID(v)
	})
}

// UpdateEnvID sets the "env_id" field to the value that was provided on create.
func (u *EnvAliasUpsertOne) UpdateEnvID() *EnvAliasUpsertOne {
	return u.Update(func(s *EnvAliasUpsert) {
		s.UpdateEnvID()
	})
}

// SetIsRenamable sets the "is_renamable" field.
func (u *EnvAliasUpsertOne) SetIsRenamable(v bool) *EnvAliasUpsertOne {
	return u.Update(func(s *EnvAliasUpsert) {
		s.SetIsRenamable(v)
	})
}

// UpdateIsRenamable sets the "is_renamable" field to the value that was provided on create.
func (u *EnvAliasUpsertOne) UpdateIsRenamable() *EnvAliasUpsertOne {
	return u.Update(func(s *EnvAliasUpsert) {
		s.UpdateIsRenamable()
	})
}

// Exec executes the query.
func (u *EnvAliasUpsertOne) Exec(ctx context.Context) error {
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for EnvAliasCreate.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *EnvAliasUpsertOne) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}

// Exec executes the UPSERT query and returns the inserted/updated ID.
func (u *EnvAliasUpsertOne) ID(ctx context.Context) (id string, err error) {
	if u.create.driver.Dialect() == dialect.MySQL {
		// In case of "ON CONFLICT", there is no way to get back non-numeric ID
		// fields from the database since MySQL does not support the RETURNING clause.
		return id, errors.New("models: EnvAliasUpsertOne.ID is not supported by MySQL driver. Use EnvAliasUpsertOne.Exec instead")
	}
	node, err := u.create.Save(ctx)
	if err != nil {
		return id, err
	}
	return node.ID, nil
}

// IDX is like ID, but panics if an error occurs.
func (u *EnvAliasUpsertOne) IDX(ctx context.Context) string {
	id, err := u.ID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// EnvAliasCreateBulk is the builder for creating many EnvAlias entities in bulk.
type EnvAliasCreateBulk struct {
	config
	err      error
	builders []*EnvAliasCreate
	conflict []sql.ConflictOption
}

// Save creates the EnvAlias entities in the database.
func (eacb *EnvAliasCreateBulk) Save(ctx context.Context) ([]*EnvAlias, error) {
	if eacb.err != nil {
		return nil, eacb.err
	}
	specs := make([]*sqlgraph.CreateSpec, len(eacb.builders))
	nodes := make([]*EnvAlias, len(eacb.builders))
	mutators := make([]Mutator, len(eacb.builders))
	for i := range eacb.builders {
		func(i int, root context.Context) {
			builder := eacb.builders[i]
			builder.defaults()
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*EnvAliasMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				var err error
				nodes[i], specs[i] = builder.createSpec()
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, eacb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					spec.OnConflict = eacb.conflict
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, eacb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{msg: err.Error(), wrap: err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, eacb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (eacb *EnvAliasCreateBulk) SaveX(ctx context.Context) []*EnvAlias {
	v, err := eacb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (eacb *EnvAliasCreateBulk) Exec(ctx context.Context) error {
	_, err := eacb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (eacb *EnvAliasCreateBulk) ExecX(ctx context.Context) {
	if err := eacb.Exec(ctx); err != nil {
		panic(err)
	}
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.EnvAlias.CreateBulk(builders...).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.EnvAliasUpsert) {
//			SetEnvID(v+v).
//		}).
//		Exec(ctx)
func (eacb *EnvAliasCreateBulk) OnConflict(opts ...sql.ConflictOption) *EnvAliasUpsertBulk {
	eacb.conflict = opts
	return &EnvAliasUpsertBulk{
		create: eacb,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.EnvAlias.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (eacb *EnvAliasCreateBulk) OnConflictColumns(columns ...string) *EnvAliasUpsertBulk {
	eacb.conflict = append(eacb.conflict, sql.ConflictColumns(columns...))
	return &EnvAliasUpsertBulk{
		create: eacb,
	}
}

// EnvAliasUpsertBulk is the builder for "upsert"-ing
// a bulk of EnvAlias nodes.
type EnvAliasUpsertBulk struct {
	create *EnvAliasCreateBulk
}

// UpdateNewValues updates the mutable fields using the new values that
// were set on create. Using this option is equivalent to using:
//
//	client.EnvAlias.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(envalias.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *EnvAliasUpsertBulk) UpdateNewValues() *EnvAliasUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		for _, b := range u.create.builders {
			if _, exists := b.mutation.ID(); exists {
				s.SetIgnore(envalias.FieldID)
			}
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.EnvAlias.Create().
//		OnConflict(sql.ResolveWithIgnore()).
//		Exec(ctx)
func (u *EnvAliasUpsertBulk) Ignore() *EnvAliasUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *EnvAliasUpsertBulk) DoNothing() *EnvAliasUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the EnvAliasCreateBulk.OnConflict
// documentation for more info.
func (u *EnvAliasUpsertBulk) Update(set func(*EnvAliasUpsert)) *EnvAliasUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&EnvAliasUpsert{UpdateSet: update})
	}))
	return u
}

// SetEnvID sets the "env_id" field.
func (u *EnvAliasUpsertBulk) SetEnvID(v string) *EnvAliasUpsertBulk {
	return u.Update(func(s *EnvAliasUpsert) {
		s.SetEnvID(v)
	})
}

// UpdateEnvID sets the "env_id" field to the value that was provided on create.
func (u *EnvAliasUpsertBulk) UpdateEnvID() *EnvAliasUpsertBulk {
	return u.Update(func(s *EnvAliasUpsert) {
		s.UpdateEnvID()
	})
}

// SetIsRenamable sets the "is_renamable" field.
func (u *EnvAliasUpsertBulk) SetIsRenamable(v bool) *EnvAliasUpsertBulk {
	return u.Update(func(s *EnvAliasUpsert) {
		s.SetIsRenamable(v)
	})
}

// UpdateIsRenamable sets the "is_renamable" field to the value that was provided on create.
func (u *EnvAliasUpsertBulk) UpdateIsRenamable() *EnvAliasUpsertBulk {
	return u.Update(func(s *EnvAliasUpsert) {
		s.UpdateIsRenamable()
	})
}

// Exec executes the query.
func (u *EnvAliasUpsertBulk) Exec(ctx context.Context) error {
	if u.create.err != nil {
		return u.create.err
	}
	for i, b := range u.create.builders {
		if len(b.conflict) != 0 {
			return fmt.Errorf("models: OnConflict was set for builder %d. Set it on the EnvAliasCreateBulk instead", i)
		}
	}
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for EnvAliasCreateBulk.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *EnvAliasUpsertBulk) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/envalias_delete.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envalias"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
)

// EnvAliasDelete is the builder for deleting a EnvAlias entity.
type EnvAliasDelete struct {
	config
	hooks    []Hook
	mutation *EnvAliasMutation
}

// Where appends a list predicates to the EnvAliasDelete builder.
func (ead *EnvAliasDelete) Where(ps ...predicate.EnvAlias) *EnvAliasDelete {
	ead.mutation.Where(ps...)
	return ead
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (ead *EnvAliasDelete) Exec(ctx context.Context) (int, error) {
	return withHooks(ctx, ead.sqlExec, ead.mutation, ead.hooks)
}

// ExecX is like Exec, but panics if an error occurs.
func (ead *EnvAliasDelete) ExecX(ctx context.Context) int {
	n, err := ead.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (ead *EnvAliasDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := sqlgraph.NewDeleteSpec(envalias.Table, sqlgraph.NewFieldSpec(envalias.FieldID, field.TypeString))
	_spec.Node.Schema = ead.schemaConfig.EnvAlias
	ctx = internal.NewSchemaConfigContext(ctx, ead.schemaConfig)
	if ps := ead.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	affected, err := sqlgraph.DeleteNodes(ctx, ead.driver, _spec)
	if err != nil && sqlgraph.IsConstraintError(err) {
		err = &ConstraintError{msg: err.Error(), wrap: err}
	}
	ead.mutation.done = true
	return affected, err
}

// EnvAliasDeleteOne is the builder for deleting a single EnvAlias entity.
type EnvAliasDeleteOne struct {
	ead *EnvAliasDelete
}

// Where appends a list predicates to the EnvAliasDelete builder.
func (eado *EnvAliasDeleteOne) Where(ps ...predicate.EnvAlias) *EnvAliasDeleteOne {
	eado.ead.mutation.Where(ps...)
	return eado
}

// Exec executes the deletion query.
func (eado *EnvAliasDeleteOne) Exec(ctx context.Context) error {
	n, err := eado.ead.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{envalias.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (eado *EnvAliasDeleteOne) ExecX(ctx context.Context) {
	if err := eado.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/envalias_query.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"fmt"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envalias"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
)

// EnvAliasQuery is the builder for querying EnvAlias entities.
type EnvAliasQuery struct {
	config
	ctx        *QueryContext
	order      []envalias.OrderOption
	inters     []Interceptor
	predicates []predicate.EnvAlias
	withEnv    *EnvQuery
	modifiers  []func(*sql.Selector)
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the EnvAliasQuery builder.
func (eaq *EnvAliasQuery) Where(ps ...predicate.EnvAlias) *EnvAliasQuery {
	eaq.predicates = append(eaq.predicates, ps...)
	return eaq
}

// Limit the number of records to be returned by this query.
func (eaq *EnvAliasQuery) Limit(limit int) *EnvAliasQuery {
	eaq.ctx.Limit = &limit
	return eaq
}

// Offset to start from.
func (eaq *EnvAliasQuery) Offset(offset int) *EnvAliasQuery {
	eaq.ctx.Offset = &offset
	return eaq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (eaq *EnvAliasQuery) Unique(unique bool) *EnvAliasQuery {
	eaq.ctx.Unique = &unique
	return eaq
}

// Order specifies how the records should be ordered.
func (eaq *EnvAliasQuery) Order(o ...envalias.OrderOption) *EnvAliasQuery {
	eaq.order = append(eaq.order, o...)
	return eaq
}

// QueryEnv chains the current query on the "env" edge.
func (eaq *EnvAliasQuery) QueryEnv() *EnvQuery {
	query := (&EnvClient{config: eaq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := eaq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := eaq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(envalias.Table, envalias.FieldID, selector),
			sqlgraph.To(env.Table, env.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, envalias.EnvTable, envalias.EnvColumn),
		)
		schemaConfig := eaq.schemaConfig
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.EnvAlias
		fromU = sqlgraph.SetNeighbors(eaq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first EnvAlias entity from the query.
// Returns a *NotFoundError when no EnvAlias was found.
func (eaq *EnvAliasQuery) First(ctx context.Context) (*EnvAlias, error) {
	nodes, err := eaq.Limit(1).All(setContextOp(ctx, eaq.ctx, "First"))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{envalias.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (eaq *EnvAliasQuery) FirstX(ctx context.Context) *EnvAlias {
	node, err := eaq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first EnvAlias ID from the query.
// Returns a *NotFoundError when no EnvAlias ID was found.
func (eaq *EnvAliasQuery) FirstID(ctx context.Context) (id string, err error) {
	var ids []string
	if ids, err = eaq.Limit(1).IDs(setContextOp(ctx, eaq.ctx, "FirstID")); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{envalias.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (eaq *EnvAliasQuery) FirstIDX(ctx context.Context) string {
	id, err := eaq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single EnvAlias entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one EnvAlias entity is found.
// Returns a *NotFoundError when no EnvAlias entities are found.
func (eaq *EnvAliasQuery) Only(ctx context.Context) (*EnvAlias, error) {
	nodes, err := eaq.Limit(2).All(setContextOp(ctx, eaq.ctx, "Only"))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{envalias.Label}
	default:
		return nil, &NotSingularError{envalias.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (eaq *EnvAliasQuery) OnlyX(ctx context.Context) *EnvAlias {
	node, err := eaq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only EnvAlias ID in the query.
// Returns a *NotSingularError when more than one EnvAlias ID is found.
// Returns a *NotFoundError when no entities are found.
func (eaq *EnvAliasQuery) OnlyID(ctx context.Context) (id string, err error) {
	var ids []string
	if ids, err = eaq.Limit(2).IDs(setContextOp(ctx, eaq.ctx, "OnlyID")); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{envalias.Label}
	default:
		err = &NotSingularError{envalias.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (eaq *EnvAliasQuery) OnlyIDX(ctx context.Context) string {
	id, err := eaq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of EnvAliasSlice.
func (eaq *EnvAliasQuery) All(ctx context.Context) ([]*EnvAlias, error) {
	ctx = setContextOp(ctx, eaq.ctx, "All")
	if err := eaq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*EnvAlias, *EnvAliasQuery]()
	return withInterceptors[[]*EnvAlias](ctx, eaq, qr, eaq.inters)
}

// AllX is like All, but panics if an error occurs.
func (eaq *EnvAliasQuery) AllX(ctx context.Context) []*EnvAlias {
	nodes, err := eaq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of EnvAlias IDs.
func (eaq *EnvAliasQuery) IDs(ctx context.Context) (ids []string, err error) {
	if eaq.ctx.Unique == nil && eaq.path != nil {
		eaq.Unique(true)
	}
	ctx = setContextOp(ctx, eaq.ctx, "IDs")
	if err = eaq.Select(envalias.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (eaq *EnvAliasQuery) IDsX(ctx context.Context) []string {
	ids, err := eaq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (eaq *EnvAliasQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, eaq.ctx, "Count")
	if err := eaq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, eaq, querierCount[*EnvAliasQuery](), eaq.inters)
}

// CountX is like Count, but panics if an error occurs.
func (eaq *EnvAliasQuery) CountX(ctx context.Context) int {
	count, err := eaq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (eaq *EnvAliasQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, eaq.ctx, "Exist")
	switch _, err := eaq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("models: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (eaq *EnvAliasQuery) ExistX(ctx context.Context) bool {
	exist, err := eaq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the EnvAliasQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (eaq *EnvAliasQuery) Clone() *EnvAliasQuery {
	if eaq == nil {
		return nil
	}
	return &EnvAliasQuery{
		config:     eaq.config,
		ctx:        eaq.ctx.Clone(),
		order:      append([]envalias.OrderOption{}, eaq.order...),
		inters:     append([]Interceptor{}, eaq.inters...),
		predicates: append([]predicate.EnvAlias{}, eaq.predicates...),
		withEnv:    eaq.withEnv.Clone(),
		// clone intermediate query.
		sql:  eaq.sql.Clone(),
		path: eaq.path,
	}
}

// WithEnv tells the query-builder to eager-load the nodes that are connected to
// the "env" edge. The optional arguments are used to configure the query builder of the edge.
func (eaq *EnvAliasQuery) WithEnv(opts ...func(*EnvQuery)) *EnvAliasQuery {
	query := (&EnvClient{config: eaq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	eaq.withEnv = query
	return eaq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		EnvID string `json:"env_id,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.EnvAlias.Query().
//		GroupBy(envalias.FieldEnvID).
//		Aggregate(models.Count()).
//		Scan(ctx, &v)
func (eaq *EnvAliasQuery) GroupBy(field string, fields ...string) *EnvAliasGroupBy {
	eaq.ctx.Fields = append([]string{field}, fields...)
	grbuild := &EnvAliasGroupBy{build: eaq}
	grbuild.flds = &eaq.ctx.Fields
	grbuild.label = envalias.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		EnvID string `json:"env_id,omitempty"`
//	}
//
//	client.EnvAlias.Query().
//		Select(envalias.FieldEnvID).
//		Scan(ctx, &v)
func (eaq *EnvAliasQuery) Select(fields ...string) *EnvAliasSelect {
	eaq.ctx.Fields = append(eaq.ctx.Fields, fields...)
	sbuild := &EnvAliasSelect{EnvAliasQuery: eaq}
	sbuild.label = envalias.Label
	sbuild.flds, sbuild.scan = &eaq.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a EnvAliasSelect configured with the given aggregations.
func (eaq *EnvAliasQuery) Aggregate(fns ...AggregateFunc) *EnvAliasSelect {
	return eaq.Select().Aggregate(fns...)
}

func (eaq *EnvAliasQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range eaq.inters {
		if inter == nil {
			return fmt.Errorf("models: uninitialized interceptor (forgotten import models/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, eaq); err != nil {
				return err
			}
		}
	}
	for _, f := range eaq.ctx.Fields {
		if !envalias.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
		}
	}
	if eaq.path != nil {
		prev, err := eaq.path(ctx)
		if err != nil {
			return err
		}
		eaq.sql = prev
	}
	return nil
}

func (eaq *EnvAliasQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*EnvAlias, error) {
	var (
		nodes       = []*EnvAlias{}
		_spec       = eaq.querySpec()
		loadedTypes = [1]bool{
			eaq.withEnv != nil,
		}
	)
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*EnvAlias).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &EnvAlias{config: eaq.config}
		nodes = append(nodes, node)
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	_spec.Node.Schema = eaq.schemaConfig.EnvAlias
	ctx = internal.NewSchemaConfigContext(ctx, eaq.schemaConfig)
	if len(eaq.modifiers) > 0 {
		_spec.Modifiers = eaq.modifiers
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, eaq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	if query := eaq.withEnv; query != nil {
		if err := eaq.loadEnv(ctx, query, nodes, nil,
			func(n *EnvAlias, e *Env) { n.Edges.Env = e }); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

func (eaq *EnvAliasQuery) loadEnv(ctx context.Context, query *EnvQuery, nodes []*EnvAlias, init func(*EnvAlias), assign func(*EnvAlias, *Env)) error {
	ids := make([]string, 0, len(nodes))
	nodeids := make(map[string][]*EnvAlias)
	for i := range nodes {
		fk := nodes[i].EnvID
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(env.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "env_id" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}

func (eaq *EnvAliasQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := eaq.querySpec()
	_spec.Node.Schema = eaq.schemaConfig.EnvAlias
	ctx = internal.NewSchemaConfigContext(ctx, eaq.schemaConfig)
	if len(eaq.modifiers) > 0 {
		_spec.Modifiers = eaq.modifiers
	}
	_spec.Node.Columns = eaq.ctx.Fields
	if len(eaq.ctx.Fields) > 0 {
		_spec.Unique = eaq.ctx.Unique != nil && *eaq.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, eaq.driver, _spec)
}

func (eaq *EnvAliasQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(envalias.Table, envalias.Columns, sqlgraph.NewFieldSpec(envalias.FieldID, field.TypeString))
	_spec.From = eaq.sql
	if unique := eaq.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if eaq.path != nil {
		_spec.Unique = true
	}
	if fields := eaq.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, envalias.FieldID)
		for i := range fields {
			if fields[i] != envalias.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
		if eaq.withEnv != nil {
			_spec.Node.AddColumnOnce(envalias.FieldEnvID)
		}
	}
	if ps := eaq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := eaq.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := eaq.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := eaq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (eaq *EnvAliasQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(eaq.driver.Dialect())
	t1 := builder.Table(envalias.Table)
	columns := eaq.ctx.Fields
	if len(columns) == 0 {
		columns = envalias.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if eaq.sql != nil {
		selector = eaq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if eaq.ctx.Unique != nil && *eaq.ctx.Unique {
		selector.Distinct()
	}
	t1.Schema(eaq.schemaConfig.EnvAlias)
	ctx = internal.NewSchemaConfigContext(ctx, eaq.schemaConfig)
	selector.WithContext(ctx)
	for _, m := range eaq.modifiers {
		m(selector)
	}
	for _, p := range eaq.predicates {
		p(selector)
	}
	for _, p := range eaq.order {
		p(selector)
	}
	if offset := eaq.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := eaq.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// Modify adds a query modifier for attaching custom logic to queries.
func (eaq *EnvAliasQuery) Modify(modifiers ...func(s *sql.Selector)) *EnvAliasSelect {
	eaq.modifiers = append(eaq.modifiers, modifiers...)
	return eaq.Select()
}

// EnvAliasGroupBy is the group-by builder for EnvAlias entities.
type EnvAliasGroupBy struct {
	selector
	build *EnvAliasQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (eagb *EnvAliasGroupBy) Aggregate(fns ...AggregateFunc) *EnvAliasGroupBy {
	eagb.fns = append(eagb.fns, fns...)
	return eagb
}

// Scan applies the selector query and scans the result into the given value.
func (eagb *EnvAliasGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, eagb.build.ctx, "GroupBy")
	if err := eagb.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*EnvAliasQuery, *EnvAliasGroupBy](ctx, eagb.build, eagb, eagb.build.inters, v)
}

func (eagb *EnvAliasGroupBy) sqlScan(ctx context.Context, root *EnvAliasQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(eagb.fns))
	for _, fn := range eagb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*eagb.flds)+len(eagb.fns))
		for _, f := range *eagb.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*eagb.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := eagb.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// EnvAliasSelect is the builder for selecting fields of EnvAlias entities.
type EnvAliasSelect struct {
	*EnvAliasQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (eas *EnvAliasSelect) Aggregate(fns ...AggregateFunc) *EnvAliasSelect {
	eas.fns = append(eas.fns, fns...)
	return eas
}

// Scan applies the selector query and scans the result into the given value.
func (eas *EnvAliasSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, eas.ctx, "Select")
	if err := eas.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*EnvAliasQuery, *EnvAliasSelect](ctx, eas.EnvAliasQuery, eas, eas.inters, v)
}

func (eas *EnvAliasSelect) sqlScan(ctx context.Context, root *EnvAliasQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(eas.fns))
	for _, fn := range eas.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*eas.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := eas.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// Modify adds a query modifier for attaching custom logic to queries.
func (eas *EnvAliasSelect) Modify(modifiers ...func(s *sql.Selector)) *EnvAliasSelect {
	eas.modifiers = append(eas.modifiers, modifiers...)
	return eas
}



================================================
File: models/envalias_update.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envalias"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
)

// EnvAliasUpdate is the builder for updating EnvAlias entities.
type EnvAliasUpdate struct {
	config
	hooks     []Hook
	mutation  *EnvAliasMutation
	modifiers []func(*sql.UpdateBuilder)
}

// Where appends a list predicates to the EnvAliasUpdate builder.
func (eau *EnvAliasUpdate) Where(ps ...predicate.EnvAlias) *EnvAliasUpdate {
	eau.mutation.Where(ps...)
	return eau
}

// SetEnvID sets the "env_id" field.
func (eau *EnvAliasUpdate) SetEnvID(s string) *EnvAliasUpdate {
	eau.mutation.SetEnvID(s)
	return eau
}

// SetNillableEnvID sets the "env_id" field if the given value is not nil.
func (eau *EnvAliasUpdate) SetNillableEnvID(s *string) *EnvAliasUpdate {
	if s != nil {
		eau.SetEnvID(*s)
	}
	return eau
}

// SetIsRenamable sets the "is_renamable" field.
func (eau *EnvAliasUpdate) SetIsRenamable(b bool) *EnvAliasUpdate {
	eau.mutation.SetIsRenamable(b)
	return eau
}

// SetNillableIsRenamable sets the "is_renamable" field if the given value is not nil.
func (eau *EnvAliasUpdate) SetNillableIsRenamable(b *bool) *EnvAliasUpdate {
	if b != nil {
		eau.SetIsRenamable(*b)
	}
	return eau
}

// SetEnv sets the "env" edge to the Env entity.
func (eau *EnvAliasUpdate) SetEnv(e *Env) *EnvAliasUpdate {
	return eau.SetEnvID(e.ID)
}

// Mutation returns the EnvAliasMutation object of the builder.
func (eau *EnvAliasUpdate) Mutation() *EnvAliasMutation {
	return eau.mutation
}

// ClearEnv clears the "env" edge to the Env entity.
func (eau *EnvAliasUpdate) ClearEnv() *EnvAliasUpdate {
	eau.mutation.ClearEnv()
	return eau
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (eau *EnvAliasUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, eau.sqlSave, eau.mutation, eau.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (eau *EnvAliasUpdate) SaveX(ctx context.Context) int {
	affected, err := eau.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (eau *EnvAliasUpdate) Exec(ctx context.Context) error {
	_, err := eau.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (eau *EnvAliasUpdate) ExecX(ctx context.Context) {
	if err := eau.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (eau *EnvAliasUpdate) check() error {
	if _, ok := eau.mutation.EnvID(); eau.mutation.EnvCleared() && !ok {
		return errors.New(`models: clearing a required unique edge "EnvAlias.env"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (eau *EnvAliasUpdate) Modify(modifiers ...func(u *sql.UpdateBuilder)) *EnvAliasUpdate {
	eau.modifiers = append(eau.modifiers, modifiers...)
	return eau
}

func (eau *EnvAliasUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := eau.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(envalias.Table, envalias.Columns, sqlgraph.NewFieldSpec(envalias.FieldID, field.TypeString))
	if ps := eau.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := eau.mutation.IsRenamable(); ok {
		_spec.SetField(envalias.FieldIsRenamable, field.TypeBool, value)
	}
	if eau.mutation.EnvCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   envalias.EnvTable,
			Columns: []string{envalias.EnvColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = eau.schemaConfig.EnvAlias
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eau.mutation.EnvIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   envalias.EnvTable,
			Columns: []string{envalias.EnvColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = eau.schemaConfig.EnvAlias
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = eau.schemaConfig.EnvAlias
	ctx = internal.NewSchemaConfigContext(ctx, eau.schemaConfig)
	_spec.AddModifiers(eau.modifiers...)
	if n, err = sqlgraph.UpdateNodes(ctx, eau.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{envalias.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	eau.mutation.done = true
	return n, nil
}

// EnvAliasUpdateOne is the builder for updating a single EnvAlias entity.
type EnvAliasUpdateOne struct {
	config
	fields    []string
	hooks     []Hook
	mutation  *EnvAliasMutation
	modifiers []func(*sql.UpdateBuilder)
}

// SetEnvID sets the "env_id" field.
func (eauo *EnvAliasUpdateOne) SetEnvID(s string) *EnvAliasUpdateOne {
	eauo.mutation.SetEnvID(s)
	return eauo
}

// SetNillableEnvID sets the "env_id" field if the given value is not nil.
func (eauo *EnvAliasUpdateOne) SetNillableEnvID(s *string) *EnvAliasUpdateOne {
	if s != nil {
		eauo.SetEnvID(*s)
	}
	return eauo
}

// SetIsRenamable sets the "is_renamable" field.
func (eauo *EnvAliasUpdateOne) SetIsRenamable(b bool) *EnvAliasUpdateOne {
	eauo.mutation.SetIsRenamable(b)
	return eauo
}

// SetNillableIsRenamable sets the "is_renamable" field if the given value is not nil.
func (eauo *EnvAliasUpdateOne) SetNillableIsRenamable(b *bool) *EnvAliasUpdateOne {
	if b != nil {
		eauo.SetIsRenamable(*b)
	}
	return eauo
}

// SetEnv sets the "env" edge to the Env entity.
func (eauo *EnvAliasUpdateOne) SetEnv(e *Env) *EnvAliasUpdateOne {
	return eauo.SetEnvID(e.ID)
}

// Mutation returns the EnvAliasMutation object of the builder.
func (eauo *EnvAliasUpdateOne) Mutation() *EnvAliasMutation {
	return eauo.mutation
}

// ClearEnv clears the "env" edge to the Env entity.
func (eauo *EnvAliasUpdateOne) ClearEnv() *EnvAliasUpdateOne {
	eauo.mutation.ClearEnv()
	return eauo
}

// Where appends a list predicates to the EnvAliasUpdate builder.
func (eauo *EnvAliasUpdateOne) Where(ps ...predicate.EnvAlias) *EnvAliasUpdateOne {
	eauo.mutation.Where(ps...)
	return eauo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (eauo *EnvAliasUpdateOne) Select(field string, fields ...string) *EnvAliasUpdateOne {
	eauo.fields = append([]string{field}, fields...)
	return eauo
}

// Save executes the query and returns the updated EnvAlias entity.
func (eauo *EnvAliasUpdateOne) Save(ctx context.Context) (*EnvAlias, error) {
	return withHooks(ctx, eauo.sqlSave, eauo.mutation, eauo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (eauo *EnvAliasUpdateOne) SaveX(ctx context.Context) *EnvAlias {
	node, err := eauo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (eauo *EnvAliasUpdateOne) Exec(ctx context.Context) error {
	_, err := eauo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (eauo *EnvAliasUpdateOne) ExecX(ctx context.Context) {
	if err := eauo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (eauo *EnvAliasUpdateOne) check() error {
	if _, ok := eauo.mutation.EnvID(); eauo.mutation.EnvCleared() && !ok {
		return errors.New(`models: clearing a required unique edge "EnvAlias.env"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (eauo *EnvAliasUpdateOne) Modify(modifiers ...func(u *sql.UpdateBuilder)) *EnvAliasUpdateOne {
	eauo.modifiers = append(eauo.modifiers, modifiers...)
	return eauo
}

func (eauo *EnvAliasUpdateOne) sqlSave(ctx context.Context) (_node *EnvAlias, err error) {
	if err := eauo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(envalias.Table, envalias.Columns, sqlgraph.NewFieldSpec(envalias.FieldID, field.TypeString))
	id, ok := eauo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`models: missing "EnvAlias.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := eauo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, envalias.FieldID)
		for _, f := range fields {
			if !envalias.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
			}
			if f != envalias.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := eauo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := eauo.mutation.IsRenamable(); ok {
		_spec.SetField(envalias.FieldIsRenamable, field.TypeBool, value)
	}
	if eauo.mutation.EnvCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   envalias.EnvTable,
			Columns: []string{envalias.EnvColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = eauo.schemaConfig.EnvAlias
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eauo.mutation.EnvIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   envalias.EnvTable,
			Columns: []string{envalias.EnvColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = eauo.schemaConfig.EnvAlias
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = eauo.schemaConfig.EnvAlias
	ctx = internal.NewSchemaConfigContext(ctx, eauo.schemaConfig)
	_spec.AddModifiers(eauo.modifiers...)
	_node = &EnvAlias{config: eauo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, eauo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{envalias.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	eauo.mutation.done = true
	return _node, nil
}



================================================
File: models/envbuild.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envbuild"
	"github.com/google/uuid"
)

// EnvBuild is the model entity for the EnvBuild schema.
type EnvBuild struct {
	config `json:"-"`
	// ID of the ent.
	ID uuid.UUID `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// FinishedAt holds the value of the "finished_at" field.
	FinishedAt *time.Time `json:"finished_at,omitempty"`
	// EnvID holds the value of the "env_id" field.
	EnvID *string `json:"env_id,omitempty"`
	// Status holds the value of the "status" field.
	Status envbuild.Status `json:"status,omitempty"`
	// Dockerfile holds the value of the "dockerfile" field.
	Dockerfile *string `json:"dockerfile,omitempty"`
	// StartCmd holds the value of the "start_cmd" field.
	StartCmd *string `json:"start_cmd,omitempty"`
	// Vcpu holds the value of the "vcpu" field.
	Vcpu int64 `json:"vcpu,omitempty"`
	// RAMMB holds the value of the "ram_mb" field.
	RAMMB int64 `json:"ram_mb,omitempty"`
	// FreeDiskSizeMB holds the value of the "free_disk_size_mb" field.
	FreeDiskSizeMB int64 `json:"free_disk_size_mb,omitempty"`
	// TotalDiskSizeMB holds the value of the "total_disk_size_mb" field.
	TotalDiskSizeMB *int64 `json:"total_disk_size_mb,omitempty"`
	// KernelVersion holds the value of the "kernel_version" field.
	KernelVersion string `json:"kernel_version,omitempty"`
	// FirecrackerVersion holds the value of the "firecracker_version" field.
	FirecrackerVersion string `json:"firecracker_version,omitempty"`
	// EnvdVersion holds the value of the "envd_version" field.
	EnvdVersion *string `json:"envd_version,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the EnvBuildQuery when eager-loading is set.
	Edges        EnvBuildEdges `json:"edges"`
	selectValues sql.SelectValues
}

// EnvBuildEdges holds the relations/edges for other nodes in the graph.
type EnvBuildEdges struct {
	// Env holds the value of the env edge.
	Env *Env `json:"env,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// EnvOrErr returns the Env value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e EnvBuildEdges) EnvOrErr() (*Env, error) {
	if e.loadedTypes[0] {
		if e.Env == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: env.Label}
		}
		return e.Env, nil
	}
	return nil, &NotLoadedError{edge: "env"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*EnvBuild) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case envbuild.FieldVcpu, envbuild.FieldRAMMB, envbuild.FieldFreeDiskSizeMB, envbuild.FieldTotalDiskSizeMB:
			values[i] = new(sql.NullInt64)
		case envbuild.FieldEnvID, envbuild.FieldStatus, envbuild.FieldDockerfile, envbuild.FieldStartCmd, envbuild.FieldKernelVersion, envbuild.FieldFirecrackerVersion, envbuild.FieldEnvdVersion:
			values[i] = new(sql.NullString)
		case envbuild.FieldCreatedAt, envbuild.FieldUpdatedAt, envbuild.FieldFinishedAt:
			values[i] = new(sql.NullTime)
		case envbuild.FieldID:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the EnvBuild fields.
func (eb *EnvBuild) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case envbuild.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				eb.ID = *value
			}
		case envbuild.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				eb.CreatedAt = value.Time
			}
		case envbuild.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				eb.UpdatedAt = value.Time
			}
		case envbuild.FieldFinishedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field finished_at", values[i])
			} else if value.Valid {
				eb.FinishedAt = new(time.Time)
				*eb.FinishedAt = value.Time
			}
		case envbuild.FieldEnvID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field env_id", values[i])
			} else if value.Valid {
				eb.EnvID = new(string)
				*eb.EnvID = value.String
			}
		case envbuild.FieldStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				eb.Status = envbuild.Status(value.String)
			}
		case envbuild.FieldDockerfile:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field dockerfile", values[i])
			} else if value.Valid {
				eb.Dockerfile = new(string)
				*eb.Dockerfile = value.String
			}
		case envbuild.FieldStartCmd:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field start_cmd", values[i])
			} else if value.Valid {
				eb.StartCmd = new(string)
				*eb.StartCmd = value.String
			}
		case envbuild.FieldVcpu:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field vcpu", values[i])
			} else if value.Valid {
				eb.Vcpu = value.Int64
			}
		case envbuild.FieldRAMMB:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field ram_mb", values[i])
			} else if value.Valid {
				eb.RAMMB = value.Int64
			}
		case envbuild.FieldFreeDiskSizeMB:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field free_disk_size_mb", values[i])
			} else if value.Valid {
				eb.FreeDiskSizeMB = value.Int64
			}
		case envbuild.FieldTotalDiskSizeMB:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field total_disk_size_mb", values[i])
			} else if value.Valid {
				eb.TotalDiskSizeMB = new(int64)
				*eb.TotalDiskSizeMB = value.Int64
			}
		case envbuild.FieldKernelVersion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field kernel_version", values[i])
			} else if value.Valid {
				eb.KernelVersion = value.String
			}
		case envbuild.FieldFirecrackerVersion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field firecracker_version", values[i])
			} else if value.Valid {
				eb.FirecrackerVersion = value.String
			}
		case envbuild.FieldEnvdVersion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field envd_version", values[i])
			} else if value.Valid {
				eb.EnvdVersion = new(string)
				*eb.EnvdVersion = value.String
			}
		default:
			eb.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the EnvBuild.
// This includes values selected through modifiers, order, etc.
func (eb *EnvBuild) Value(name string) (ent.Value, error) {
	return eb.selectValues.Get(name)
}

// QueryEnv queries the "env" edge of the EnvBuild entity.
func (eb *EnvBuild) QueryEnv() *EnvQuery {
	return NewEnvBuildClient(eb.config).QueryEnv(eb)
}

// Update returns a builder for updating this EnvBuild.
// Note that you need to call EnvBuild.Unwrap() before calling this method if this EnvBuild
// was returned from a transaction, and the transaction was committed or rolled back.
func (eb *EnvBuild) Update() *EnvBuildUpdateOne {
	return NewEnvBuildClient(eb.config).UpdateOne(eb)
}

// Unwrap unwraps the EnvBuild entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (eb *EnvBuild) Unwrap() *EnvBuild {
	_tx, ok := eb.config.driver.(*txDriver)
	if !ok {
		panic("models: EnvBuild is not a transactional entity")
	}
	eb.config.driver = _tx.drv
	return eb
}

// String implements the fmt.Stringer.
func (eb *EnvBuild) String() string {
	var builder strings.Builder
	builder.WriteString("EnvBuild(")
	builder.WriteString(fmt.Sprintf("id=%v, ", eb.ID))
	builder.WriteString("created_at=")
	builder.WriteString(eb.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(eb.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	if v := eb.FinishedAt; v != nil {
		builder.WriteString("finished_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := eb.EnvID; v != nil {
		builder.WriteString("env_id=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(fmt.Sprintf("%v", eb.Status))
	builder.WriteString(", ")
	if v := eb.Dockerfile; v != nil {
		builder.WriteString("dockerfile=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := eb.StartCmd; v != nil {
		builder.WriteString("start_cmd=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("vcpu=")
	builder.WriteString(fmt.Sprintf("%v", eb.Vcpu))
	builder.WriteString(", ")
	builder.WriteString("ram_mb=")
	builder.WriteString(fmt.Sprintf("%v", eb.RAMMB))
	builder.WriteString(", ")
	builder.WriteString("free_disk_size_mb=")
	builder.WriteString(fmt.Sprintf("%v", eb.FreeDiskSizeMB))
	builder.WriteString(", ")
	if v := eb.TotalDiskSizeMB; v != nil {
		builder.WriteString("total_disk_size_mb=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("kernel_version=")
	builder.WriteString(eb.KernelVersion)
	builder.WriteString(", ")
	builder.WriteString("firecracker_version=")
	builder.WriteString(eb.FirecrackerVersion)
	builder.WriteString(", ")
	if v := eb.EnvdVersion; v != nil {
		builder.WriteString("envd_version=")
		builder.WriteString(*v)
	}
	builder.WriteByte(')')
	return builder.String()
}

// EnvBuilds is a parsable slice of EnvBuild.
type EnvBuilds []*EnvBuild



================================================
File: models/envbuild_create.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envbuild"
	"github.com/google/uuid"
)

// EnvBuildCreate is the builder for creating a EnvBuild entity.
type EnvBuildCreate struct {
	config
	mutation *EnvBuildMutation
	hooks    []Hook
	conflict []sql.ConflictOption
}

// SetCreatedAt sets the "created_at" field.
func (ebc *EnvBuildCreate) SetCreatedAt(t time.Time) *EnvBuildCreate {
	ebc.mutation.SetCreatedAt(t)
	return ebc
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (ebc *EnvBuildCreate) SetNillableCreatedAt(t *time.Time) *EnvBuildCreate {
	if t != nil {
		ebc.SetCreatedAt(*t)
	}
	return ebc
}

// SetUpdatedAt sets the "updated_at" field.
func (ebc *EnvBuildCreate) SetUpdatedAt(t time.Time) *EnvBuildCreate {
	ebc.mutation.SetUpdatedAt(t)
	return ebc
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (ebc *EnvBuildCreate) SetNillableUpdatedAt(t *time.Time) *EnvBuildCreate {
	if t != nil {
		ebc.SetUpdatedAt(*t)
	}
	return ebc
}

// SetFinishedAt sets the "finished_at" field.
func (ebc *EnvBuildCreate) SetFinishedAt(t time.Time) *EnvBuildCreate {
	ebc.mutation.SetFinishedAt(t)
	return ebc
}

// SetNillableFinishedAt sets the "finished_at" field if the given value is not nil.
func (ebc *EnvBuildCreate) SetNillableFinishedAt(t *time.Time) *EnvBuildCreate {
	if t != nil {
		ebc.SetFinishedAt(*t)
	}
	return ebc
}

// SetEnvID sets the "env_id" field.
func (ebc *EnvBuildCreate) SetEnvID(s string) *EnvBuildCreate {
	ebc.mutation.SetEnvID(s)
	return ebc
}

// SetNillableEnvID sets the "env_id" field if the given value is not nil.
func (ebc *EnvBuildCreate) SetNillableEnvID(s *string) *EnvBuildCreate {
	if s != nil {
		ebc.SetEnvID(*s)
	}
	return ebc
}

// SetStatus sets the "status" field.
func (ebc *EnvBuildCreate) SetStatus(e envbuild.Status) *EnvBuildCreate {
	ebc.mutation.SetStatus(e)
	return ebc
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (ebc *EnvBuildCreate) SetNillableStatus(e *envbuild.Status) *EnvBuildCreate {
	if e != nil {
		ebc.SetStatus(*e)
	}
	return ebc
}

// SetDockerfile sets the "dockerfile" field.
func (ebc *EnvBuildCreate) SetDockerfile(s string) *EnvBuildCreate {
	ebc.mutation.SetDockerfile(s)
	return ebc
}

// SetNillableDockerfile sets the "dockerfile" field if the given value is not nil.
func (ebc *EnvBuildCreate) SetNillableDockerfile(s *string) *EnvBuildCreate {
	if s != nil {
		ebc.SetDockerfile(*s)
	}
	return ebc
}

// SetStartCmd sets the "start_cmd" field.
func (ebc *EnvBuildCreate) SetStartCmd(s string) *EnvBuildCreate {
	ebc.mutation.SetStartCmd(s)
	return ebc
}

// SetNillableStartCmd sets the "start_cmd" field if the given value is not nil.
func (ebc *EnvBuildCreate) SetNillableStartCmd(s *string) *EnvBuildCreate {
	if s != nil {
		ebc.SetStartCmd(*s)
	}
	return ebc
}

// SetVcpu sets the "vcpu" field.
func (ebc *EnvBuildCreate) SetVcpu(i int64) *EnvBuildCreate {
	ebc.mutation.SetVcpu(i)
	return ebc
}

// SetRAMMB sets the "ram_mb" field.
func (ebc *EnvBuildCreate) SetRAMMB(i int64) *EnvBuildCreate {
	ebc.mutation.SetRAMMB(i)
	return ebc
}

// SetFreeDiskSizeMB sets the "free_disk_size_mb" field.
func (ebc *EnvBuildCreate) SetFreeDiskSizeMB(i int64) *EnvBuildCreate {
	ebc.mutation.SetFreeDiskSizeMB(i)
	return ebc
}

// SetTotalDiskSizeMB sets the "total_disk_size_mb" field.
func (ebc *EnvBuildCreate) SetTotalDiskSizeMB(i int64) *EnvBuildCreate {
	ebc.mutation.SetTotalDiskSizeMB(i)
	return ebc
}

// SetNillableTotalDiskSizeMB sets the "total_disk_size_mb" field if the given value is not nil.
func (ebc *EnvBuildCreate) SetNillableTotalDiskSizeMB(i *int64) *EnvBuildCreate {
	if i != nil {
		ebc.SetTotalDiskSizeMB(*i)
	}
	return ebc
}

// SetKernelVersion sets the "kernel_version" field.
func (ebc *EnvBuildCreate) SetKernelVersion(s string) *EnvBuildCreate {
	ebc.mutation.SetKernelVersion(s)
	return ebc
}

// SetNillableKernelVersion sets the "kernel_version" field if the given value is not nil.
func (ebc *EnvBuildCreate) SetNillableKernelVersion(s *string) *EnvBuildCreate {
	if s != nil {
		ebc.SetKernelVersion(*s)
	}
	return ebc
}

// SetFirecrackerVersion sets the "firecracker_version" field.
func (ebc *EnvBuildCreate) SetFirecrackerVersion(s string) *EnvBuildCreate {
	ebc.mutation.SetFirecrackerVersion(s)
	return ebc
}

// SetNillableFirecrackerVersion sets the "firecracker_version" field if the given value is not nil.
func (ebc *EnvBuildCreate) SetNillableFirecrackerVersion(s *string) *EnvBuildCreate {
	if s != nil {
		ebc.SetFirecrackerVersion(*s)
	}
	return ebc
}

// SetEnvdVersion sets the "envd_version" field.
func (ebc *EnvBuildCreate) SetEnvdVersion(s string) *EnvBuildCreate {
	ebc.mutation.SetEnvdVersion(s)
	return ebc
}

// SetNillableEnvdVersion sets the "envd_version" field if the given value is not nil.
func (ebc *EnvBuildCreate) SetNillableEnvdVersion(s *string) *EnvBuildCreate {
	if s != nil {
		ebc.SetEnvdVersion(*s)
	}
	return ebc
}

// SetID sets the "id" field.
func (ebc *EnvBuildCreate) SetID(u uuid.UUID) *EnvBuildCreate {
	ebc.mutation.SetID(u)
	return ebc
}

// SetEnv sets the "env" edge to the Env entity.
func (ebc *EnvBuildCreate) SetEnv(e *Env) *EnvBuildCreate {
	return ebc.SetEnvID(e.ID)
}

// Mutation returns the EnvBuildMutation object of the builder.
func (ebc *EnvBuildCreate) Mutation() *EnvBuildMutation {
	return ebc.mutation
}

// Save creates the EnvBuild in the database.
func (ebc *EnvBuildCreate) Save(ctx context.Context) (*EnvBuild, error) {
	ebc.defaults()
	return withHooks(ctx, ebc.sqlSave, ebc.mutation, ebc.hooks)
}

// SaveX calls Save and panics if Save returns an error.
func (ebc *EnvBuildCreate) SaveX(ctx context.Context) *EnvBuild {
	v, err := ebc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (ebc *EnvBuildCreate) Exec(ctx context.Context) error {
	_, err := ebc.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ebc *EnvBuildCreate) ExecX(ctx context.Context) {
	if err := ebc.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (ebc *EnvBuildCreate) defaults() {
	if _, ok := ebc.mutation.CreatedAt(); !ok {
		v := envbuild.DefaultCreatedAt()
		ebc.mutation.SetCreatedAt(v)
	}
	if _, ok := ebc.mutation.UpdatedAt(); !ok {
		v := envbuild.DefaultUpdatedAt()
		ebc.mutation.SetUpdatedAt(v)
	}
	if _, ok := ebc.mutation.Status(); !ok {
		v := envbuild.DefaultStatus
		ebc.mutation.SetStatus(v)
	}
	if _, ok := ebc.mutation.KernelVersion(); !ok {
		v := envbuild.DefaultKernelVersion
		ebc.mutation.SetKernelVersion(v)
	}
	if _, ok := ebc.mutation.FirecrackerVersion(); !ok {
		v := envbuild.DefaultFirecrackerVersion
		ebc.mutation.SetFirecrackerVersion(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (ebc *EnvBuildCreate) check() error {
	if _, ok := ebc.mutation.CreatedAt(); !ok {
		return &ValidationError{Name: "created_at", err: errors.New(`models: missing required field "EnvBuild.created_at"`)}
	}
	if _, ok := ebc.mutation.UpdatedAt(); !ok {
		return &ValidationError{Name: "updated_at", err: errors.New(`models: missing required field "EnvBuild.updated_at"`)}
	}
	if _, ok := ebc.mutation.Status(); !ok {
		return &ValidationError{Name: "status", err: errors.New(`models: missing required field "EnvBuild.status"`)}
	}
	if v, ok := ebc.mutation.Status(); ok {
		if err := envbuild.StatusValidator(v); err != nil {
			return &ValidationError{Name: "status", err: fmt.Errorf(`models: validator failed for field "EnvBuild.status": %w`, err)}
		}
	}
	if _, ok := ebc.mutation.Vcpu(); !ok {
		return &ValidationError{Name: "vcpu", err: errors.New(`models: missing required field "EnvBuild.vcpu"`)}
	}
	if _, ok := ebc.mutation.RAMMB(); !ok {
		return &ValidationError{Name: "ram_mb", err: errors.New(`models: missing required field "EnvBuild.ram_mb"`)}
	}
	if _, ok := ebc.mutation.FreeDiskSizeMB(); !ok {
		return &ValidationError{Name: "free_disk_size_mb", err: errors.New(`models: missing required field "EnvBuild.free_disk_size_mb"`)}
	}
	if _, ok := ebc.mutation.KernelVersion(); !ok {
		return &ValidationError{Name: "kernel_version", err: errors.New(`models: missing required field "EnvBuild.kernel_version"`)}
	}
	if _, ok := ebc.mutation.FirecrackerVersion(); !ok {
		return &ValidationError{Name: "firecracker_version", err: errors.New(`models: missing required field "EnvBuild.firecracker_version"`)}
	}
	return nil
}

func (ebc *EnvBuildCreate) sqlSave(ctx context.Context) (*EnvBuild, error) {
	if err := ebc.check(); err != nil {
		return nil, err
	}
	_node, _spec := ebc.createSpec()
	if err := sqlgraph.CreateNode(ctx, ebc.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	if _spec.ID.Value != nil {
		if id, ok := _spec.ID.Value.(*uuid.UUID); ok {
			_node.ID = *id
		} else if err := _node.ID.Scan(_spec.ID.Value); err != nil {
			return nil, err
		}
	}
	ebc.mutation.id = &_node.ID
	ebc.mutation.done = true
	return _node, nil
}

func (ebc *EnvBuildCreate) createSpec() (*EnvBuild, *sqlgraph.CreateSpec) {
	var (
		_node = &EnvBuild{config: ebc.config}
		_spec = sqlgraph.NewCreateSpec(envbuild.Table, sqlgraph.NewFieldSpec(envbuild.FieldID, field.TypeUUID))
	)
	_spec.Schema = ebc.schemaConfig.EnvBuild
	_spec.OnConflict = ebc.conflict
	if id, ok := ebc.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = &id
	}
	if value, ok := ebc.mutation.CreatedAt(); ok {
		_spec.SetField(envbuild.FieldCreatedAt, field.TypeTime, value)
		_node.CreatedAt = value
	}
	if value, ok := ebc.mutation.UpdatedAt(); ok {
		_spec.SetField(envbuild.FieldUpdatedAt, field.TypeTime, value)
		_node.UpdatedAt = value
	}
	if value, ok := ebc.mutation.FinishedAt(); ok {
		_spec.SetField(envbuild.FieldFinishedAt, field.TypeTime, value)
		_node.FinishedAt = &value
	}
	if value, ok := ebc.mutation.Status(); ok {
		_spec.SetField(envbuild.FieldStatus, field.TypeEnum, value)
		_node.Status = value
	}
	if value, ok := ebc.mutation.Dockerfile(); ok {
		_spec.SetField(envbuild.FieldDockerfile, field.TypeString, value)
		_node.Dockerfile = &value
	}
	if value, ok := ebc.mutation.StartCmd(); ok {
		_spec.SetField(envbuild.FieldStartCmd, field.TypeString, value)
		_node.StartCmd = &value
	}
	if value, ok := ebc.mutation.Vcpu(); ok {
		_spec.SetField(envbuild.FieldVcpu, field.TypeInt64, value)
		_node.Vcpu = value
	}
	if value, ok := ebc.mutation.RAMMB(); ok {
		_spec.SetField(envbuild.FieldRAMMB, field.TypeInt64, value)
		_node.RAMMB = value
	}
	if value, ok := ebc.mutation.FreeDiskSizeMB(); ok {
		_spec.SetField(envbuild.FieldFreeDiskSizeMB, field.TypeInt64, value)
		_node.FreeDiskSizeMB = value
	}
	if value, ok := ebc.mutation.TotalDiskSizeMB(); ok {
		_spec.SetField(envbuild.FieldTotalDiskSizeMB, field.TypeInt64, value)
		_node.TotalDiskSizeMB = &value
	}
	if value, ok := ebc.mutation.KernelVersion(); ok {
		_spec.SetField(envbuild.FieldKernelVersion, field.TypeString, value)
		_node.KernelVersion = value
	}
	if value, ok := ebc.mutation.FirecrackerVersion(); ok {
		_spec.SetField(envbuild.FieldFirecrackerVersion, field.TypeString, value)
		_node.FirecrackerVersion = value
	}
	if value, ok := ebc.mutation.EnvdVersion(); ok {
		_spec.SetField(envbuild.FieldEnvdVersion, field.TypeString, value)
		_node.EnvdVersion = &value
	}
	if nodes := ebc.mutation.EnvIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   envbuild.EnvTable,
			Columns: []string{envbuild.EnvColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = ebc.schemaConfig.EnvBuild
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.EnvID = &nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.EnvBuild.Create().
//		SetCreatedAt(v).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.EnvBuildUpsert) {
//			SetCreatedAt(v+v).
//		}).
//		Exec(ctx)
func (ebc *EnvBuildCreate) OnConflict(opts ...sql.ConflictOption) *EnvBuildUpsertOne {
	ebc.conflict = opts
	return &EnvBuildUpsertOne{
		create: ebc,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.EnvBuild.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (ebc *EnvBuildCreate) OnConflictColumns(columns ...string) *EnvBuildUpsertOne {
	ebc.conflict = append(ebc.conflict, sql.ConflictColumns(columns...))
	return &EnvBuildUpsertOne{
		create: ebc,
	}
}

type (
	// EnvBuildUpsertOne is the builder for "upsert"-ing
	//  one EnvBuild node.
	EnvBuildUpsertOne struct {
		create *EnvBuildCreate
	}

	// EnvBuildUpsert is the "OnConflict" setter.
	EnvBuildUpsert struct {
		*sql.UpdateSet
	}
)

// SetUpdatedAt sets the "updated_at" field.
func (u *EnvBuildUpsert) SetUpdatedAt(v time.Time) *EnvBuildUpsert {
	u.Set(envbuild.FieldUpdatedAt, v)
	return u
}

// UpdateUpdatedAt sets the "updated_at" field to the value that was provided on create.
func (u *EnvBuildUpsert) UpdateUpdatedAt() *EnvBuildUpsert {
	u.SetExcluded(envbuild.FieldUpdatedAt)
	return u
}

// SetFinishedAt sets the "finished_at" field.
func (u *EnvBuildUpsert) SetFinishedAt(v time.Time) *EnvBuildUpsert {
	u.Set(envbuild.FieldFinishedAt, v)
	return u
}

// UpdateFinishedAt sets the "finished_at" field to the value that was provided on create.
func (u *EnvBuildUpsert) UpdateFinishedAt() *EnvBuildUpsert {
	u.SetExcluded(envbuild.FieldFinishedAt)
	return u
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (u *EnvBuildUpsert) ClearFinishedAt() *EnvBuildUpsert {
	u.SetNull(envbuild.FieldFinishedAt)
	return u
}

// SetEnvID sets the "env_id" field.
func (u *EnvBuildUpsert) SetEnvID(v string) *EnvBuildUpsert {
	u.Set(envbuild.FieldEnvID, v)
	return u
}

// UpdateEnvID sets the "env_id" field to the value that was provided on create.
func (u *EnvBuildUpsert) UpdateEnvID() *EnvBuildUpsert {
	u.SetExcluded(envbuild.FieldEnvID)
	return u
}

// ClearEnvID clears the value of the "env_id" field.
func (u *EnvBuildUpsert) ClearEnvID() *EnvBuildUpsert {
	u.SetNull(envbuild.FieldEnvID)
	return u
}

// SetStatus sets the "status" field.
func (u *EnvBuildUpsert) SetStatus(v envbuild.Status) *EnvBuildUpsert {
	u.Set(envbuild.FieldStatus, v)
	return u
}

// UpdateStatus sets the "status" field to the value that was provided on create.
func (u *EnvBuildUpsert) UpdateStatus() *EnvBuildUpsert {
	u.SetExcluded(envbuild.FieldStatus)
	return u
}

// SetDockerfile sets the "dockerfile" field.
func (u *EnvBuildUpsert) SetDockerfile(v string) *EnvBuildUpsert {
	u.Set(envbuild.FieldDockerfile, v)
	return u
}

// UpdateDockerfile sets the "dockerfile" field to the value that was provided on create.
func (u *EnvBuildUpsert) UpdateDockerfile() *EnvBuildUpsert {
	u.SetExcluded(envbuild.FieldDockerfile)
	return u
}

// ClearDockerfile clears the value of the "dockerfile" field.
func (u *EnvBuildUpsert) ClearDockerfile() *EnvBuildUpsert {
	u.SetNull(envbuild.FieldDockerfile)
	return u
}

// SetStartCmd sets the "start_cmd" field.
func (u *EnvBuildUpsert) SetStartCmd(v string) *EnvBuildUpsert {
	u.Set(envbuild.FieldStartCmd, v)
	return u
}

// UpdateStartCmd sets the "start_cmd" field to the value that was provided on create.
func (u *EnvBuildUpsert) UpdateStartCmd() *EnvBuildUpsert {
	u.SetExcluded(envbuild.FieldStartCmd)
	return u
}

// ClearStartCmd clears the value of the "start_cmd" field.
func (u *EnvBuildUpsert) ClearStartCmd() *EnvBuildUpsert {
	u.SetNull(envbuild.FieldStartCmd)
	return u
}

// SetVcpu sets the "vcpu" field.
func (u *EnvBuildUpsert) SetVcpu(v int64) *EnvBuildUpsert {
	u.Set(envbuild.FieldVcpu, v)
	return u
}

// UpdateVcpu sets the "vcpu" field to the value that was provided on create.
func (u *EnvBuildUpsert) UpdateVcpu() *EnvBuildUpsert {
	u.SetExcluded(envbuild.FieldVcpu)
	return u
}

// AddVcpu adds v to the "vcpu" field.
func (u *EnvBuildUpsert) AddVcpu(v int64) *EnvBuildUpsert {
	u.Add(envbuild.FieldVcpu, v)
	return u
}

// SetRAMMB sets the "ram_mb" field.
func (u *EnvBuildUpsert) SetRAMMB(v int64) *EnvBuildUpsert {
	u.Set(envbuild.FieldRAMMB, v)
	return u
}

// UpdateRAMMB sets the "ram_mb" field to the value that was provided on create.
func (u *EnvBuildUpsert) UpdateRAMMB() *EnvBuildUpsert {
	u.SetExcluded(envbuild.FieldRAMMB)
	return u
}

// AddRAMMB adds v to the "ram_mb" field.
func (u *EnvBuildUpsert) AddRAMMB(v int64) *EnvBuildUpsert {
	u.Add(envbuild.FieldRAMMB, v)
	return u
}

// SetFreeDiskSizeMB sets the "free_disk_size_mb" field.
func (u *EnvBuildUpsert) SetFreeDiskSizeMB(v int64) *EnvBuildUpsert {
	u.Set(envbuild.FieldFreeDiskSizeMB, v)
	return u
}

// UpdateFreeDiskSizeMB sets the "free_disk_size_mb" field to the value that was provided on create.
func (u *EnvBuildUpsert) UpdateFreeDiskSizeMB() *EnvBuildUpsert {
	u.SetExcluded(envbuild.FieldFreeDiskSizeMB)
	return u
}

// AddFreeDiskSizeMB adds v to the "free_disk_size_mb" field.
func (u *EnvBuildUpsert) AddFreeDiskSizeMB(v int64) *EnvBuildUpsert {
	u.Add(envbuild.FieldFreeDiskSizeMB, v)
	return u
}

// SetTotalDiskSizeMB sets the "total_disk_size_mb" field.
func (u *EnvBuildUpsert) SetTotalDiskSizeMB(v int64) *EnvBuildUpsert {
	u.Set(envbuild.FieldTotalDiskSizeMB, v)
	return u
}

// UpdateTotalDiskSizeMB sets the "total_disk_size_mb" field to the value that was provided on create.
func (u *EnvBuildUpsert) UpdateTotalDiskSizeMB() *EnvBuildUpsert {
	u.SetExcluded(envbuild.FieldTotalDiskSizeMB)
	return u
}

// AddTotalDiskSizeMB adds v to the "total_disk_size_mb" field.
func (u *EnvBuildUpsert) AddTotalDiskSizeMB(v int64) *EnvBuildUpsert {
	u.Add(envbuild.FieldTotalDiskSizeMB, v)
	return u
}

// ClearTotalDiskSizeMB clears the value of the "total_disk_size_mb" field.
func (u *EnvBuildUpsert) ClearTotalDiskSizeMB() *EnvBuildUpsert {
	u.SetNull(envbuild.FieldTotalDiskSizeMB)
	return u
}

// SetKernelVersion sets the "kernel_version" field.
func (u *EnvBuildUpsert) SetKernelVersion(v string) *EnvBuildUpsert {
	u.Set(envbuild.FieldKernelVersion, v)
	return u
}

// UpdateKernelVersion sets the "kernel_version" field to the value that was provided on create.
func (u *EnvBuildUpsert) UpdateKernelVersion() *EnvBuildUpsert {
	u.SetExcluded(envbuild.FieldKernelVersion)
	return u
}

// SetFirecrackerVersion sets the "firecracker_version" field.
func (u *EnvBuildUpsert) SetFirecrackerVersion(v string) *EnvBuildUpsert {
	u.Set(envbuild.FieldFirecrackerVersion, v)
	return u
}

// UpdateFirecrackerVersion sets the "firecracker_version" field to the value that was provided on create.
func (u *EnvBuildUpsert) UpdateFirecrackerVersion() *EnvBuildUpsert {
	u.SetExcluded(envbuild.FieldFirecrackerVersion)
	return u
}

// SetEnvdVersion sets the "envd_version" field.
func (u *EnvBuildUpsert) SetEnvdVersion(v string) *EnvBuildUpsert {
	u.Set(envbuild.FieldEnvdVersion, v)
	return u
}

// UpdateEnvdVersion sets the "envd_version" field to the value that was provided on create.
func (u *EnvBuildUpsert) UpdateEnvdVersion() *EnvBuildUpsert {
	u.SetExcluded(envbuild.FieldEnvdVersion)
	return u
}

// ClearEnvdVersion clears the value of the "envd_version" field.
func (u *EnvBuildUpsert) ClearEnvdVersion() *EnvBuildUpsert {
	u.SetNull(envbuild.FieldEnvdVersion)
	return u
}

// UpdateNewValues updates the mutable fields using the new values that were set on create except the ID field.
// Using this option is equivalent to using:
//
//	client.EnvBuild.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(envbuild.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *EnvBuildUpsertOne) UpdateNewValues() *EnvBuildUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		if _, exists := u.create.mutation.ID(); exists {
			s.SetIgnore(envbuild.FieldID)
		}
		if _, exists := u.create.mutation.CreatedAt(); exists {
			s.SetIgnore(envbuild.FieldCreatedAt)
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.EnvBuild.Create().
//	    OnConflict(sql.ResolveWithIgnore()).
//	    Exec(ctx)
func (u *EnvBuildUpsertOne) Ignore() *EnvBuildUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *EnvBuildUpsertOne) DoNothing() *EnvBuildUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the EnvBuildCreate.OnConflict
// documentation for more info.
func (u *EnvBuildUpsertOne) Update(set func(*EnvBuildUpsert)) *EnvBuildUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&EnvBuildUpsert{UpdateSet: update})
	}))
	return u
}

// SetUpdatedAt sets the "updated_at" field.
func (u *EnvBuildUpsertOne) SetUpdatedAt(v time.Time) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetUpdatedAt(v)
	})
}

// UpdateUpdatedAt sets the "updated_at" field to the value that was provided on create.
func (u *EnvBuildUpsertOne) UpdateUpdatedAt() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateUpdatedAt()
	})
}

// SetFinishedAt sets the "finished_at" field.
func (u *EnvBuildUpsertOne) SetFinishedAt(v time.Time) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetFinishedAt(v)
	})
}

// UpdateFinishedAt sets the "finished_at" field to the value that was provided on create.
func (u *EnvBuildUpsertOne) UpdateFinishedAt() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateFinishedAt()
	})
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (u *EnvBuildUpsertOne) ClearFinishedAt() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.ClearFinishedAt()
	})
}

// SetEnvID sets the "env_id" field.
func (u *EnvBuildUpsertOne) SetEnvID(v string) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetEnvID(v)
	})
}

// UpdateEnvID sets the "env_id" field to the value that was provided on create.
func (u *EnvBuildUpsertOne) UpdateEnvID() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateEnvID()
	})
}

// ClearEnvID clears the value of the "env_id" field.
func (u *EnvBuildUpsertOne) ClearEnvID() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.ClearEnvID()
	})
}

// SetStatus sets the "status" field.
func (u *EnvBuildUpsertOne) SetStatus(v envbuild.Status) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetStatus(v)
	})
}

// UpdateStatus sets the "status" field to the value that was provided on create.
func (u *EnvBuildUpsertOne) UpdateStatus() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateStatus()
	})
}

// SetDockerfile sets the "dockerfile" field.
func (u *EnvBuildUpsertOne) SetDockerfile(v string) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetDockerfile(v)
	})
}

// UpdateDockerfile sets the "dockerfile" field to the value that was provided on create.
func (u *EnvBuildUpsertOne) UpdateDockerfile() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateDockerfile()
	})
}

// ClearDockerfile clears the value of the "dockerfile" field.
func (u *EnvBuildUpsertOne) ClearDockerfile() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.ClearDockerfile()
	})
}

// SetStartCmd sets the "start_cmd" field.
func (u *EnvBuildUpsertOne) SetStartCmd(v string) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetStartCmd(v)
	})
}

// UpdateStartCmd sets the "start_cmd" field to the value that was provided on create.
func (u *EnvBuildUpsertOne) UpdateStartCmd() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateStartCmd()
	})
}

// ClearStartCmd clears the value of the "start_cmd" field.
func (u *EnvBuildUpsertOne) ClearStartCmd() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.ClearStartCmd()
	})
}

// SetVcpu sets the "vcpu" field.
func (u *EnvBuildUpsertOne) SetVcpu(v int64) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetVcpu(v)
	})
}

// AddVcpu adds v to the "vcpu" field.
func (u *EnvBuildUpsertOne) AddVcpu(v int64) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.AddVcpu(v)
	})
}

// UpdateVcpu sets the "vcpu" field to the value that was provided on create.
func (u *EnvBuildUpsertOne) UpdateVcpu() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateVcpu()
	})
}

// SetRAMMB sets the "ram_mb" field.
func (u *EnvBuildUpsertOne) SetRAMMB(v int64) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetRAMMB(v)
	})
}

// AddRAMMB adds v to the "ram_mb" field.
func (u *EnvBuildUpsertOne) AddRAMMB(v int64) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.AddRAMMB(v)
	})
}

// UpdateRAMMB sets the "ram_mb" field to the value that was provided on create.
func (u *EnvBuildUpsertOne) UpdateRAMMB() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateRAMMB()
	})
}

// SetFreeDiskSizeMB sets the "free_disk_size_mb" field.
func (u *EnvBuildUpsertOne) SetFreeDiskSizeMB(v int64) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetFreeDiskSizeMB(v)
	})
}

// AddFreeDiskSizeMB adds v to the "free_disk_size_mb" field.
func (u *EnvBuildUpsertOne) AddFreeDiskSizeMB(v int64) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.AddFreeDiskSizeMB(v)
	})
}

// UpdateFreeDiskSizeMB sets the "free_disk_size_mb" field to the value that was provided on create.
func (u *EnvBuildUpsertOne) UpdateFreeDiskSizeMB() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateFreeDiskSizeMB()
	})
}

// SetTotalDiskSizeMB sets the "total_disk_size_mb" field.
func (u *EnvBuildUpsertOne) SetTotalDiskSizeMB(v int64) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetTotalDiskSizeMB(v)
	})
}

// AddTotalDiskSizeMB adds v to the "total_disk_size_mb" field.
func (u *EnvBuildUpsertOne) AddTotalDiskSizeMB(v int64) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.AddTotalDiskSizeMB(v)
	})
}

// UpdateTotalDiskSizeMB sets the "total_disk_size_mb" field to the value that was provided on create.
func (u *EnvBuildUpsertOne) UpdateTotalDiskSizeMB() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateTotalDiskSizeMB()
	})
}

// ClearTotalDiskSizeMB clears the value of the "total_disk_size_mb" field.
func (u *EnvBuildUpsertOne) ClearTotalDiskSizeMB() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.ClearTotalDiskSizeMB()
	})
}

// SetKernelVersion sets the "kernel_version" field.
func (u *EnvBuildUpsertOne) SetKernelVersion(v string) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetKernelVersion(v)
	})
}

// UpdateKernelVersion sets the "kernel_version" field to the value that was provided on create.
func (u *EnvBuildUpsertOne) UpdateKernelVersion() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateKernelVersion()
	})
}

// SetFirecrackerVersion sets the "firecracker_version" field.
func (u *EnvBuildUpsertOne) SetFirecrackerVersion(v string) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetFirecrackerVersion(v)
	})
}

// UpdateFirecrackerVersion sets the "firecracker_version" field to the value that was provided on create.
func (u *EnvBuildUpsertOne) UpdateFirecrackerVersion() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateFirecrackerVersion()
	})
}

// SetEnvdVersion sets the "envd_version" field.
func (u *EnvBuildUpsertOne) SetEnvdVersion(v string) *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetEnvdVersion(v)
	})
}

// UpdateEnvdVersion sets the "envd_version" field to the value that was provided on create.
func (u *EnvBuildUpsertOne) UpdateEnvdVersion() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateEnvdVersion()
	})
}

// ClearEnvdVersion clears the value of the "envd_version" field.
func (u *EnvBuildUpsertOne) ClearEnvdVersion() *EnvBuildUpsertOne {
	return u.Update(func(s *EnvBuildUpsert) {
		s.ClearEnvdVersion()
	})
}

// Exec executes the query.
func (u *EnvBuildUpsertOne) Exec(ctx context.Context) error {
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for EnvBuildCreate.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *EnvBuildUpsertOne) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}

// Exec executes the UPSERT query and returns the inserted/updated ID.
func (u *EnvBuildUpsertOne) ID(ctx context.Context) (id uuid.UUID, err error) {
	if u.create.driver.Dialect() == dialect.MySQL {
		// In case of "ON CONFLICT", there is no way to get back non-numeric ID
		// fields from the database since MySQL does not support the RETURNING clause.
		return id, errors.New("models: EnvBuildUpsertOne.ID is not supported by MySQL driver. Use EnvBuildUpsertOne.Exec instead")
	}
	node, err := u.create.Save(ctx)
	if err != nil {
		return id, err
	}
	return node.ID, nil
}

// IDX is like ID, but panics if an error occurs.
func (u *EnvBuildUpsertOne) IDX(ctx context.Context) uuid.UUID {
	id, err := u.ID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// EnvBuildCreateBulk is the builder for creating many EnvBuild entities in bulk.
type EnvBuildCreateBulk struct {
	config
	err      error
	builders []*EnvBuildCreate
	conflict []sql.ConflictOption
}

// Save creates the EnvBuild entities in the database.
func (ebcb *EnvBuildCreateBulk) Save(ctx context.Context) ([]*EnvBuild, error) {
	if ebcb.err != nil {
		return nil, ebcb.err
	}
	specs := make([]*sqlgraph.CreateSpec, len(ebcb.builders))
	nodes := make([]*EnvBuild, len(ebcb.builders))
	mutators := make([]Mutator, len(ebcb.builders))
	for i := range ebcb.builders {
		func(i int, root context.Context) {
			builder := ebcb.builders[i]
			builder.defaults()
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*EnvBuildMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				var err error
				nodes[i], specs[i] = builder.createSpec()
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, ebcb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					spec.OnConflict = ebcb.conflict
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, ebcb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{msg: err.Error(), wrap: err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, ebcb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (ebcb *EnvBuildCreateBulk) SaveX(ctx context.Context) []*EnvBuild {
	v, err := ebcb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (ebcb *EnvBuildCreateBulk) Exec(ctx context.Context) error {
	_, err := ebcb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ebcb *EnvBuildCreateBulk) ExecX(ctx context.Context) {
	if err := ebcb.Exec(ctx); err != nil {
		panic(err)
	}
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.EnvBuild.CreateBulk(builders...).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.EnvBuildUpsert) {
//			SetCreatedAt(v+v).
//		}).
//		Exec(ctx)
func (ebcb *EnvBuildCreateBulk) OnConflict(opts ...sql.ConflictOption) *EnvBuildUpsertBulk {
	ebcb.conflict = opts
	return &EnvBuildUpsertBulk{
		create: ebcb,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.EnvBuild.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (ebcb *EnvBuildCreateBulk) OnConflictColumns(columns ...string) *EnvBuildUpsertBulk {
	ebcb.conflict = append(ebcb.conflict, sql.ConflictColumns(columns...))
	return &EnvBuildUpsertBulk{
		create: ebcb,
	}
}

// EnvBuildUpsertBulk is the builder for "upsert"-ing
// a bulk of EnvBuild nodes.
type EnvBuildUpsertBulk struct {
	create *EnvBuildCreateBulk
}

// UpdateNewValues updates the mutable fields using the new values that
// were set on create. Using this option is equivalent to using:
//
//	client.EnvBuild.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(envbuild.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *EnvBuildUpsertBulk) UpdateNewValues() *EnvBuildUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		for _, b := range u.create.builders {
			if _, exists := b.mutation.ID(); exists {
				s.SetIgnore(envbuild.FieldID)
			}
			if _, exists := b.mutation.CreatedAt(); exists {
				s.SetIgnore(envbuild.FieldCreatedAt)
			}
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.EnvBuild.Create().
//		OnConflict(sql.ResolveWithIgnore()).
//		Exec(ctx)
func (u *EnvBuildUpsertBulk) Ignore() *EnvBuildUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *EnvBuildUpsertBulk) DoNothing() *EnvBuildUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the EnvBuildCreateBulk.OnConflict
// documentation for more info.
func (u *EnvBuildUpsertBulk) Update(set func(*EnvBuildUpsert)) *EnvBuildUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&EnvBuildUpsert{UpdateSet: update})
	}))
	return u
}

// SetUpdatedAt sets the "updated_at" field.
func (u *EnvBuildUpsertBulk) SetUpdatedAt(v time.Time) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetUpdatedAt(v)
	})
}

// UpdateUpdatedAt sets the "updated_at" field to the value that was provided on create.
func (u *EnvBuildUpsertBulk) UpdateUpdatedAt() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateUpdatedAt()
	})
}

// SetFinishedAt sets the "finished_at" field.
func (u *EnvBuildUpsertBulk) SetFinishedAt(v time.Time) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetFinishedAt(v)
	})
}

// UpdateFinishedAt sets the "finished_at" field to the value that was provided on create.
func (u *EnvBuildUpsertBulk) UpdateFinishedAt() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateFinishedAt()
	})
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (u *EnvBuildUpsertBulk) ClearFinishedAt() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.ClearFinishedAt()
	})
}

// SetEnvID sets the "env_id" field.
func (u *EnvBuildUpsertBulk) SetEnvID(v string) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetEnvID(v)
	})
}

// UpdateEnvID sets the "env_id" field to the value that was provided on create.
func (u *EnvBuildUpsertBulk) UpdateEnvID() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateEnvID()
	})
}

// ClearEnvID clears the value of the "env_id" field.
func (u *EnvBuildUpsertBulk) ClearEnvID() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.ClearEnvID()
	})
}

// SetStatus sets the "status" field.
func (u *EnvBuildUpsertBulk) SetStatus(v envbuild.Status) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetStatus(v)
	})
}

// UpdateStatus sets the "status" field to the value that was provided on create.
func (u *EnvBuildUpsertBulk) UpdateStatus() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateStatus()
	})
}

// SetDockerfile sets the "dockerfile" field.
func (u *EnvBuildUpsertBulk) SetDockerfile(v string) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetDockerfile(v)
	})
}

// UpdateDockerfile sets the "dockerfile" field to the value that was provided on create.
func (u *EnvBuildUpsertBulk) UpdateDockerfile() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateDockerfile()
	})
}

// ClearDockerfile clears the value of the "dockerfile" field.
func (u *EnvBuildUpsertBulk) ClearDockerfile() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.ClearDockerfile()
	})
}

// SetStartCmd sets the "start_cmd" field.
func (u *EnvBuildUpsertBulk) SetStartCmd(v string) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetStartCmd(v)
	})
}

// UpdateStartCmd sets the "start_cmd" field to the value that was provided on create.
func (u *EnvBuildUpsertBulk) UpdateStartCmd() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateStartCmd()
	})
}

// ClearStartCmd clears the value of the "start_cmd" field.
func (u *EnvBuildUpsertBulk) ClearStartCmd() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.ClearStartCmd()
	})
}

// SetVcpu sets the "vcpu" field.
func (u *EnvBuildUpsertBulk) SetVcpu(v int64) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetVcpu(v)
	})
}

// AddVcpu adds v to the "vcpu" field.
func (u *EnvBuildUpsertBulk) AddVcpu(v int64) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.AddVcpu(v)
	})
}

// UpdateVcpu sets the "vcpu" field to the value that was provided on create.
func (u *EnvBuildUpsertBulk) UpdateVcpu() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateVcpu()
	})
}

// SetRAMMB sets the "ram_mb" field.
func (u *EnvBuildUpsertBulk) SetRAMMB(v int64) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetRAMMB(v)
	})
}

// AddRAMMB adds v to the "ram_mb" field.
func (u *EnvBuildUpsertBulk) AddRAMMB(v int64) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.AddRAMMB(v)
	})
}

// UpdateRAMMB sets the "ram_mb" field to the value that was provided on create.
func (u *EnvBuildUpsertBulk) UpdateRAMMB() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateRAMMB()
	})
}

// SetFreeDiskSizeMB sets the "free_disk_size_mb" field.
func (u *EnvBuildUpsertBulk) SetFreeDiskSizeMB(v int64) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetFreeDiskSizeMB(v)
	})
}

// AddFreeDiskSizeMB adds v to the "free_disk_size_mb" field.
func (u *EnvBuildUpsertBulk) AddFreeDiskSizeMB(v int64) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.AddFreeDiskSizeMB(v)
	})
}

// UpdateFreeDiskSizeMB sets the "free_disk_size_mb" field to the value that was provided on create.
func (u *EnvBuildUpsertBulk) UpdateFreeDiskSizeMB() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateFreeDiskSizeMB()
	})
}

// SetTotalDiskSizeMB sets the "total_disk_size_mb" field.
func (u *EnvBuildUpsertBulk) SetTotalDiskSizeMB(v int64) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetTotalDiskSizeMB(v)
	})
}

// AddTotalDiskSizeMB adds v to the "total_disk_size_mb" field.
func (u *EnvBuildUpsertBulk) AddTotalDiskSizeMB(v int64) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.AddTotalDiskSizeMB(v)
	})
}

// UpdateTotalDiskSizeMB sets the "total_disk_size_mb" field to the value that was provided on create.
func (u *EnvBuildUpsertBulk) UpdateTotalDiskSizeMB() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateTotalDiskSizeMB()
	})
}

// ClearTotalDiskSizeMB clears the value of the "total_disk_size_mb" field.
func (u *EnvBuildUpsertBulk) ClearTotalDiskSizeMB() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.ClearTotalDiskSizeMB()
	})
}

// SetKernelVersion sets the "kernel_version" field.
func (u *EnvBuildUpsertBulk) SetKernelVersion(v string) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetKernelVersion(v)
	})
}

// UpdateKernelVersion sets the "kernel_version" field to the value that was provided on create.
func (u *EnvBuildUpsertBulk) UpdateKernelVersion() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateKernelVersion()
	})
}

// SetFirecrackerVersion sets the "firecracker_version" field.
func (u *EnvBuildUpsertBulk) SetFirecrackerVersion(v string) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetFirecrackerVersion(v)
	})
}

// UpdateFirecrackerVersion sets the "firecracker_version" field to the value that was provided on create.
func (u *EnvBuildUpsertBulk) UpdateFirecrackerVersion() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateFirecrackerVersion()
	})
}

// SetEnvdVersion sets the "envd_version" field.
func (u *EnvBuildUpsertBulk) SetEnvdVersion(v string) *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.SetEnvdVersion(v)
	})
}

// UpdateEnvdVersion sets the "envd_version" field to the value that was provided on create.
func (u *EnvBuildUpsertBulk) UpdateEnvdVersion() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.UpdateEnvdVersion()
	})
}

// ClearEnvdVersion clears the value of the "envd_version" field.
func (u *EnvBuildUpsertBulk) ClearEnvdVersion() *EnvBuildUpsertBulk {
	return u.Update(func(s *EnvBuildUpsert) {
		s.ClearEnvdVersion()
	})
}

// Exec executes the query.
func (u *EnvBuildUpsertBulk) Exec(ctx context.Context) error {
	if u.create.err != nil {
		return u.create.err
	}
	for i, b := range u.create.builders {
		if len(b.conflict) != 0 {
			return fmt.Errorf("models: OnConflict was set for builder %d. Set it on the EnvBuildCreateBulk instead", i)
		}
	}
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for EnvBuildCreateBulk.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *EnvBuildUpsertBulk) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/envbuild_delete.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envbuild"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
)

// EnvBuildDelete is the builder for deleting a EnvBuild entity.
type EnvBuildDelete struct {
	config
	hooks    []Hook
	mutation *EnvBuildMutation
}

// Where appends a list predicates to the EnvBuildDelete builder.
func (ebd *EnvBuildDelete) Where(ps ...predicate.EnvBuild) *EnvBuildDelete {
	ebd.mutation.Where(ps...)
	return ebd
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (ebd *EnvBuildDelete) Exec(ctx context.Context) (int, error) {
	return withHooks(ctx, ebd.sqlExec, ebd.mutation, ebd.hooks)
}

// ExecX is like Exec, but panics if an error occurs.
func (ebd *EnvBuildDelete) ExecX(ctx context.Context) int {
	n, err := ebd.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (ebd *EnvBuildDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := sqlgraph.NewDeleteSpec(envbuild.Table, sqlgraph.NewFieldSpec(envbuild.FieldID, field.TypeUUID))
	_spec.Node.Schema = ebd.schemaConfig.EnvBuild
	ctx = internal.NewSchemaConfigContext(ctx, ebd.schemaConfig)
	if ps := ebd.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	affected, err := sqlgraph.DeleteNodes(ctx, ebd.driver, _spec)
	if err != nil && sqlgraph.IsConstraintError(err) {
		err = &ConstraintError{msg: err.Error(), wrap: err}
	}
	ebd.mutation.done = true
	return affected, err
}

// EnvBuildDeleteOne is the builder for deleting a single EnvBuild entity.
type EnvBuildDeleteOne struct {
	ebd *EnvBuildDelete
}

// Where appends a list predicates to the EnvBuildDelete builder.
func (ebdo *EnvBuildDeleteOne) Where(ps ...predicate.EnvBuild) *EnvBuildDeleteOne {
	ebdo.ebd.mutation.Where(ps...)
	return ebdo
}

// Exec executes the deletion query.
func (ebdo *EnvBuildDeleteOne) Exec(ctx context.Context) error {
	n, err := ebdo.ebd.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{envbuild.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (ebdo *EnvBuildDeleteOne) ExecX(ctx context.Context) {
	if err := ebdo.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/envbuild_query.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"fmt"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envbuild"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/google/uuid"
)

// EnvBuildQuery is the builder for querying EnvBuild entities.
type EnvBuildQuery struct {
	config
	ctx        *QueryContext
	order      []envbuild.OrderOption
	inters     []Interceptor
	predicates []predicate.EnvBuild
	withEnv    *EnvQuery
	modifiers  []func(*sql.Selector)
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the EnvBuildQuery builder.
func (ebq *EnvBuildQuery) Where(ps ...predicate.EnvBuild) *EnvBuildQuery {
	ebq.predicates = append(ebq.predicates, ps...)
	return ebq
}

// Limit the number of records to be returned by this query.
func (ebq *EnvBuildQuery) Limit(limit int) *EnvBuildQuery {
	ebq.ctx.Limit = &limit
	return ebq
}

// Offset to start from.
func (ebq *EnvBuildQuery) Offset(offset int) *EnvBuildQuery {
	ebq.ctx.Offset = &offset
	return ebq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (ebq *EnvBuildQuery) Unique(unique bool) *EnvBuildQuery {
	ebq.ctx.Unique = &unique
	return ebq
}

// Order specifies how the records should be ordered.
func (ebq *EnvBuildQuery) Order(o ...envbuild.OrderOption) *EnvBuildQuery {
	ebq.order = append(ebq.order, o...)
	return ebq
}

// QueryEnv chains the current query on the "env" edge.
func (ebq *EnvBuildQuery) QueryEnv() *EnvQuery {
	query := (&EnvClient{config: ebq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := ebq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := ebq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(envbuild.Table, envbuild.FieldID, selector),
			sqlgraph.To(env.Table, env.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, envbuild.EnvTable, envbuild.EnvColumn),
		)
		schemaConfig := ebq.schemaConfig
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.EnvBuild
		fromU = sqlgraph.SetNeighbors(ebq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first EnvBuild entity from the query.
// Returns a *NotFoundError when no EnvBuild was found.
func (ebq *EnvBuildQuery) First(ctx context.Context) (*EnvBuild, error) {
	nodes, err := ebq.Limit(1).All(setContextOp(ctx, ebq.ctx, "First"))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{envbuild.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (ebq *EnvBuildQuery) FirstX(ctx context.Context) *EnvBuild {
	node, err := ebq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first EnvBuild ID from the query.
// Returns a *NotFoundError when no EnvBuild ID was found.
func (ebq *EnvBuildQuery) FirstID(ctx context.Context) (id uuid.UUID, err error) {
	var ids []uuid.UUID
	if ids, err = ebq.Limit(1).IDs(setContextOp(ctx, ebq.ctx, "FirstID")); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{envbuild.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (ebq *EnvBuildQuery) FirstIDX(ctx context.Context) uuid.UUID {
	id, err := ebq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single EnvBuild entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one EnvBuild entity is found.
// Returns a *NotFoundError when no EnvBuild entities are found.
func (ebq *EnvBuildQuery) Only(ctx context.Context) (*EnvBuild, error) {
	nodes, err := ebq.Limit(2).All(setContextOp(ctx, ebq.ctx, "Only"))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{envbuild.Label}
	default:
		return nil, &NotSingularError{envbuild.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (ebq *EnvBuildQuery) OnlyX(ctx context.Context) *EnvBuild {
	node, err := ebq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only EnvBuild ID in the query.
// Returns a *NotSingularError when more than one EnvBuild ID is found.
// Returns a *NotFoundError when no entities are found.
func (ebq *EnvBuildQuery) OnlyID(ctx context.Context) (id uuid.UUID, err error) {
	var ids []uuid.UUID
	if ids, err = ebq.Limit(2).IDs(setContextOp(ctx, ebq.ctx, "OnlyID")); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{envbuild.Label}
	default:
		err = &NotSingularError{envbuild.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (ebq *EnvBuildQuery) OnlyIDX(ctx context.Context) uuid.UUID {
	id, err := ebq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of EnvBuilds.
func (ebq *EnvBuildQuery) All(ctx context.Context) ([]*EnvBuild, error) {
	ctx = setContextOp(ctx, ebq.ctx, "All")
	if err := ebq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*EnvBuild, *EnvBuildQuery]()
	return withInterceptors[[]*EnvBuild](ctx, ebq, qr, ebq.inters)
}

// AllX is like All, but panics if an error occurs.
func (ebq *EnvBuildQuery) AllX(ctx context.Context) []*EnvBuild {
	nodes, err := ebq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of EnvBuild IDs.
func (ebq *EnvBuildQuery) IDs(ctx context.Context) (ids []uuid.UUID, err error) {
	if ebq.ctx.Unique == nil && ebq.path != nil {
		ebq.Unique(true)
	}
	ctx = setContextOp(ctx, ebq.ctx, "IDs")
	if err = ebq.Select(envbuild.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (ebq *EnvBuildQuery) IDsX(ctx context.Context) []uuid.UUID {
	ids, err := ebq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (ebq *EnvBuildQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, ebq.ctx, "Count")
	if err := ebq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, ebq, querierCount[*EnvBuildQuery](), ebq.inters)
}

// CountX is like Count, but panics if an error occurs.
func (ebq *EnvBuildQuery) CountX(ctx context.Context) int {
	count, err := ebq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (ebq *EnvBuildQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, ebq.ctx, "Exist")
	switch _, err := ebq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("models: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (ebq *EnvBuildQuery) ExistX(ctx context.Context) bool {
	exist, err := ebq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the EnvBuildQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (ebq *EnvBuildQuery) Clone() *EnvBuildQuery {
	if ebq == nil {
		return nil
	}
	return &EnvBuildQuery{
		config:     ebq.config,
		ctx:        ebq.ctx.Clone(),
		order:      append([]envbuild.OrderOption{}, ebq.order...),
		inters:     append([]Interceptor{}, ebq.inters...),
		predicates: append([]predicate.EnvBuild{}, ebq.predicates...),
		withEnv:    ebq.withEnv.Clone(),
		// clone intermediate query.
		sql:  ebq.sql.Clone(),
		path: ebq.path,
	}
}

// WithEnv tells the query-builder to eager-load the nodes that are connected to
// the "env" edge. The optional arguments are used to configure the query builder of the edge.
func (ebq *EnvBuildQuery) WithEnv(opts ...func(*EnvQuery)) *EnvBuildQuery {
	query := (&EnvClient{config: ebq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	ebq.withEnv = query
	return ebq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		CreatedAt time.Time `json:"created_at,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.EnvBuild.Query().
//		GroupBy(envbuild.FieldCreatedAt).
//		Aggregate(models.Count()).
//		Scan(ctx, &v)
func (ebq *EnvBuildQuery) GroupBy(field string, fields ...string) *EnvBuildGroupBy {
	ebq.ctx.Fields = append([]string{field}, fields...)
	grbuild := &EnvBuildGroupBy{build: ebq}
	grbuild.flds = &ebq.ctx.Fields
	grbuild.label = envbuild.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		CreatedAt time.Time `json:"created_at,omitempty"`
//	}
//
//	client.EnvBuild.Query().
//		Select(envbuild.FieldCreatedAt).
//		Scan(ctx, &v)
func (ebq *EnvBuildQuery) Select(fields ...string) *EnvBuildSelect {
	ebq.ctx.Fields = append(ebq.ctx.Fields, fields...)
	sbuild := &EnvBuildSelect{EnvBuildQuery: ebq}
	sbuild.label = envbuild.Label
	sbuild.flds, sbuild.scan = &ebq.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a EnvBuildSelect configured with the given aggregations.
func (ebq *EnvBuildQuery) Aggregate(fns ...AggregateFunc) *EnvBuildSelect {
	return ebq.Select().Aggregate(fns...)
}

func (ebq *EnvBuildQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range ebq.inters {
		if inter == nil {
			return fmt.Errorf("models: uninitialized interceptor (forgotten import models/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, ebq); err != nil {
				return err
			}
		}
	}
	for _, f := range ebq.ctx.Fields {
		if !envbuild.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
		}
	}
	if ebq.path != nil {
		prev, err := ebq.path(ctx)
		if err != nil {
			return err
		}
		ebq.sql = prev
	}
	return nil
}

func (ebq *EnvBuildQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*EnvBuild, error) {
	var (
		nodes       = []*EnvBuild{}
		_spec       = ebq.querySpec()
		loadedTypes = [1]bool{
			ebq.withEnv != nil,
		}
	)
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*EnvBuild).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &EnvBuild{config: ebq.config}
		nodes = append(nodes, node)
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	_spec.Node.Schema = ebq.schemaConfig.EnvBuild
	ctx = internal.NewSchemaConfigContext(ctx, ebq.schemaConfig)
	if len(ebq.modifiers) > 0 {
		_spec.Modifiers = ebq.modifiers
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, ebq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	if query := ebq.withEnv; query != nil {
		if err := ebq.loadEnv(ctx, query, nodes, nil,
			func(n *EnvBuild, e *Env) { n.Edges.Env = e }); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

func (ebq *EnvBuildQuery) loadEnv(ctx context.Context, query *EnvQuery, nodes []*EnvBuild, init func(*EnvBuild), assign func(*EnvBuild, *Env)) error {
	ids := make([]string, 0, len(nodes))
	nodeids := make(map[string][]*EnvBuild)
	for i := range nodes {
		if nodes[i].EnvID == nil {
			continue
		}
		fk := *nodes[i].EnvID
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(env.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "env_id" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}

func (ebq *EnvBuildQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := ebq.querySpec()
	_spec.Node.Schema = ebq.schemaConfig.EnvBuild
	ctx = internal.NewSchemaConfigContext(ctx, ebq.schemaConfig)
	if len(ebq.modifiers) > 0 {
		_spec.Modifiers = ebq.modifiers
	}
	_spec.Node.Columns = ebq.ctx.Fields
	if len(ebq.ctx.Fields) > 0 {
		_spec.Unique = ebq.ctx.Unique != nil && *ebq.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, ebq.driver, _spec)
}

func (ebq *EnvBuildQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(envbuild.Table, envbuild.Columns, sqlgraph.NewFieldSpec(envbuild.FieldID, field.TypeUUID))
	_spec.From = ebq.sql
	if unique := ebq.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if ebq.path != nil {
		_spec.Unique = true
	}
	if fields := ebq.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, envbuild.FieldID)
		for i := range fields {
			if fields[i] != envbuild.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
		if ebq.withEnv != nil {
			_spec.Node.AddColumnOnce(envbuild.FieldEnvID)
		}
	}
	if ps := ebq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := ebq.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := ebq.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := ebq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (ebq *EnvBuildQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(ebq.driver.Dialect())
	t1 := builder.Table(envbuild.Table)
	columns := ebq.ctx.Fields
	if len(columns) == 0 {
		columns = envbuild.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if ebq.sql != nil {
		selector = ebq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if ebq.ctx.Unique != nil && *ebq.ctx.Unique {
		selector.Distinct()
	}
	t1.Schema(ebq.schemaConfig.EnvBuild)
	ctx = internal.NewSchemaConfigContext(ctx, ebq.schemaConfig)
	selector.WithContext(ctx)
	for _, m := range ebq.modifiers {
		m(selector)
	}
	for _, p := range ebq.predicates {
		p(selector)
	}
	for _, p := range ebq.order {
		p(selector)
	}
	if offset := ebq.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := ebq.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// Modify adds a query modifier for attaching custom logic to queries.
func (ebq *EnvBuildQuery) Modify(modifiers ...func(s *sql.Selector)) *EnvBuildSelect {
	ebq.modifiers = append(ebq.modifiers, modifiers...)
	return ebq.Select()
}

// EnvBuildGroupBy is the group-by builder for EnvBuild entities.
type EnvBuildGroupBy struct {
	selector
	build *EnvBuildQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (ebgb *EnvBuildGroupBy) Aggregate(fns ...AggregateFunc) *EnvBuildGroupBy {
	ebgb.fns = append(ebgb.fns, fns...)
	return ebgb
}

// Scan applies the selector query and scans the result into the given value.
func (ebgb *EnvBuildGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, ebgb.build.ctx, "GroupBy")
	if err := ebgb.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*EnvBuildQuery, *EnvBuildGroupBy](ctx, ebgb.build, ebgb, ebgb.build.inters, v)
}

func (ebgb *EnvBuildGroupBy) sqlScan(ctx context.Context, root *EnvBuildQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(ebgb.fns))
	for _, fn := range ebgb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*ebgb.flds)+len(ebgb.fns))
		for _, f := range *ebgb.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*ebgb.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := ebgb.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// EnvBuildSelect is the builder for selecting fields of EnvBuild entities.
type EnvBuildSelect struct {
	*EnvBuildQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (ebs *EnvBuildSelect) Aggregate(fns ...AggregateFunc) *EnvBuildSelect {
	ebs.fns = append(ebs.fns, fns...)
	return ebs
}

// Scan applies the selector query and scans the result into the given value.
func (ebs *EnvBuildSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, ebs.ctx, "Select")
	if err := ebs.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*EnvBuildQuery, *EnvBuildSelect](ctx, ebs.EnvBuildQuery, ebs, ebs.inters, v)
}

func (ebs *EnvBuildSelect) sqlScan(ctx context.Context, root *EnvBuildQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(ebs.fns))
	for _, fn := range ebs.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*ebs.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := ebs.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// Modify adds a query modifier for attaching custom logic to queries.
func (ebs *EnvBuildSelect) Modify(modifiers ...func(s *sql.Selector)) *EnvBuildSelect {
	ebs.modifiers = append(ebs.modifiers, modifiers...)
	return ebs
}



================================================
File: models/envbuild_update.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envbuild"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
)

// EnvBuildUpdate is the builder for updating EnvBuild entities.
type EnvBuildUpdate struct {
	config
	hooks     []Hook
	mutation  *EnvBuildMutation
	modifiers []func(*sql.UpdateBuilder)
}

// Where appends a list predicates to the EnvBuildUpdate builder.
func (ebu *EnvBuildUpdate) Where(ps ...predicate.EnvBuild) *EnvBuildUpdate {
	ebu.mutation.Where(ps...)
	return ebu
}

// SetUpdatedAt sets the "updated_at" field.
func (ebu *EnvBuildUpdate) SetUpdatedAt(t time.Time) *EnvBuildUpdate {
	ebu.mutation.SetUpdatedAt(t)
	return ebu
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (ebu *EnvBuildUpdate) SetNillableUpdatedAt(t *time.Time) *EnvBuildUpdate {
	if t != nil {
		ebu.SetUpdatedAt(*t)
	}
	return ebu
}

// SetFinishedAt sets the "finished_at" field.
func (ebu *EnvBuildUpdate) SetFinishedAt(t time.Time) *EnvBuildUpdate {
	ebu.mutation.SetFinishedAt(t)
	return ebu
}

// SetNillableFinishedAt sets the "finished_at" field if the given value is not nil.
func (ebu *EnvBuildUpdate) SetNillableFinishedAt(t *time.Time) *EnvBuildUpdate {
	if t != nil {
		ebu.SetFinishedAt(*t)
	}
	return ebu
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (ebu *EnvBuildUpdate) ClearFinishedAt() *EnvBuildUpdate {
	ebu.mutation.ClearFinishedAt()
	return ebu
}

// SetEnvID sets the "env_id" field.
func (ebu *EnvBuildUpdate) SetEnvID(s string) *EnvBuildUpdate {
	ebu.mutation.SetEnvID(s)
	return ebu
}

// SetNillableEnvID sets the "env_id" field if the given value is not nil.
func (ebu *EnvBuildUpdate) SetNillableEnvID(s *string) *EnvBuildUpdate {
	if s != nil {
		ebu.SetEnvID(*s)
	}
	return ebu
}

// ClearEnvID clears the value of the "env_id" field.
func (ebu *EnvBuildUpdate) ClearEnvID() *EnvBuildUpdate {
	ebu.mutation.ClearEnvID()
	return ebu
}

// SetStatus sets the "status" field.
func (ebu *EnvBuildUpdate) SetStatus(e envbuild.Status) *EnvBuildUpdate {
	ebu.mutation.SetStatus(e)
	return ebu
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (ebu *EnvBuildUpdate) SetNillableStatus(e *envbuild.Status) *EnvBuildUpdate {
	if e != nil {
		ebu.SetStatus(*e)
	}
	return ebu
}

// SetDockerfile sets the "dockerfile" field.
func (ebu *EnvBuildUpdate) SetDockerfile(s string) *EnvBuildUpdate {
	ebu.mutation.SetDockerfile(s)
	return ebu
}

// SetNillableDockerfile sets the "dockerfile" field if the given value is not nil.
func (ebu *EnvBuildUpdate) SetNillableDockerfile(s *string) *EnvBuildUpdate {
	if s != nil {
		ebu.SetDockerfile(*s)
	}
	return ebu
}

// ClearDockerfile clears the value of the "dockerfile" field.
func (ebu *EnvBuildUpdate) ClearDockerfile() *EnvBuildUpdate {
	ebu.mutation.ClearDockerfile()
	return ebu
}

// SetStartCmd sets the "start_cmd" field.
func (ebu *EnvBuildUpdate) SetStartCmd(s string) *EnvBuildUpdate {
	ebu.mutation.SetStartCmd(s)
	return ebu
}

// SetNillableStartCmd sets the "start_cmd" field if the given value is not nil.
func (ebu *EnvBuildUpdate) SetNillableStartCmd(s *string) *EnvBuildUpdate {
	if s != nil {
		ebu.SetStartCmd(*s)
	}
	return ebu
}

// ClearStartCmd clears the value of the "start_cmd" field.
func (ebu *EnvBuildUpdate) ClearStartCmd() *EnvBuildUpdate {
	ebu.mutation.ClearStartCmd()
	return ebu
}

// SetVcpu sets the "vcpu" field.
func (ebu *EnvBuildUpdate) SetVcpu(i int64) *EnvBuildUpdate {
	ebu.mutation.ResetVcpu()
	ebu.mutation.SetVcpu(i)
	return ebu
}

// SetNillableVcpu sets the "vcpu" field if the given value is not nil.
func (ebu *EnvBuildUpdate) SetNillableVcpu(i *int64) *EnvBuildUpdate {
	if i != nil {
		ebu.SetVcpu(*i)
	}
	return ebu
}

// AddVcpu adds i to the "vcpu" field.
func (ebu *EnvBuildUpdate) AddVcpu(i int64) *EnvBuildUpdate {
	ebu.mutation.AddVcpu(i)
	return ebu
}

// SetRAMMB sets the "ram_mb" field.
func (ebu *EnvBuildUpdate) SetRAMMB(i int64) *EnvBuildUpdate {
	ebu.mutation.ResetRAMMB()
	ebu.mutation.SetRAMMB(i)
	return ebu
}

// SetNillableRAMMB sets the "ram_mb" field if the given value is not nil.
func (ebu *EnvBuildUpdate) SetNillableRAMMB(i *int64) *EnvBuildUpdate {
	if i != nil {
		ebu.SetRAMMB(*i)
	}
	return ebu
}

// AddRAMMB adds i to the "ram_mb" field.
func (ebu *EnvBuildUpdate) AddRAMMB(i int64) *EnvBuildUpdate {
	ebu.mutation.AddRAMMB(i)
	return ebu
}

// SetFreeDiskSizeMB sets the "free_disk_size_mb" field.
func (ebu *EnvBuildUpdate) SetFreeDiskSizeMB(i int64) *EnvBuildUpdate {
	ebu.mutation.ResetFreeDiskSizeMB()
	ebu.mutation.SetFreeDiskSizeMB(i)
	return ebu
}

// SetNillableFreeDiskSizeMB sets the "free_disk_size_mb" field if the given value is not nil.
func (ebu *EnvBuildUpdate) SetNillableFreeDiskSizeMB(i *int64) *EnvBuildUpdate {
	if i != nil {
		ebu.SetFreeDiskSizeMB(*i)
	}
	return ebu
}

// AddFreeDiskSizeMB adds i to the "free_disk_size_mb" field.
func (ebu *EnvBuildUpdate) AddFreeDiskSizeMB(i int64) *EnvBuildUpdate {
	ebu.mutation.AddFreeDiskSizeMB(i)
	return ebu
}

// SetTotalDiskSizeMB sets the "total_disk_size_mb" field.
func (ebu *EnvBuildUpdate) SetTotalDiskSizeMB(i int64) *EnvBuildUpdate {
	ebu.mutation.ResetTotalDiskSizeMB()
	ebu.mutation.SetTotalDiskSizeMB(i)
	return ebu
}

// SetNillableTotalDiskSizeMB sets the "total_disk_size_mb" field if the given value is not nil.
func (ebu *EnvBuildUpdate) SetNillableTotalDiskSizeMB(i *int64) *EnvBuildUpdate {
	if i != nil {
		ebu.SetTotalDiskSizeMB(*i)
	}
	return ebu
}

// AddTotalDiskSizeMB adds i to the "total_disk_size_mb" field.
func (ebu *EnvBuildUpdate) AddTotalDiskSizeMB(i int64) *EnvBuildUpdate {
	ebu.mutation.AddTotalDiskSizeMB(i)
	return ebu
}

// ClearTotalDiskSizeMB clears the value of the "total_disk_size_mb" field.
func (ebu *EnvBuildUpdate) ClearTotalDiskSizeMB() *EnvBuildUpdate {
	ebu.mutation.ClearTotalDiskSizeMB()
	return ebu
}

// SetKernelVersion sets the "kernel_version" field.
func (ebu *EnvBuildUpdate) SetKernelVersion(s string) *EnvBuildUpdate {
	ebu.mutation.SetKernelVersion(s)
	return ebu
}

// SetNillableKernelVersion sets the "kernel_version" field if the given value is not nil.
func (ebu *EnvBuildUpdate) SetNillableKernelVersion(s *string) *EnvBuildUpdate {
	if s != nil {
		ebu.SetKernelVersion(*s)
	}
	return ebu
}

// SetFirecrackerVersion sets the "firecracker_version" field.
func (ebu *EnvBuildUpdate) SetFirecrackerVersion(s string) *EnvBuildUpdate {
	ebu.mutation.SetFirecrackerVersion(s)
	return ebu
}

// SetNillableFirecrackerVersion sets the "firecracker_version" field if the given value is not nil.
func (ebu *EnvBuildUpdate) SetNillableFirecrackerVersion(s *string) *EnvBuildUpdate {
	if s != nil {
		ebu.SetFirecrackerVersion(*s)
	}
	return ebu
}

// SetEnvdVersion sets the "envd_version" field.
func (ebu *EnvBuildUpdate) SetEnvdVersion(s string) *EnvBuildUpdate {
	ebu.mutation.SetEnvdVersion(s)
	return ebu
}

// SetNillableEnvdVersion sets the "envd_version" field if the given value is not nil.
func (ebu *EnvBuildUpdate) SetNillableEnvdVersion(s *string) *EnvBuildUpdate {
	if s != nil {
		ebu.SetEnvdVersion(*s)
	}
	return ebu
}

// ClearEnvdVersion clears the value of the "envd_version" field.
func (ebu *EnvBuildUpdate) ClearEnvdVersion() *EnvBuildUpdate {
	ebu.mutation.ClearEnvdVersion()
	return ebu
}

// SetEnv sets the "env" edge to the Env entity.
func (ebu *EnvBuildUpdate) SetEnv(e *Env) *EnvBuildUpdate {
	return ebu.SetEnvID(e.ID)
}

// Mutation returns the EnvBuildMutation object of the builder.
func (ebu *EnvBuildUpdate) Mutation() *EnvBuildMutation {
	return ebu.mutation
}

// ClearEnv clears the "env" edge to the Env entity.
func (ebu *EnvBuildUpdate) ClearEnv() *EnvBuildUpdate {
	ebu.mutation.ClearEnv()
	return ebu
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (ebu *EnvBuildUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, ebu.sqlSave, ebu.mutation, ebu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (ebu *EnvBuildUpdate) SaveX(ctx context.Context) int {
	affected, err := ebu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (ebu *EnvBuildUpdate) Exec(ctx context.Context) error {
	_, err := ebu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ebu *EnvBuildUpdate) ExecX(ctx context.Context) {
	if err := ebu.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (ebu *EnvBuildUpdate) check() error {
	if v, ok := ebu.mutation.Status(); ok {
		if err := envbuild.StatusValidator(v); err != nil {
			return &ValidationError{Name: "status", err: fmt.Errorf(`models: validator failed for field "EnvBuild.status": %w`, err)}
		}
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (ebu *EnvBuildUpdate) Modify(modifiers ...func(u *sql.UpdateBuilder)) *EnvBuildUpdate {
	ebu.modifiers = append(ebu.modifiers, modifiers...)
	return ebu
}

func (ebu *EnvBuildUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := ebu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(envbuild.Table, envbuild.Columns, sqlgraph.NewFieldSpec(envbuild.FieldID, field.TypeUUID))
	if ps := ebu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := ebu.mutation.UpdatedAt(); ok {
		_spec.SetField(envbuild.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := ebu.mutation.FinishedAt(); ok {
		_spec.SetField(envbuild.FieldFinishedAt, field.TypeTime, value)
	}
	if ebu.mutation.FinishedAtCleared() {
		_spec.ClearField(envbuild.FieldFinishedAt, field.TypeTime)
	}
	if value, ok := ebu.mutation.Status(); ok {
		_spec.SetField(envbuild.FieldStatus, field.TypeEnum, value)
	}
	if value, ok := ebu.mutation.Dockerfile(); ok {
		_spec.SetField(envbuild.FieldDockerfile, field.TypeString, value)
	}
	if ebu.mutation.DockerfileCleared() {
		_spec.ClearField(envbuild.FieldDockerfile, field.TypeString)
	}
	if value, ok := ebu.mutation.StartCmd(); ok {
		_spec.SetField(envbuild.FieldStartCmd, field.TypeString, value)
	}
	if ebu.mutation.StartCmdCleared() {
		_spec.ClearField(envbuild.FieldStartCmd, field.TypeString)
	}
	if value, ok := ebu.mutation.Vcpu(); ok {
		_spec.SetField(envbuild.FieldVcpu, field.TypeInt64, value)
	}
	if value, ok := ebu.mutation.AddedVcpu(); ok {
		_spec.AddField(envbuild.FieldVcpu, field.TypeInt64, value)
	}
	if value, ok := ebu.mutation.RAMMB(); ok {
		_spec.SetField(envbuild.FieldRAMMB, field.TypeInt64, value)
	}
	if value, ok := ebu.mutation.AddedRAMMB(); ok {
		_spec.AddField(envbuild.FieldRAMMB, field.TypeInt64, value)
	}
	if value, ok := ebu.mutation.FreeDiskSizeMB(); ok {
		_spec.SetField(envbuild.FieldFreeDiskSizeMB, field.TypeInt64, value)
	}
	if value, ok := ebu.mutation.AddedFreeDiskSizeMB(); ok {
		_spec.AddField(envbuild.FieldFreeDiskSizeMB, field.TypeInt64, value)
	}
	if value, ok := ebu.mutation.TotalDiskSizeMB(); ok {
		_spec.SetField(envbuild.FieldTotalDiskSizeMB, field.TypeInt64, value)
	}
	if value, ok := ebu.mutation.AddedTotalDiskSizeMB(); ok {
		_spec.AddField(envbuild.FieldTotalDiskSizeMB, field.TypeInt64, value)
	}
	if ebu.mutation.TotalDiskSizeMBCleared() {
		_spec.ClearField(envbuild.FieldTotalDiskSizeMB, field.TypeInt64)
	}
	if value, ok := ebu.mutation.KernelVersion(); ok {
		_spec.SetField(envbuild.FieldKernelVersion, field.TypeString, value)
	}
	if value, ok := ebu.mutation.FirecrackerVersion(); ok {
		_spec.SetField(envbuild.FieldFirecrackerVersion, field.TypeString, value)
	}
	if value, ok := ebu.mutation.EnvdVersion(); ok {
		_spec.SetField(envbuild.FieldEnvdVersion, field.TypeString, value)
	}
	if ebu.mutation.EnvdVersionCleared() {
		_spec.ClearField(envbuild.FieldEnvdVersion, field.TypeString)
	}
	if ebu.mutation.EnvCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   envbuild.EnvTable,
			Columns: []string{envbuild.EnvColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = ebu.schemaConfig.EnvBuild
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ebu.mutation.EnvIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   envbuild.EnvTable,
			Columns: []string{envbuild.EnvColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = ebu.schemaConfig.EnvBuild
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = ebu.schemaConfig.EnvBuild
	ctx = internal.NewSchemaConfigContext(ctx, ebu.schemaConfig)
	_spec.AddModifiers(ebu.modifiers...)
	if n, err = sqlgraph.UpdateNodes(ctx, ebu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{envbuild.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	ebu.mutation.done = true
	return n, nil
}

// EnvBuildUpdateOne is the builder for updating a single EnvBuild entity.
type EnvBuildUpdateOne struct {
	config
	fields    []string
	hooks     []Hook
	mutation  *EnvBuildMutation
	modifiers []func(*sql.UpdateBuilder)
}

// SetUpdatedAt sets the "updated_at" field.
func (ebuo *EnvBuildUpdateOne) SetUpdatedAt(t time.Time) *EnvBuildUpdateOne {
	ebuo.mutation.SetUpdatedAt(t)
	return ebuo
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (ebuo *EnvBuildUpdateOne) SetNillableUpdatedAt(t *time.Time) *EnvBuildUpdateOne {
	if t != nil {
		ebuo.SetUpdatedAt(*t)
	}
	return ebuo
}

// SetFinishedAt sets the "finished_at" field.
func (ebuo *EnvBuildUpdateOne) SetFinishedAt(t time.Time) *EnvBuildUpdateOne {
	ebuo.mutation.SetFinishedAt(t)
	return ebuo
}

// SetNillableFinishedAt sets the "finished_at" field if the given value is not nil.
func (ebuo *EnvBuildUpdateOne) SetNillableFinishedAt(t *time.Time) *EnvBuildUpdateOne {
	if t != nil {
		ebuo.SetFinishedAt(*t)
	}
	return ebuo
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (ebuo *EnvBuildUpdateOne) ClearFinishedAt() *EnvBuildUpdateOne {
	ebuo.mutation.ClearFinishedAt()
	return ebuo
}

// SetEnvID sets the "env_id" field.
func (ebuo *EnvBuildUpdateOne) SetEnvID(s string) *EnvBuildUpdateOne {
	ebuo.mutation.SetEnvID(s)
	return ebuo
}

// SetNillableEnvID sets the "env_id" field if the given value is not nil.
func (ebuo *EnvBuildUpdateOne) SetNillableEnvID(s *string) *EnvBuildUpdateOne {
	if s != nil {
		ebuo.SetEnvID(*s)
	}
	return ebuo
}

// ClearEnvID clears the value of the "env_id" field.
func (ebuo *EnvBuildUpdateOne) ClearEnvID() *EnvBuildUpdateOne {
	ebuo.mutation.ClearEnvID()
	return ebuo
}

// SetStatus sets the "status" field.
func (ebuo *EnvBuildUpdateOne) SetStatus(e envbuild.Status) *EnvBuildUpdateOne {
	ebuo.mutation.SetStatus(e)
	return ebuo
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (ebuo *EnvBuildUpdateOne) SetNillableStatus(e *envbuild.Status) *EnvBuildUpdateOne {
	if e != nil {
		ebuo.SetStatus(*e)
	}
	return ebuo
}

// SetDockerfile sets the "dockerfile" field.
func (ebuo *EnvBuildUpdateOne) SetDockerfile(s string) *EnvBuildUpdateOne {
	ebuo.mutation.SetDockerfile(s)
	return ebuo
}

// SetNillableDockerfile sets the "dockerfile" field if the given value is not nil.
func (ebuo *EnvBuildUpdateOne) SetNillableDockerfile(s *string) *EnvBuildUpdateOne {
	if s != nil {
		ebuo.SetDockerfile(*s)
	}
	return ebuo
}

// ClearDockerfile clears the value of the "dockerfile" field.
func (ebuo *EnvBuildUpdateOne) ClearDockerfile() *EnvBuildUpdateOne {
	ebuo.mutation.ClearDockerfile()
	return ebuo
}

// SetStartCmd sets the "start_cmd" field.
func (ebuo *EnvBuildUpdateOne) SetStartCmd(s string) *EnvBuildUpdateOne {
	ebuo.mutation.SetStartCmd(s)
	return ebuo
}

// SetNillableStartCmd sets the "start_cmd" field if the given value is not nil.
func (ebuo *EnvBuildUpdateOne) SetNillableStartCmd(s *string) *EnvBuildUpdateOne {
	if s != nil {
		ebuo.SetStartCmd(*s)
	}
	return ebuo
}

// ClearStartCmd clears the value of the "start_cmd" field.
func (ebuo *EnvBuildUpdateOne) ClearStartCmd() *EnvBuildUpdateOne {
	ebuo.mutation.ClearStartCmd()
	return ebuo
}

// SetVcpu sets the "vcpu" field.
func (ebuo *EnvBuildUpdateOne) SetVcpu(i int64) *EnvBuildUpdateOne {
	ebuo.mutation.ResetVcpu()
	ebuo.mutation.SetVcpu(i)
	return ebuo
}

// SetNillableVcpu sets the "vcpu" field if the given value is not nil.
func (ebuo *EnvBuildUpdateOne) SetNillableVcpu(i *int64) *EnvBuildUpdateOne {
	if i != nil {
		ebuo.SetVcpu(*i)
	}
	return ebuo
}

// AddVcpu adds i to the "vcpu" field.
func (ebuo *EnvBuildUpdateOne) AddVcpu(i int64) *EnvBuildUpdateOne {
	ebuo.mutation.AddVcpu(i)
	return ebuo
}

// SetRAMMB sets the "ram_mb" field.
func (ebuo *EnvBuildUpdateOne) SetRAMMB(i int64) *EnvBuildUpdateOne {
	ebuo.mutation.ResetRAMMB()
	ebuo.mutation.SetRAMMB(i)
	return ebuo
}

// SetNillableRAMMB sets the "ram_mb" field if the given value is not nil.
func (ebuo *EnvBuildUpdateOne) SetNillableRAMMB(i *int64) *EnvBuildUpdateOne {
	if i != nil {
		ebuo.SetRAMMB(*i)
	}
	return ebuo
}

// AddRAMMB adds i to the "ram_mb" field.
func (ebuo *EnvBuildUpdateOne) AddRAMMB(i int64) *EnvBuildUpdateOne {
	ebuo.mutation.AddRAMMB(i)
	return ebuo
}

// SetFreeDiskSizeMB sets the "free_disk_size_mb" field.
func (ebuo *EnvBuildUpdateOne) SetFreeDiskSizeMB(i int64) *EnvBuildUpdateOne {
	ebuo.mutation.ResetFreeDiskSizeMB()
	ebuo.mutation.SetFreeDiskSizeMB(i)
	return ebuo
}

// SetNillableFreeDiskSizeMB sets the "free_disk_size_mb" field if the given value is not nil.
func (ebuo *EnvBuildUpdateOne) SetNillableFreeDiskSizeMB(i *int64) *EnvBuildUpdateOne {
	if i != nil {
		ebuo.SetFreeDiskSizeMB(*i)
	}
	return ebuo
}

// AddFreeDiskSizeMB adds i to the "free_disk_size_mb" field.
func (ebuo *EnvBuildUpdateOne) AddFreeDiskSizeMB(i int64) *EnvBuildUpdateOne {
	ebuo.mutation.AddFreeDiskSizeMB(i)
	return ebuo
}

// SetTotalDiskSizeMB sets the "total_disk_size_mb" field.
func (ebuo *EnvBuildUpdateOne) SetTotalDiskSizeMB(i int64) *EnvBuildUpdateOne {
	ebuo.mutation.ResetTotalDiskSizeMB()
	ebuo.mutation.SetTotalDiskSizeMB(i)
	return ebuo
}

// SetNillableTotalDiskSizeMB sets the "total_disk_size_mb" field if the given value is not nil.
func (ebuo *EnvBuildUpdateOne) SetNillableTotalDiskSizeMB(i *int64) *EnvBuildUpdateOne {
	if i != nil {
		ebuo.SetTotalDiskSizeMB(*i)
	}
	return ebuo
}

// AddTotalDiskSizeMB adds i to the "total_disk_size_mb" field.
func (ebuo *EnvBuildUpdateOne) AddTotalDiskSizeMB(i int64) *EnvBuildUpdateOne {
	ebuo.mutation.AddTotalDiskSizeMB(i)
	return ebuo
}

// ClearTotalDiskSizeMB clears the value of the "total_disk_size_mb" field.
func (ebuo *EnvBuildUpdateOne) ClearTotalDiskSizeMB() *EnvBuildUpdateOne {
	ebuo.mutation.ClearTotalDiskSizeMB()
	return ebuo
}

// SetKernelVersion sets the "kernel_version" field.
func (ebuo *EnvBuildUpdateOne) SetKernelVersion(s string) *EnvBuildUpdateOne {
	ebuo.mutation.SetKernelVersion(s)
	return ebuo
}

// SetNillableKernelVersion sets the "kernel_version" field if the given value is not nil.
func (ebuo *EnvBuildUpdateOne) SetNillableKernelVersion(s *string) *EnvBuildUpdateOne {
	if s != nil {
		ebuo.SetKernelVersion(*s)
	}
	return ebuo
}

// SetFirecrackerVersion sets the "firecracker_version" field.
func (ebuo *EnvBuildUpdateOne) SetFirecrackerVersion(s string) *EnvBuildUpdateOne {
	ebuo.mutation.SetFirecrackerVersion(s)
	return ebuo
}

// SetNillableFirecrackerVersion sets the "firecracker_version" field if the given value is not nil.
func (ebuo *EnvBuildUpdateOne) SetNillableFirecrackerVersion(s *string) *EnvBuildUpdateOne {
	if s != nil {
		ebuo.SetFirecrackerVersion(*s)
	}
	return ebuo
}

// SetEnvdVersion sets the "envd_version" field.
func (ebuo *EnvBuildUpdateOne) SetEnvdVersion(s string) *EnvBuildUpdateOne {
	ebuo.mutation.SetEnvdVersion(s)
	return ebuo
}

// SetNillableEnvdVersion sets the "envd_version" field if the given value is not nil.
func (ebuo *EnvBuildUpdateOne) SetNillableEnvdVersion(s *string) *EnvBuildUpdateOne {
	if s != nil {
		ebuo.SetEnvdVersion(*s)
	}
	return ebuo
}

// ClearEnvdVersion clears the value of the "envd_version" field.
func (ebuo *EnvBuildUpdateOne) ClearEnvdVersion() *EnvBuildUpdateOne {
	ebuo.mutation.ClearEnvdVersion()
	return ebuo
}

// SetEnv sets the "env" edge to the Env entity.
func (ebuo *EnvBuildUpdateOne) SetEnv(e *Env) *EnvBuildUpdateOne {
	return ebuo.SetEnvID(e.ID)
}

// Mutation returns the EnvBuildMutation object of the builder.
func (ebuo *EnvBuildUpdateOne) Mutation() *EnvBuildMutation {
	return ebuo.mutation
}

// ClearEnv clears the "env" edge to the Env entity.
func (ebuo *EnvBuildUpdateOne) ClearEnv() *EnvBuildUpdateOne {
	ebuo.mutation.ClearEnv()
	return ebuo
}

// Where appends a list predicates to the EnvBuildUpdate builder.
func (ebuo *EnvBuildUpdateOne) Where(ps ...predicate.EnvBuild) *EnvBuildUpdateOne {
	ebuo.mutation.Where(ps...)
	return ebuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (ebuo *EnvBuildUpdateOne) Select(field string, fields ...string) *EnvBuildUpdateOne {
	ebuo.fields = append([]string{field}, fields...)
	return ebuo
}

// Save executes the query and returns the updated EnvBuild entity.
func (ebuo *EnvBuildUpdateOne) Save(ctx context.Context) (*EnvBuild, error) {
	return withHooks(ctx, ebuo.sqlSave, ebuo.mutation, ebuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (ebuo *EnvBuildUpdateOne) SaveX(ctx context.Context) *EnvBuild {
	node, err := ebuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (ebuo *EnvBuildUpdateOne) Exec(ctx context.Context) error {
	_, err := ebuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ebuo *EnvBuildUpdateOne) ExecX(ctx context.Context) {
	if err := ebuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (ebuo *EnvBuildUpdateOne) check() error {
	if v, ok := ebuo.mutation.Status(); ok {
		if err := envbuild.StatusValidator(v); err != nil {
			return &ValidationError{Name: "status", err: fmt.Errorf(`models: validator failed for field "EnvBuild.status": %w`, err)}
		}
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (ebuo *EnvBuildUpdateOne) Modify(modifiers ...func(u *sql.UpdateBuilder)) *EnvBuildUpdateOne {
	ebuo.modifiers = append(ebuo.modifiers, modifiers...)
	return ebuo
}

func (ebuo *EnvBuildUpdateOne) sqlSave(ctx context.Context) (_node *EnvBuild, err error) {
	if err := ebuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(envbuild.Table, envbuild.Columns, sqlgraph.NewFieldSpec(envbuild.FieldID, field.TypeUUID))
	id, ok := ebuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`models: missing "EnvBuild.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := ebuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, envbuild.FieldID)
		for _, f := range fields {
			if !envbuild.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
			}
			if f != envbuild.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := ebuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := ebuo.mutation.UpdatedAt(); ok {
		_spec.SetField(envbuild.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := ebuo.mutation.FinishedAt(); ok {
		_spec.SetField(envbuild.FieldFinishedAt, field.TypeTime, value)
	}
	if ebuo.mutation.FinishedAtCleared() {
		_spec.ClearField(envbuild.FieldFinishedAt, field.TypeTime)
	}
	if value, ok := ebuo.mutation.Status(); ok {
		_spec.SetField(envbuild.FieldStatus, field.TypeEnum, value)
	}
	if value, ok := ebuo.mutation.Dockerfile(); ok {
		_spec.SetField(envbuild.FieldDockerfile, field.TypeString, value)
	}
	if ebuo.mutation.DockerfileCleared() {
		_spec.ClearField(envbuild.FieldDockerfile, field.TypeString)
	}
	if value, ok := ebuo.mutation.StartCmd(); ok {
		_spec.SetField(envbuild.FieldStartCmd, field.TypeString, value)
	}
	if ebuo.mutation.StartCmdCleared() {
		_spec.ClearField(envbuild.FieldStartCmd, field.TypeString)
	}
	if value, ok := ebuo.mutation.Vcpu(); ok {
		_spec.SetField(envbuild.FieldVcpu, field.TypeInt64, value)
	}
	if value, ok := ebuo.mutation.AddedVcpu(); ok {
		_spec.AddField(envbuild.FieldVcpu, field.TypeInt64, value)
	}
	if value, ok := ebuo.mutation.RAMMB(); ok {
		_spec.SetField(envbuild.FieldRAMMB, field.TypeInt64, value)
	}
	if value, ok := ebuo.mutation.AddedRAMMB(); ok {
		_spec.AddField(envbuild.FieldRAMMB, field.TypeInt64, value)
	}
	if value, ok := ebuo.mutation.FreeDiskSizeMB(); ok {
		_spec.SetField(envbuild.FieldFreeDiskSizeMB, field.TypeInt64, value)
	}
	if value, ok := ebuo.mutation.AddedFreeDiskSizeMB(); ok {
		_spec.AddField(envbuild.FieldFreeDiskSizeMB, field.TypeInt64, value)
	}
	if value, ok := ebuo.mutation.TotalDiskSizeMB(); ok {
		_spec.SetField(envbuild.FieldTotalDiskSizeMB, field.TypeInt64, value)
	}
	if value, ok := ebuo.mutation.AddedTotalDiskSizeMB(); ok {
		_spec.AddField(envbuild.FieldTotalDiskSizeMB, field.TypeInt64, value)
	}
	if ebuo.mutation.TotalDiskSizeMBCleared() {
		_spec.ClearField(envbuild.FieldTotalDiskSizeMB, field.TypeInt64)
	}
	if value, ok := ebuo.mutation.KernelVersion(); ok {
		_spec.SetField(envbuild.FieldKernelVersion, field.TypeString, value)
	}
	if value, ok := ebuo.mutation.FirecrackerVersion(); ok {
		_spec.SetField(envbuild.FieldFirecrackerVersion, field.TypeString, value)
	}
	if value, ok := ebuo.mutation.EnvdVersion(); ok {
		_spec.SetField(envbuild.FieldEnvdVersion, field.TypeString, value)
	}
	if ebuo.mutation.EnvdVersionCleared() {
		_spec.ClearField(envbuild.FieldEnvdVersion, field.TypeString)
	}
	if ebuo.mutation.EnvCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   envbuild.EnvTable,
			Columns: []string{envbuild.EnvColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = ebuo.schemaConfig.EnvBuild
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := ebuo.mutation.EnvIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   envbuild.EnvTable,
			Columns: []string{envbuild.EnvColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = ebuo.schemaConfig.EnvBuild
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = ebuo.schemaConfig.EnvBuild
	ctx = internal.NewSchemaConfigContext(ctx, ebuo.schemaConfig)
	_spec.AddModifiers(ebuo.modifiers...)
	_node = &EnvBuild{config: ebuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, ebuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{envbuild.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	ebuo.mutation.done = true
	return _node, nil
}



================================================
File: models/mutation.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/accesstoken"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envalias"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envbuild"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/snapshot"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/teamapikey"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/tier"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccessToken = "AccessToken"
	TypeEnv         = "Env"
	TypeEnvAlias    = "EnvAlias"
	TypeEnvBuild    = "EnvBuild"
	TypeSnapshot    = "Snapshot"
	TypeTeam        = "Team"
	TypeTeamAPIKey  = "TeamAPIKey"
	TypeTier        = "Tier"
	TypeUser        = "User"
	TypeUsersTeams  = "UsersTeams"
)

// AccessTokenMutation represents an operation that mutates the AccessToken nodes in the graph.
type AccessTokenMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*AccessToken, error)
	predicates    []predicate.AccessToken
}

var _ ent.Mutation = (*AccessTokenMutation)(nil)

// accesstokenOption allows management of the mutation configuration using functional options.
type accesstokenOption func(*AccessTokenMutation)

// newAccessTokenMutation creates new mutation for the AccessToken entity.
func newAccessTokenMutation(c config, op Op, opts ...accesstokenOption) *AccessTokenMutation {
	m := &AccessTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAccessToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccessTokenID sets the ID field of the mutation.
func withAccessTokenID(id string) accesstokenOption {
	return func(m *AccessTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *AccessToken
		)
		m.oldValue = func(ctx context.Context) (*AccessToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccessToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccessToken sets the old AccessToken of the mutation.
func withAccessToken(node *AccessToken) accesstokenOption {
	return func(m *AccessTokenMutation) {
		m.oldValue = func(context.Context) (*AccessToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccessTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccessTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccessToken entities.
func (m *AccessTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccessTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccessTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccessToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AccessTokenMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AccessTokenMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AccessTokenMutation) ResetUserID() {
	m.user = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccessTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccessTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AccessTokenMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[accesstoken.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AccessTokenMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[accesstoken.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccessTokenMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, accesstoken.FieldCreatedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *AccessTokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[accesstoken.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AccessTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AccessTokenMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AccessTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AccessTokenMutation builder.
func (m *AccessTokenMutation) Where(ps ...predicate.AccessToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccessTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccessTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccessToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccessTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccessTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccessToken).
func (m *AccessTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccessTokenMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.user != nil {
		fields = append(fields, accesstoken.FieldUserID)
	}
	if m.created_at != nil {
		fields = append(fields, accesstoken.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccessTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accesstoken.FieldUserID:
		return m.UserID()
	case accesstoken.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccessTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accesstoken.FieldUserID:
		return m.OldUserID(ctx)
	case accesstoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AccessToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accesstoken.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case accesstoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AccessToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccessTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccessTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccessToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccessTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accesstoken.FieldCreatedAt) {
		fields = append(fields, accesstoken.FieldCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccessTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccessTokenMutation) ClearField(name string) error {
	switch name {
	case accesstoken.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AccessToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccessTokenMutation) ResetField(name string) error {
	switch name {
	case accesstoken.FieldUserID:
		m.ResetUserID()
		return nil
	case accesstoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AccessToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccessTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, accesstoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccessTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accesstoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccessTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccessTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccessTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, accesstoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccessTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case accesstoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccessTokenMutation) ClearEdge(name string) error {
	switch name {
	case accesstoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AccessToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccessTokenMutation) ResetEdge(name string) error {
	switch name {
	case accesstoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AccessToken edge %s", name)
}

// EnvMutation represents an operation that mutates the Env nodes in the graph.
type EnvMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	public             *bool
	build_count        *int32
	addbuild_count     *int32
	spawn_count        *int64
	addspawn_count     *int64
	last_spawned_at    *time.Time
	clearedFields      map[string]struct{}
	team               *uuid.UUID
	clearedteam        bool
	creator            *uuid.UUID
	clearedcreator     bool
	env_aliases        map[string]struct{}
	removedenv_aliases map[string]struct{}
	clearedenv_aliases bool
	builds             map[uuid.UUID]struct{}
	removedbuilds      map[uuid.UUID]struct{}
	clearedbuilds      bool
	snapshots          map[uuid.UUID]struct{}
	removedsnapshots   map[uuid.UUID]struct{}
	clearedsnapshots   bool
	done               bool
	oldValue           func(context.Context) (*Env, error)
	predicates         []predicate.Env
}

var _ ent.Mutation = (*EnvMutation)(nil)

// envOption allows management of the mutation configuration using functional options.
type envOption func(*EnvMutation)

// newEnvMutation creates new mutation for the Env entity.
func newEnvMutation(c config, op Op, opts ...envOption) *EnvMutation {
	m := &EnvMutation{
		config:        c,
		op:            op,
		typ:           TypeEnv,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvID sets the ID field of the mutation.
func withEnvID(id string) envOption {
	return func(m *EnvMutation) {
		var (
			err   error
			once  sync.Once
			value *Env
		)
		m.oldValue = func(ctx context.Context) (*Env, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Env.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnv sets the old Env of the mutation.
func withEnv(node *Env) envOption {
	return func(m *EnvMutation) {
		m.oldValue = func(context.Context) (*Env, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Env entities.
func (m *EnvMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnvMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnvMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Env.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnvMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnvMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnvMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnvMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnvMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnvMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTeamID sets the "team_id" field.
func (m *EnvMutation) SetTeamID(u uuid.UUID) {
	m.team = &u
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *EnvMutation) TeamID() (r uuid.UUID, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldTeamID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *EnvMutation) ResetTeamID() {
	m.team = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EnvMutation) SetCreatedBy(u uuid.UUID) {
	m.creator = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EnvMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldCreatedBy(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *EnvMutation) ClearCreatedBy() {
	m.creator = nil
	m.clearedFields[env.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *EnvMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[env.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EnvMutation) ResetCreatedBy() {
	m.creator = nil
	delete(m.clearedFields, env.FieldCreatedBy)
}

// SetPublic sets the "public" field.
func (m *EnvMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *EnvMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *EnvMutation) ResetPublic() {
	m.public = nil
}

// SetBuildCount sets the "build_count" field.
func (m *EnvMutation) SetBuildCount(i int32) {
	m.build_count = &i
	m.addbuild_count = nil
}

// BuildCount returns the value of the "build_count" field in the mutation.
func (m *EnvMutation) BuildCount() (r int32, exists bool) {
	v := m.build_count
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildCount returns the old "build_count" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldBuildCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildCount: %w", err)
	}
	return oldValue.BuildCount, nil
}

// AddBuildCount adds i to the "build_count" field.
func (m *EnvMutation) AddBuildCount(i int32) {
	if m.addbuild_count != nil {
		*m.addbuild_count += i
	} else {
		m.addbuild_count = &i
	}
}

// AddedBuildCount returns the value that was added to the "build_count" field in this mutation.
func (m *EnvMutation) AddedBuildCount() (r int32, exists bool) {
	v := m.addbuild_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetBuildCount resets all changes to the "build_count" field.
func (m *EnvMutation) ResetBuildCount() {
	m.build_count = nil
	m.addbuild_count = nil
}

// SetSpawnCount sets the "spawn_count" field.
func (m *EnvMutation) SetSpawnCount(i int64) {
	m.spawn_count = &i
	m.addspawn_count = nil
}

// SpawnCount returns the value of the "spawn_count" field in the mutation.
func (m *EnvMutation) SpawnCount() (r int64, exists bool) {
	v := m.spawn_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSpawnCount returns the old "spawn_count" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldSpawnCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpawnCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpawnCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpawnCount: %w", err)
	}
	return oldValue.SpawnCount, nil
}

// AddSpawnCount adds i to the "spawn_count" field.
func (m *EnvMutation) AddSpawnCount(i int64) {
	if m.addspawn_count != nil {
		*m.addspawn_count += i
	} else {
		m.addspawn_count = &i
	}
}

// AddedSpawnCount returns the value that was added to the "spawn_count" field in this mutation.
func (m *EnvMutation) AddedSpawnCount() (r int64, exists bool) {
	v := m.addspawn_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpawnCount resets all changes to the "spawn_count" field.
func (m *EnvMutation) ResetSpawnCount() {
	m.spawn_count = nil
	m.addspawn_count = nil
}

// SetLastSpawnedAt sets the "last_spawned_at" field.
func (m *EnvMutation) SetLastSpawnedAt(t time.Time) {
	m.last_spawned_at = &t
}

// LastSpawnedAt returns the value of the "last_spawned_at" field in the mutation.
func (m *EnvMutation) LastSpawnedAt() (r time.Time, exists bool) {
	v := m.last_spawned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSpawnedAt returns the old "last_spawned_at" field's value of the Env entity.
// If the Env object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvMutation) OldLastSpawnedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSpawnedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSpawnedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSpawnedAt: %w", err)
	}
	return oldValue.LastSpawnedAt, nil
}

// ClearLastSpawnedAt clears the value of the "last_spawned_at" field.
func (m *EnvMutation) ClearLastSpawnedAt() {
	m.last_spawned_at = nil
	m.clearedFields[env.FieldLastSpawnedAt] = struct{}{}
}

// LastSpawnedAtCleared returns if the "last_spawned_at" field was cleared in this mutation.
func (m *EnvMutation) LastSpawnedAtCleared() bool {
	_, ok := m.clearedFields[env.FieldLastSpawnedAt]
	return ok
}

// ResetLastSpawnedAt resets all changes to the "last_spawned_at" field.
func (m *EnvMutation) ResetLastSpawnedAt() {
	m.last_spawned_at = nil
	delete(m.clearedFields, env.FieldLastSpawnedAt)
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *EnvMutation) ClearTeam() {
	m.clearedteam = true
	m.clearedFields[env.FieldTeamID] = struct{}{}
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *EnvMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *EnvMutation) TeamIDs() (ids []uuid.UUID) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *EnvMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *EnvMutation) SetCreatorID(id uuid.UUID) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *EnvMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[env.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *EnvMutation) CreatorCleared() bool {
	return m.CreatedByCleared() || m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *EnvMutation) CreatorID() (id uuid.UUID, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *EnvMutation) CreatorIDs() (ids []uuid.UUID) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *EnvMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// AddEnvAliasIDs adds the "env_aliases" edge to the EnvAlias entity by ids.
func (m *EnvMutation) AddEnvAliasIDs(ids ...string) {
	if m.env_aliases == nil {
		m.env_aliases = make(map[string]struct{})
	}
	for i := range ids {
		m.env_aliases[ids[i]] = struct{}{}
	}
}

// ClearEnvAliases clears the "env_aliases" edge to the EnvAlias entity.
func (m *EnvMutation) ClearEnvAliases() {
	m.clearedenv_aliases = true
}

// EnvAliasesCleared reports if the "env_aliases" edge to the EnvAlias entity was cleared.
func (m *EnvMutation) EnvAliasesCleared() bool {
	return m.clearedenv_aliases
}

// RemoveEnvAliasIDs removes the "env_aliases" edge to the EnvAlias entity by IDs.
func (m *EnvMutation) RemoveEnvAliasIDs(ids ...string) {
	if m.removedenv_aliases == nil {
		m.removedenv_aliases = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.env_aliases, ids[i])
		m.removedenv_aliases[ids[i]] = struct{}{}
	}
}

// RemovedEnvAliases returns the removed IDs of the "env_aliases" edge to the EnvAlias entity.
func (m *EnvMutation) RemovedEnvAliasesIDs() (ids []string) {
	for id := range m.removedenv_aliases {
		ids = append(ids, id)
	}
	return
}

// EnvAliasesIDs returns the "env_aliases" edge IDs in the mutation.
func (m *EnvMutation) EnvAliasesIDs() (ids []string) {
	for id := range m.env_aliases {
		ids = append(ids, id)
	}
	return
}

// ResetEnvAliases resets all changes to the "env_aliases" edge.
func (m *EnvMutation) ResetEnvAliases() {
	m.env_aliases = nil
	m.clearedenv_aliases = false
	m.removedenv_aliases = nil
}

// AddBuildIDs adds the "builds" edge to the EnvBuild entity by ids.
func (m *EnvMutation) AddBuildIDs(ids ...uuid.UUID) {
	if m.builds == nil {
		m.builds = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.builds[ids[i]] = struct{}{}
	}
}

// ClearBuilds clears the "builds" edge to the EnvBuild entity.
func (m *EnvMutation) ClearBuilds() {
	m.clearedbuilds = true
}

// BuildsCleared reports if the "builds" edge to the EnvBuild entity was cleared.
func (m *EnvMutation) BuildsCleared() bool {
	return m.clearedbuilds
}

// RemoveBuildIDs removes the "builds" edge to the EnvBuild entity by IDs.
func (m *EnvMutation) RemoveBuildIDs(ids ...uuid.UUID) {
	if m.removedbuilds == nil {
		m.removedbuilds = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.builds, ids[i])
		m.removedbuilds[ids[i]] = struct{}{}
	}
}

// RemovedBuilds returns the removed IDs of the "builds" edge to the EnvBuild entity.
func (m *EnvMutation) RemovedBuildsIDs() (ids []uuid.UUID) {
	for id := range m.removedbuilds {
		ids = append(ids, id)
	}
	return
}

// BuildsIDs returns the "builds" edge IDs in the mutation.
func (m *EnvMutation) BuildsIDs() (ids []uuid.UUID) {
	for id := range m.builds {
		ids = append(ids, id)
	}
	return
}

// ResetBuilds resets all changes to the "builds" edge.
func (m *EnvMutation) ResetBuilds() {
	m.builds = nil
	m.clearedbuilds = false
	m.removedbuilds = nil
}

// AddSnapshotIDs adds the "snapshots" edge to the Snapshot entity by ids.
func (m *EnvMutation) AddSnapshotIDs(ids ...uuid.UUID) {
	if m.snapshots == nil {
		m.snapshots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.snapshots[ids[i]] = struct{}{}
	}
}

// ClearSnapshots clears the "snapshots" edge to the Snapshot entity.
func (m *EnvMutation) ClearSnapshots() {
	m.clearedsnapshots = true
}

// SnapshotsCleared reports if the "snapshots" edge to the Snapshot entity was cleared.
func (m *EnvMutation) SnapshotsCleared() bool {
	return m.clearedsnapshots
}

// RemoveSnapshotIDs removes the "snapshots" edge to the Snapshot entity by IDs.
func (m *EnvMutation) RemoveSnapshotIDs(ids ...uuid.UUID) {
	if m.removedsnapshots == nil {
		m.removedsnapshots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.snapshots, ids[i])
		m.removedsnapshots[ids[i]] = struct{}{}
	}
}

// RemovedSnapshots returns the removed IDs of the "snapshots" edge to the Snapshot entity.
func (m *EnvMutation) RemovedSnapshotsIDs() (ids []uuid.UUID) {
	for id := range m.removedsnapshots {
		ids = append(ids, id)
	}
	return
}

// SnapshotsIDs returns the "snapshots" edge IDs in the mutation.
func (m *EnvMutation) SnapshotsIDs() (ids []uuid.UUID) {
	for id := range m.snapshots {
		ids = append(ids, id)
	}
	return
}

// ResetSnapshots resets all changes to the "snapshots" edge.
func (m *EnvMutation) ResetSnapshots() {
	m.snapshots = nil
	m.clearedsnapshots = false
	m.removedsnapshots = nil
}

// Where appends a list predicates to the EnvMutation builder.
func (m *EnvMutation) Where(ps ...predicate.Env) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnvMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnvMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Env, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnvMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnvMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Env).
func (m *EnvMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, env.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, env.FieldUpdatedAt)
	}
	if m.team != nil {
		fields = append(fields, env.FieldTeamID)
	}
	if m.creator != nil {
		fields = append(fields, env.FieldCreatedBy)
	}
	if m.public != nil {
		fields = append(fields, env.FieldPublic)
	}
	if m.build_count != nil {
		fields = append(fields, env.FieldBuildCount)
	}
	if m.spawn_count != nil {
		fields = append(fields, env.FieldSpawnCount)
	}
	if m.last_spawned_at != nil {
		fields = append(fields, env.FieldLastSpawnedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case env.FieldCreatedAt:
		return m.CreatedAt()
	case env.FieldUpdatedAt:
		return m.UpdatedAt()
	case env.FieldTeamID:
		return m.TeamID()
	case env.FieldCreatedBy:
		return m.CreatedBy()
	case env.FieldPublic:
		return m.Public()
	case env.FieldBuildCount:
		return m.BuildCount()
	case env.FieldSpawnCount:
		return m.SpawnCount()
	case env.FieldLastSpawnedAt:
		return m.LastSpawnedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case env.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case env.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case env.FieldTeamID:
		return m.OldTeamID(ctx)
	case env.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case env.FieldPublic:
		return m.OldPublic(ctx)
	case env.FieldBuildCount:
		return m.OldBuildCount(ctx)
	case env.FieldSpawnCount:
		return m.OldSpawnCount(ctx)
	case env.FieldLastSpawnedAt:
		return m.OldLastSpawnedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Env field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvMutation) SetField(name string, value ent.Value) error {
	switch name {
	case env.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case env.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case env.FieldTeamID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case env.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case env.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case env.FieldBuildCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildCount(v)
		return nil
	case env.FieldSpawnCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpawnCount(v)
		return nil
	case env.FieldLastSpawnedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSpawnedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Env field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvMutation) AddedFields() []string {
	var fields []string
	if m.addbuild_count != nil {
		fields = append(fields, env.FieldBuildCount)
	}
	if m.addspawn_count != nil {
		fields = append(fields, env.FieldSpawnCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case env.FieldBuildCount:
		return m.AddedBuildCount()
	case env.FieldSpawnCount:
		return m.AddedSpawnCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvMutation) AddField(name string, value ent.Value) error {
	switch name {
	case env.FieldBuildCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBuildCount(v)
		return nil
	case env.FieldSpawnCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpawnCount(v)
		return nil
	}
	return fmt.Errorf("unknown Env numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(env.FieldCreatedBy) {
		fields = append(fields, env.FieldCreatedBy)
	}
	if m.FieldCleared(env.FieldLastSpawnedAt) {
		fields = append(fields, env.FieldLastSpawnedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvMutation) ClearField(name string) error {
	switch name {
	case env.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case env.FieldLastSpawnedAt:
		m.ClearLastSpawnedAt()
		return nil
	}
	return fmt.Errorf("unknown Env nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvMutation) ResetField(name string) error {
	switch name {
	case env.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case env.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case env.FieldTeamID:
		m.ResetTeamID()
		return nil
	case env.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case env.FieldPublic:
		m.ResetPublic()
		return nil
	case env.FieldBuildCount:
		m.ResetBuildCount()
		return nil
	case env.FieldSpawnCount:
		m.ResetSpawnCount()
		return nil
	case env.FieldLastSpawnedAt:
		m.ResetLastSpawnedAt()
		return nil
	}
	return fmt.Errorf("unknown Env field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.team != nil {
		edges = append(edges, env.EdgeTeam)
	}
	if m.creator != nil {
		edges = append(edges, env.EdgeCreator)
	}
	if m.env_aliases != nil {
		edges = append(edges, env.EdgeEnvAliases)
	}
	if m.builds != nil {
		edges = append(edges, env.EdgeBuilds)
	}
	if m.snapshots != nil {
		edges = append(edges, env.EdgeSnapshots)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case env.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case env.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case env.EdgeEnvAliases:
		ids := make([]ent.Value, 0, len(m.env_aliases))
		for id := range m.env_aliases {
			ids = append(ids, id)
		}
		return ids
	case env.EdgeBuilds:
		ids := make([]ent.Value, 0, len(m.builds))
		for id := range m.builds {
			ids = append(ids, id)
		}
		return ids
	case env.EdgeSnapshots:
		ids := make([]ent.Value, 0, len(m.snapshots))
		for id := range m.snapshots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedenv_aliases != nil {
		edges = append(edges, env.EdgeEnvAliases)
	}
	if m.removedbuilds != nil {
		edges = append(edges, env.EdgeBuilds)
	}
	if m.removedsnapshots != nil {
		edges = append(edges, env.EdgeSnapshots)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case env.EdgeEnvAliases:
		ids := make([]ent.Value, 0, len(m.removedenv_aliases))
		for id := range m.removedenv_aliases {
			ids = append(ids, id)
		}
		return ids
	case env.EdgeBuilds:
		ids := make([]ent.Value, 0, len(m.removedbuilds))
		for id := range m.removedbuilds {
			ids = append(ids, id)
		}
		return ids
	case env.EdgeSnapshots:
		ids := make([]ent.Value, 0, len(m.removedsnapshots))
		for id := range m.removedsnapshots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedteam {
		edges = append(edges, env.EdgeTeam)
	}
	if m.clearedcreator {
		edges = append(edges, env.EdgeCreator)
	}
	if m.clearedenv_aliases {
		edges = append(edges, env.EdgeEnvAliases)
	}
	if m.clearedbuilds {
		edges = append(edges, env.EdgeBuilds)
	}
	if m.clearedsnapshots {
		edges = append(edges, env.EdgeSnapshots)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvMutation) EdgeCleared(name string) bool {
	switch name {
	case env.EdgeTeam:
		return m.clearedteam
	case env.EdgeCreator:
		return m.clearedcreator
	case env.EdgeEnvAliases:
		return m.clearedenv_aliases
	case env.EdgeBuilds:
		return m.clearedbuilds
	case env.EdgeSnapshots:
		return m.clearedsnapshots
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvMutation) ClearEdge(name string) error {
	switch name {
	case env.EdgeTeam:
		m.ClearTeam()
		return nil
	case env.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown Env unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvMutation) ResetEdge(name string) error {
	switch name {
	case env.EdgeTeam:
		m.ResetTeam()
		return nil
	case env.EdgeCreator:
		m.ResetCreator()
		return nil
	case env.EdgeEnvAliases:
		m.ResetEnvAliases()
		return nil
	case env.EdgeBuilds:
		m.ResetBuilds()
		return nil
	case env.EdgeSnapshots:
		m.ResetSnapshots()
		return nil
	}
	return fmt.Errorf("unknown Env edge %s", name)
}

// EnvAliasMutation represents an operation that mutates the EnvAlias nodes in the graph.
type EnvAliasMutation struct {
	config
	op            Op
	typ           string
	id            *string
	is_renamable  *bool
	clearedFields map[string]struct{}
	env           *string
	clearedenv    bool
	done          bool
	oldValue      func(context.Context) (*EnvAlias, error)
	predicates    []predicate.EnvAlias
}

var _ ent.Mutation = (*EnvAliasMutation)(nil)

// envaliasOption allows management of the mutation configuration using functional options.
type envaliasOption func(*EnvAliasMutation)

// newEnvAliasMutation creates new mutation for the EnvAlias entity.
func newEnvAliasMutation(c config, op Op, opts ...envaliasOption) *EnvAliasMutation {
	m := &EnvAliasMutation{
		config:        c,
		op:            op,
		typ:           TypeEnvAlias,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvAliasID sets the ID field of the mutation.
func withEnvAliasID(id string) envaliasOption {
	return func(m *EnvAliasMutation) {
		var (
			err   error
			once  sync.Once
			value *EnvAlias
		)
		m.oldValue = func(ctx context.Context) (*EnvAlias, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnvAlias.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnvAlias sets the old EnvAlias of the mutation.
func withEnvAlias(node *EnvAlias) envaliasOption {
	return func(m *EnvAliasMutation) {
		m.oldValue = func(context.Context) (*EnvAlias, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvAliasMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvAliasMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EnvAlias entities.
func (m *EnvAliasMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnvAliasMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnvAliasMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnvAlias.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnvID sets the "env_id" field.
func (m *EnvAliasMutation) SetEnvID(s string) {
	m.env = &s
}

// EnvID returns the value of the "env_id" field in the mutation.
func (m *EnvAliasMutation) EnvID() (r string, exists bool) {
	v := m.env
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvID returns the old "env_id" field's value of the EnvAlias entity.
// If the EnvAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvAliasMutation) OldEnvID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvID: %w", err)
	}
	return oldValue.EnvID, nil
}

// ResetEnvID resets all changes to the "env_id" field.
func (m *EnvAliasMutation) ResetEnvID() {
	m.env = nil
}

// SetIsRenamable sets the "is_renamable" field.
func (m *EnvAliasMutation) SetIsRenamable(b bool) {
	m.is_renamable = &b
}

// IsRenamable returns the value of the "is_renamable" field in the mutation.
func (m *EnvAliasMutation) IsRenamable() (r bool, exists bool) {
	v := m.is_renamable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRenamable returns the old "is_renamable" field's value of the EnvAlias entity.
// If the EnvAlias object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvAliasMutation) OldIsRenamable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRenamable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRenamable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRenamable: %w", err)
	}
	return oldValue.IsRenamable, nil
}

// ResetIsRenamable resets all changes to the "is_renamable" field.
func (m *EnvAliasMutation) ResetIsRenamable() {
	m.is_renamable = nil
}

// ClearEnv clears the "env" edge to the Env entity.
func (m *EnvAliasMutation) ClearEnv() {
	m.clearedenv = true
	m.clearedFields[envalias.FieldEnvID] = struct{}{}
}

// EnvCleared reports if the "env" edge to the Env entity was cleared.
func (m *EnvAliasMutation) EnvCleared() bool {
	return m.clearedenv
}

// EnvIDs returns the "env" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvID instead. It exists only for internal usage by the builders.
func (m *EnvAliasMutation) EnvIDs() (ids []string) {
	if id := m.env; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnv resets all changes to the "env" edge.
func (m *EnvAliasMutation) ResetEnv() {
	m.env = nil
	m.clearedenv = false
}

// Where appends a list predicates to the EnvAliasMutation builder.
func (m *EnvAliasMutation) Where(ps ...predicate.EnvAlias) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnvAliasMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnvAliasMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnvAlias, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnvAliasMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnvAliasMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnvAlias).
func (m *EnvAliasMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvAliasMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.env != nil {
		fields = append(fields, envalias.FieldEnvID)
	}
	if m.is_renamable != nil {
		fields = append(fields, envalias.FieldIsRenamable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvAliasMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case envalias.FieldEnvID:
		return m.EnvID()
	case envalias.FieldIsRenamable:
		return m.IsRenamable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvAliasMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case envalias.FieldEnvID:
		return m.OldEnvID(ctx)
	case envalias.FieldIsRenamable:
		return m.OldIsRenamable(ctx)
	}
	return nil, fmt.Errorf("unknown EnvAlias field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvAliasMutation) SetField(name string, value ent.Value) error {
	switch name {
	case envalias.FieldEnvID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvID(v)
		return nil
	case envalias.FieldIsRenamable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRenamable(v)
		return nil
	}
	return fmt.Errorf("unknown EnvAlias field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvAliasMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvAliasMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvAliasMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EnvAlias numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvAliasMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvAliasMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvAliasMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EnvAlias nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvAliasMutation) ResetField(name string) error {
	switch name {
	case envalias.FieldEnvID:
		m.ResetEnvID()
		return nil
	case envalias.FieldIsRenamable:
		m.ResetIsRenamable()
		return nil
	}
	return fmt.Errorf("unknown EnvAlias field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvAliasMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.env != nil {
		edges = append(edges, envalias.EdgeEnv)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvAliasMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case envalias.EdgeEnv:
		if id := m.env; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvAliasMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvAliasMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvAliasMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedenv {
		edges = append(edges, envalias.EdgeEnv)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvAliasMutation) EdgeCleared(name string) bool {
	switch name {
	case envalias.EdgeEnv:
		return m.clearedenv
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvAliasMutation) ClearEdge(name string) error {
	switch name {
	case envalias.EdgeEnv:
		m.ClearEnv()
		return nil
	}
	return fmt.Errorf("unknown EnvAlias unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvAliasMutation) ResetEdge(name string) error {
	switch name {
	case envalias.EdgeEnv:
		m.ResetEnv()
		return nil
	}
	return fmt.Errorf("unknown EnvAlias edge %s", name)
}

// EnvBuildMutation represents an operation that mutates the EnvBuild nodes in the graph.
type EnvBuildMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	finished_at           *time.Time
	status                *envbuild.Status
	dockerfile            *string
	start_cmd             *string
	vcpu                  *int64
	addvcpu               *int64
	ram_mb                *int64
	addram_mb             *int64
	free_disk_size_mb     *int64
	addfree_disk_size_mb  *int64
	total_disk_size_mb    *int64
	addtotal_disk_size_mb *int64
	kernel_version        *string
	firecracker_version   *string
	envd_version          *string
	clearedFields         map[string]struct{}
	env                   *string
	clearedenv            bool
	done                  bool
	oldValue              func(context.Context) (*EnvBuild, error)
	predicates            []predicate.EnvBuild
}

var _ ent.Mutation = (*EnvBuildMutation)(nil)

// envbuildOption allows management of the mutation configuration using functional options.
type envbuildOption func(*EnvBuildMutation)

// newEnvBuildMutation creates new mutation for the EnvBuild entity.
func newEnvBuildMutation(c config, op Op, opts ...envbuildOption) *EnvBuildMutation {
	m := &EnvBuildMutation{
		config:        c,
		op:            op,
		typ:           TypeEnvBuild,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvBuildID sets the ID field of the mutation.
func withEnvBuildID(id uuid.UUID) envbuildOption {
	return func(m *EnvBuildMutation) {
		var (
			err   error
			once  sync.Once
			value *EnvBuild
		)
		m.oldValue = func(ctx context.Context) (*EnvBuild, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnvBuild.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnvBuild sets the old EnvBuild of the mutation.
func withEnvBuild(node *EnvBuild) envbuildOption {
	return func(m *EnvBuildMutation) {
		m.oldValue = func(context.Context) (*EnvBuild, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvBuildMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvBuildMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EnvBuild entities.
func (m *EnvBuildMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnvBuildMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnvBuildMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnvBuild.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnvBuildMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnvBuildMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnvBuild entity.
// If the EnvBuild object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvBuildMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnvBuildMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnvBuildMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnvBuildMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnvBuild entity.
// If the EnvBuild object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvBuildMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnvBuildMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *EnvBuildMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *EnvBuildMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the EnvBuild entity.
// If the EnvBuild object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvBuildMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *EnvBuildMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[envbuild.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *EnvBuildMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[envbuild.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *EnvBuildMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, envbuild.FieldFinishedAt)
}

// SetEnvID sets the "env_id" field.
func (m *EnvBuildMutation) SetEnvID(s string) {
	m.env = &s
}

// EnvID returns the value of the "env_id" field in the mutation.
func (m *EnvBuildMutation) EnvID() (r string, exists bool) {
	v := m.env
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvID returns the old "env_id" field's value of the EnvBuild entity.
// If the EnvBuild object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvBuildMutation) OldEnvID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvID: %w", err)
	}
	return oldValue.EnvID, nil
}

// ClearEnvID clears the value of the "env_id" field.
func (m *EnvBuildMutation) ClearEnvID() {
	m.env = nil
	m.clearedFields[envbuild.FieldEnvID] = struct{}{}
}

// EnvIDCleared returns if the "env_id" field was cleared in this mutation.
func (m *EnvBuildMutation) EnvIDCleared() bool {
	_, ok := m.clearedFields[envbuild.FieldEnvID]
	return ok
}

// ResetEnvID resets all changes to the "env_id" field.
func (m *EnvBuildMutation) ResetEnvID() {
	m.env = nil
	delete(m.clearedFields, envbuild.FieldEnvID)
}

// SetStatus sets the "status" field.
func (m *EnvBuildMutation) SetStatus(e envbuild.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EnvBuildMutation) Status() (r envbuild.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EnvBuild entity.
// If the EnvBuild object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvBuildMutation) OldStatus(ctx context.Context) (v envbuild.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EnvBuildMutation) ResetStatus() {
	m.status = nil
}

// SetDockerfile sets the "dockerfile" field.
func (m *EnvBuildMutation) SetDockerfile(s string) {
	m.dockerfile = &s
}

// Dockerfile returns the value of the "dockerfile" field in the mutation.
func (m *EnvBuildMutation) Dockerfile() (r string, exists bool) {
	v := m.dockerfile
	if v == nil {
		return
	}
	return *v, true
}

// OldDockerfile returns the old "dockerfile" field's value of the EnvBuild entity.
// If the EnvBuild object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvBuildMutation) OldDockerfile(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDockerfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDockerfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDockerfile: %w", err)
	}
	return oldValue.Dockerfile, nil
}

// ClearDockerfile clears the value of the "dockerfile" field.
func (m *EnvBuildMutation) ClearDockerfile() {
	m.dockerfile = nil
	m.clearedFields[envbuild.FieldDockerfile] = struct{}{}
}

// DockerfileCleared returns if the "dockerfile" field was cleared in this mutation.
func (m *EnvBuildMutation) DockerfileCleared() bool {
	_, ok := m.clearedFields[envbuild.FieldDockerfile]
	return ok
}

// ResetDockerfile resets all changes to the "dockerfile" field.
func (m *EnvBuildMutation) ResetDockerfile() {
	m.dockerfile = nil
	delete(m.clearedFields, envbuild.FieldDockerfile)
}

// SetStartCmd sets the "start_cmd" field.
func (m *EnvBuildMutation) SetStartCmd(s string) {
	m.start_cmd = &s
}

// StartCmd returns the value of the "start_cmd" field in the mutation.
func (m *EnvBuildMutation) StartCmd() (r string, exists bool) {
	v := m.start_cmd
	if v == nil {
		return
	}
	return *v, true
}

// OldStartCmd returns the old "start_cmd" field's value of the EnvBuild entity.
// If the EnvBuild object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvBuildMutation) OldStartCmd(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartCmd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartCmd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartCmd: %w", err)
	}
	return oldValue.StartCmd, nil
}

// ClearStartCmd clears the value of the "start_cmd" field.
func (m *EnvBuildMutation) ClearStartCmd() {
	m.start_cmd = nil
	m.clearedFields[envbuild.FieldStartCmd] = struct{}{}
}

// StartCmdCleared returns if the "start_cmd" field was cleared in this mutation.
func (m *EnvBuildMutation) StartCmdCleared() bool {
	_, ok := m.clearedFields[envbuild.FieldStartCmd]
	return ok
}

// ResetStartCmd resets all changes to the "start_cmd" field.
func (m *EnvBuildMutation) ResetStartCmd() {
	m.start_cmd = nil
	delete(m.clearedFields, envbuild.FieldStartCmd)
}

// SetVcpu sets the "vcpu" field.
func (m *EnvBuildMutation) SetVcpu(i int64) {
	m.vcpu = &i
	m.addvcpu = nil
}

// Vcpu returns the value of the "vcpu" field in the mutation.
func (m *EnvBuildMutation) Vcpu() (r int64, exists bool) {
	v := m.vcpu
	if v == nil {
		return
	}
	return *v, true
}

// OldVcpu returns the old "vcpu" field's value of the EnvBuild entity.
// If the EnvBuild object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvBuildMutation) OldVcpu(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVcpu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVcpu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVcpu: %w", err)
	}
	return oldValue.Vcpu, nil
}

// AddVcpu adds i to the "vcpu" field.
func (m *EnvBuildMutation) AddVcpu(i int64) {
	if m.addvcpu != nil {
		*m.addvcpu += i
	} else {
		m.addvcpu = &i
	}
}

// AddedVcpu returns the value that was added to the "vcpu" field in this mutation.
func (m *EnvBuildMutation) AddedVcpu() (r int64, exists bool) {
	v := m.addvcpu
	if v == nil {
		return
	}
	return *v, true
}

// ResetVcpu resets all changes to the "vcpu" field.
func (m *EnvBuildMutation) ResetVcpu() {
	m.vcpu = nil
	m.addvcpu = nil
}

// SetRAMMB sets the "ram_mb" field.
func (m *EnvBuildMutation) SetRAMMB(i int64) {
	m.ram_mb = &i
	m.addram_mb = nil
}

// RAMMB returns the value of the "ram_mb" field in the mutation.
func (m *EnvBuildMutation) RAMMB() (r int64, exists bool) {
	v := m.ram_mb
	if v == nil {
		return
	}
	return *v, true
}

// OldRAMMB returns the old "ram_mb" field's value of the EnvBuild entity.
// If the EnvBuild object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvBuildMutation) OldRAMMB(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRAMMB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRAMMB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRAMMB: %w", err)
	}
	return oldValue.RAMMB, nil
}

// AddRAMMB adds i to the "ram_mb" field.
func (m *EnvBuildMutation) AddRAMMB(i int64) {
	if m.addram_mb != nil {
		*m.addram_mb += i
	} else {
		m.addram_mb = &i
	}
}

// AddedRAMMB returns the value that was added to the "ram_mb" field in this mutation.
func (m *EnvBuildMutation) AddedRAMMB() (r int64, exists bool) {
	v := m.addram_mb
	if v == nil {
		return
	}
	return *v, true
}

// ResetRAMMB resets all changes to the "ram_mb" field.
func (m *EnvBuildMutation) ResetRAMMB() {
	m.ram_mb = nil
	m.addram_mb = nil
}

// SetFreeDiskSizeMB sets the "free_disk_size_mb" field.
func (m *EnvBuildMutation) SetFreeDiskSizeMB(i int64) {
	m.free_disk_size_mb = &i
	m.addfree_disk_size_mb = nil
}

// FreeDiskSizeMB returns the value of the "free_disk_size_mb" field in the mutation.
func (m *EnvBuildMutation) FreeDiskSizeMB() (r int64, exists bool) {
	v := m.free_disk_size_mb
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeDiskSizeMB returns the old "free_disk_size_mb" field's value of the EnvBuild entity.
// If the EnvBuild object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvBuildMutation) OldFreeDiskSizeMB(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeDiskSizeMB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeDiskSizeMB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeDiskSizeMB: %w", err)
	}
	return oldValue.FreeDiskSizeMB, nil
}

// AddFreeDiskSizeMB adds i to the "free_disk_size_mb" field.
func (m *EnvBuildMutation) AddFreeDiskSizeMB(i int64) {
	if m.addfree_disk_size_mb != nil {
		*m.addfree_disk_size_mb += i
	} else {
		m.addfree_disk_size_mb = &i
	}
}

// AddedFreeDiskSizeMB returns the value that was added to the "free_disk_size_mb" field in this mutation.
func (m *EnvBuildMutation) AddedFreeDiskSizeMB() (r int64, exists bool) {
	v := m.addfree_disk_size_mb
	if v == nil {
		return
	}
	return *v, true
}

// ResetFreeDiskSizeMB resets all changes to the "free_disk_size_mb" field.
func (m *EnvBuildMutation) ResetFreeDiskSizeMB() {
	m.free_disk_size_mb = nil
	m.addfree_disk_size_mb = nil
}

// SetTotalDiskSizeMB sets the "total_disk_size_mb" field.
func (m *EnvBuildMutation) SetTotalDiskSizeMB(i int64) {
	m.total_disk_size_mb = &i
	m.addtotal_disk_size_mb = nil
}

// TotalDiskSizeMB returns the value of the "total_disk_size_mb" field in the mutation.
func (m *EnvBuildMutation) TotalDiskSizeMB() (r int64, exists bool) {
	v := m.total_disk_size_mb
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalDiskSizeMB returns the old "total_disk_size_mb" field's value of the EnvBuild entity.
// If the EnvBuild object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvBuildMutation) OldTotalDiskSizeMB(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalDiskSizeMB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalDiskSizeMB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalDiskSizeMB: %w", err)
	}
	return oldValue.TotalDiskSizeMB, nil
}

// AddTotalDiskSizeMB adds i to the "total_disk_size_mb" field.
func (m *EnvBuildMutation) AddTotalDiskSizeMB(i int64) {
	if m.addtotal_disk_size_mb != nil {
		*m.addtotal_disk_size_mb += i
	} else {
		m.addtotal_disk_size_mb = &i
	}
}

// AddedTotalDiskSizeMB returns the value that was added to the "total_disk_size_mb" field in this mutation.
func (m *EnvBuildMutation) AddedTotalDiskSizeMB() (r int64, exists bool) {
	v := m.addtotal_disk_size_mb
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalDiskSizeMB clears the value of the "total_disk_size_mb" field.
func (m *EnvBuildMutation) ClearTotalDiskSizeMB() {
	m.total_disk_size_mb = nil
	m.addtotal_disk_size_mb = nil
	m.clearedFields[envbuild.FieldTotalDiskSizeMB] = struct{}{}
}

// TotalDiskSizeMBCleared returns if the "total_disk_size_mb" field was cleared in this mutation.
func (m *EnvBuildMutation) TotalDiskSizeMBCleared() bool {
	_, ok := m.clearedFields[envbuild.FieldTotalDiskSizeMB]
	return ok
}

// ResetTotalDiskSizeMB resets all changes to the "total_disk_size_mb" field.
func (m *EnvBuildMutation) ResetTotalDiskSizeMB() {
	m.total_disk_size_mb = nil
	m.addtotal_disk_size_mb = nil
	delete(m.clearedFields, envbuild.FieldTotalDiskSizeMB)
}

// SetKernelVersion sets the "kernel_version" field.
func (m *EnvBuildMutation) SetKernelVersion(s string) {
	m.kernel_version = &s
}

// KernelVersion returns the value of the "kernel_version" field in the mutation.
func (m *EnvBuildMutation) KernelVersion() (r string, exists bool) {
	v := m.kernel_version
	if v == nil {
		return
	}
	return *v, true
}

// OldKernelVersion returns the old "kernel_version" field's value of the EnvBuild entity.
// If the EnvBuild object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvBuildMutation) OldKernelVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKernelVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKernelVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKernelVersion: %w", err)
	}
	return oldValue.KernelVersion, nil
}

// ResetKernelVersion resets all changes to the "kernel_version" field.
func (m *EnvBuildMutation) ResetKernelVersion() {
	m.kernel_version = nil
}

// SetFirecrackerVersion sets the "firecracker_version" field.
func (m *EnvBuildMutation) SetFirecrackerVersion(s string) {
	m.firecracker_version = &s
}

// FirecrackerVersion returns the value of the "firecracker_version" field in the mutation.
func (m *EnvBuildMutation) FirecrackerVersion() (r string, exists bool) {
	v := m.firecracker_version
	if v == nil {
		return
	}
	return *v, true
}

// OldFirecrackerVersion returns the old "firecracker_version" field's value of the EnvBuild entity.
// If the EnvBuild object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvBuildMutation) OldFirecrackerVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirecrackerVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirecrackerVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirecrackerVersion: %w", err)
	}
	return oldValue.FirecrackerVersion, nil
}

// ResetFirecrackerVersion resets all changes to the "firecracker_version" field.
func (m *EnvBuildMutation) ResetFirecrackerVersion() {
	m.firecracker_version = nil
}

// SetEnvdVersion sets the "envd_version" field.
func (m *EnvBuildMutation) SetEnvdVersion(s string) {
	m.envd_version = &s
}

// EnvdVersion returns the value of the "envd_version" field in the mutation.
func (m *EnvBuildMutation) EnvdVersion() (r string, exists bool) {
	v := m.envd_version
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvdVersion returns the old "envd_version" field's value of the EnvBuild entity.
// If the EnvBuild object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvBuildMutation) OldEnvdVersion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvdVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvdVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvdVersion: %w", err)
	}
	return oldValue.EnvdVersion, nil
}

// ClearEnvdVersion clears the value of the "envd_version" field.
func (m *EnvBuildMutation) ClearEnvdVersion() {
	m.envd_version = nil
	m.clearedFields[envbuild.FieldEnvdVersion] = struct{}{}
}

// EnvdVersionCleared returns if the "envd_version" field was cleared in this mutation.
func (m *EnvBuildMutation) EnvdVersionCleared() bool {
	_, ok := m.clearedFields[envbuild.FieldEnvdVersion]
	return ok
}

// ResetEnvdVersion resets all changes to the "envd_version" field.
func (m *EnvBuildMutation) ResetEnvdVersion() {
	m.envd_version = nil
	delete(m.clearedFields, envbuild.FieldEnvdVersion)
}

// ClearEnv clears the "env" edge to the Env entity.
func (m *EnvBuildMutation) ClearEnv() {
	m.clearedenv = true
	m.clearedFields[envbuild.FieldEnvID] = struct{}{}
}

// EnvCleared reports if the "env" edge to the Env entity was cleared.
func (m *EnvBuildMutation) EnvCleared() bool {
	return m.EnvIDCleared() || m.clearedenv
}

// EnvIDs returns the "env" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvID instead. It exists only for internal usage by the builders.
func (m *EnvBuildMutation) EnvIDs() (ids []string) {
	if id := m.env; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnv resets all changes to the "env" edge.
func (m *EnvBuildMutation) ResetEnv() {
	m.env = nil
	m.clearedenv = false
}

// Where appends a list predicates to the EnvBuildMutation builder.
func (m *EnvBuildMutation) Where(ps ...predicate.EnvBuild) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnvBuildMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnvBuildMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnvBuild, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnvBuildMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnvBuildMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnvBuild).
func (m *EnvBuildMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvBuildMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, envbuild.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, envbuild.FieldUpdatedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, envbuild.FieldFinishedAt)
	}
	if m.env != nil {
		fields = append(fields, envbuild.FieldEnvID)
	}
	if m.status != nil {
		fields = append(fields, envbuild.FieldStatus)
	}
	if m.dockerfile != nil {
		fields = append(fields, envbuild.FieldDockerfile)
	}
	if m.start_cmd != nil {
		fields = append(fields, envbuild.FieldStartCmd)
	}
	if m.vcpu != nil {
		fields = append(fields, envbuild.FieldVcpu)
	}
	if m.ram_mb != nil {
		fields = append(fields, envbuild.FieldRAMMB)
	}
	if m.free_disk_size_mb != nil {
		fields = append(fields, envbuild.FieldFreeDiskSizeMB)
	}
	if m.total_disk_size_mb != nil {
		fields = append(fields, envbuild.FieldTotalDiskSizeMB)
	}
	if m.kernel_version != nil {
		fields = append(fields, envbuild.FieldKernelVersion)
	}
	if m.firecracker_version != nil {
		fields = append(fields, envbuild.FieldFirecrackerVersion)
	}
	if m.envd_version != nil {
		fields = append(fields, envbuild.FieldEnvdVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvBuildMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case envbuild.FieldCreatedAt:
		return m.CreatedAt()
	case envbuild.FieldUpdatedAt:
		return m.UpdatedAt()
	case envbuild.FieldFinishedAt:
		return m.FinishedAt()
	case envbuild.FieldEnvID:
		return m.EnvID()
	case envbuild.FieldStatus:
		return m.Status()
	case envbuild.FieldDockerfile:
		return m.Dockerfile()
	case envbuild.FieldStartCmd:
		return m.StartCmd()
	case envbuild.FieldVcpu:
		return m.Vcpu()
	case envbuild.FieldRAMMB:
		return m.RAMMB()
	case envbuild.FieldFreeDiskSizeMB:
		return m.FreeDiskSizeMB()
	case envbuild.FieldTotalDiskSizeMB:
		return m.TotalDiskSizeMB()
	case envbuild.FieldKernelVersion:
		return m.KernelVersion()
	case envbuild.FieldFirecrackerVersion:
		return m.FirecrackerVersion()
	case envbuild.FieldEnvdVersion:
		return m.EnvdVersion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvBuildMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case envbuild.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case envbuild.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case envbuild.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case envbuild.FieldEnvID:
		return m.OldEnvID(ctx)
	case envbuild.FieldStatus:
		return m.OldStatus(ctx)
	case envbuild.FieldDockerfile:
		return m.OldDockerfile(ctx)
	case envbuild.FieldStartCmd:
		return m.OldStartCmd(ctx)
	case envbuild.FieldVcpu:
		return m.OldVcpu(ctx)
	case envbuild.FieldRAMMB:
		return m.OldRAMMB(ctx)
	case envbuild.FieldFreeDiskSizeMB:
		return m.OldFreeDiskSizeMB(ctx)
	case envbuild.FieldTotalDiskSizeMB:
		return m.OldTotalDiskSizeMB(ctx)
	case envbuild.FieldKernelVersion:
		return m.OldKernelVersion(ctx)
	case envbuild.FieldFirecrackerVersion:
		return m.OldFirecrackerVersion(ctx)
	case envbuild.FieldEnvdVersion:
		return m.OldEnvdVersion(ctx)
	}
	return nil, fmt.Errorf("unknown EnvBuild field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvBuildMutation) SetField(name string, value ent.Value) error {
	switch name {
	case envbuild.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case envbuild.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case envbuild.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case envbuild.FieldEnvID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvID(v)
		return nil
	case envbuild.FieldStatus:
		v, ok := value.(envbuild.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case envbuild.FieldDockerfile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDockerfile(v)
		return nil
	case envbuild.FieldStartCmd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartCmd(v)
		return nil
	case envbuild.FieldVcpu:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVcpu(v)
		return nil
	case envbuild.FieldRAMMB:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRAMMB(v)
		return nil
	case envbuild.FieldFreeDiskSizeMB:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeDiskSizeMB(v)
		return nil
	case envbuild.FieldTotalDiskSizeMB:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalDiskSizeMB(v)
		return nil
	case envbuild.FieldKernelVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKernelVersion(v)
		return nil
	case envbuild.FieldFirecrackerVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirecrackerVersion(v)
		return nil
	case envbuild.FieldEnvdVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvdVersion(v)
		return nil
	}
	return fmt.Errorf("unknown EnvBuild field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvBuildMutation) AddedFields() []string {
	var fields []string
	if m.addvcpu != nil {
		fields = append(fields, envbuild.FieldVcpu)
	}
	if m.addram_mb != nil {
		fields = append(fields, envbuild.FieldRAMMB)
	}
	if m.addfree_disk_size_mb != nil {
		fields = append(fields, envbuild.FieldFreeDiskSizeMB)
	}
	if m.addtotal_disk_size_mb != nil {
		fields = append(fields, envbuild.FieldTotalDiskSizeMB)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvBuildMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case envbuild.FieldVcpu:
		return m.AddedVcpu()
	case envbuild.FieldRAMMB:
		return m.AddedRAMMB()
	case envbuild.FieldFreeDiskSizeMB:
		return m.AddedFreeDiskSizeMB()
	case envbuild.FieldTotalDiskSizeMB:
		return m.AddedTotalDiskSizeMB()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvBuildMutation) AddField(name string, value ent.Value) error {
	switch name {
	case envbuild.FieldVcpu:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVcpu(v)
		return nil
	case envbuild.FieldRAMMB:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRAMMB(v)
		return nil
	case envbuild.FieldFreeDiskSizeMB:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreeDiskSizeMB(v)
		return nil
	case envbuild.FieldTotalDiskSizeMB:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalDiskSizeMB(v)
		return nil
	}
	return fmt.Errorf("unknown EnvBuild numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvBuildMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(envbuild.FieldFinishedAt) {
		fields = append(fields, envbuild.FieldFinishedAt)
	}
	if m.FieldCleared(envbuild.FieldEnvID) {
		fields = append(fields, envbuild.FieldEnvID)
	}
	if m.FieldCleared(envbuild.FieldDockerfile) {
		fields = append(fields, envbuild.FieldDockerfile)
	}
	if m.FieldCleared(envbuild.FieldStartCmd) {
		fields = append(fields, envbuild.FieldStartCmd)
	}
	if m.FieldCleared(envbuild.FieldTotalDiskSizeMB) {
		fields = append(fields, envbuild.FieldTotalDiskSizeMB)
	}
	if m.FieldCleared(envbuild.FieldEnvdVersion) {
		fields = append(fields, envbuild.FieldEnvdVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvBuildMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvBuildMutation) ClearField(name string) error {
	switch name {
	case envbuild.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	case envbuild.FieldEnvID:
		m.ClearEnvID()
		return nil
	case envbuild.FieldDockerfile:
		m.ClearDockerfile()
		return nil
	case envbuild.FieldStartCmd:
		m.ClearStartCmd()
		return nil
	case envbuild.FieldTotalDiskSizeMB:
		m.ClearTotalDiskSizeMB()
		return nil
	case envbuild.FieldEnvdVersion:
		m.ClearEnvdVersion()
		return nil
	}
	return fmt.Errorf("unknown EnvBuild nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvBuildMutation) ResetField(name string) error {
	switch name {
	case envbuild.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case envbuild.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case envbuild.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case envbuild.FieldEnvID:
		m.ResetEnvID()
		return nil
	case envbuild.FieldStatus:
		m.ResetStatus()
		return nil
	case envbuild.FieldDockerfile:
		m.ResetDockerfile()
		return nil
	case envbuild.FieldStartCmd:
		m.ResetStartCmd()
		return nil
	case envbuild.FieldVcpu:
		m.ResetVcpu()
		return nil
	case envbuild.FieldRAMMB:
		m.ResetRAMMB()
		return nil
	case envbuild.FieldFreeDiskSizeMB:
		m.ResetFreeDiskSizeMB()
		return nil
	case envbuild.FieldTotalDiskSizeMB:
		m.ResetTotalDiskSizeMB()
		return nil
	case envbuild.FieldKernelVersion:
		m.ResetKernelVersion()
		return nil
	case envbuild.FieldFirecrackerVersion:
		m.ResetFirecrackerVersion()
		return nil
	case envbuild.FieldEnvdVersion:
		m.ResetEnvdVersion()
		return nil
	}
	return fmt.Errorf("unknown EnvBuild field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvBuildMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.env != nil {
		edges = append(edges, envbuild.EdgeEnv)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvBuildMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case envbuild.EdgeEnv:
		if id := m.env; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvBuildMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvBuildMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvBuildMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedenv {
		edges = append(edges, envbuild.EdgeEnv)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvBuildMutation) EdgeCleared(name string) bool {
	switch name {
	case envbuild.EdgeEnv:
		return m.clearedenv
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvBuildMutation) ClearEdge(name string) error {
	switch name {
	case envbuild.EdgeEnv:
		m.ClearEnv()
		return nil
	}
	return fmt.Errorf("unknown EnvBuild unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvBuildMutation) ResetEdge(name string) error {
	switch name {
	case envbuild.EdgeEnv:
		m.ResetEnv()
		return nil
	}
	return fmt.Errorf("unknown EnvBuild edge %s", name)
}

// SnapshotMutation represents an operation that mutates the Snapshot nodes in the graph.
type SnapshotMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	base_env_id   *string
	sandbox_id    *string
	metadata      *map[string]string
	clearedFields map[string]struct{}
	env           *string
	clearedenv    bool
	done          bool
	oldValue      func(context.Context) (*Snapshot, error)
	predicates    []predicate.Snapshot
}

var _ ent.Mutation = (*SnapshotMutation)(nil)

// snapshotOption allows management of the mutation configuration using functional options.
type snapshotOption func(*SnapshotMutation)

// newSnapshotMutation creates new mutation for the Snapshot entity.
func newSnapshotMutation(c config, op Op, opts ...snapshotOption) *SnapshotMutation {
	m := &SnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSnapshotID sets the ID field of the mutation.
func withSnapshotID(id uuid.UUID) snapshotOption {
	return func(m *SnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *Snapshot
		)
		m.oldValue = func(ctx context.Context) (*Snapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Snapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSnapshot sets the old Snapshot of the mutation.
func withSnapshot(node *Snapshot) snapshotOption {
	return func(m *SnapshotMutation) {
		m.oldValue = func(context.Context) (*Snapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Snapshot entities.
func (m *SnapshotMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SnapshotMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SnapshotMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Snapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SnapshotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SnapshotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SnapshotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetBaseEnvID sets the "base_env_id" field.
func (m *SnapshotMutation) SetBaseEnvID(s string) {
	m.base_env_id = &s
}

// BaseEnvID returns the value of the "base_env_id" field in the mutation.
func (m *SnapshotMutation) BaseEnvID() (r string, exists bool) {
	v := m.base_env_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseEnvID returns the old "base_env_id" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldBaseEnvID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseEnvID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseEnvID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseEnvID: %w", err)
	}
	return oldValue.BaseEnvID, nil
}

// ResetBaseEnvID resets all changes to the "base_env_id" field.
func (m *SnapshotMutation) ResetBaseEnvID() {
	m.base_env_id = nil
}

// SetEnvID sets the "env_id" field.
func (m *SnapshotMutation) SetEnvID(s string) {
	m.env = &s
}

// EnvID returns the value of the "env_id" field in the mutation.
func (m *SnapshotMutation) EnvID() (r string, exists bool) {
	v := m.env
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvID returns the old "env_id" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldEnvID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvID: %w", err)
	}
	return oldValue.EnvID, nil
}

// ResetEnvID resets all changes to the "env_id" field.
func (m *SnapshotMutation) ResetEnvID() {
	m.env = nil
}

// SetSandboxID sets the "sandbox_id" field.
func (m *SnapshotMutation) SetSandboxID(s string) {
	m.sandbox_id = &s
}

// SandboxID returns the value of the "sandbox_id" field in the mutation.
func (m *SnapshotMutation) SandboxID() (r string, exists bool) {
	v := m.sandbox_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSandboxID returns the old "sandbox_id" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldSandboxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSandboxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSandboxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSandboxID: %w", err)
	}
	return oldValue.SandboxID, nil
}

// ResetSandboxID resets all changes to the "sandbox_id" field.
func (m *SnapshotMutation) ResetSandboxID() {
	m.sandbox_id = nil
}

// SetMetadata sets the "metadata" field.
func (m *SnapshotMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SnapshotMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Snapshot entity.
// If the Snapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SnapshotMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SnapshotMutation) ResetMetadata() {
	m.metadata = nil
}

// ClearEnv clears the "env" edge to the Env entity.
func (m *SnapshotMutation) ClearEnv() {
	m.clearedenv = true
	m.clearedFields[snapshot.FieldEnvID] = struct{}{}
}

// EnvCleared reports if the "env" edge to the Env entity was cleared.
func (m *SnapshotMutation) EnvCleared() bool {
	return m.clearedenv
}

// EnvIDs returns the "env" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvID instead. It exists only for internal usage by the builders.
func (m *SnapshotMutation) EnvIDs() (ids []string) {
	if id := m.env; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnv resets all changes to the "env" edge.
func (m *SnapshotMutation) ResetEnv() {
	m.env = nil
	m.clearedenv = false
}

// Where appends a list predicates to the SnapshotMutation builder.
func (m *SnapshotMutation) Where(ps ...predicate.Snapshot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SnapshotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SnapshotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Snapshot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SnapshotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SnapshotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Snapshot).
func (m *SnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SnapshotMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, snapshot.FieldCreatedAt)
	}
	if m.base_env_id != nil {
		fields = append(fields, snapshot.FieldBaseEnvID)
	}
	if m.env != nil {
		fields = append(fields, snapshot.FieldEnvID)
	}
	if m.sandbox_id != nil {
		fields = append(fields, snapshot.FieldSandboxID)
	}
	if m.metadata != nil {
		fields = append(fields, snapshot.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case snapshot.FieldCreatedAt:
		return m.CreatedAt()
	case snapshot.FieldBaseEnvID:
		return m.BaseEnvID()
	case snapshot.FieldEnvID:
		return m.EnvID()
	case snapshot.FieldSandboxID:
		return m.SandboxID()
	case snapshot.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case snapshot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case snapshot.FieldBaseEnvID:
		return m.OldBaseEnvID(ctx)
	case snapshot.FieldEnvID:
		return m.OldEnvID(ctx)
	case snapshot.FieldSandboxID:
		return m.OldSandboxID(ctx)
	case snapshot.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Snapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case snapshot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case snapshot.FieldBaseEnvID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseEnvID(v)
		return nil
	case snapshot.FieldEnvID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvID(v)
		return nil
	case snapshot.FieldSandboxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSandboxID(v)
		return nil
	case snapshot.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Snapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SnapshotMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SnapshotMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Snapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SnapshotMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SnapshotMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Snapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SnapshotMutation) ResetField(name string) error {
	switch name {
	case snapshot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case snapshot.FieldBaseEnvID:
		m.ResetBaseEnvID()
		return nil
	case snapshot.FieldEnvID:
		m.ResetEnvID()
		return nil
	case snapshot.FieldSandboxID:
		m.ResetSandboxID()
		return nil
	case snapshot.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Snapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.env != nil {
		edges = append(edges, snapshot.EdgeEnv)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SnapshotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case snapshot.EdgeEnv:
		if id := m.env; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SnapshotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedenv {
		edges = append(edges, snapshot.EdgeEnv)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SnapshotMutation) EdgeCleared(name string) bool {
	switch name {
	case snapshot.EdgeEnv:
		return m.clearedenv
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SnapshotMutation) ClearEdge(name string) error {
	switch name {
	case snapshot.EdgeEnv:
		m.ClearEnv()
		return nil
	}
	return fmt.Errorf("unknown Snapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SnapshotMutation) ResetEdge(name string) error {
	switch name {
	case snapshot.EdgeEnv:
		m.ResetEnv()
		return nil
	}
	return fmt.Errorf("unknown Snapshot edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	is_banned            *bool
	is_blocked           *bool
	blocked_reason       *string
	name                 *string
	email                *string
	clearedFields        map[string]struct{}
	users                map[uuid.UUID]struct{}
	removedusers         map[uuid.UUID]struct{}
	clearedusers         bool
	team_api_keys        map[uuid.UUID]struct{}
	removedteam_api_keys map[uuid.UUID]struct{}
	clearedteam_api_keys bool
	team_tier            *string
	clearedteam_tier     bool
	envs                 map[string]struct{}
	removedenvs          map[string]struct{}
	clearedenvs          bool
	users_teams          map[int]struct{}
	removedusers_teams   map[int]struct{}
	clearedusers_teams   bool
	done                 bool
	oldValue             func(context.Context) (*Team, error)
	predicates           []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id uuid.UUID) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetIsBanned sets the "is_banned" field.
func (m *TeamMutation) SetIsBanned(b bool) {
	m.is_banned = &b
}

// IsBanned returns the value of the "is_banned" field in the mutation.
func (m *TeamMutation) IsBanned() (r bool, exists bool) {
	v := m.is_banned
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBanned returns the old "is_banned" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldIsBanned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBanned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBanned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBanned: %w", err)
	}
	return oldValue.IsBanned, nil
}

// ClearIsBanned clears the value of the "is_banned" field.
func (m *TeamMutation) ClearIsBanned() {
	m.is_banned = nil
	m.clearedFields[team.FieldIsBanned] = struct{}{}
}

// IsBannedCleared returns if the "is_banned" field was cleared in this mutation.
func (m *TeamMutation) IsBannedCleared() bool {
	_, ok := m.clearedFields[team.FieldIsBanned]
	return ok
}

// ResetIsBanned resets all changes to the "is_banned" field.
func (m *TeamMutation) ResetIsBanned() {
	m.is_banned = nil
	delete(m.clearedFields, team.FieldIsBanned)
}

// SetIsBlocked sets the "is_blocked" field.
func (m *TeamMutation) SetIsBlocked(b bool) {
	m.is_blocked = &b
}

// IsBlocked returns the value of the "is_blocked" field in the mutation.
func (m *TeamMutation) IsBlocked() (r bool, exists bool) {
	v := m.is_blocked
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBlocked returns the old "is_blocked" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldIsBlocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBlocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBlocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBlocked: %w", err)
	}
	return oldValue.IsBlocked, nil
}

// ClearIsBlocked clears the value of the "is_blocked" field.
func (m *TeamMutation) ClearIsBlocked() {
	m.is_blocked = nil
	m.clearedFields[team.FieldIsBlocked] = struct{}{}
}

// IsBlockedCleared returns if the "is_blocked" field was cleared in this mutation.
func (m *TeamMutation) IsBlockedCleared() bool {
	_, ok := m.clearedFields[team.FieldIsBlocked]
	return ok
}

// ResetIsBlocked resets all changes to the "is_blocked" field.
func (m *TeamMutation) ResetIsBlocked() {
	m.is_blocked = nil
	delete(m.clearedFields, team.FieldIsBlocked)
}

// SetBlockedReason sets the "blocked_reason" field.
func (m *TeamMutation) SetBlockedReason(s string) {
	m.blocked_reason = &s
}

// BlockedReason returns the value of the "blocked_reason" field in the mutation.
func (m *TeamMutation) BlockedReason() (r string, exists bool) {
	v := m.blocked_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockedReason returns the old "blocked_reason" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldBlockedReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockedReason: %w", err)
	}
	return oldValue.BlockedReason, nil
}

// ClearBlockedReason clears the value of the "blocked_reason" field.
func (m *TeamMutation) ClearBlockedReason() {
	m.blocked_reason = nil
	m.clearedFields[team.FieldBlockedReason] = struct{}{}
}

// BlockedReasonCleared returns if the "blocked_reason" field was cleared in this mutation.
func (m *TeamMutation) BlockedReasonCleared() bool {
	_, ok := m.clearedFields[team.FieldBlockedReason]
	return ok
}

// ResetBlockedReason resets all changes to the "blocked_reason" field.
func (m *TeamMutation) ResetBlockedReason() {
	m.blocked_reason = nil
	delete(m.clearedFields, team.FieldBlockedReason)
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// SetTier sets the "tier" field.
func (m *TeamMutation) SetTier(s string) {
	m.team_tier = &s
}

// Tier returns the value of the "tier" field in the mutation.
func (m *TeamMutation) Tier() (r string, exists bool) {
	v := m.team_tier
	if v == nil {
		return
	}
	return *v, true
}

// OldTier returns the old "tier" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldTier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTier: %w", err)
	}
	return oldValue.Tier, nil
}

// ResetTier resets all changes to the "tier" field.
func (m *TeamMutation) ResetTier() {
	m.team_tier = nil
}

// SetEmail sets the "email" field.
func (m *TeamMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *TeamMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *TeamMutation) ResetEmail() {
	m.email = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *TeamMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *TeamMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *TeamMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *TeamMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *TeamMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *TeamMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *TeamMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddTeamAPIKeyIDs adds the "team_api_keys" edge to the TeamAPIKey entity by ids.
func (m *TeamMutation) AddTeamAPIKeyIDs(ids ...uuid.UUID) {
	if m.team_api_keys == nil {
		m.team_api_keys = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.team_api_keys[ids[i]] = struct{}{}
	}
}

// ClearTeamAPIKeys clears the "team_api_keys" edge to the TeamAPIKey entity.
func (m *TeamMutation) ClearTeamAPIKeys() {
	m.clearedteam_api_keys = true
}

// TeamAPIKeysCleared reports if the "team_api_keys" edge to the TeamAPIKey entity was cleared.
func (m *TeamMutation) TeamAPIKeysCleared() bool {
	return m.clearedteam_api_keys
}

// RemoveTeamAPIKeyIDs removes the "team_api_keys" edge to the TeamAPIKey entity by IDs.
func (m *TeamMutation) RemoveTeamAPIKeyIDs(ids ...uuid.UUID) {
	if m.removedteam_api_keys == nil {
		m.removedteam_api_keys = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.team_api_keys, ids[i])
		m.removedteam_api_keys[ids[i]] = struct{}{}
	}
}

// RemovedTeamAPIKeys returns the removed IDs of the "team_api_keys" edge to the TeamAPIKey entity.
func (m *TeamMutation) RemovedTeamAPIKeysIDs() (ids []uuid.UUID) {
	for id := range m.removedteam_api_keys {
		ids = append(ids, id)
	}
	return
}

// TeamAPIKeysIDs returns the "team_api_keys" edge IDs in the mutation.
func (m *TeamMutation) TeamAPIKeysIDs() (ids []uuid.UUID) {
	for id := range m.team_api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetTeamAPIKeys resets all changes to the "team_api_keys" edge.
func (m *TeamMutation) ResetTeamAPIKeys() {
	m.team_api_keys = nil
	m.clearedteam_api_keys = false
	m.removedteam_api_keys = nil
}

// SetTeamTierID sets the "team_tier" edge to the Tier entity by id.
func (m *TeamMutation) SetTeamTierID(id string) {
	m.team_tier = &id
}

// ClearTeamTier clears the "team_tier" edge to the Tier entity.
func (m *TeamMutation) ClearTeamTier() {
	m.clearedteam_tier = true
	m.clearedFields[team.FieldTier] = struct{}{}
}

// TeamTierCleared reports if the "team_tier" edge to the Tier entity was cleared.
func (m *TeamMutation) TeamTierCleared() bool {
	return m.clearedteam_tier
}

// TeamTierID returns the "team_tier" edge ID in the mutation.
func (m *TeamMutation) TeamTierID() (id string, exists bool) {
	if m.team_tier != nil {
		return *m.team_tier, true
	}
	return
}

// TeamTierIDs returns the "team_tier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamTierID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) TeamTierIDs() (ids []string) {
	if id := m.team_tier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeamTier resets all changes to the "team_tier" edge.
func (m *TeamMutation) ResetTeamTier() {
	m.team_tier = nil
	m.clearedteam_tier = false
}

// AddEnvIDs adds the "envs" edge to the Env entity by ids.
func (m *TeamMutation) AddEnvIDs(ids ...string) {
	if m.envs == nil {
		m.envs = make(map[string]struct{})
	}
	for i := range ids {
		m.envs[ids[i]] = struct{}{}
	}
}

// ClearEnvs clears the "envs" edge to the Env entity.
func (m *TeamMutation) ClearEnvs() {
	m.clearedenvs = true
}

// EnvsCleared reports if the "envs" edge to the Env entity was cleared.
func (m *TeamMutation) EnvsCleared() bool {
	return m.clearedenvs
}

// RemoveEnvIDs removes the "envs" edge to the Env entity by IDs.
func (m *TeamMutation) RemoveEnvIDs(ids ...string) {
	if m.removedenvs == nil {
		m.removedenvs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.envs, ids[i])
		m.removedenvs[ids[i]] = struct{}{}
	}
}

// RemovedEnvs returns the removed IDs of the "envs" edge to the Env entity.
func (m *TeamMutation) RemovedEnvsIDs() (ids []string) {
	for id := range m.removedenvs {
		ids = append(ids, id)
	}
	return
}

// EnvsIDs returns the "envs" edge IDs in the mutation.
func (m *TeamMutation) EnvsIDs() (ids []string) {
	for id := range m.envs {
		ids = append(ids, id)
	}
	return
}

// ResetEnvs resets all changes to the "envs" edge.
func (m *TeamMutation) ResetEnvs() {
	m.envs = nil
	m.clearedenvs = false
	m.removedenvs = nil
}

// AddUsersTeamIDs adds the "users_teams" edge to the UsersTeams entity by ids.
func (m *TeamMutation) AddUsersTeamIDs(ids ...int) {
	if m.users_teams == nil {
		m.users_teams = make(map[int]struct{})
	}
	for i := range ids {
		m.users_teams[ids[i]] = struct{}{}
	}
}

// ClearUsersTeams clears the "users_teams" edge to the UsersTeams entity.
func (m *TeamMutation) ClearUsersTeams() {
	m.clearedusers_teams = true
}

// UsersTeamsCleared reports if the "users_teams" edge to the UsersTeams entity was cleared.
func (m *TeamMutation) UsersTeamsCleared() bool {
	return m.clearedusers_teams
}

// RemoveUsersTeamIDs removes the "users_teams" edge to the UsersTeams entity by IDs.
func (m *TeamMutation) RemoveUsersTeamIDs(ids ...int) {
	if m.removedusers_teams == nil {
		m.removedusers_teams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users_teams, ids[i])
		m.removedusers_teams[ids[i]] = struct{}{}
	}
}

// RemovedUsersTeams returns the removed IDs of the "users_teams" edge to the UsersTeams entity.
func (m *TeamMutation) RemovedUsersTeamsIDs() (ids []int) {
	for id := range m.removedusers_teams {
		ids = append(ids, id)
	}
	return
}

// UsersTeamsIDs returns the "users_teams" edge IDs in the mutation.
func (m *TeamMutation) UsersTeamsIDs() (ids []int) {
	for id := range m.users_teams {
		ids = append(ids, id)
	}
	return
}

// ResetUsersTeams resets all changes to the "users_teams" edge.
func (m *TeamMutation) ResetUsersTeams() {
	m.users_teams = nil
	m.clearedusers_teams = false
	m.removedusers_teams = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, team.FieldCreatedAt)
	}
	if m.is_banned != nil {
		fields = append(fields, team.FieldIsBanned)
	}
	if m.is_blocked != nil {
		fields = append(fields, team.FieldIsBlocked)
	}
	if m.blocked_reason != nil {
		fields = append(fields, team.FieldBlockedReason)
	}
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	if m.team_tier != nil {
		fields = append(fields, team.FieldTier)
	}
	if m.email != nil {
		fields = append(fields, team.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldCreatedAt:
		return m.CreatedAt()
	case team.FieldIsBanned:
		return m.IsBanned()
	case team.FieldIsBlocked:
		return m.IsBlocked()
	case team.FieldBlockedReason:
		return m.BlockedReason()
	case team.FieldName:
		return m.Name()
	case team.FieldTier:
		return m.Tier()
	case team.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case team.FieldIsBanned:
		return m.OldIsBanned(ctx)
	case team.FieldIsBlocked:
		return m.OldIsBlocked(ctx)
	case team.FieldBlockedReason:
		return m.OldBlockedReason(ctx)
	case team.FieldName:
		return m.OldName(ctx)
	case team.FieldTier:
		return m.OldTier(ctx)
	case team.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case team.FieldIsBanned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBanned(v)
		return nil
	case team.FieldIsBlocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBlocked(v)
		return nil
	case team.FieldBlockedReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockedReason(v)
		return nil
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case team.FieldTier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTier(v)
		return nil
	case team.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(team.FieldIsBanned) {
		fields = append(fields, team.FieldIsBanned)
	}
	if m.FieldCleared(team.FieldIsBlocked) {
		fields = append(fields, team.FieldIsBlocked)
	}
	if m.FieldCleared(team.FieldBlockedReason) {
		fields = append(fields, team.FieldBlockedReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	switch name {
	case team.FieldIsBanned:
		m.ClearIsBanned()
		return nil
	case team.FieldIsBlocked:
		m.ClearIsBlocked()
		return nil
	case team.FieldBlockedReason:
		m.ClearBlockedReason()
		return nil
	}
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case team.FieldIsBanned:
		m.ResetIsBanned()
		return nil
	case team.FieldIsBlocked:
		m.ResetIsBlocked()
		return nil
	case team.FieldBlockedReason:
		m.ResetBlockedReason()
		return nil
	case team.FieldName:
		m.ResetName()
		return nil
	case team.FieldTier:
		m.ResetTier()
		return nil
	case team.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.users != nil {
		edges = append(edges, team.EdgeUsers)
	}
	if m.team_api_keys != nil {
		edges = append(edges, team.EdgeTeamAPIKeys)
	}
	if m.team_tier != nil {
		edges = append(edges, team.EdgeTeamTier)
	}
	if m.envs != nil {
		edges = append(edges, team.EdgeEnvs)
	}
	if m.users_teams != nil {
		edges = append(edges, team.EdgeUsersTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamAPIKeys:
		ids := make([]ent.Value, 0, len(m.team_api_keys))
		for id := range m.team_api_keys {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamTier:
		if id := m.team_tier; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeEnvs:
		ids := make([]ent.Value, 0, len(m.envs))
		for id := range m.envs {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeUsersTeams:
		ids := make([]ent.Value, 0, len(m.users_teams))
		for id := range m.users_teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedusers != nil {
		edges = append(edges, team.EdgeUsers)
	}
	if m.removedteam_api_keys != nil {
		edges = append(edges, team.EdgeTeamAPIKeys)
	}
	if m.removedenvs != nil {
		edges = append(edges, team.EdgeEnvs)
	}
	if m.removedusers_teams != nil {
		edges = append(edges, team.EdgeUsersTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedteam_api_keys))
		for id := range m.removedteam_api_keys {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeEnvs:
		ids := make([]ent.Value, 0, len(m.removedenvs))
		for id := range m.removedenvs {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeUsersTeams:
		ids := make([]ent.Value, 0, len(m.removedusers_teams))
		for id := range m.removedusers_teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedusers {
		edges = append(edges, team.EdgeUsers)
	}
	if m.clearedteam_api_keys {
		edges = append(edges, team.EdgeTeamAPIKeys)
	}
	if m.clearedteam_tier {
		edges = append(edges, team.EdgeTeamTier)
	}
	if m.clearedenvs {
		edges = append(edges, team.EdgeEnvs)
	}
	if m.clearedusers_teams {
		edges = append(edges, team.EdgeUsersTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeUsers:
		return m.clearedusers
	case team.EdgeTeamAPIKeys:
		return m.clearedteam_api_keys
	case team.EdgeTeamTier:
		return m.clearedteam_tier
	case team.EdgeEnvs:
		return m.clearedenvs
	case team.EdgeUsersTeams:
		return m.clearedusers_teams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	case team.EdgeTeamTier:
		m.ClearTeamTier()
		return nil
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeUsers:
		m.ResetUsers()
		return nil
	case team.EdgeTeamAPIKeys:
		m.ResetTeamAPIKeys()
		return nil
	case team.EdgeTeamTier:
		m.ResetTeamTier()
		return nil
	case team.EdgeEnvs:
		m.ResetEnvs()
		return nil
	case team.EdgeUsersTeams:
		m.ResetUsersTeams()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// TeamAPIKeyMutation represents an operation that mutates the TeamAPIKey nodes in the graph.
type TeamAPIKeyMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	api_key        *string
	created_at     *time.Time
	updated_at     *time.Time
	name           *string
	last_used      *time.Time
	clearedFields  map[string]struct{}
	team           *uuid.UUID
	clearedteam    bool
	creator        *uuid.UUID
	clearedcreator bool
	done           bool
	oldValue       func(context.Context) (*TeamAPIKey, error)
	predicates     []predicate.TeamAPIKey
}

var _ ent.Mutation = (*TeamAPIKeyMutation)(nil)

// teamapikeyOption allows management of the mutation configuration using functional options.
type teamapikeyOption func(*TeamAPIKeyMutation)

// newTeamAPIKeyMutation creates new mutation for the TeamAPIKey entity.
func newTeamAPIKeyMutation(c config, op Op, opts ...teamapikeyOption) *TeamAPIKeyMutation {
	m := &TeamAPIKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeTeamAPIKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamAPIKeyID sets the ID field of the mutation.
func withTeamAPIKeyID(id uuid.UUID) teamapikeyOption {
	return func(m *TeamAPIKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *TeamAPIKey
		)
		m.oldValue = func(ctx context.Context) (*TeamAPIKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeamAPIKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeamAPIKey sets the old TeamAPIKey of the mutation.
func withTeamAPIKey(node *TeamAPIKey) teamapikeyOption {
	return func(m *TeamAPIKeyMutation) {
		m.oldValue = func(context.Context) (*TeamAPIKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamAPIKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamAPIKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TeamAPIKey entities.
func (m *TeamAPIKeyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamAPIKeyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamAPIKeyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeamAPIKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAPIKey sets the "api_key" field.
func (m *TeamAPIKeyMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *TeamAPIKeyMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the TeamAPIKey entity.
// If the TeamAPIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamAPIKeyMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *TeamAPIKeyMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamAPIKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamAPIKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TeamAPIKey entity.
// If the TeamAPIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamAPIKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamAPIKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeamAPIKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeamAPIKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TeamAPIKey entity.
// If the TeamAPIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamAPIKeyMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TeamAPIKeyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[teamapikey.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TeamAPIKeyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[teamapikey.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeamAPIKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, teamapikey.FieldUpdatedAt)
}

// SetTeamID sets the "team_id" field.
func (m *TeamAPIKeyMutation) SetTeamID(u uuid.UUID) {
	m.team = &u
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *TeamAPIKeyMutation) TeamID() (r uuid.UUID, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the TeamAPIKey entity.
// If the TeamAPIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamAPIKeyMutation) OldTeamID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *TeamAPIKeyMutation) ResetTeamID() {
	m.team = nil
}

// SetName sets the "name" field.
func (m *TeamAPIKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamAPIKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TeamAPIKey entity.
// If the TeamAPIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamAPIKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamAPIKeyMutation) ResetName() {
	m.name = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TeamAPIKeyMutation) SetCreatedBy(u uuid.UUID) {
	m.creator = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TeamAPIKeyMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TeamAPIKey entity.
// If the TeamAPIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamAPIKeyMutation) OldCreatedBy(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TeamAPIKeyMutation) ClearCreatedBy() {
	m.creator = nil
	m.clearedFields[teamapikey.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TeamAPIKeyMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[teamapikey.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TeamAPIKeyMutation) ResetCreatedBy() {
	m.creator = nil
	delete(m.clearedFields, teamapikey.FieldCreatedBy)
}

// SetLastUsed sets the "last_used" field.
func (m *TeamAPIKeyMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *TeamAPIKeyMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the TeamAPIKey entity.
// If the TeamAPIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamAPIKeyMutation) OldLastUsed(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ClearLastUsed clears the value of the "last_used" field.
func (m *TeamAPIKeyMutation) ClearLastUsed() {
	m.last_used = nil
	m.clearedFields[teamapikey.FieldLastUsed] = struct{}{}
}

// LastUsedCleared returns if the "last_used" field was cleared in this mutation.
func (m *TeamAPIKeyMutation) LastUsedCleared() bool {
	_, ok := m.clearedFields[teamapikey.FieldLastUsed]
	return ok
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *TeamAPIKeyMutation) ResetLastUsed() {
	m.last_used = nil
	delete(m.clearedFields, teamapikey.FieldLastUsed)
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *TeamAPIKeyMutation) ClearTeam() {
	m.clearedteam = true
	m.clearedFields[teamapikey.FieldTeamID] = struct{}{}
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *TeamAPIKeyMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *TeamAPIKeyMutation) TeamIDs() (ids []uuid.UUID) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *TeamAPIKeyMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *TeamAPIKeyMutation) SetCreatorID(id uuid.UUID) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *TeamAPIKeyMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[teamapikey.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *TeamAPIKeyMutation) CreatorCleared() bool {
	return m.CreatedByCleared() || m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *TeamAPIKeyMutation) CreatorID() (id uuid.UUID, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *TeamAPIKeyMutation) CreatorIDs() (ids []uuid.UUID) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *TeamAPIKeyMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// Where appends a list predicates to the TeamAPIKeyMutation builder.
func (m *TeamAPIKeyMutation) Where(ps ...predicate.TeamAPIKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamAPIKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamAPIKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TeamAPIKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamAPIKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamAPIKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TeamAPIKey).
func (m *TeamAPIKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamAPIKeyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.api_key != nil {
		fields = append(fields, teamapikey.FieldAPIKey)
	}
	if m.created_at != nil {
		fields = append(fields, teamapikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teamapikey.FieldUpdatedAt)
	}
	if m.team != nil {
		fields = append(fields, teamapikey.FieldTeamID)
	}
	if m.name != nil {
		fields = append(fields, teamapikey.FieldName)
	}
	if m.creator != nil {
		fields = append(fields, teamapikey.FieldCreatedBy)
	}
	if m.last_used != nil {
		fields = append(fields, teamapikey.FieldLastUsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamAPIKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teamapikey.FieldAPIKey:
		return m.APIKey()
	case teamapikey.FieldCreatedAt:
		return m.CreatedAt()
	case teamapikey.FieldUpdatedAt:
		return m.UpdatedAt()
	case teamapikey.FieldTeamID:
		return m.TeamID()
	case teamapikey.FieldName:
		return m.Name()
	case teamapikey.FieldCreatedBy:
		return m.CreatedBy()
	case teamapikey.FieldLastUsed:
		return m.LastUsed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamAPIKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teamapikey.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case teamapikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teamapikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case teamapikey.FieldTeamID:
		return m.OldTeamID(ctx)
	case teamapikey.FieldName:
		return m.OldName(ctx)
	case teamapikey.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case teamapikey.FieldLastUsed:
		return m.OldLastUsed(ctx)
	}
	return nil, fmt.Errorf("unknown TeamAPIKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamAPIKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teamapikey.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case teamapikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teamapikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case teamapikey.FieldTeamID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case teamapikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case teamapikey.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case teamapikey.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	}
	return fmt.Errorf("unknown TeamAPIKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamAPIKeyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamAPIKeyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamAPIKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TeamAPIKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamAPIKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(teamapikey.FieldUpdatedAt) {
		fields = append(fields, teamapikey.FieldUpdatedAt)
	}
	if m.FieldCleared(teamapikey.FieldCreatedBy) {
		fields = append(fields, teamapikey.FieldCreatedBy)
	}
	if m.FieldCleared(teamapikey.FieldLastUsed) {
		fields = append(fields, teamapikey.FieldLastUsed)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamAPIKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamAPIKeyMutation) ClearField(name string) error {
	switch name {
	case teamapikey.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case teamapikey.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case teamapikey.FieldLastUsed:
		m.ClearLastUsed()
		return nil
	}
	return fmt.Errorf("unknown TeamAPIKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamAPIKeyMutation) ResetField(name string) error {
	switch name {
	case teamapikey.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case teamapikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teamapikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case teamapikey.FieldTeamID:
		m.ResetTeamID()
		return nil
	case teamapikey.FieldName:
		m.ResetName()
		return nil
	case teamapikey.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case teamapikey.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	}
	return fmt.Errorf("unknown TeamAPIKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamAPIKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.team != nil {
		edges = append(edges, teamapikey.EdgeTeam)
	}
	if m.creator != nil {
		edges = append(edges, teamapikey.EdgeCreator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamAPIKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teamapikey.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case teamapikey.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamAPIKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamAPIKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamAPIKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedteam {
		edges = append(edges, teamapikey.EdgeTeam)
	}
	if m.clearedcreator {
		edges = append(edges, teamapikey.EdgeCreator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamAPIKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case teamapikey.EdgeTeam:
		return m.clearedteam
	case teamapikey.EdgeCreator:
		return m.clearedcreator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamAPIKeyMutation) ClearEdge(name string) error {
	switch name {
	case teamapikey.EdgeTeam:
		m.ClearTeam()
		return nil
	case teamapikey.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown TeamAPIKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamAPIKeyMutation) ResetEdge(name string) error {
	switch name {
	case teamapikey.EdgeTeam:
		m.ResetTeam()
		return nil
	case teamapikey.EdgeCreator:
		m.ResetCreator()
		return nil
	}
	return fmt.Errorf("unknown TeamAPIKey edge %s", name)
}

// TierMutation represents an operation that mutates the Tier nodes in the graph.
type TierMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	name                    *string
	disk_mb                 *int64
	adddisk_mb              *int64
	concurrent_instances    *int64
	addconcurrent_instances *int64
	max_length_hours        *int64
	addmax_length_hours     *int64
	clearedFields           map[string]struct{}
	teams                   map[uuid.UUID]struct{}
	removedteams            map[uuid.UUID]struct{}
	clearedteams            bool
	done                    bool
	oldValue                func(context.Context) (*Tier, error)
	predicates              []predicate.Tier
}

var _ ent.Mutation = (*TierMutation)(nil)

// tierOption allows management of the mutation configuration using functional options.
type tierOption func(*TierMutation)

// newTierMutation creates new mutation for the Tier entity.
func newTierMutation(c config, op Op, opts ...tierOption) *TierMutation {
	m := &TierMutation{
		config:        c,
		op:            op,
		typ:           TypeTier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTierID sets the ID field of the mutation.
func withTierID(id string) tierOption {
	return func(m *TierMutation) {
		var (
			err   error
			once  sync.Once
			value *Tier
		)
		m.oldValue = func(ctx context.Context) (*Tier, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTier sets the old Tier of the mutation.
func withTier(node *Tier) tierOption {
	return func(m *TierMutation) {
		m.oldValue = func(context.Context) (*Tier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tier entities.
func (m *TierMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TierMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TierMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tier.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TierMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TierMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tier entity.
// If the Tier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TierMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TierMutation) ResetName() {
	m.name = nil
}

// SetDiskMB sets the "disk_mb" field.
func (m *TierMutation) SetDiskMB(i int64) {
	m.disk_mb = &i
	m.adddisk_mb = nil
}

// DiskMB returns the value of the "disk_mb" field in the mutation.
func (m *TierMutation) DiskMB() (r int64, exists bool) {
	v := m.disk_mb
	if v == nil {
		return
	}
	return *v, true
}

// OldDiskMB returns the old "disk_mb" field's value of the Tier entity.
// If the Tier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TierMutation) OldDiskMB(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiskMB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiskMB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiskMB: %w", err)
	}
	return oldValue.DiskMB, nil
}

// AddDiskMB adds i to the "disk_mb" field.
func (m *TierMutation) AddDiskMB(i int64) {
	if m.adddisk_mb != nil {
		*m.adddisk_mb += i
	} else {
		m.adddisk_mb = &i
	}
}

// AddedDiskMB returns the value that was added to the "disk_mb" field in this mutation.
func (m *TierMutation) AddedDiskMB() (r int64, exists bool) {
	v := m.adddisk_mb
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiskMB resets all changes to the "disk_mb" field.
func (m *TierMutation) ResetDiskMB() {
	m.disk_mb = nil
	m.adddisk_mb = nil
}

// SetConcurrentInstances sets the "concurrent_instances" field.
func (m *TierMutation) SetConcurrentInstances(i int64) {
	m.concurrent_instances = &i
	m.addconcurrent_instances = nil
}

// ConcurrentInstances returns the value of the "concurrent_instances" field in the mutation.
func (m *TierMutation) ConcurrentInstances() (r int64, exists bool) {
	v := m.concurrent_instances
	if v == nil {
		return
	}
	return *v, true
}

// OldConcurrentInstances returns the old "concurrent_instances" field's value of the Tier entity.
// If the Tier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TierMutation) OldConcurrentInstances(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConcurrentInstances is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConcurrentInstances requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConcurrentInstances: %w", err)
	}
	return oldValue.ConcurrentInstances, nil
}

// AddConcurrentInstances adds i to the "concurrent_instances" field.
func (m *TierMutation) AddConcurrentInstances(i int64) {
	if m.addconcurrent_instances != nil {
		*m.addconcurrent_instances += i
	} else {
		m.addconcurrent_instances = &i
	}
}

// AddedConcurrentInstances returns the value that was added to the "concurrent_instances" field in this mutation.
func (m *TierMutation) AddedConcurrentInstances() (r int64, exists bool) {
	v := m.addconcurrent_instances
	if v == nil {
		return
	}
	return *v, true
}

// ResetConcurrentInstances resets all changes to the "concurrent_instances" field.
func (m *TierMutation) ResetConcurrentInstances() {
	m.concurrent_instances = nil
	m.addconcurrent_instances = nil
}

// SetMaxLengthHours sets the "max_length_hours" field.
func (m *TierMutation) SetMaxLengthHours(i int64) {
	m.max_length_hours = &i
	m.addmax_length_hours = nil
}

// MaxLengthHours returns the value of the "max_length_hours" field in the mutation.
func (m *TierMutation) MaxLengthHours() (r int64, exists bool) {
	v := m.max_length_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxLengthHours returns the old "max_length_hours" field's value of the Tier entity.
// If the Tier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TierMutation) OldMaxLengthHours(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxLengthHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxLengthHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxLengthHours: %w", err)
	}
	return oldValue.MaxLengthHours, nil
}

// AddMaxLengthHours adds i to the "max_length_hours" field.
func (m *TierMutation) AddMaxLengthHours(i int64) {
	if m.addmax_length_hours != nil {
		*m.addmax_length_hours += i
	} else {
		m.addmax_length_hours = &i
	}
}

// AddedMaxLengthHours returns the value that was added to the "max_length_hours" field in this mutation.
func (m *TierMutation) AddedMaxLengthHours() (r int64, exists bool) {
	v := m.addmax_length_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxLengthHours resets all changes to the "max_length_hours" field.
func (m *TierMutation) ResetMaxLengthHours() {
	m.max_length_hours = nil
	m.addmax_length_hours = nil
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *TierMutation) AddTeamIDs(ids ...uuid.UUID) {
	if m.teams == nil {
		m.teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *TierMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *TierMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *TierMutation) RemoveTeamIDs(ids ...uuid.UUID) {
	if m.removedteams == nil {
		m.removedteams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *TierMutation) RemovedTeamsIDs() (ids []uuid.UUID) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *TierMutation) TeamsIDs() (ids []uuid.UUID) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *TierMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// Where appends a list predicates to the TierMutation builder.
func (m *TierMutation) Where(ps ...predicate.Tier) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TierMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TierMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tier, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TierMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TierMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tier).
func (m *TierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TierMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, tier.FieldName)
	}
	if m.disk_mb != nil {
		fields = append(fields, tier.FieldDiskMB)
	}
	if m.concurrent_instances != nil {
		fields = append(fields, tier.FieldConcurrentInstances)
	}
	if m.max_length_hours != nil {
		fields = append(fields, tier.FieldMaxLengthHours)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tier.FieldName:
		return m.Name()
	case tier.FieldDiskMB:
		return m.DiskMB()
	case tier.FieldConcurrentInstances:
		return m.ConcurrentInstances()
	case tier.FieldMaxLengthHours:
		return m.MaxLengthHours()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tier.FieldName:
		return m.OldName(ctx)
	case tier.FieldDiskMB:
		return m.OldDiskMB(ctx)
	case tier.FieldConcurrentInstances:
		return m.OldConcurrentInstances(ctx)
	case tier.FieldMaxLengthHours:
		return m.OldMaxLengthHours(ctx)
	}
	return nil, fmt.Errorf("unknown Tier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tier.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tier.FieldDiskMB:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiskMB(v)
		return nil
	case tier.FieldConcurrentInstances:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConcurrentInstances(v)
		return nil
	case tier.FieldMaxLengthHours:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxLengthHours(v)
		return nil
	}
	return fmt.Errorf("unknown Tier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TierMutation) AddedFields() []string {
	var fields []string
	if m.adddisk_mb != nil {
		fields = append(fields, tier.FieldDiskMB)
	}
	if m.addconcurrent_instances != nil {
		fields = append(fields, tier.FieldConcurrentInstances)
	}
	if m.addmax_length_hours != nil {
		fields = append(fields, tier.FieldMaxLengthHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TierMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tier.FieldDiskMB:
		return m.AddedDiskMB()
	case tier.FieldConcurrentInstances:
		return m.AddedConcurrentInstances()
	case tier.FieldMaxLengthHours:
		return m.AddedMaxLengthHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TierMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tier.FieldDiskMB:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiskMB(v)
		return nil
	case tier.FieldConcurrentInstances:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConcurrentInstances(v)
		return nil
	case tier.FieldMaxLengthHours:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxLengthHours(v)
		return nil
	}
	return fmt.Errorf("unknown Tier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TierMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TierMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TierMutation) ResetField(name string) error {
	switch name {
	case tier.FieldName:
		m.ResetName()
		return nil
	case tier.FieldDiskMB:
		m.ResetDiskMB()
		return nil
	case tier.FieldConcurrentInstances:
		m.ResetConcurrentInstances()
		return nil
	case tier.FieldMaxLengthHours:
		m.ResetMaxLengthHours()
		return nil
	}
	return fmt.Errorf("unknown Tier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TierMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.teams != nil {
		edges = append(edges, tier.EdgeTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tier.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedteams != nil {
		edges = append(edges, tier.EdgeTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tier.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedteams {
		edges = append(edges, tier.EdgeTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TierMutation) EdgeCleared(name string) bool {
	switch name {
	case tier.EdgeTeams:
		return m.clearedteams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TierMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TierMutation) ResetEdge(name string) error {
	switch name {
	case tier.EdgeTeams:
		m.ResetTeams()
		return nil
	}
	return fmt.Errorf("unknown Tier edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	email                   *string
	clearedFields           map[string]struct{}
	teams                   map[uuid.UUID]struct{}
	removedteams            map[uuid.UUID]struct{}
	clearedteams            bool
	created_envs            map[string]struct{}
	removedcreated_envs     map[string]struct{}
	clearedcreated_envs     bool
	access_tokens           map[string]struct{}
	removedaccess_tokens    map[string]struct{}
	clearedaccess_tokens    bool
	created_api_keys        map[uuid.UUID]struct{}
	removedcreated_api_keys map[uuid.UUID]struct{}
	clearedcreated_api_keys bool
	users_teams             map[int]struct{}
	removedusers_teams      map[int]struct{}
	clearedusers_teams      bool
	done                    bool
	oldValue                func(context.Context) (*User, error)
	predicates              []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *UserMutation) AddTeamIDs(ids ...uuid.UUID) {
	if m.teams == nil {
		m.teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *UserMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *UserMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *UserMutation) RemoveTeamIDs(ids ...uuid.UUID) {
	if m.removedteams == nil {
		m.removedteams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *UserMutation) RemovedTeamsIDs() (ids []uuid.UUID) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *UserMutation) TeamsIDs() (ids []uuid.UUID) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *UserMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// AddCreatedEnvIDs adds the "created_envs" edge to the Env entity by ids.
func (m *UserMutation) AddCreatedEnvIDs(ids ...string) {
	if m.created_envs == nil {
		m.created_envs = make(map[string]struct{})
	}
	for i := range ids {
		m.created_envs[ids[i]] = struct{}{}
	}
}

// ClearCreatedEnvs clears the "created_envs" edge to the Env entity.
func (m *UserMutation) ClearCreatedEnvs() {
	m.clearedcreated_envs = true
}

// CreatedEnvsCleared reports if the "created_envs" edge to the Env entity was cleared.
func (m *UserMutation) CreatedEnvsCleared() bool {
	return m.clearedcreated_envs
}

// RemoveCreatedEnvIDs removes the "created_envs" edge to the Env entity by IDs.
func (m *UserMutation) RemoveCreatedEnvIDs(ids ...string) {
	if m.removedcreated_envs == nil {
		m.removedcreated_envs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.created_envs, ids[i])
		m.removedcreated_envs[ids[i]] = struct{}{}
	}
}

// RemovedCreatedEnvs returns the removed IDs of the "created_envs" edge to the Env entity.
func (m *UserMutation) RemovedCreatedEnvsIDs() (ids []string) {
	for id := range m.removedcreated_envs {
		ids = append(ids, id)
	}
	return
}

// CreatedEnvsIDs returns the "created_envs" edge IDs in the mutation.
func (m *UserMutation) CreatedEnvsIDs() (ids []string) {
	for id := range m.created_envs {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedEnvs resets all changes to the "created_envs" edge.
func (m *UserMutation) ResetCreatedEnvs() {
	m.created_envs = nil
	m.clearedcreated_envs = false
	m.removedcreated_envs = nil
}

// AddAccessTokenIDs adds the "access_tokens" edge to the AccessToken entity by ids.
func (m *UserMutation) AddAccessTokenIDs(ids ...string) {
	if m.access_tokens == nil {
		m.access_tokens = make(map[string]struct{})
	}
	for i := range ids {
		m.access_tokens[ids[i]] = struct{}{}
	}
}

// ClearAccessTokens clears the "access_tokens" edge to the AccessToken entity.
func (m *UserMutation) ClearAccessTokens() {
	m.clearedaccess_tokens = true
}

// AccessTokensCleared reports if the "access_tokens" edge to the AccessToken entity was cleared.
func (m *UserMutation) AccessTokensCleared() bool {
	return m.clearedaccess_tokens
}

// RemoveAccessTokenIDs removes the "access_tokens" edge to the AccessToken entity by IDs.
func (m *UserMutation) RemoveAccessTokenIDs(ids ...string) {
	if m.removedaccess_tokens == nil {
		m.removedaccess_tokens = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.access_tokens, ids[i])
		m.removedaccess_tokens[ids[i]] = struct{}{}
	}
}

// RemovedAccessTokens returns the removed IDs of the "access_tokens" edge to the AccessToken entity.
func (m *UserMutation) RemovedAccessTokensIDs() (ids []string) {
	for id := range m.removedaccess_tokens {
		ids = append(ids, id)
	}
	return
}

// AccessTokensIDs returns the "access_tokens" edge IDs in the mutation.
func (m *UserMutation) AccessTokensIDs() (ids []string) {
	for id := range m.access_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetAccessTokens resets all changes to the "access_tokens" edge.
func (m *UserMutation) ResetAccessTokens() {
	m.access_tokens = nil
	m.clearedaccess_tokens = false
	m.removedaccess_tokens = nil
}

// AddCreatedAPIKeyIDs adds the "created_api_keys" edge to the TeamAPIKey entity by ids.
func (m *UserMutation) AddCreatedAPIKeyIDs(ids ...uuid.UUID) {
	if m.created_api_keys == nil {
		m.created_api_keys = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.created_api_keys[ids[i]] = struct{}{}
	}
}

// ClearCreatedAPIKeys clears the "created_api_keys" edge to the TeamAPIKey entity.
func (m *UserMutation) ClearCreatedAPIKeys() {
	m.clearedcreated_api_keys = true
}

// CreatedAPIKeysCleared reports if the "created_api_keys" edge to the TeamAPIKey entity was cleared.
func (m *UserMutation) CreatedAPIKeysCleared() bool {
	return m.clearedcreated_api_keys
}

// RemoveCreatedAPIKeyIDs removes the "created_api_keys" edge to the TeamAPIKey entity by IDs.
func (m *UserMutation) RemoveCreatedAPIKeyIDs(ids ...uuid.UUID) {
	if m.removedcreated_api_keys == nil {
		m.removedcreated_api_keys = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.created_api_keys, ids[i])
		m.removedcreated_api_keys[ids[i]] = struct{}{}
	}
}

// RemovedCreatedAPIKeys returns the removed IDs of the "created_api_keys" edge to the TeamAPIKey entity.
func (m *UserMutation) RemovedCreatedAPIKeysIDs() (ids []uuid.UUID) {
	for id := range m.removedcreated_api_keys {
		ids = append(ids, id)
	}
	return
}

// CreatedAPIKeysIDs returns the "created_api_keys" edge IDs in the mutation.
func (m *UserMutation) CreatedAPIKeysIDs() (ids []uuid.UUID) {
	for id := range m.created_api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedAPIKeys resets all changes to the "created_api_keys" edge.
func (m *UserMutation) ResetCreatedAPIKeys() {
	m.created_api_keys = nil
	m.clearedcreated_api_keys = false
	m.removedcreated_api_keys = nil
}

// AddUsersTeamIDs adds the "users_teams" edge to the UsersTeams entity by ids.
func (m *UserMutation) AddUsersTeamIDs(ids ...int) {
	if m.users_teams == nil {
		m.users_teams = make(map[int]struct{})
	}
	for i := range ids {
		m.users_teams[ids[i]] = struct{}{}
	}
}

// ClearUsersTeams clears the "users_teams" edge to the UsersTeams entity.
func (m *UserMutation) ClearUsersTeams() {
	m.clearedusers_teams = true
}

// UsersTeamsCleared reports if the "users_teams" edge to the UsersTeams entity was cleared.
func (m *UserMutation) UsersTeamsCleared() bool {
	return m.clearedusers_teams
}

// RemoveUsersTeamIDs removes the "users_teams" edge to the UsersTeams entity by IDs.
func (m *UserMutation) RemoveUsersTeamIDs(ids ...int) {
	if m.removedusers_teams == nil {
		m.removedusers_teams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users_teams, ids[i])
		m.removedusers_teams[ids[i]] = struct{}{}
	}
}

// RemovedUsersTeams returns the removed IDs of the "users_teams" edge to the UsersTeams entity.
func (m *UserMutation) RemovedUsersTeamsIDs() (ids []int) {
	for id := range m.removedusers_teams {
		ids = append(ids, id)
	}
	return
}

// UsersTeamsIDs returns the "users_teams" edge IDs in the mutation.
func (m *UserMutation) UsersTeamsIDs() (ids []int) {
	for id := range m.users_teams {
		ids = append(ids, id)
	}
	return
}

// ResetUsersTeams resets all changes to the "users_teams" edge.
func (m *UserMutation) ResetUsersTeams() {
	m.users_teams = nil
	m.clearedusers_teams = false
	m.removedusers_teams = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.teams != nil {
		edges = append(edges, user.EdgeTeams)
	}
	if m.created_envs != nil {
		edges = append(edges, user.EdgeCreatedEnvs)
	}
	if m.access_tokens != nil {
		edges = append(edges, user.EdgeAccessTokens)
	}
	if m.created_api_keys != nil {
		edges = append(edges, user.EdgeCreatedAPIKeys)
	}
	if m.users_teams != nil {
		edges = append(edges, user.EdgeUsersTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedEnvs:
		ids := make([]ent.Value, 0, len(m.created_envs))
		for id := range m.created_envs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAccessTokens:
		ids := make([]ent.Value, 0, len(m.access_tokens))
		for id := range m.access_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedAPIKeys:
		ids := make([]ent.Value, 0, len(m.created_api_keys))
		for id := range m.created_api_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUsersTeams:
		ids := make([]ent.Value, 0, len(m.users_teams))
		for id := range m.users_teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedteams != nil {
		edges = append(edges, user.EdgeTeams)
	}
	if m.removedcreated_envs != nil {
		edges = append(edges, user.EdgeCreatedEnvs)
	}
	if m.removedaccess_tokens != nil {
		edges = append(edges, user.EdgeAccessTokens)
	}
	if m.removedcreated_api_keys != nil {
		edges = append(edges, user.EdgeCreatedAPIKeys)
	}
	if m.removedusers_teams != nil {
		edges = append(edges, user.EdgeUsersTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedEnvs:
		ids := make([]ent.Value, 0, len(m.removedcreated_envs))
		for id := range m.removedcreated_envs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAccessTokens:
		ids := make([]ent.Value, 0, len(m.removedaccess_tokens))
		for id := range m.removedaccess_tokens {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedcreated_api_keys))
		for id := range m.removedcreated_api_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUsersTeams:
		ids := make([]ent.Value, 0, len(m.removedusers_teams))
		for id := range m.removedusers_teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedteams {
		edges = append(edges, user.EdgeTeams)
	}
	if m.clearedcreated_envs {
		edges = append(edges, user.EdgeCreatedEnvs)
	}
	if m.clearedaccess_tokens {
		edges = append(edges, user.EdgeAccessTokens)
	}
	if m.clearedcreated_api_keys {
		edges = append(edges, user.EdgeCreatedAPIKeys)
	}
	if m.clearedusers_teams {
		edges = append(edges, user.EdgeUsersTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeTeams:
		return m.clearedteams
	case user.EdgeCreatedEnvs:
		return m.clearedcreated_envs
	case user.EdgeAccessTokens:
		return m.clearedaccess_tokens
	case user.EdgeCreatedAPIKeys:
		return m.clearedcreated_api_keys
	case user.EdgeUsersTeams:
		return m.clearedusers_teams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeTeams:
		m.ResetTeams()
		return nil
	case user.EdgeCreatedEnvs:
		m.ResetCreatedEnvs()
		return nil
	case user.EdgeAccessTokens:
		m.ResetAccessTokens()
		return nil
	case user.EdgeCreatedAPIKeys:
		m.ResetCreatedAPIKeys()
		return nil
	case user.EdgeUsersTeams:
		m.ResetUsersTeams()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UsersTeamsMutation represents an operation that mutates the UsersTeams nodes in the graph.
type UsersTeamsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	is_default    *bool
	clearedFields map[string]struct{}
	users         *uuid.UUID
	clearedusers  bool
	teams         *uuid.UUID
	clearedteams  bool
	done          bool
	oldValue      func(context.Context) (*UsersTeams, error)
	predicates    []predicate.UsersTeams
}

var _ ent.Mutation = (*UsersTeamsMutation)(nil)

// usersteamsOption allows management of the mutation configuration using functional options.
type usersteamsOption func(*UsersTeamsMutation)

// newUsersTeamsMutation creates new mutation for the UsersTeams entity.
func newUsersTeamsMutation(c config, op Op, opts ...usersteamsOption) *UsersTeamsMutation {
	m := &UsersTeamsMutation{
		config:        c,
		op:            op,
		typ:           TypeUsersTeams,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsersTeamsID sets the ID field of the mutation.
func withUsersTeamsID(id int) usersteamsOption {
	return func(m *UsersTeamsMutation) {
		var (
			err   error
			once  sync.Once
			value *UsersTeams
		)
		m.oldValue = func(ctx context.Context) (*UsersTeams, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsersTeams.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsersTeams sets the old UsersTeams of the mutation.
func withUsersTeams(node *UsersTeams) usersteamsOption {
	return func(m *UsersTeamsMutation) {
		m.oldValue = func(context.Context) (*UsersTeams, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsersTeamsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsersTeamsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsersTeamsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsersTeamsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsersTeams.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UsersTeamsMutation) SetUserID(u uuid.UUID) {
	m.users = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UsersTeamsMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UsersTeams entity.
// If the UsersTeams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersTeamsMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UsersTeamsMutation) ResetUserID() {
	m.users = nil
}

// SetTeamID sets the "team_id" field.
func (m *UsersTeamsMutation) SetTeamID(u uuid.UUID) {
	m.teams = &u
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *UsersTeamsMutation) TeamID() (r uuid.UUID, exists bool) {
	v := m.teams
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the UsersTeams entity.
// If the UsersTeams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersTeamsMutation) OldTeamID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *UsersTeamsMutation) ResetTeamID() {
	m.teams = nil
}

// SetIsDefault sets the "is_default" field.
func (m *UsersTeamsMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *UsersTeamsMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the UsersTeams entity.
// If the UsersTeams object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsersTeamsMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *UsersTeamsMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *UsersTeamsMutation) SetUsersID(id uuid.UUID) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *UsersTeamsMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[usersteams.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *UsersTeamsMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *UsersTeamsMutation) UsersID() (id uuid.UUID, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *UsersTeamsMutation) UsersIDs() (ids []uuid.UUID) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *UsersTeamsMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// SetTeamsID sets the "teams" edge to the Team entity by id.
func (m *UsersTeamsMutation) SetTeamsID(id uuid.UUID) {
	m.teams = &id
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *UsersTeamsMutation) ClearTeams() {
	m.clearedteams = true
	m.clearedFields[usersteams.FieldTeamID] = struct{}{}
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *UsersTeamsMutation) TeamsCleared() bool {
	return m.clearedteams
}

// TeamsID returns the "teams" edge ID in the mutation.
func (m *UsersTeamsMutation) TeamsID() (id uuid.UUID, exists bool) {
	if m.teams != nil {
		return *m.teams, true
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamsID instead. It exists only for internal usage by the builders.
func (m *UsersTeamsMutation) TeamsIDs() (ids []uuid.UUID) {
	if id := m.teams; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *UsersTeamsMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
}

// Where appends a list predicates to the UsersTeamsMutation builder.
func (m *UsersTeamsMutation) Where(ps ...predicate.UsersTeams) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsersTeamsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsersTeamsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsersTeams, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsersTeamsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsersTeamsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsersTeams).
func (m *UsersTeamsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsersTeamsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.users != nil {
		fields = append(fields, usersteams.FieldUserID)
	}
	if m.teams != nil {
		fields = append(fields, usersteams.FieldTeamID)
	}
	if m.is_default != nil {
		fields = append(fields, usersteams.FieldIsDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsersTeamsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersteams.FieldUserID:
		return m.UserID()
	case usersteams.FieldTeamID:
		return m.TeamID()
	case usersteams.FieldIsDefault:
		return m.IsDefault()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsersTeamsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersteams.FieldUserID:
		return m.OldUserID(ctx)
	case usersteams.FieldTeamID:
		return m.OldTeamID(ctx)
	case usersteams.FieldIsDefault:
		return m.OldIsDefault(ctx)
	}
	return nil, fmt.Errorf("unknown UsersTeams field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsersTeamsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersteams.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usersteams.FieldTeamID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case usersteams.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown UsersTeams field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsersTeamsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsersTeamsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsersTeamsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UsersTeams numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsersTeamsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsersTeamsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsersTeamsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UsersTeams nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsersTeamsMutation) ResetField(name string) error {
	switch name {
	case usersteams.FieldUserID:
		m.ResetUserID()
		return nil
	case usersteams.FieldTeamID:
		m.ResetTeamID()
		return nil
	case usersteams.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	}
	return fmt.Errorf("unknown UsersTeams field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsersTeamsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, usersteams.EdgeUsers)
	}
	if m.teams != nil {
		edges = append(edges, usersteams.EdgeTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsersTeamsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersteams.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	case usersteams.EdgeTeams:
		if id := m.teams; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsersTeamsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsersTeamsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsersTeamsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, usersteams.EdgeUsers)
	}
	if m.clearedteams {
		edges = append(edges, usersteams.EdgeTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsersTeamsMutation) EdgeCleared(name string) bool {
	switch name {
	case usersteams.EdgeUsers:
		return m.clearedusers
	case usersteams.EdgeTeams:
		return m.clearedteams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsersTeamsMutation) ClearEdge(name string) error {
	switch name {
	case usersteams.EdgeUsers:
		m.ClearUsers()
		return nil
	case usersteams.EdgeTeams:
		m.ClearTeams()
		return nil
	}
	return fmt.Errorf("unknown UsersTeams unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsersTeamsMutation) ResetEdge(name string) error {
	switch name {
	case usersteams.EdgeUsers:
		m.ResetUsers()
		return nil
	case usersteams.EdgeTeams:
		m.ResetTeams()
		return nil
	}
	return fmt.Errorf("unknown UsersTeams edge %s", name)
}



================================================
File: models/runtime.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"time"

	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envalias"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/envbuild"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/snapshot"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/teamapikey"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"
	"github.com/e2b-dev/infra/packages/shared/pkg/schema"
)

// The init function reads all schema descriptors with runtime code
// (default values, validators, hooks and policies) and stitches it
// to their package variables.
func init() {
	envFields := schema.Env{}.Fields()
	_ = envFields
	// envDescCreatedAt is the schema descriptor for created_at field.
	envDescCreatedAt := envFields[1].Descriptor()
	// env.DefaultCreatedAt holds the default value on creation for the created_at field.
	env.DefaultCreatedAt = envDescCreatedAt.Default.(func() time.Time)
	// envDescUpdatedAt is the schema descriptor for updated_at field.
	envDescUpdatedAt := envFields[2].Descriptor()
	// env.DefaultUpdatedAt holds the default value on creation for the updated_at field.
	env.DefaultUpdatedAt = envDescUpdatedAt.Default.(func() time.Time)
	// envDescBuildCount is the schema descriptor for build_count field.
	envDescBuildCount := envFields[6].Descriptor()
	// env.DefaultBuildCount holds the default value on creation for the build_count field.
	env.DefaultBuildCount = envDescBuildCount.Default.(int32)
	// envDescSpawnCount is the schema descriptor for spawn_count field.
	envDescSpawnCount := envFields[7].Descriptor()
	// env.DefaultSpawnCount holds the default value on creation for the spawn_count field.
	env.DefaultSpawnCount = envDescSpawnCount.Default.(int64)
	envaliasFields := schema.EnvAlias{}.Fields()
	_ = envaliasFields
	// envaliasDescIsRenamable is the schema descriptor for is_renamable field.
	envaliasDescIsRenamable := envaliasFields[2].Descriptor()
	// envalias.DefaultIsRenamable holds the default value on creation for the is_renamable field.
	envalias.DefaultIsRenamable = envaliasDescIsRenamable.Default.(bool)
	envbuildFields := schema.EnvBuild{}.Fields()
	_ = envbuildFields
	// envbuildDescCreatedAt is the schema descriptor for created_at field.
	envbuildDescCreatedAt := envbuildFields[1].Descriptor()
	// envbuild.DefaultCreatedAt holds the default value on creation for the created_at field.
	envbuild.DefaultCreatedAt = envbuildDescCreatedAt.Default.(func() time.Time)
	// envbuildDescUpdatedAt is the schema descriptor for updated_at field.
	envbuildDescUpdatedAt := envbuildFields[2].Descriptor()
	// envbuild.DefaultUpdatedAt holds the default value on creation for the updated_at field.
	envbuild.DefaultUpdatedAt = envbuildDescUpdatedAt.Default.(func() time.Time)
	// envbuildDescKernelVersion is the schema descriptor for kernel_version field.
	envbuildDescKernelVersion := envbuildFields[12].Descriptor()
	// envbuild.DefaultKernelVersion holds the default value on creation for the kernel_version field.
	envbuild.DefaultKernelVersion = envbuildDescKernelVersion.Default.(string)
	// envbuildDescFirecrackerVersion is the schema descriptor for firecracker_version field.
	envbuildDescFirecrackerVersion := envbuildFields[13].Descriptor()
	// envbuild.DefaultFirecrackerVersion holds the default value on creation for the firecracker_version field.
	envbuild.DefaultFirecrackerVersion = envbuildDescFirecrackerVersion.Default.(string)
	snapshotFields := schema.Snapshot{}.Fields()
	_ = snapshotFields
	// snapshotDescCreatedAt is the schema descriptor for created_at field.
	snapshotDescCreatedAt := snapshotFields[1].Descriptor()
	// snapshot.DefaultCreatedAt holds the default value on creation for the created_at field.
	snapshot.DefaultCreatedAt = snapshotDescCreatedAt.Default.(func() time.Time)
	teamFields := schema.Team{}.Fields()
	_ = teamFields
	// teamDescCreatedAt is the schema descriptor for created_at field.
	teamDescCreatedAt := teamFields[1].Descriptor()
	// team.DefaultCreatedAt holds the default value on creation for the created_at field.
	team.DefaultCreatedAt = teamDescCreatedAt.Default.(func() time.Time)
	// teamDescEmail is the schema descriptor for email field.
	teamDescEmail := teamFields[7].Descriptor()
	// team.EmailValidator is a validator for the "email" field. It is called by the builders before save.
	team.EmailValidator = teamDescEmail.Validators[0].(func(string) error)
	teamapikeyFields := schema.TeamAPIKey{}.Fields()
	_ = teamapikeyFields
	// teamapikeyDescCreatedAt is the schema descriptor for created_at field.
	teamapikeyDescCreatedAt := teamapikeyFields[2].Descriptor()
	// teamapikey.DefaultCreatedAt holds the default value on creation for the created_at field.
	teamapikey.DefaultCreatedAt = teamapikeyDescCreatedAt.Default.(func() time.Time)
	// teamapikeyDescName is the schema descriptor for name field.
	teamapikeyDescName := teamapikeyFields[5].Descriptor()
	// teamapikey.DefaultName holds the default value on creation for the name field.
	teamapikey.DefaultName = teamapikeyDescName.Default.(string)
	userFields := schema.User{}.Fields()
	_ = userFields
	// userDescEmail is the schema descriptor for email field.
	userDescEmail := userFields[1].Descriptor()
	// user.EmailValidator is a validator for the "email" field. It is called by the builders before save.
	user.EmailValidator = userDescEmail.Validators[0].(func(string) error)
	usersteamsFields := schema.UsersTeams{}.Fields()
	_ = usersteamsFields
	// usersteamsDescIsDefault is the schema descriptor for is_default field.
	usersteamsDescIsDefault := usersteamsFields[2].Descriptor()
	// usersteams.DefaultIsDefault holds the default value on creation for the is_default field.
	usersteams.DefaultIsDefault = usersteamsDescIsDefault.Default.(bool)
}



================================================
File: models/snapshot.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/snapshot"
	"github.com/google/uuid"
)

// Snapshot is the model entity for the Snapshot schema.
type Snapshot struct {
	config `json:"-"`
	// ID of the ent.
	ID uuid.UUID `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// BaseEnvID holds the value of the "base_env_id" field.
	BaseEnvID string `json:"base_env_id,omitempty"`
	// EnvID holds the value of the "env_id" field.
	EnvID string `json:"env_id,omitempty"`
	// SandboxID holds the value of the "sandbox_id" field.
	SandboxID string `json:"sandbox_id,omitempty"`
	// Metadata holds the value of the "metadata" field.
	Metadata map[string]string `json:"metadata,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the SnapshotQuery when eager-loading is set.
	Edges        SnapshotEdges `json:"edges"`
	selectValues sql.SelectValues
}

// SnapshotEdges holds the relations/edges for other nodes in the graph.
type SnapshotEdges struct {
	// Env holds the value of the env edge.
	Env *Env `json:"env,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// EnvOrErr returns the Env value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e SnapshotEdges) EnvOrErr() (*Env, error) {
	if e.loadedTypes[0] {
		if e.Env == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: env.Label}
		}
		return e.Env, nil
	}
	return nil, &NotLoadedError{edge: "env"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Snapshot) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case snapshot.FieldMetadata:
			values[i] = new([]byte)
		case snapshot.FieldBaseEnvID, snapshot.FieldEnvID, snapshot.FieldSandboxID:
			values[i] = new(sql.NullString)
		case snapshot.FieldCreatedAt:
			values[i] = new(sql.NullTime)
		case snapshot.FieldID:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Snapshot fields.
func (s *Snapshot) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case snapshot.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				s.ID = *value
			}
		case snapshot.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				s.CreatedAt = value.Time
			}
		case snapshot.FieldBaseEnvID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field base_env_id", values[i])
			} else if value.Valid {
				s.BaseEnvID = value.String
			}
		case snapshot.FieldEnvID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field env_id", values[i])
			} else if value.Valid {
				s.EnvID = value.String
			}
		case snapshot.FieldSandboxID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field sandbox_id", values[i])
			} else if value.Valid {
				s.SandboxID = value.String
			}
		case snapshot.FieldMetadata:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field metadata", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &s.Metadata); err != nil {
					return fmt.Errorf("unmarshal field metadata: %w", err)
				}
			}
		default:
			s.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Snapshot.
// This includes values selected through modifiers, order, etc.
func (s *Snapshot) Value(name string) (ent.Value, error) {
	return s.selectValues.Get(name)
}

// QueryEnv queries the "env" edge of the Snapshot entity.
func (s *Snapshot) QueryEnv() *EnvQuery {
	return NewSnapshotClient(s.config).QueryEnv(s)
}

// Update returns a builder for updating this Snapshot.
// Note that you need to call Snapshot.Unwrap() before calling this method if this Snapshot
// was returned from a transaction, and the transaction was committed or rolled back.
func (s *Snapshot) Update() *SnapshotUpdateOne {
	return NewSnapshotClient(s.config).UpdateOne(s)
}

// Unwrap unwraps the Snapshot entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (s *Snapshot) Unwrap() *Snapshot {
	_tx, ok := s.config.driver.(*txDriver)
	if !ok {
		panic("models: Snapshot is not a transactional entity")
	}
	s.config.driver = _tx.drv
	return s
}

// String implements the fmt.Stringer.
func (s *Snapshot) String() string {
	var builder strings.Builder
	builder.WriteString("Snapshot(")
	builder.WriteString(fmt.Sprintf("id=%v, ", s.ID))
	builder.WriteString("created_at=")
	builder.WriteString(s.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("base_env_id=")
	builder.WriteString(s.BaseEnvID)
	builder.WriteString(", ")
	builder.WriteString("env_id=")
	builder.WriteString(s.EnvID)
	builder.WriteString(", ")
	builder.WriteString("sandbox_id=")
	builder.WriteString(s.SandboxID)
	builder.WriteString(", ")
	builder.WriteString("metadata=")
	builder.WriteString(fmt.Sprintf("%v", s.Metadata))
	builder.WriteByte(')')
	return builder.String()
}

// Snapshots is a parsable slice of Snapshot.
type Snapshots []*Snapshot



================================================
File: models/snapshot_create.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/snapshot"
	"github.com/google/uuid"
)

// SnapshotCreate is the builder for creating a Snapshot entity.
type SnapshotCreate struct {
	config
	mutation *SnapshotMutation
	hooks    []Hook
	conflict []sql.ConflictOption
}

// SetCreatedAt sets the "created_at" field.
func (sc *SnapshotCreate) SetCreatedAt(t time.Time) *SnapshotCreate {
	sc.mutation.SetCreatedAt(t)
	return sc
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (sc *SnapshotCreate) SetNillableCreatedAt(t *time.Time) *SnapshotCreate {
	if t != nil {
		sc.SetCreatedAt(*t)
	}
	return sc
}

// SetBaseEnvID sets the "base_env_id" field.
func (sc *SnapshotCreate) SetBaseEnvID(s string) *SnapshotCreate {
	sc.mutation.SetBaseEnvID(s)
	return sc
}

// SetEnvID sets the "env_id" field.
func (sc *SnapshotCreate) SetEnvID(s string) *SnapshotCreate {
	sc.mutation.SetEnvID(s)
	return sc
}

// SetSandboxID sets the "sandbox_id" field.
func (sc *SnapshotCreate) SetSandboxID(s string) *SnapshotCreate {
	sc.mutation.SetSandboxID(s)
	return sc
}

// SetMetadata sets the "metadata" field.
func (sc *SnapshotCreate) SetMetadata(m map[string]string) *SnapshotCreate {
	sc.mutation.SetMetadata(m)
	return sc
}

// SetID sets the "id" field.
func (sc *SnapshotCreate) SetID(u uuid.UUID) *SnapshotCreate {
	sc.mutation.SetID(u)
	return sc
}

// SetEnv sets the "env" edge to the Env entity.
func (sc *SnapshotCreate) SetEnv(e *Env) *SnapshotCreate {
	return sc.SetEnvID(e.ID)
}

// Mutation returns the SnapshotMutation object of the builder.
func (sc *SnapshotCreate) Mutation() *SnapshotMutation {
	return sc.mutation
}

// Save creates the Snapshot in the database.
func (sc *SnapshotCreate) Save(ctx context.Context) (*Snapshot, error) {
	sc.defaults()
	return withHooks(ctx, sc.sqlSave, sc.mutation, sc.hooks)
}

// SaveX calls Save and panics if Save returns an error.
func (sc *SnapshotCreate) SaveX(ctx context.Context) *Snapshot {
	v, err := sc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (sc *SnapshotCreate) Exec(ctx context.Context) error {
	_, err := sc.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (sc *SnapshotCreate) ExecX(ctx context.Context) {
	if err := sc.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (sc *SnapshotCreate) defaults() {
	if _, ok := sc.mutation.CreatedAt(); !ok {
		v := snapshot.DefaultCreatedAt()
		sc.mutation.SetCreatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (sc *SnapshotCreate) check() error {
	if _, ok := sc.mutation.CreatedAt(); !ok {
		return &ValidationError{Name: "created_at", err: errors.New(`models: missing required field "Snapshot.created_at"`)}
	}
	if _, ok := sc.mutation.BaseEnvID(); !ok {
		return &ValidationError{Name: "base_env_id", err: errors.New(`models: missing required field "Snapshot.base_env_id"`)}
	}
	if _, ok := sc.mutation.EnvID(); !ok {
		return &ValidationError{Name: "env_id", err: errors.New(`models: missing required field "Snapshot.env_id"`)}
	}
	if _, ok := sc.mutation.SandboxID(); !ok {
		return &ValidationError{Name: "sandbox_id", err: errors.New(`models: missing required field "Snapshot.sandbox_id"`)}
	}
	if _, ok := sc.mutation.Metadata(); !ok {
		return &ValidationError{Name: "metadata", err: errors.New(`models: missing required field "Snapshot.metadata"`)}
	}
	if _, ok := sc.mutation.EnvID(); !ok {
		return &ValidationError{Name: "env", err: errors.New(`models: missing required edge "Snapshot.env"`)}
	}
	return nil
}

func (sc *SnapshotCreate) sqlSave(ctx context.Context) (*Snapshot, error) {
	if err := sc.check(); err != nil {
		return nil, err
	}
	_node, _spec := sc.createSpec()
	if err := sqlgraph.CreateNode(ctx, sc.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	if _spec.ID.Value != nil {
		if id, ok := _spec.ID.Value.(*uuid.UUID); ok {
			_node.ID = *id
		} else if err := _node.ID.Scan(_spec.ID.Value); err != nil {
			return nil, err
		}
	}
	sc.mutation.id = &_node.ID
	sc.mutation.done = true
	return _node, nil
}

func (sc *SnapshotCreate) createSpec() (*Snapshot, *sqlgraph.CreateSpec) {
	var (
		_node = &Snapshot{config: sc.config}
		_spec = sqlgraph.NewCreateSpec(snapshot.Table, sqlgraph.NewFieldSpec(snapshot.FieldID, field.TypeUUID))
	)
	_spec.Schema = sc.schemaConfig.Snapshot
	_spec.OnConflict = sc.conflict
	if id, ok := sc.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = &id
	}
	if value, ok := sc.mutation.CreatedAt(); ok {
		_spec.SetField(snapshot.FieldCreatedAt, field.TypeTime, value)
		_node.CreatedAt = value
	}
	if value, ok := sc.mutation.BaseEnvID(); ok {
		_spec.SetField(snapshot.FieldBaseEnvID, field.TypeString, value)
		_node.BaseEnvID = value
	}
	if value, ok := sc.mutation.SandboxID(); ok {
		_spec.SetField(snapshot.FieldSandboxID, field.TypeString, value)
		_node.SandboxID = value
	}
	if value, ok := sc.mutation.Metadata(); ok {
		_spec.SetField(snapshot.FieldMetadata, field.TypeJSON, value)
		_node.Metadata = value
	}
	if nodes := sc.mutation.EnvIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   snapshot.EnvTable,
			Columns: []string{snapshot.EnvColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = sc.schemaConfig.Snapshot
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.EnvID = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.Snapshot.Create().
//		SetCreatedAt(v).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.SnapshotUpsert) {
//			SetCreatedAt(v+v).
//		}).
//		Exec(ctx)
func (sc *SnapshotCreate) OnConflict(opts ...sql.ConflictOption) *SnapshotUpsertOne {
	sc.conflict = opts
	return &SnapshotUpsertOne{
		create: sc,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.Snapshot.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (sc *SnapshotCreate) OnConflictColumns(columns ...string) *SnapshotUpsertOne {
	sc.conflict = append(sc.conflict, sql.ConflictColumns(columns...))
	return &SnapshotUpsertOne{
		create: sc,
	}
}

type (
	// SnapshotUpsertOne is the builder for "upsert"-ing
	//  one Snapshot node.
	SnapshotUpsertOne struct {
		create *SnapshotCreate
	}

	// SnapshotUpsert is the "OnConflict" setter.
	SnapshotUpsert struct {
		*sql.UpdateSet
	}
)

// SetBaseEnvID sets the "base_env_id" field.
func (u *SnapshotUpsert) SetBaseEnvID(v string) *SnapshotUpsert {
	u.Set(snapshot.FieldBaseEnvID, v)
	return u
}

// UpdateBaseEnvID sets the "base_env_id" field to the value that was provided on create.
func (u *SnapshotUpsert) UpdateBaseEnvID() *SnapshotUpsert {
	u.SetExcluded(snapshot.FieldBaseEnvID)
	return u
}

// SetEnvID sets the "env_id" field.
func (u *SnapshotUpsert) SetEnvID(v string) *SnapshotUpsert {
	u.Set(snapshot.FieldEnvID, v)
	return u
}

// UpdateEnvID sets the "env_id" field to the value that was provided on create.
func (u *SnapshotUpsert) UpdateEnvID() *SnapshotUpsert {
	u.SetExcluded(snapshot.FieldEnvID)
	return u
}

// SetSandboxID sets the "sandbox_id" field.
func (u *SnapshotUpsert) SetSandboxID(v string) *SnapshotUpsert {
	u.Set(snapshot.FieldSandboxID, v)
	return u
}

// UpdateSandboxID sets the "sandbox_id" field to the value that was provided on create.
func (u *SnapshotUpsert) UpdateSandboxID() *SnapshotUpsert {
	u.SetExcluded(snapshot.FieldSandboxID)
	return u
}

// SetMetadata sets the "metadata" field.
func (u *SnapshotUpsert) SetMetadata(v map[string]string) *SnapshotUpsert {
	u.Set(snapshot.FieldMetadata, v)
	return u
}

// UpdateMetadata sets the "metadata" field to the value that was provided on create.
func (u *SnapshotUpsert) UpdateMetadata() *SnapshotUpsert {
	u.SetExcluded(snapshot.FieldMetadata)
	return u
}

// UpdateNewValues updates the mutable fields using the new values that were set on create except the ID field.
// Using this option is equivalent to using:
//
//	client.Snapshot.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(snapshot.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *SnapshotUpsertOne) UpdateNewValues() *SnapshotUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		if _, exists := u.create.mutation.ID(); exists {
			s.SetIgnore(snapshot.FieldID)
		}
		if _, exists := u.create.mutation.CreatedAt(); exists {
			s.SetIgnore(snapshot.FieldCreatedAt)
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.Snapshot.Create().
//	    OnConflict(sql.ResolveWithIgnore()).
//	    Exec(ctx)
func (u *SnapshotUpsertOne) Ignore() *SnapshotUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *SnapshotUpsertOne) DoNothing() *SnapshotUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the SnapshotCreate.OnConflict
// documentation for more info.
func (u *SnapshotUpsertOne) Update(set func(*SnapshotUpsert)) *SnapshotUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&SnapshotUpsert{UpdateSet: update})
	}))
	return u
}

// SetBaseEnvID sets the "base_env_id" field.
func (u *SnapshotUpsertOne) SetBaseEnvID(v string) *SnapshotUpsertOne {
	return u.Update(func(s *SnapshotUpsert) {
		s.SetBaseEnvID(v)
	})
}

// UpdateBaseEnvID sets the "base_env_id" field to the value that was provided on create.
func (u *SnapshotUpsertOne) UpdateBaseEnvID() *SnapshotUpsertOne {
	return u.Update(func(s *SnapshotUpsert) {
		s.UpdateBaseEnvID()
	})
}

// SetEnvID sets the "env_id" field.
func (u *SnapshotUpsertOne) SetEnvID(v string) *SnapshotUpsertOne {
	return u.Update(func(s *SnapshotUpsert) {
		s.SetEnvID(v)
	})
}

// UpdateEnvID sets the "env_id" field to the value that was provided on create.
func (u *SnapshotUpsertOne) UpdateEnvID() *SnapshotUpsertOne {
	return u.Update(func(s *SnapshotUpsert) {
		s.UpdateEnvID()
	})
}

// SetSandboxID sets the "sandbox_id" field.
func (u *SnapshotUpsertOne) SetSandboxID(v string) *SnapshotUpsertOne {
	return u.Update(func(s *SnapshotUpsert) {
		s.SetSandboxID(v)
	})
}

// UpdateSandboxID sets the "sandbox_id" field to the value that was provided on create.
func (u *SnapshotUpsertOne) UpdateSandboxID() *SnapshotUpsertOne {
	return u.Update(func(s *SnapshotUpsert) {
		s.UpdateSandboxID()
	})
}

// SetMetadata sets the "metadata" field.
func (u *SnapshotUpsertOne) SetMetadata(v map[string]string) *SnapshotUpsertOne {
	return u.Update(func(s *SnapshotUpsert) {
		s.SetMetadata(v)
	})
}

// UpdateMetadata sets the "metadata" field to the value that was provided on create.
func (u *SnapshotUpsertOne) UpdateMetadata() *SnapshotUpsertOne {
	return u.Update(func(s *SnapshotUpsert) {
		s.UpdateMetadata()
	})
}

// Exec executes the query.
func (u *SnapshotUpsertOne) Exec(ctx context.Context) error {
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for SnapshotCreate.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *SnapshotUpsertOne) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}

// Exec executes the UPSERT query and returns the inserted/updated ID.
func (u *SnapshotUpsertOne) ID(ctx context.Context) (id uuid.UUID, err error) {
	if u.create.driver.Dialect() == dialect.MySQL {
		// In case of "ON CONFLICT", there is no way to get back non-numeric ID
		// fields from the database since MySQL does not support the RETURNING clause.
		return id, errors.New("models: SnapshotUpsertOne.ID is not supported by MySQL driver. Use SnapshotUpsertOne.Exec instead")
	}
	node, err := u.create.Save(ctx)
	if err != nil {
		return id, err
	}
	return node.ID, nil
}

// IDX is like ID, but panics if an error occurs.
func (u *SnapshotUpsertOne) IDX(ctx context.Context) uuid.UUID {
	id, err := u.ID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// SnapshotCreateBulk is the builder for creating many Snapshot entities in bulk.
type SnapshotCreateBulk struct {
	config
	err      error
	builders []*SnapshotCreate
	conflict []sql.ConflictOption
}

// Save creates the Snapshot entities in the database.
func (scb *SnapshotCreateBulk) Save(ctx context.Context) ([]*Snapshot, error) {
	if scb.err != nil {
		return nil, scb.err
	}
	specs := make([]*sqlgraph.CreateSpec, len(scb.builders))
	nodes := make([]*Snapshot, len(scb.builders))
	mutators := make([]Mutator, len(scb.builders))
	for i := range scb.builders {
		func(i int, root context.Context) {
			builder := scb.builders[i]
			builder.defaults()
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*SnapshotMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				var err error
				nodes[i], specs[i] = builder.createSpec()
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, scb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					spec.OnConflict = scb.conflict
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, scb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{msg: err.Error(), wrap: err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, scb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (scb *SnapshotCreateBulk) SaveX(ctx context.Context) []*Snapshot {
	v, err := scb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (scb *SnapshotCreateBulk) Exec(ctx context.Context) error {
	_, err := scb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (scb *SnapshotCreateBulk) ExecX(ctx context.Context) {
	if err := scb.Exec(ctx); err != nil {
		panic(err)
	}
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.Snapshot.CreateBulk(builders...).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.SnapshotUpsert) {
//			SetCreatedAt(v+v).
//		}).
//		Exec(ctx)
func (scb *SnapshotCreateBulk) OnConflict(opts ...sql.ConflictOption) *SnapshotUpsertBulk {
	scb.conflict = opts
	return &SnapshotUpsertBulk{
		create: scb,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.Snapshot.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (scb *SnapshotCreateBulk) OnConflictColumns(columns ...string) *SnapshotUpsertBulk {
	scb.conflict = append(scb.conflict, sql.ConflictColumns(columns...))
	return &SnapshotUpsertBulk{
		create: scb,
	}
}

// SnapshotUpsertBulk is the builder for "upsert"-ing
// a bulk of Snapshot nodes.
type SnapshotUpsertBulk struct {
	create *SnapshotCreateBulk
}

// UpdateNewValues updates the mutable fields using the new values that
// were set on create. Using this option is equivalent to using:
//
//	client.Snapshot.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(snapshot.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *SnapshotUpsertBulk) UpdateNewValues() *SnapshotUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		for _, b := range u.create.builders {
			if _, exists := b.mutation.ID(); exists {
				s.SetIgnore(snapshot.FieldID)
			}
			if _, exists := b.mutation.CreatedAt(); exists {
				s.SetIgnore(snapshot.FieldCreatedAt)
			}
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.Snapshot.Create().
//		OnConflict(sql.ResolveWithIgnore()).
//		Exec(ctx)
func (u *SnapshotUpsertBulk) Ignore() *SnapshotUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *SnapshotUpsertBulk) DoNothing() *SnapshotUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the SnapshotCreateBulk.OnConflict
// documentation for more info.
func (u *SnapshotUpsertBulk) Update(set func(*SnapshotUpsert)) *SnapshotUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&SnapshotUpsert{UpdateSet: update})
	}))
	return u
}

// SetBaseEnvID sets the "base_env_id" field.
func (u *SnapshotUpsertBulk) SetBaseEnvID(v string) *SnapshotUpsertBulk {
	return u.Update(func(s *SnapshotUpsert) {
		s.SetBaseEnvID(v)
	})
}

// UpdateBaseEnvID sets the "base_env_id" field to the value that was provided on create.
func (u *SnapshotUpsertBulk) UpdateBaseEnvID() *SnapshotUpsertBulk {
	return u.Update(func(s *SnapshotUpsert) {
		s.UpdateBaseEnvID()
	})
}

// SetEnvID sets the "env_id" field.
func (u *SnapshotUpsertBulk) SetEnvID(v string) *SnapshotUpsertBulk {
	return u.Update(func(s *SnapshotUpsert) {
		s.SetEnvID(v)
	})
}

// UpdateEnvID sets the "env_id" field to the value that was provided on create.
func (u *SnapshotUpsertBulk) UpdateEnvID() *SnapshotUpsertBulk {
	return u.Update(func(s *SnapshotUpsert) {
		s.UpdateEnvID()
	})
}

// SetSandboxID sets the "sandbox_id" field.
func (u *SnapshotUpsertBulk) SetSandboxID(v string) *SnapshotUpsertBulk {
	return u.Update(func(s *SnapshotUpsert) {
		s.SetSandboxID(v)
	})
}

// UpdateSandboxID sets the "sandbox_id" field to the value that was provided on create.
func (u *SnapshotUpsertBulk) UpdateSandboxID() *SnapshotUpsertBulk {
	return u.Update(func(s *SnapshotUpsert) {
		s.UpdateSandboxID()
	})
}

// SetMetadata sets the "metadata" field.
func (u *SnapshotUpsertBulk) SetMetadata(v map[string]string) *SnapshotUpsertBulk {
	return u.Update(func(s *SnapshotUpsert) {
		s.SetMetadata(v)
	})
}

// UpdateMetadata sets the "metadata" field to the value that was provided on create.
func (u *SnapshotUpsertBulk) UpdateMetadata() *SnapshotUpsertBulk {
	return u.Update(func(s *SnapshotUpsert) {
		s.UpdateMetadata()
	})
}

// Exec executes the query.
func (u *SnapshotUpsertBulk) Exec(ctx context.Context) error {
	if u.create.err != nil {
		return u.create.err
	}
	for i, b := range u.create.builders {
		if len(b.conflict) != 0 {
			return fmt.Errorf("models: OnConflict was set for builder %d. Set it on the SnapshotCreateBulk instead", i)
		}
	}
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for SnapshotCreateBulk.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *SnapshotUpsertBulk) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/snapshot_delete.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/snapshot"
)

// SnapshotDelete is the builder for deleting a Snapshot entity.
type SnapshotDelete struct {
	config
	hooks    []Hook
	mutation *SnapshotMutation
}

// Where appends a list predicates to the SnapshotDelete builder.
func (sd *SnapshotDelete) Where(ps ...predicate.Snapshot) *SnapshotDelete {
	sd.mutation.Where(ps...)
	return sd
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (sd *SnapshotDelete) Exec(ctx context.Context) (int, error) {
	return withHooks(ctx, sd.sqlExec, sd.mutation, sd.hooks)
}

// ExecX is like Exec, but panics if an error occurs.
func (sd *SnapshotDelete) ExecX(ctx context.Context) int {
	n, err := sd.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (sd *SnapshotDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := sqlgraph.NewDeleteSpec(snapshot.Table, sqlgraph.NewFieldSpec(snapshot.FieldID, field.TypeUUID))
	_spec.Node.Schema = sd.schemaConfig.Snapshot
	ctx = internal.NewSchemaConfigContext(ctx, sd.schemaConfig)
	if ps := sd.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	affected, err := sqlgraph.DeleteNodes(ctx, sd.driver, _spec)
	if err != nil && sqlgraph.IsConstraintError(err) {
		err = &ConstraintError{msg: err.Error(), wrap: err}
	}
	sd.mutation.done = true
	return affected, err
}

// SnapshotDeleteOne is the builder for deleting a single Snapshot entity.
type SnapshotDeleteOne struct {
	sd *SnapshotDelete
}

// Where appends a list predicates to the SnapshotDelete builder.
func (sdo *SnapshotDeleteOne) Where(ps ...predicate.Snapshot) *SnapshotDeleteOne {
	sdo.sd.mutation.Where(ps...)
	return sdo
}

// Exec executes the deletion query.
func (sdo *SnapshotDeleteOne) Exec(ctx context.Context) error {
	n, err := sdo.sd.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{snapshot.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (sdo *SnapshotDeleteOne) ExecX(ctx context.Context) {
	if err := sdo.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/snapshot_query.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"fmt"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/snapshot"
	"github.com/google/uuid"
)

// SnapshotQuery is the builder for querying Snapshot entities.
type SnapshotQuery struct {
	config
	ctx        *QueryContext
	order      []snapshot.OrderOption
	inters     []Interceptor
	predicates []predicate.Snapshot
	withEnv    *EnvQuery
	modifiers  []func(*sql.Selector)
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the SnapshotQuery builder.
func (sq *SnapshotQuery) Where(ps ...predicate.Snapshot) *SnapshotQuery {
	sq.predicates = append(sq.predicates, ps...)
	return sq
}

// Limit the number of records to be returned by this query.
func (sq *SnapshotQuery) Limit(limit int) *SnapshotQuery {
	sq.ctx.Limit = &limit
	return sq
}

// Offset to start from.
func (sq *SnapshotQuery) Offset(offset int) *SnapshotQuery {
	sq.ctx.Offset = &offset
	return sq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (sq *SnapshotQuery) Unique(unique bool) *SnapshotQuery {
	sq.ctx.Unique = &unique
	return sq
}

// Order specifies how the records should be ordered.
func (sq *SnapshotQuery) Order(o ...snapshot.OrderOption) *SnapshotQuery {
	sq.order = append(sq.order, o...)
	return sq
}

// QueryEnv chains the current query on the "env" edge.
func (sq *SnapshotQuery) QueryEnv() *EnvQuery {
	query := (&EnvClient{config: sq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := sq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := sq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(snapshot.Table, snapshot.FieldID, selector),
			sqlgraph.To(env.Table, env.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, snapshot.EnvTable, snapshot.EnvColumn),
		)
		schemaConfig := sq.schemaConfig
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.Snapshot
		fromU = sqlgraph.SetNeighbors(sq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first Snapshot entity from the query.
// Returns a *NotFoundError when no Snapshot was found.
func (sq *SnapshotQuery) First(ctx context.Context) (*Snapshot, error) {
	nodes, err := sq.Limit(1).All(setContextOp(ctx, sq.ctx, "First"))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{snapshot.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (sq *SnapshotQuery) FirstX(ctx context.Context) *Snapshot {
	node, err := sq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first Snapshot ID from the query.
// Returns a *NotFoundError when no Snapshot ID was found.
func (sq *SnapshotQuery) FirstID(ctx context.Context) (id uuid.UUID, err error) {
	var ids []uuid.UUID
	if ids, err = sq.Limit(1).IDs(setContextOp(ctx, sq.ctx, "FirstID")); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{snapshot.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (sq *SnapshotQuery) FirstIDX(ctx context.Context) uuid.UUID {
	id, err := sq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single Snapshot entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one Snapshot entity is found.
// Returns a *NotFoundError when no Snapshot entities are found.
func (sq *SnapshotQuery) Only(ctx context.Context) (*Snapshot, error) {
	nodes, err := sq.Limit(2).All(setContextOp(ctx, sq.ctx, "Only"))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{snapshot.Label}
	default:
		return nil, &NotSingularError{snapshot.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (sq *SnapshotQuery) OnlyX(ctx context.Context) *Snapshot {
	node, err := sq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only Snapshot ID in the query.
// Returns a *NotSingularError when more than one Snapshot ID is found.
// Returns a *NotFoundError when no entities are found.
func (sq *SnapshotQuery) OnlyID(ctx context.Context) (id uuid.UUID, err error) {
	var ids []uuid.UUID
	if ids, err = sq.Limit(2).IDs(setContextOp(ctx, sq.ctx, "OnlyID")); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{snapshot.Label}
	default:
		err = &NotSingularError{snapshot.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (sq *SnapshotQuery) OnlyIDX(ctx context.Context) uuid.UUID {
	id, err := sq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of Snapshots.
func (sq *SnapshotQuery) All(ctx context.Context) ([]*Snapshot, error) {
	ctx = setContextOp(ctx, sq.ctx, "All")
	if err := sq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*Snapshot, *SnapshotQuery]()
	return withInterceptors[[]*Snapshot](ctx, sq, qr, sq.inters)
}

// AllX is like All, but panics if an error occurs.
func (sq *SnapshotQuery) AllX(ctx context.Context) []*Snapshot {
	nodes, err := sq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of Snapshot IDs.
func (sq *SnapshotQuery) IDs(ctx context.Context) (ids []uuid.UUID, err error) {
	if sq.ctx.Unique == nil && sq.path != nil {
		sq.Unique(true)
	}
	ctx = setContextOp(ctx, sq.ctx, "IDs")
	if err = sq.Select(snapshot.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (sq *SnapshotQuery) IDsX(ctx context.Context) []uuid.UUID {
	ids, err := sq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (sq *SnapshotQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, sq.ctx, "Count")
	if err := sq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, sq, querierCount[*SnapshotQuery](), sq.inters)
}

// CountX is like Count, but panics if an error occurs.
func (sq *SnapshotQuery) CountX(ctx context.Context) int {
	count, err := sq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (sq *SnapshotQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, sq.ctx, "Exist")
	switch _, err := sq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("models: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (sq *SnapshotQuery) ExistX(ctx context.Context) bool {
	exist, err := sq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the SnapshotQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (sq *SnapshotQuery) Clone() *SnapshotQuery {
	if sq == nil {
		return nil
	}
	return &SnapshotQuery{
		config:     sq.config,
		ctx:        sq.ctx.Clone(),
		order:      append([]snapshot.OrderOption{}, sq.order...),
		inters:     append([]Interceptor{}, sq.inters...),
		predicates: append([]predicate.Snapshot{}, sq.predicates...),
		withEnv:    sq.withEnv.Clone(),
		// clone intermediate query.
		sql:  sq.sql.Clone(),
		path: sq.path,
	}
}

// WithEnv tells the query-builder to eager-load the nodes that are connected to
// the "env" edge. The optional arguments are used to configure the query builder of the edge.
func (sq *SnapshotQuery) WithEnv(opts ...func(*EnvQuery)) *SnapshotQuery {
	query := (&EnvClient{config: sq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	sq.withEnv = query
	return sq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		CreatedAt time.Time `json:"created_at,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.Snapshot.Query().
//		GroupBy(snapshot.FieldCreatedAt).
//		Aggregate(models.Count()).
//		Scan(ctx, &v)
func (sq *SnapshotQuery) GroupBy(field string, fields ...string) *SnapshotGroupBy {
	sq.ctx.Fields = append([]string{field}, fields...)
	grbuild := &SnapshotGroupBy{build: sq}
	grbuild.flds = &sq.ctx.Fields
	grbuild.label = snapshot.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		CreatedAt time.Time `json:"created_at,omitempty"`
//	}
//
//	client.Snapshot.Query().
//		Select(snapshot.FieldCreatedAt).
//		Scan(ctx, &v)
func (sq *SnapshotQuery) Select(fields ...string) *SnapshotSelect {
	sq.ctx.Fields = append(sq.ctx.Fields, fields...)
	sbuild := &SnapshotSelect{SnapshotQuery: sq}
	sbuild.label = snapshot.Label
	sbuild.flds, sbuild.scan = &sq.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a SnapshotSelect configured with the given aggregations.
func (sq *SnapshotQuery) Aggregate(fns ...AggregateFunc) *SnapshotSelect {
	return sq.Select().Aggregate(fns...)
}

func (sq *SnapshotQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range sq.inters {
		if inter == nil {
			return fmt.Errorf("models: uninitialized interceptor (forgotten import models/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, sq); err != nil {
				return err
			}
		}
	}
	for _, f := range sq.ctx.Fields {
		if !snapshot.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
		}
	}
	if sq.path != nil {
		prev, err := sq.path(ctx)
		if err != nil {
			return err
		}
		sq.sql = prev
	}
	return nil
}

func (sq *SnapshotQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*Snapshot, error) {
	var (
		nodes       = []*Snapshot{}
		_spec       = sq.querySpec()
		loadedTypes = [1]bool{
			sq.withEnv != nil,
		}
	)
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*Snapshot).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &Snapshot{config: sq.config}
		nodes = append(nodes, node)
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	_spec.Node.Schema = sq.schemaConfig.Snapshot
	ctx = internal.NewSchemaConfigContext(ctx, sq.schemaConfig)
	if len(sq.modifiers) > 0 {
		_spec.Modifiers = sq.modifiers
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, sq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	if query := sq.withEnv; query != nil {
		if err := sq.loadEnv(ctx, query, nodes, nil,
			func(n *Snapshot, e *Env) { n.Edges.Env = e }); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

func (sq *SnapshotQuery) loadEnv(ctx context.Context, query *EnvQuery, nodes []*Snapshot, init func(*Snapshot), assign func(*Snapshot, *Env)) error {
	ids := make([]string, 0, len(nodes))
	nodeids := make(map[string][]*Snapshot)
	for i := range nodes {
		fk := nodes[i].EnvID
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(env.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "env_id" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}

func (sq *SnapshotQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := sq.querySpec()
	_spec.Node.Schema = sq.schemaConfig.Snapshot
	ctx = internal.NewSchemaConfigContext(ctx, sq.schemaConfig)
	if len(sq.modifiers) > 0 {
		_spec.Modifiers = sq.modifiers
	}
	_spec.Node.Columns = sq.ctx.Fields
	if len(sq.ctx.Fields) > 0 {
		_spec.Unique = sq.ctx.Unique != nil && *sq.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, sq.driver, _spec)
}

func (sq *SnapshotQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(snapshot.Table, snapshot.Columns, sqlgraph.NewFieldSpec(snapshot.FieldID, field.TypeUUID))
	_spec.From = sq.sql
	if unique := sq.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if sq.path != nil {
		_spec.Unique = true
	}
	if fields := sq.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, snapshot.FieldID)
		for i := range fields {
			if fields[i] != snapshot.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
		if sq.withEnv != nil {
			_spec.Node.AddColumnOnce(snapshot.FieldEnvID)
		}
	}
	if ps := sq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := sq.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := sq.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := sq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (sq *SnapshotQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(sq.driver.Dialect())
	t1 := builder.Table(snapshot.Table)
	columns := sq.ctx.Fields
	if len(columns) == 0 {
		columns = snapshot.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if sq.sql != nil {
		selector = sq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if sq.ctx.Unique != nil && *sq.ctx.Unique {
		selector.Distinct()
	}
	t1.Schema(sq.schemaConfig.Snapshot)
	ctx = internal.NewSchemaConfigContext(ctx, sq.schemaConfig)
	selector.WithContext(ctx)
	for _, m := range sq.modifiers {
		m(selector)
	}
	for _, p := range sq.predicates {
		p(selector)
	}
	for _, p := range sq.order {
		p(selector)
	}
	if offset := sq.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := sq.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// Modify adds a query modifier for attaching custom logic to queries.
func (sq *SnapshotQuery) Modify(modifiers ...func(s *sql.Selector)) *SnapshotSelect {
	sq.modifiers = append(sq.modifiers, modifiers...)
	return sq.Select()
}

// SnapshotGroupBy is the group-by builder for Snapshot entities.
type SnapshotGroupBy struct {
	selector
	build *SnapshotQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (sgb *SnapshotGroupBy) Aggregate(fns ...AggregateFunc) *SnapshotGroupBy {
	sgb.fns = append(sgb.fns, fns...)
	return sgb
}

// Scan applies the selector query and scans the result into the given value.
func (sgb *SnapshotGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, sgb.build.ctx, "GroupBy")
	if err := sgb.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*SnapshotQuery, *SnapshotGroupBy](ctx, sgb.build, sgb, sgb.build.inters, v)
}

func (sgb *SnapshotGroupBy) sqlScan(ctx context.Context, root *SnapshotQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(sgb.fns))
	for _, fn := range sgb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*sgb.flds)+len(sgb.fns))
		for _, f := range *sgb.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*sgb.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := sgb.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// SnapshotSelect is the builder for selecting fields of Snapshot entities.
type SnapshotSelect struct {
	*SnapshotQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (ss *SnapshotSelect) Aggregate(fns ...AggregateFunc) *SnapshotSelect {
	ss.fns = append(ss.fns, fns...)
	return ss
}

// Scan applies the selector query and scans the result into the given value.
func (ss *SnapshotSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, ss.ctx, "Select")
	if err := ss.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*SnapshotQuery, *SnapshotSelect](ctx, ss.SnapshotQuery, ss, ss.inters, v)
}

func (ss *SnapshotSelect) sqlScan(ctx context.Context, root *SnapshotQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(ss.fns))
	for _, fn := range ss.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*ss.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := ss.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// Modify adds a query modifier for attaching custom logic to queries.
func (ss *SnapshotSelect) Modify(modifiers ...func(s *sql.Selector)) *SnapshotSelect {
	ss.modifiers = append(ss.modifiers, modifiers...)
	return ss
}



================================================
File: models/snapshot_update.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/snapshot"
)

// SnapshotUpdate is the builder for updating Snapshot entities.
type SnapshotUpdate struct {
	config
	hooks     []Hook
	mutation  *SnapshotMutation
	modifiers []func(*sql.UpdateBuilder)
}

// Where appends a list predicates to the SnapshotUpdate builder.
func (su *SnapshotUpdate) Where(ps ...predicate.Snapshot) *SnapshotUpdate {
	su.mutation.Where(ps...)
	return su
}

// SetBaseEnvID sets the "base_env_id" field.
func (su *SnapshotUpdate) SetBaseEnvID(s string) *SnapshotUpdate {
	su.mutation.SetBaseEnvID(s)
	return su
}

// SetNillableBaseEnvID sets the "base_env_id" field if the given value is not nil.
func (su *SnapshotUpdate) SetNillableBaseEnvID(s *string) *SnapshotUpdate {
	if s != nil {
		su.SetBaseEnvID(*s)
	}
	return su
}

// SetEnvID sets the "env_id" field.
func (su *SnapshotUpdate) SetEnvID(s string) *SnapshotUpdate {
	su.mutation.SetEnvID(s)
	return su
}

// SetNillableEnvID sets the "env_id" field if the given value is not nil.
func (su *SnapshotUpdate) SetNillableEnvID(s *string) *SnapshotUpdate {
	if s != nil {
		su.SetEnvID(*s)
	}
	return su
}

// SetSandboxID sets the "sandbox_id" field.
func (su *SnapshotUpdate) SetSandboxID(s string) *SnapshotUpdate {
	su.mutation.SetSandboxID(s)
	return su
}

// SetNillableSandboxID sets the "sandbox_id" field if the given value is not nil.
func (su *SnapshotUpdate) SetNillableSandboxID(s *string) *SnapshotUpdate {
	if s != nil {
		su.SetSandboxID(*s)
	}
	return su
}

// SetMetadata sets the "metadata" field.
func (su *SnapshotUpdate) SetMetadata(m map[string]string) *SnapshotUpdate {
	su.mutation.SetMetadata(m)
	return su
}

// SetEnv sets the "env" edge to the Env entity.
func (su *SnapshotUpdate) SetEnv(e *Env) *SnapshotUpdate {
	return su.SetEnvID(e.ID)
}

// Mutation returns the SnapshotMutation object of the builder.
func (su *SnapshotUpdate) Mutation() *SnapshotMutation {
	return su.mutation
}

// ClearEnv clears the "env" edge to the Env entity.
func (su *SnapshotUpdate) ClearEnv() *SnapshotUpdate {
	su.mutation.ClearEnv()
	return su
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (su *SnapshotUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, su.sqlSave, su.mutation, su.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (su *SnapshotUpdate) SaveX(ctx context.Context) int {
	affected, err := su.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (su *SnapshotUpdate) Exec(ctx context.Context) error {
	_, err := su.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (su *SnapshotUpdate) ExecX(ctx context.Context) {
	if err := su.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (su *SnapshotUpdate) check() error {
	if _, ok := su.mutation.EnvID(); su.mutation.EnvCleared() && !ok {
		return errors.New(`models: clearing a required unique edge "Snapshot.env"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (su *SnapshotUpdate) Modify(modifiers ...func(u *sql.UpdateBuilder)) *SnapshotUpdate {
	su.modifiers = append(su.modifiers, modifiers...)
	return su
}

func (su *SnapshotUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := su.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(snapshot.Table, snapshot.Columns, sqlgraph.NewFieldSpec(snapshot.FieldID, field.TypeUUID))
	if ps := su.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := su.mutation.BaseEnvID(); ok {
		_spec.SetField(snapshot.FieldBaseEnvID, field.TypeString, value)
	}
	if value, ok := su.mutation.SandboxID(); ok {
		_spec.SetField(snapshot.FieldSandboxID, field.TypeString, value)
	}
	if value, ok := su.mutation.Metadata(); ok {
		_spec.SetField(snapshot.FieldMetadata, field.TypeJSON, value)
	}
	if su.mutation.EnvCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   snapshot.EnvTable,
			Columns: []string{snapshot.EnvColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = su.schemaConfig.Snapshot
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := su.mutation.EnvIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   snapshot.EnvTable,
			Columns: []string{snapshot.EnvColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = su.schemaConfig.Snapshot
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = su.schemaConfig.Snapshot
	ctx = internal.NewSchemaConfigContext(ctx, su.schemaConfig)
	_spec.AddModifiers(su.modifiers...)
	if n, err = sqlgraph.UpdateNodes(ctx, su.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{snapshot.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	su.mutation.done = true
	return n, nil
}

// SnapshotUpdateOne is the builder for updating a single Snapshot entity.
type SnapshotUpdateOne struct {
	config
	fields    []string
	hooks     []Hook
	mutation  *SnapshotMutation
	modifiers []func(*sql.UpdateBuilder)
}

// SetBaseEnvID sets the "base_env_id" field.
func (suo *SnapshotUpdateOne) SetBaseEnvID(s string) *SnapshotUpdateOne {
	suo.mutation.SetBaseEnvID(s)
	return suo
}

// SetNillableBaseEnvID sets the "base_env_id" field if the given value is not nil.
func (suo *SnapshotUpdateOne) SetNillableBaseEnvID(s *string) *SnapshotUpdateOne {
	if s != nil {
		suo.SetBaseEnvID(*s)
	}
	return suo
}

// SetEnvID sets the "env_id" field.
func (suo *SnapshotUpdateOne) SetEnvID(s string) *SnapshotUpdateOne {
	suo.mutation.SetEnvID(s)
	return suo
}

// SetNillableEnvID sets the "env_id" field if the given value is not nil.
func (suo *SnapshotUpdateOne) SetNillableEnvID(s *string) *SnapshotUpdateOne {
	if s != nil {
		suo.SetEnvID(*s)
	}
	return suo
}

// SetSandboxID sets the "sandbox_id" field.
func (suo *SnapshotUpdateOne) SetSandboxID(s string) *SnapshotUpdateOne {
	suo.mutation.SetSandboxID(s)
	return suo
}

// SetNillableSandboxID sets the "sandbox_id" field if the given value is not nil.
func (suo *SnapshotUpdateOne) SetNillableSandboxID(s *string) *SnapshotUpdateOne {
	if s != nil {
		suo.SetSandboxID(*s)
	}
	return suo
}

// SetMetadata sets the "metadata" field.
func (suo *SnapshotUpdateOne) SetMetadata(m map[string]string) *SnapshotUpdateOne {
	suo.mutation.SetMetadata(m)
	return suo
}

// SetEnv sets the "env" edge to the Env entity.
func (suo *SnapshotUpdateOne) SetEnv(e *Env) *SnapshotUpdateOne {
	return suo.SetEnvID(e.ID)
}

// Mutation returns the SnapshotMutation object of the builder.
func (suo *SnapshotUpdateOne) Mutation() *SnapshotMutation {
	return suo.mutation
}

// ClearEnv clears the "env" edge to the Env entity.
func (suo *SnapshotUpdateOne) ClearEnv() *SnapshotUpdateOne {
	suo.mutation.ClearEnv()
	return suo
}

// Where appends a list predicates to the SnapshotUpdate builder.
func (suo *SnapshotUpdateOne) Where(ps ...predicate.Snapshot) *SnapshotUpdateOne {
	suo.mutation.Where(ps...)
	return suo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (suo *SnapshotUpdateOne) Select(field string, fields ...string) *SnapshotUpdateOne {
	suo.fields = append([]string{field}, fields...)
	return suo
}

// Save executes the query and returns the updated Snapshot entity.
func (suo *SnapshotUpdateOne) Save(ctx context.Context) (*Snapshot, error) {
	return withHooks(ctx, suo.sqlSave, suo.mutation, suo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (suo *SnapshotUpdateOne) SaveX(ctx context.Context) *Snapshot {
	node, err := suo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (suo *SnapshotUpdateOne) Exec(ctx context.Context) error {
	_, err := suo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (suo *SnapshotUpdateOne) ExecX(ctx context.Context) {
	if err := suo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (suo *SnapshotUpdateOne) check() error {
	if _, ok := suo.mutation.EnvID(); suo.mutation.EnvCleared() && !ok {
		return errors.New(`models: clearing a required unique edge "Snapshot.env"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (suo *SnapshotUpdateOne) Modify(modifiers ...func(u *sql.UpdateBuilder)) *SnapshotUpdateOne {
	suo.modifiers = append(suo.modifiers, modifiers...)
	return suo
}

func (suo *SnapshotUpdateOne) sqlSave(ctx context.Context) (_node *Snapshot, err error) {
	if err := suo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(snapshot.Table, snapshot.Columns, sqlgraph.NewFieldSpec(snapshot.FieldID, field.TypeUUID))
	id, ok := suo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`models: missing "Snapshot.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := suo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, snapshot.FieldID)
		for _, f := range fields {
			if !snapshot.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
			}
			if f != snapshot.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := suo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := suo.mutation.BaseEnvID(); ok {
		_spec.SetField(snapshot.FieldBaseEnvID, field.TypeString, value)
	}
	if value, ok := suo.mutation.SandboxID(); ok {
		_spec.SetField(snapshot.FieldSandboxID, field.TypeString, value)
	}
	if value, ok := suo.mutation.Metadata(); ok {
		_spec.SetField(snapshot.FieldMetadata, field.TypeJSON, value)
	}
	if suo.mutation.EnvCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   snapshot.EnvTable,
			Columns: []string{snapshot.EnvColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = suo.schemaConfig.Snapshot
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := suo.mutation.EnvIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   snapshot.EnvTable,
			Columns: []string{snapshot.EnvColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = suo.schemaConfig.Snapshot
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = suo.schemaConfig.Snapshot
	ctx = internal.NewSchemaConfigContext(ctx, suo.schemaConfig)
	_spec.AddModifiers(suo.modifiers...)
	_node = &Snapshot{config: suo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, suo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{snapshot.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	suo.mutation.done = true
	return _node, nil
}



================================================
File: models/team.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/tier"
	"github.com/google/uuid"
)

// Team is the model entity for the Team schema.
type Team struct {
	config `json:"-"`
	// ID of the ent.
	ID uuid.UUID `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// IsBanned holds the value of the "is_banned" field.
	IsBanned bool `json:"is_banned,omitempty"`
	// IsBlocked holds the value of the "is_blocked" field.
	IsBlocked bool `json:"is_blocked,omitempty"`
	// BlockedReason holds the value of the "blocked_reason" field.
	BlockedReason *string `json:"blocked_reason,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Tier holds the value of the "tier" field.
	Tier string `json:"tier,omitempty"`
	// Email holds the value of the "email" field.
	Email string `json:"email,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the TeamQuery when eager-loading is set.
	Edges        TeamEdges `json:"edges"`
	selectValues sql.SelectValues
}

// TeamEdges holds the relations/edges for other nodes in the graph.
type TeamEdges struct {
	// Users holds the value of the users edge.
	Users []*User `json:"users,omitempty"`
	// TeamAPIKeys holds the value of the team_api_keys edge.
	TeamAPIKeys []*TeamAPIKey `json:"team_api_keys,omitempty"`
	// TeamTier holds the value of the team_tier edge.
	TeamTier *Tier `json:"team_tier,omitempty"`
	// Envs holds the value of the envs edge.
	Envs []*Env `json:"envs,omitempty"`
	// UsersTeams holds the value of the users_teams edge.
	UsersTeams []*UsersTeams `json:"users_teams,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [5]bool
}

// UsersOrErr returns the Users value or an error if the edge
// was not loaded in eager-loading.
func (e TeamEdges) UsersOrErr() ([]*User, error) {
	if e.loadedTypes[0] {
		return e.Users, nil
	}
	return nil, &NotLoadedError{edge: "users"}
}

// TeamAPIKeysOrErr returns the TeamAPIKeys value or an error if the edge
// was not loaded in eager-loading.
func (e TeamEdges) TeamAPIKeysOrErr() ([]*TeamAPIKey, error) {
	if e.loadedTypes[1] {
		return e.TeamAPIKeys, nil
	}
	return nil, &NotLoadedError{edge: "team_api_keys"}
}

// TeamTierOrErr returns the TeamTier value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e TeamEdges) TeamTierOrErr() (*Tier, error) {
	if e.loadedTypes[2] {
		if e.TeamTier == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: tier.Label}
		}
		return e.TeamTier, nil
	}
	return nil, &NotLoadedError{edge: "team_tier"}
}

// EnvsOrErr returns the Envs value or an error if the edge
// was not loaded in eager-loading.
func (e TeamEdges) EnvsOrErr() ([]*Env, error) {
	if e.loadedTypes[3] {
		return e.Envs, nil
	}
	return nil, &NotLoadedError{edge: "envs"}
}

// UsersTeamsOrErr returns the UsersTeams value or an error if the edge
// was not loaded in eager-loading.
func (e TeamEdges) UsersTeamsOrErr() ([]*UsersTeams, error) {
	if e.loadedTypes[4] {
		return e.UsersTeams, nil
	}
	return nil, &NotLoadedError{edge: "users_teams"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Team) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case team.FieldIsBanned, team.FieldIsBlocked:
			values[i] = new(sql.NullBool)
		case team.FieldBlockedReason, team.FieldName, team.FieldTier, team.FieldEmail:
			values[i] = new(sql.NullString)
		case team.FieldCreatedAt:
			values[i] = new(sql.NullTime)
		case team.FieldID:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Team fields.
func (t *Team) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case team.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				t.ID = *value
			}
		case team.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				t.CreatedAt = value.Time
			}
		case team.FieldIsBanned:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_banned", values[i])
			} else if value.Valid {
				t.IsBanned = value.Bool
			}
		case team.FieldIsBlocked:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_blocked", values[i])
			} else if value.Valid {
				t.IsBlocked = value.Bool
			}
		case team.FieldBlockedReason:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field blocked_reason", values[i])
			} else if value.Valid {
				t.BlockedReason = new(string)
				*t.BlockedReason = value.String
			}
		case team.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				t.Name = value.String
			}
		case team.FieldTier:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field tier", values[i])
			} else if value.Valid {
				t.Tier = value.String
			}
		case team.FieldEmail:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field email", values[i])
			} else if value.Valid {
				t.Email = value.String
			}
		default:
			t.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Team.
// This includes values selected through modifiers, order, etc.
func (t *Team) Value(name string) (ent.Value, error) {
	return t.selectValues.Get(name)
}

// QueryUsers queries the "users" edge of the Team entity.
func (t *Team) QueryUsers() *UserQuery {
	return NewTeamClient(t.config).QueryUsers(t)
}

// QueryTeamAPIKeys queries the "team_api_keys" edge of the Team entity.
func (t *Team) QueryTeamAPIKeys() *TeamAPIKeyQuery {
	return NewTeamClient(t.config).QueryTeamAPIKeys(t)
}

// QueryTeamTier queries the "team_tier" edge of the Team entity.
func (t *Team) QueryTeamTier() *TierQuery {
	return NewTeamClient(t.config).QueryTeamTier(t)
}

// QueryEnvs queries the "envs" edge of the Team entity.
func (t *Team) QueryEnvs() *EnvQuery {
	return NewTeamClient(t.config).QueryEnvs(t)
}

// QueryUsersTeams queries the "users_teams" edge of the Team entity.
func (t *Team) QueryUsersTeams() *UsersTeamsQuery {
	return NewTeamClient(t.config).QueryUsersTeams(t)
}

// Update returns a builder for updating this Team.
// Note that you need to call Team.Unwrap() before calling this method if this Team
// was returned from a transaction, and the transaction was committed or rolled back.
func (t *Team) Update() *TeamUpdateOne {
	return NewTeamClient(t.config).UpdateOne(t)
}

// Unwrap unwraps the Team entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (t *Team) Unwrap() *Team {
	_tx, ok := t.config.driver.(*txDriver)
	if !ok {
		panic("models: Team is not a transactional entity")
	}
	t.config.driver = _tx.drv
	return t
}

// String implements the fmt.Stringer.
func (t *Team) String() string {
	var builder strings.Builder
	builder.WriteString("Team(")
	builder.WriteString(fmt.Sprintf("id=%v, ", t.ID))
	builder.WriteString("created_at=")
	builder.WriteString(t.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("is_banned=")
	builder.WriteString(fmt.Sprintf("%v", t.IsBanned))
	builder.WriteString(", ")
	builder.WriteString("is_blocked=")
	builder.WriteString(fmt.Sprintf("%v", t.IsBlocked))
	builder.WriteString(", ")
	if v := t.BlockedReason; v != nil {
		builder.WriteString("blocked_reason=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("name=")
	builder.WriteString(t.Name)
	builder.WriteString(", ")
	builder.WriteString("tier=")
	builder.WriteString(t.Tier)
	builder.WriteString(", ")
	builder.WriteString("email=")
	builder.WriteString(t.Email)
	builder.WriteByte(')')
	return builder.String()
}

// Teams is a parsable slice of Team.
type Teams []*Team



================================================
File: models/team_create.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/teamapikey"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/tier"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"
	"github.com/google/uuid"
)

// TeamCreate is the builder for creating a Team entity.
type TeamCreate struct {
	config
	mutation *TeamMutation
	hooks    []Hook
	conflict []sql.ConflictOption
}

// SetCreatedAt sets the "created_at" field.
func (tc *TeamCreate) SetCreatedAt(t time.Time) *TeamCreate {
	tc.mutation.SetCreatedAt(t)
	return tc
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (tc *TeamCreate) SetNillableCreatedAt(t *time.Time) *TeamCreate {
	if t != nil {
		tc.SetCreatedAt(*t)
	}
	return tc
}

// SetIsBanned sets the "is_banned" field.
func (tc *TeamCreate) SetIsBanned(b bool) *TeamCreate {
	tc.mutation.SetIsBanned(b)
	return tc
}

// SetNillableIsBanned sets the "is_banned" field if the given value is not nil.
func (tc *TeamCreate) SetNillableIsBanned(b *bool) *TeamCreate {
	if b != nil {
		tc.SetIsBanned(*b)
	}
	return tc
}

// SetIsBlocked sets the "is_blocked" field.
func (tc *TeamCreate) SetIsBlocked(b bool) *TeamCreate {
	tc.mutation.SetIsBlocked(b)
	return tc
}

// SetNillableIsBlocked sets the "is_blocked" field if the given value is not nil.
func (tc *TeamCreate) SetNillableIsBlocked(b *bool) *TeamCreate {
	if b != nil {
		tc.SetIsBlocked(*b)
	}
	return tc
}

// SetBlockedReason sets the "blocked_reason" field.
func (tc *TeamCreate) SetBlockedReason(s string) *TeamCreate {
	tc.mutation.SetBlockedReason(s)
	return tc
}

// SetNillableBlockedReason sets the "blocked_reason" field if the given value is not nil.
func (tc *TeamCreate) SetNillableBlockedReason(s *string) *TeamCreate {
	if s != nil {
		tc.SetBlockedReason(*s)
	}
	return tc
}

// SetName sets the "name" field.
func (tc *TeamCreate) SetName(s string) *TeamCreate {
	tc.mutation.SetName(s)
	return tc
}

// SetTier sets the "tier" field.
func (tc *TeamCreate) SetTier(s string) *TeamCreate {
	tc.mutation.SetTier(s)
	return tc
}

// SetEmail sets the "email" field.
func (tc *TeamCreate) SetEmail(s string) *TeamCreate {
	tc.mutation.SetEmail(s)
	return tc
}

// SetID sets the "id" field.
func (tc *TeamCreate) SetID(u uuid.UUID) *TeamCreate {
	tc.mutation.SetID(u)
	return tc
}

// AddUserIDs adds the "users" edge to the User entity by IDs.
func (tc *TeamCreate) AddUserIDs(ids ...uuid.UUID) *TeamCreate {
	tc.mutation.AddUserIDs(ids...)
	return tc
}

// AddUsers adds the "users" edges to the User entity.
func (tc *TeamCreate) AddUsers(u ...*User) *TeamCreate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return tc.AddUserIDs(ids...)
}

// AddTeamAPIKeyIDs adds the "team_api_keys" edge to the TeamAPIKey entity by IDs.
func (tc *TeamCreate) AddTeamAPIKeyIDs(ids ...uuid.UUID) *TeamCreate {
	tc.mutation.AddTeamAPIKeyIDs(ids...)
	return tc
}

// AddTeamAPIKeys adds the "team_api_keys" edges to the TeamAPIKey entity.
func (tc *TeamCreate) AddTeamAPIKeys(t ...*TeamAPIKey) *TeamCreate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tc.AddTeamAPIKeyIDs(ids...)
}

// SetTeamTierID sets the "team_tier" edge to the Tier entity by ID.
func (tc *TeamCreate) SetTeamTierID(id string) *TeamCreate {
	tc.mutation.SetTeamTierID(id)
	return tc
}

// SetTeamTier sets the "team_tier" edge to the Tier entity.
func (tc *TeamCreate) SetTeamTier(t *Tier) *TeamCreate {
	return tc.SetTeamTierID(t.ID)
}

// AddEnvIDs adds the "envs" edge to the Env entity by IDs.
func (tc *TeamCreate) AddEnvIDs(ids ...string) *TeamCreate {
	tc.mutation.AddEnvIDs(ids...)
	return tc
}

// AddEnvs adds the "envs" edges to the Env entity.
func (tc *TeamCreate) AddEnvs(e ...*Env) *TeamCreate {
	ids := make([]string, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return tc.AddEnvIDs(ids...)
}

// AddUsersTeamIDs adds the "users_teams" edge to the UsersTeams entity by IDs.
func (tc *TeamCreate) AddUsersTeamIDs(ids ...int) *TeamCreate {
	tc.mutation.AddUsersTeamIDs(ids...)
	return tc
}

// AddUsersTeams adds the "users_teams" edges to the UsersTeams entity.
func (tc *TeamCreate) AddUsersTeams(u ...*UsersTeams) *TeamCreate {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return tc.AddUsersTeamIDs(ids...)
}

// Mutation returns the TeamMutation object of the builder.
func (tc *TeamCreate) Mutation() *TeamMutation {
	return tc.mutation
}

// Save creates the Team in the database.
func (tc *TeamCreate) Save(ctx context.Context) (*Team, error) {
	tc.defaults()
	return withHooks(ctx, tc.sqlSave, tc.mutation, tc.hooks)
}

// SaveX calls Save and panics if Save returns an error.
func (tc *TeamCreate) SaveX(ctx context.Context) *Team {
	v, err := tc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (tc *TeamCreate) Exec(ctx context.Context) error {
	_, err := tc.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (tc *TeamCreate) ExecX(ctx context.Context) {
	if err := tc.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (tc *TeamCreate) defaults() {
	if _, ok := tc.mutation.CreatedAt(); !ok {
		v := team.DefaultCreatedAt()
		tc.mutation.SetCreatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (tc *TeamCreate) check() error {
	if _, ok := tc.mutation.CreatedAt(); !ok {
		return &ValidationError{Name: "created_at", err: errors.New(`models: missing required field "Team.created_at"`)}
	}
	if _, ok := tc.mutation.Name(); !ok {
		return &ValidationError{Name: "name", err: errors.New(`models: missing required field "Team.name"`)}
	}
	if _, ok := tc.mutation.Tier(); !ok {
		return &ValidationError{Name: "tier", err: errors.New(`models: missing required field "Team.tier"`)}
	}
	if _, ok := tc.mutation.Email(); !ok {
		return &ValidationError{Name: "email", err: errors.New(`models: missing required field "Team.email"`)}
	}
	if v, ok := tc.mutation.Email(); ok {
		if err := team.EmailValidator(v); err != nil {
			return &ValidationError{Name: "email", err: fmt.Errorf(`models: validator failed for field "Team.email": %w`, err)}
		}
	}
	if _, ok := tc.mutation.TeamTierID(); !ok {
		return &ValidationError{Name: "team_tier", err: errors.New(`models: missing required edge "Team.team_tier"`)}
	}
	return nil
}

func (tc *TeamCreate) sqlSave(ctx context.Context) (*Team, error) {
	if err := tc.check(); err != nil {
		return nil, err
	}
	_node, _spec := tc.createSpec()
	if err := sqlgraph.CreateNode(ctx, tc.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	if _spec.ID.Value != nil {
		if id, ok := _spec.ID.Value.(*uuid.UUID); ok {
			_node.ID = *id
		} else if err := _node.ID.Scan(_spec.ID.Value); err != nil {
			return nil, err
		}
	}
	tc.mutation.id = &_node.ID
	tc.mutation.done = true
	return _node, nil
}

func (tc *TeamCreate) createSpec() (*Team, *sqlgraph.CreateSpec) {
	var (
		_node = &Team{config: tc.config}
		_spec = sqlgraph.NewCreateSpec(team.Table, sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID))
	)
	_spec.Schema = tc.schemaConfig.Team
	_spec.OnConflict = tc.conflict
	if id, ok := tc.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = &id
	}
	if value, ok := tc.mutation.CreatedAt(); ok {
		_spec.SetField(team.FieldCreatedAt, field.TypeTime, value)
		_node.CreatedAt = value
	}
	if value, ok := tc.mutation.IsBanned(); ok {
		_spec.SetField(team.FieldIsBanned, field.TypeBool, value)
		_node.IsBanned = value
	}
	if value, ok := tc.mutation.IsBlocked(); ok {
		_spec.SetField(team.FieldIsBlocked, field.TypeBool, value)
		_node.IsBlocked = value
	}
	if value, ok := tc.mutation.BlockedReason(); ok {
		_spec.SetField(team.FieldBlockedReason, field.TypeString, value)
		_node.BlockedReason = &value
	}
	if value, ok := tc.mutation.Name(); ok {
		_spec.SetField(team.FieldName, field.TypeString, value)
		_node.Name = value
	}
	if value, ok := tc.mutation.Email(); ok {
		_spec.SetField(team.FieldEmail, field.TypeString, value)
		_node.Email = value
	}
	if nodes := tc.mutation.UsersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   team.UsersTable,
			Columns: team.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tc.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &UsersTeamsCreate{config: tc.config, mutation: newUsersTeamsMutation(tc.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tc.mutation.TeamAPIKeysIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   team.TeamAPIKeysTable,
			Columns: []string{team.TeamAPIKeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tc.schemaConfig.TeamAPIKey
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tc.mutation.TeamTierIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   team.TeamTierTable,
			Columns: []string{team.TeamTierColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tier.FieldID, field.TypeString),
			},
		}
		edge.Schema = tc.schemaConfig.Team
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.Tier = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tc.mutation.EnvsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   team.EnvsTable,
			Columns: []string{team.EnvsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = tc.schemaConfig.Env
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := tc.mutation.UsersTeamsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   team.UsersTeamsTable,
			Columns: []string{team.UsersTeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt),
			},
		}
		edge.Schema = tc.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.Team.Create().
//		SetCreatedAt(v).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.TeamUpsert) {
//			SetCreatedAt(v+v).
//		}).
//		Exec(ctx)
func (tc *TeamCreate) OnConflict(opts ...sql.ConflictOption) *TeamUpsertOne {
	tc.conflict = opts
	return &TeamUpsertOne{
		create: tc,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.Team.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (tc *TeamCreate) OnConflictColumns(columns ...string) *TeamUpsertOne {
	tc.conflict = append(tc.conflict, sql.ConflictColumns(columns...))
	return &TeamUpsertOne{
		create: tc,
	}
}

type (
	// TeamUpsertOne is the builder for "upsert"-ing
	//  one Team node.
	TeamUpsertOne struct {
		create *TeamCreate
	}

	// TeamUpsert is the "OnConflict" setter.
	TeamUpsert struct {
		*sql.UpdateSet
	}
)

// SetIsBanned sets the "is_banned" field.
func (u *TeamUpsert) SetIsBanned(v bool) *TeamUpsert {
	u.Set(team.FieldIsBanned, v)
	return u
}

// UpdateIsBanned sets the "is_banned" field to the value that was provided on create.
func (u *TeamUpsert) UpdateIsBanned() *TeamUpsert {
	u.SetExcluded(team.FieldIsBanned)
	return u
}

// ClearIsBanned clears the value of the "is_banned" field.
func (u *TeamUpsert) ClearIsBanned() *TeamUpsert {
	u.SetNull(team.FieldIsBanned)
	return u
}

// SetIsBlocked sets the "is_blocked" field.
func (u *TeamUpsert) SetIsBlocked(v bool) *TeamUpsert {
	u.Set(team.FieldIsBlocked, v)
	return u
}

// UpdateIsBlocked sets the "is_blocked" field to the value that was provided on create.
func (u *TeamUpsert) UpdateIsBlocked() *TeamUpsert {
	u.SetExcluded(team.FieldIsBlocked)
	return u
}

// ClearIsBlocked clears the value of the "is_blocked" field.
func (u *TeamUpsert) ClearIsBlocked() *TeamUpsert {
	u.SetNull(team.FieldIsBlocked)
	return u
}

// SetBlockedReason sets the "blocked_reason" field.
func (u *TeamUpsert) SetBlockedReason(v string) *TeamUpsert {
	u.Set(team.FieldBlockedReason, v)
	return u
}

// UpdateBlockedReason sets the "blocked_reason" field to the value that was provided on create.
func (u *TeamUpsert) UpdateBlockedReason() *TeamUpsert {
	u.SetExcluded(team.FieldBlockedReason)
	return u
}

// ClearBlockedReason clears the value of the "blocked_reason" field.
func (u *TeamUpsert) ClearBlockedReason() *TeamUpsert {
	u.SetNull(team.FieldBlockedReason)
	return u
}

// SetName sets the "name" field.
func (u *TeamUpsert) SetName(v string) *TeamUpsert {
	u.Set(team.FieldName, v)
	return u
}

// UpdateName sets the "name" field to the value that was provided on create.
func (u *TeamUpsert) UpdateName() *TeamUpsert {
	u.SetExcluded(team.FieldName)
	return u
}

// SetTier sets the "tier" field.
func (u *TeamUpsert) SetTier(v string) *TeamUpsert {
	u.Set(team.FieldTier, v)
	return u
}

// UpdateTier sets the "tier" field to the value that was provided on create.
func (u *TeamUpsert) UpdateTier() *TeamUpsert {
	u.SetExcluded(team.FieldTier)
	return u
}

// SetEmail sets the "email" field.
func (u *TeamUpsert) SetEmail(v string) *TeamUpsert {
	u.Set(team.FieldEmail, v)
	return u
}

// UpdateEmail sets the "email" field to the value that was provided on create.
func (u *TeamUpsert) UpdateEmail() *TeamUpsert {
	u.SetExcluded(team.FieldEmail)
	return u
}

// UpdateNewValues updates the mutable fields using the new values that were set on create except the ID field.
// Using this option is equivalent to using:
//
//	client.Team.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(team.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *TeamUpsertOne) UpdateNewValues() *TeamUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		if _, exists := u.create.mutation.ID(); exists {
			s.SetIgnore(team.FieldID)
		}
		if _, exists := u.create.mutation.CreatedAt(); exists {
			s.SetIgnore(team.FieldCreatedAt)
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.Team.Create().
//	    OnConflict(sql.ResolveWithIgnore()).
//	    Exec(ctx)
func (u *TeamUpsertOne) Ignore() *TeamUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *TeamUpsertOne) DoNothing() *TeamUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the TeamCreate.OnConflict
// documentation for more info.
func (u *TeamUpsertOne) Update(set func(*TeamUpsert)) *TeamUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&TeamUpsert{UpdateSet: update})
	}))
	return u
}

// SetIsBanned sets the "is_banned" field.
func (u *TeamUpsertOne) SetIsBanned(v bool) *TeamUpsertOne {
	return u.Update(func(s *TeamUpsert) {
		s.SetIsBanned(v)
	})
}

// UpdateIsBanned sets the "is_banned" field to the value that was provided on create.
func (u *TeamUpsertOne) UpdateIsBanned() *TeamUpsertOne {
	return u.Update(func(s *TeamUpsert) {
		s.UpdateIsBanned()
	})
}

// ClearIsBanned clears the value of the "is_banned" field.
func (u *TeamUpsertOne) ClearIsBanned() *TeamUpsertOne {
	return u.Update(func(s *TeamUpsert) {
		s.ClearIsBanned()
	})
}

// SetIsBlocked sets the "is_blocked" field.
func (u *TeamUpsertOne) SetIsBlocked(v bool) *TeamUpsertOne {
	return u.Update(func(s *TeamUpsert) {
		s.SetIsBlocked(v)
	})
}

// UpdateIsBlocked sets the "is_blocked" field to the value that was provided on create.
func (u *TeamUpsertOne) UpdateIsBlocked() *TeamUpsertOne {
	return u.Update(func(s *TeamUpsert) {
		s.UpdateIsBlocked()
	})
}

// ClearIsBlocked clears the value of the "is_blocked" field.
func (u *TeamUpsertOne) ClearIsBlocked() *TeamUpsertOne {
	return u.Update(func(s *TeamUpsert) {
		s.ClearIsBlocked()
	})
}

// SetBlockedReason sets the "blocked_reason" field.
func (u *TeamUpsertOne) SetBlockedReason(v string) *TeamUpsertOne {
	return u.Update(func(s *TeamUpsert) {
		s.SetBlockedReason(v)
	})
}

// UpdateBlockedReason sets the "blocked_reason" field to the value that was provided on create.
func (u *TeamUpsertOne) UpdateBlockedReason() *TeamUpsertOne {
	return u.Update(func(s *TeamUpsert) {
		s.UpdateBlockedReason()
	})
}

// ClearBlockedReason clears the value of the "blocked_reason" field.
func (u *TeamUpsertOne) ClearBlockedReason() *TeamUpsertOne {
	return u.Update(func(s *TeamUpsert) {
		s.ClearBlockedReason()
	})
}

// SetName sets the "name" field.
func (u *TeamUpsertOne) SetName(v string) *TeamUpsertOne {
	return u.Update(func(s *TeamUpsert) {
		s.SetName(v)
	})
}

// UpdateName sets the "name" field to the value that was provided on create.
func (u *TeamUpsertOne) UpdateName() *TeamUpsertOne {
	return u.Update(func(s *TeamUpsert) {
		s.UpdateName()
	})
}

// SetTier sets the "tier" field.
func (u *TeamUpsertOne) SetTier(v string) *TeamUpsertOne {
	return u.Update(func(s *TeamUpsert) {
		s.SetTier(v)
	})
}

// UpdateTier sets the "tier" field to the value that was provided on create.
func (u *TeamUpsertOne) UpdateTier() *TeamUpsertOne {
	return u.Update(func(s *TeamUpsert) {
		s.UpdateTier()
	})
}

// SetEmail sets the "email" field.
func (u *TeamUpsertOne) SetEmail(v string) *TeamUpsertOne {
	return u.Update(func(s *TeamUpsert) {
		s.SetEmail(v)
	})
}

// UpdateEmail sets the "email" field to the value that was provided on create.
func (u *TeamUpsertOne) UpdateEmail() *TeamUpsertOne {
	return u.Update(func(s *TeamUpsert) {
		s.UpdateEmail()
	})
}

// Exec executes the query.
func (u *TeamUpsertOne) Exec(ctx context.Context) error {
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for TeamCreate.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *TeamUpsertOne) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}

// Exec executes the UPSERT query and returns the inserted/updated ID.
func (u *TeamUpsertOne) ID(ctx context.Context) (id uuid.UUID, err error) {
	if u.create.driver.Dialect() == dialect.MySQL {
		// In case of "ON CONFLICT", there is no way to get back non-numeric ID
		// fields from the database since MySQL does not support the RETURNING clause.
		return id, errors.New("models: TeamUpsertOne.ID is not supported by MySQL driver. Use TeamUpsertOne.Exec instead")
	}
	node, err := u.create.Save(ctx)
	if err != nil {
		return id, err
	}
	return node.ID, nil
}

// IDX is like ID, but panics if an error occurs.
func (u *TeamUpsertOne) IDX(ctx context.Context) uuid.UUID {
	id, err := u.ID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// TeamCreateBulk is the builder for creating many Team entities in bulk.
type TeamCreateBulk struct {
	config
	err      error
	builders []*TeamCreate
	conflict []sql.ConflictOption
}

// Save creates the Team entities in the database.
func (tcb *TeamCreateBulk) Save(ctx context.Context) ([]*Team, error) {
	if tcb.err != nil {
		return nil, tcb.err
	}
	specs := make([]*sqlgraph.CreateSpec, len(tcb.builders))
	nodes := make([]*Team, len(tcb.builders))
	mutators := make([]Mutator, len(tcb.builders))
	for i := range tcb.builders {
		func(i int, root context.Context) {
			builder := tcb.builders[i]
			builder.defaults()
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*TeamMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				var err error
				nodes[i], specs[i] = builder.createSpec()
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, tcb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					spec.OnConflict = tcb.conflict
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, tcb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{msg: err.Error(), wrap: err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, tcb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (tcb *TeamCreateBulk) SaveX(ctx context.Context) []*Team {
	v, err := tcb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (tcb *TeamCreateBulk) Exec(ctx context.Context) error {
	_, err := tcb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (tcb *TeamCreateBulk) ExecX(ctx context.Context) {
	if err := tcb.Exec(ctx); err != nil {
		panic(err)
	}
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.Team.CreateBulk(builders...).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.TeamUpsert) {
//			SetCreatedAt(v+v).
//		}).
//		Exec(ctx)
func (tcb *TeamCreateBulk) OnConflict(opts ...sql.ConflictOption) *TeamUpsertBulk {
	tcb.conflict = opts
	return &TeamUpsertBulk{
		create: tcb,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.Team.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (tcb *TeamCreateBulk) OnConflictColumns(columns ...string) *TeamUpsertBulk {
	tcb.conflict = append(tcb.conflict, sql.ConflictColumns(columns...))
	return &TeamUpsertBulk{
		create: tcb,
	}
}

// TeamUpsertBulk is the builder for "upsert"-ing
// a bulk of Team nodes.
type TeamUpsertBulk struct {
	create *TeamCreateBulk
}

// UpdateNewValues updates the mutable fields using the new values that
// were set on create. Using this option is equivalent to using:
//
//	client.Team.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(team.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *TeamUpsertBulk) UpdateNewValues() *TeamUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		for _, b := range u.create.builders {
			if _, exists := b.mutation.ID(); exists {
				s.SetIgnore(team.FieldID)
			}
			if _, exists := b.mutation.CreatedAt(); exists {
				s.SetIgnore(team.FieldCreatedAt)
			}
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.Team.Create().
//		OnConflict(sql.ResolveWithIgnore()).
//		Exec(ctx)
func (u *TeamUpsertBulk) Ignore() *TeamUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *TeamUpsertBulk) DoNothing() *TeamUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the TeamCreateBulk.OnConflict
// documentation for more info.
func (u *TeamUpsertBulk) Update(set func(*TeamUpsert)) *TeamUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&TeamUpsert{UpdateSet: update})
	}))
	return u
}

// SetIsBanned sets the "is_banned" field.
func (u *TeamUpsertBulk) SetIsBanned(v bool) *TeamUpsertBulk {
	return u.Update(func(s *TeamUpsert) {
		s.SetIsBanned(v)
	})
}

// UpdateIsBanned sets the "is_banned" field to the value that was provided on create.
func (u *TeamUpsertBulk) UpdateIsBanned() *TeamUpsertBulk {
	return u.Update(func(s *TeamUpsert) {
		s.UpdateIsBanned()
	})
}

// ClearIsBanned clears the value of the "is_banned" field.
func (u *TeamUpsertBulk) ClearIsBanned() *TeamUpsertBulk {
	return u.Update(func(s *TeamUpsert) {
		s.ClearIsBanned()
	})
}

// SetIsBlocked sets the "is_blocked" field.
func (u *TeamUpsertBulk) SetIsBlocked(v bool) *TeamUpsertBulk {
	return u.Update(func(s *TeamUpsert) {
		s.SetIsBlocked(v)
	})
}

// UpdateIsBlocked sets the "is_blocked" field to the value that was provided on create.
func (u *TeamUpsertBulk) UpdateIsBlocked() *TeamUpsertBulk {
	return u.Update(func(s *TeamUpsert) {
		s.UpdateIsBlocked()
	})
}

// ClearIsBlocked clears the value of the "is_blocked" field.
func (u *TeamUpsertBulk) ClearIsBlocked() *TeamUpsertBulk {
	return u.Update(func(s *TeamUpsert) {
		s.ClearIsBlocked()
	})
}

// SetBlockedReason sets the "blocked_reason" field.
func (u *TeamUpsertBulk) SetBlockedReason(v string) *TeamUpsertBulk {
	return u.Update(func(s *TeamUpsert) {
		s.SetBlockedReason(v)
	})
}

// UpdateBlockedReason sets the "blocked_reason" field to the value that was provided on create.
func (u *TeamUpsertBulk) UpdateBlockedReason() *TeamUpsertBulk {
	return u.Update(func(s *TeamUpsert) {
		s.UpdateBlockedReason()
	})
}

// ClearBlockedReason clears the value of the "blocked_reason" field.
func (u *TeamUpsertBulk) ClearBlockedReason() *TeamUpsertBulk {
	return u.Update(func(s *TeamUpsert) {
		s.ClearBlockedReason()
	})
}

// SetName sets the "name" field.
func (u *TeamUpsertBulk) SetName(v string) *TeamUpsertBulk {
	return u.Update(func(s *TeamUpsert) {
		s.SetName(v)
	})
}

// UpdateName sets the "name" field to the value that was provided on create.
func (u *TeamUpsertBulk) UpdateName() *TeamUpsertBulk {
	return u.Update(func(s *TeamUpsert) {
		s.UpdateName()
	})
}

// SetTier sets the "tier" field.
func (u *TeamUpsertBulk) SetTier(v string) *TeamUpsertBulk {
	return u.Update(func(s *TeamUpsert) {
		s.SetTier(v)
	})
}

// UpdateTier sets the "tier" field to the value that was provided on create.
func (u *TeamUpsertBulk) UpdateTier() *TeamUpsertBulk {
	return u.Update(func(s *TeamUpsert) {
		s.UpdateTier()
	})
}

// SetEmail sets the "email" field.
func (u *TeamUpsertBulk) SetEmail(v string) *TeamUpsertBulk {
	return u.Update(func(s *TeamUpsert) {
		s.SetEmail(v)
	})
}

// UpdateEmail sets the "email" field to the value that was provided on create.
func (u *TeamUpsertBulk) UpdateEmail() *TeamUpsertBulk {
	return u.Update(func(s *TeamUpsert) {
		s.UpdateEmail()
	})
}

// Exec executes the query.
func (u *TeamUpsertBulk) Exec(ctx context.Context) error {
	if u.create.err != nil {
		return u.create.err
	}
	for i, b := range u.create.builders {
		if len(b.conflict) != 0 {
			return fmt.Errorf("models: OnConflict was set for builder %d. Set it on the TeamCreateBulk instead", i)
		}
	}
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for TeamCreateBulk.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *TeamUpsertBulk) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/team_delete.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
)

// TeamDelete is the builder for deleting a Team entity.
type TeamDelete struct {
	config
	hooks    []Hook
	mutation *TeamMutation
}

// Where appends a list predicates to the TeamDelete builder.
func (td *TeamDelete) Where(ps ...predicate.Team) *TeamDelete {
	td.mutation.Where(ps...)
	return td
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (td *TeamDelete) Exec(ctx context.Context) (int, error) {
	return withHooks(ctx, td.sqlExec, td.mutation, td.hooks)
}

// ExecX is like Exec, but panics if an error occurs.
func (td *TeamDelete) ExecX(ctx context.Context) int {
	n, err := td.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (td *TeamDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := sqlgraph.NewDeleteSpec(team.Table, sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID))
	_spec.Node.Schema = td.schemaConfig.Team
	ctx = internal.NewSchemaConfigContext(ctx, td.schemaConfig)
	if ps := td.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	affected, err := sqlgraph.DeleteNodes(ctx, td.driver, _spec)
	if err != nil && sqlgraph.IsConstraintError(err) {
		err = &ConstraintError{msg: err.Error(), wrap: err}
	}
	td.mutation.done = true
	return affected, err
}

// TeamDeleteOne is the builder for deleting a single Team entity.
type TeamDeleteOne struct {
	td *TeamDelete
}

// Where appends a list predicates to the TeamDelete builder.
func (tdo *TeamDeleteOne) Where(ps ...predicate.Team) *TeamDeleteOne {
	tdo.td.mutation.Where(ps...)
	return tdo
}

// Exec executes the deletion query.
func (tdo *TeamDeleteOne) Exec(ctx context.Context) error {
	n, err := tdo.td.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{team.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (tdo *TeamDeleteOne) ExecX(ctx context.Context) {
	if err := tdo.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/team_query.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"database/sql/driver"
	"fmt"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/teamapikey"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/tier"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"
	"github.com/google/uuid"
)

// TeamQuery is the builder for querying Team entities.
type TeamQuery struct {
	config
	ctx             *QueryContext
	order           []team.OrderOption
	inters          []Interceptor
	predicates      []predicate.Team
	withUsers       *UserQuery
	withTeamAPIKeys *TeamAPIKeyQuery
	withTeamTier    *TierQuery
	withEnvs        *EnvQuery
	withUsersTeams  *UsersTeamsQuery
	modifiers       []func(*sql.Selector)
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the TeamQuery builder.
func (tq *TeamQuery) Where(ps ...predicate.Team) *TeamQuery {
	tq.predicates = append(tq.predicates, ps...)
	return tq
}

// Limit the number of records to be returned by this query.
func (tq *TeamQuery) Limit(limit int) *TeamQuery {
	tq.ctx.Limit = &limit
	return tq
}

// Offset to start from.
func (tq *TeamQuery) Offset(offset int) *TeamQuery {
	tq.ctx.Offset = &offset
	return tq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (tq *TeamQuery) Unique(unique bool) *TeamQuery {
	tq.ctx.Unique = &unique
	return tq
}

// Order specifies how the records should be ordered.
func (tq *TeamQuery) Order(o ...team.OrderOption) *TeamQuery {
	tq.order = append(tq.order, o...)
	return tq
}

// QueryUsers chains the current query on the "users" edge.
func (tq *TeamQuery) QueryUsers() *UserQuery {
	query := (&UserClient{config: tq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := tq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := tq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, selector),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, team.UsersTable, team.UsersPrimaryKey...),
		)
		schemaConfig := tq.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.UsersTeams
		fromU = sqlgraph.SetNeighbors(tq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryTeamAPIKeys chains the current query on the "team_api_keys" edge.
func (tq *TeamQuery) QueryTeamAPIKeys() *TeamAPIKeyQuery {
	query := (&TeamAPIKeyClient{config: tq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := tq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := tq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, selector),
			sqlgraph.To(teamapikey.Table, teamapikey.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.TeamAPIKeysTable, team.TeamAPIKeysColumn),
		)
		schemaConfig := tq.schemaConfig
		step.To.Schema = schemaConfig.TeamAPIKey
		step.Edge.Schema = schemaConfig.TeamAPIKey
		fromU = sqlgraph.SetNeighbors(tq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryTeamTier chains the current query on the "team_tier" edge.
func (tq *TeamQuery) QueryTeamTier() *TierQuery {
	query := (&TierClient{config: tq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := tq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := tq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, selector),
			sqlgraph.To(tier.Table, tier.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, team.TeamTierTable, team.TeamTierColumn),
		)
		schemaConfig := tq.schemaConfig
		step.To.Schema = schemaConfig.Tier
		step.Edge.Schema = schemaConfig.Team
		fromU = sqlgraph.SetNeighbors(tq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryEnvs chains the current query on the "envs" edge.
func (tq *TeamQuery) QueryEnvs() *EnvQuery {
	query := (&EnvClient{config: tq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := tq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := tq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, selector),
			sqlgraph.To(env.Table, env.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.EnvsTable, team.EnvsColumn),
		)
		schemaConfig := tq.schemaConfig
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.Env
		fromU = sqlgraph.SetNeighbors(tq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryUsersTeams chains the current query on the "users_teams" edge.
func (tq *TeamQuery) QueryUsersTeams() *UsersTeamsQuery {
	query := (&UsersTeamsClient{config: tq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := tq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := tq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, selector),
			sqlgraph.To(usersteams.Table, usersteams.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, team.UsersTeamsTable, team.UsersTeamsColumn),
		)
		schemaConfig := tq.schemaConfig
		step.To.Schema = schemaConfig.UsersTeams
		step.Edge.Schema = schemaConfig.UsersTeams
		fromU = sqlgraph.SetNeighbors(tq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first Team entity from the query.
// Returns a *NotFoundError when no Team was found.
func (tq *TeamQuery) First(ctx context.Context) (*Team, error) {
	nodes, err := tq.Limit(1).All(setContextOp(ctx, tq.ctx, "First"))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{team.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (tq *TeamQuery) FirstX(ctx context.Context) *Team {
	node, err := tq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first Team ID from the query.
// Returns a *NotFoundError when no Team ID was found.
func (tq *TeamQuery) FirstID(ctx context.Context) (id uuid.UUID, err error) {
	var ids []uuid.UUID
	if ids, err = tq.Limit(1).IDs(setContextOp(ctx, tq.ctx, "FirstID")); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{team.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (tq *TeamQuery) FirstIDX(ctx context.Context) uuid.UUID {
	id, err := tq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single Team entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one Team entity is found.
// Returns a *NotFoundError when no Team entities are found.
func (tq *TeamQuery) Only(ctx context.Context) (*Team, error) {
	nodes, err := tq.Limit(2).All(setContextOp(ctx, tq.ctx, "Only"))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{team.Label}
	default:
		return nil, &NotSingularError{team.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (tq *TeamQuery) OnlyX(ctx context.Context) *Team {
	node, err := tq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only Team ID in the query.
// Returns a *NotSingularError when more than one Team ID is found.
// Returns a *NotFoundError when no entities are found.
func (tq *TeamQuery) OnlyID(ctx context.Context) (id uuid.UUID, err error) {
	var ids []uuid.UUID
	if ids, err = tq.Limit(2).IDs(setContextOp(ctx, tq.ctx, "OnlyID")); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{team.Label}
	default:
		err = &NotSingularError{team.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (tq *TeamQuery) OnlyIDX(ctx context.Context) uuid.UUID {
	id, err := tq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of Teams.
func (tq *TeamQuery) All(ctx context.Context) ([]*Team, error) {
	ctx = setContextOp(ctx, tq.ctx, "All")
	if err := tq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*Team, *TeamQuery]()
	return withInterceptors[[]*Team](ctx, tq, qr, tq.inters)
}

// AllX is like All, but panics if an error occurs.
func (tq *TeamQuery) AllX(ctx context.Context) []*Team {
	nodes, err := tq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of Team IDs.
func (tq *TeamQuery) IDs(ctx context.Context) (ids []uuid.UUID, err error) {
	if tq.ctx.Unique == nil && tq.path != nil {
		tq.Unique(true)
	}
	ctx = setContextOp(ctx, tq.ctx, "IDs")
	if err = tq.Select(team.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (tq *TeamQuery) IDsX(ctx context.Context) []uuid.UUID {
	ids, err := tq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (tq *TeamQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, tq.ctx, "Count")
	if err := tq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, tq, querierCount[*TeamQuery](), tq.inters)
}

// CountX is like Count, but panics if an error occurs.
func (tq *TeamQuery) CountX(ctx context.Context) int {
	count, err := tq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (tq *TeamQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, tq.ctx, "Exist")
	switch _, err := tq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("models: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (tq *TeamQuery) ExistX(ctx context.Context) bool {
	exist, err := tq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the TeamQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (tq *TeamQuery) Clone() *TeamQuery {
	if tq == nil {
		return nil
	}
	return &TeamQuery{
		config:          tq.config,
		ctx:             tq.ctx.Clone(),
		order:           append([]team.OrderOption{}, tq.order...),
		inters:          append([]Interceptor{}, tq.inters...),
		predicates:      append([]predicate.Team{}, tq.predicates...),
		withUsers:       tq.withUsers.Clone(),
		withTeamAPIKeys: tq.withTeamAPIKeys.Clone(),
		withTeamTier:    tq.withTeamTier.Clone(),
		withEnvs:        tq.withEnvs.Clone(),
		withUsersTeams:  tq.withUsersTeams.Clone(),
		// clone intermediate query.
		sql:  tq.sql.Clone(),
		path: tq.path,
	}
}

// WithUsers tells the query-builder to eager-load the nodes that are connected to
// the "users" edge. The optional arguments are used to configure the query builder of the edge.
func (tq *TeamQuery) WithUsers(opts ...func(*UserQuery)) *TeamQuery {
	query := (&UserClient{config: tq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	tq.withUsers = query
	return tq
}

// WithTeamAPIKeys tells the query-builder to eager-load the nodes that are connected to
// the "team_api_keys" edge. The optional arguments are used to configure the query builder of the edge.
func (tq *TeamQuery) WithTeamAPIKeys(opts ...func(*TeamAPIKeyQuery)) *TeamQuery {
	query := (&TeamAPIKeyClient{config: tq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	tq.withTeamAPIKeys = query
	return tq
}

// WithTeamTier tells the query-builder to eager-load the nodes that are connected to
// the "team_tier" edge. The optional arguments are used to configure the query builder of the edge.
func (tq *TeamQuery) WithTeamTier(opts ...func(*TierQuery)) *TeamQuery {
	query := (&TierClient{config: tq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	tq.withTeamTier = query
	return tq
}

// WithEnvs tells the query-builder to eager-load the nodes that are connected to
// the "envs" edge. The optional arguments are used to configure the query builder of the edge.
func (tq *TeamQuery) WithEnvs(opts ...func(*EnvQuery)) *TeamQuery {
	query := (&EnvClient{config: tq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	tq.withEnvs = query
	return tq
}

// WithUsersTeams tells the query-builder to eager-load the nodes that are connected to
// the "users_teams" edge. The optional arguments are used to configure the query builder of the edge.
func (tq *TeamQuery) WithUsersTeams(opts ...func(*UsersTeamsQuery)) *TeamQuery {
	query := (&UsersTeamsClient{config: tq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	tq.withUsersTeams = query
	return tq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		CreatedAt time.Time `json:"created_at,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.Team.Query().
//		GroupBy(team.FieldCreatedAt).
//		Aggregate(models.Count()).
//		Scan(ctx, &v)
func (tq *TeamQuery) GroupBy(field string, fields ...string) *TeamGroupBy {
	tq.ctx.Fields = append([]string{field}, fields...)
	grbuild := &TeamGroupBy{build: tq}
	grbuild.flds = &tq.ctx.Fields
	grbuild.label = team.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		CreatedAt time.Time `json:"created_at,omitempty"`
//	}
//
//	client.Team.Query().
//		Select(team.FieldCreatedAt).
//		Scan(ctx, &v)
func (tq *TeamQuery) Select(fields ...string) *TeamSelect {
	tq.ctx.Fields = append(tq.ctx.Fields, fields...)
	sbuild := &TeamSelect{TeamQuery: tq}
	sbuild.label = team.Label
	sbuild.flds, sbuild.scan = &tq.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a TeamSelect configured with the given aggregations.
func (tq *TeamQuery) Aggregate(fns ...AggregateFunc) *TeamSelect {
	return tq.Select().Aggregate(fns...)
}

func (tq *TeamQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range tq.inters {
		if inter == nil {
			return fmt.Errorf("models: uninitialized interceptor (forgotten import models/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, tq); err != nil {
				return err
			}
		}
	}
	for _, f := range tq.ctx.Fields {
		if !team.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
		}
	}
	if tq.path != nil {
		prev, err := tq.path(ctx)
		if err != nil {
			return err
		}
		tq.sql = prev
	}
	return nil
}

func (tq *TeamQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*Team, error) {
	var (
		nodes       = []*Team{}
		_spec       = tq.querySpec()
		loadedTypes = [5]bool{
			tq.withUsers != nil,
			tq.withTeamAPIKeys != nil,
			tq.withTeamTier != nil,
			tq.withEnvs != nil,
			tq.withUsersTeams != nil,
		}
	)
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*Team).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &Team{config: tq.config}
		nodes = append(nodes, node)
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	_spec.Node.Schema = tq.schemaConfig.Team
	ctx = internal.NewSchemaConfigContext(ctx, tq.schemaConfig)
	if len(tq.modifiers) > 0 {
		_spec.Modifiers = tq.modifiers
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, tq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	if query := tq.withUsers; query != nil {
		if err := tq.loadUsers(ctx, query, nodes,
			func(n *Team) { n.Edges.Users = []*User{} },
			func(n *Team, e *User) { n.Edges.Users = append(n.Edges.Users, e) }); err != nil {
			return nil, err
		}
	}
	if query := tq.withTeamAPIKeys; query != nil {
		if err := tq.loadTeamAPIKeys(ctx, query, nodes,
			func(n *Team) { n.Edges.TeamAPIKeys = []*TeamAPIKey{} },
			func(n *Team, e *TeamAPIKey) { n.Edges.TeamAPIKeys = append(n.Edges.TeamAPIKeys, e) }); err != nil {
			return nil, err
		}
	}
	if query := tq.withTeamTier; query != nil {
		if err := tq.loadTeamTier(ctx, query, nodes, nil,
			func(n *Team, e *Tier) { n.Edges.TeamTier = e }); err != nil {
			return nil, err
		}
	}
	if query := tq.withEnvs; query != nil {
		if err := tq.loadEnvs(ctx, query, nodes,
			func(n *Team) { n.Edges.Envs = []*Env{} },
			func(n *Team, e *Env) { n.Edges.Envs = append(n.Edges.Envs, e) }); err != nil {
			return nil, err
		}
	}
	if query := tq.withUsersTeams; query != nil {
		if err := tq.loadUsersTeams(ctx, query, nodes,
			func(n *Team) { n.Edges.UsersTeams = []*UsersTeams{} },
			func(n *Team, e *UsersTeams) { n.Edges.UsersTeams = append(n.Edges.UsersTeams, e) }); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

func (tq *TeamQuery) loadUsers(ctx context.Context, query *UserQuery, nodes []*Team, init func(*Team), assign func(*Team, *User)) error {
	edgeIDs := make([]driver.Value, len(nodes))
	byID := make(map[uuid.UUID]*Team)
	nids := make(map[uuid.UUID]map[*Team]struct{})
	for i, node := range nodes {
		edgeIDs[i] = node.ID
		byID[node.ID] = node
		if init != nil {
			init(node)
		}
	}
	query.Where(func(s *sql.Selector) {
		joinT := sql.Table(team.UsersTable)
		joinT.Schema(tq.schemaConfig.UsersTeams)
		s.Join(joinT).On(s.C(user.FieldID), joinT.C(team.UsersPrimaryKey[1]))
		s.Where(sql.InValues(joinT.C(team.UsersPrimaryKey[0]), edgeIDs...))
		columns := s.SelectedColumns()
		s.Select(joinT.C(team.UsersPrimaryKey[0]))
		s.AppendSelect(columns...)
		s.SetDistinct(false)
	})
	if err := query.prepareQuery(ctx); err != nil {
		return err
	}
	qr := QuerierFunc(func(ctx context.Context, q Query) (Value, error) {
		return query.sqlAll(ctx, func(_ context.Context, spec *sqlgraph.QuerySpec) {
			assign := spec.Assign
			values := spec.ScanValues
			spec.ScanValues = func(columns []string) ([]any, error) {
				values, err := values(columns[1:])
				if err != nil {
					return nil, err
				}
				return append([]any{new(uuid.UUID)}, values...), nil
			}
			spec.Assign = func(columns []string, values []any) error {
				outValue := *values[0].(*uuid.UUID)
				inValue := *values[1].(*uuid.UUID)
				if nids[inValue] == nil {
					nids[inValue] = map[*Team]struct{}{byID[outValue]: {}}
					return assign(columns[1:], values[1:])
				}
				nids[inValue][byID[outValue]] = struct{}{}
				return nil
			}
		})
	})
	neighbors, err := withInterceptors[[]*User](ctx, query, qr, query.inters)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected "users" node returned %v`, n.ID)
		}
		for kn := range nodes {
			assign(kn, n)
		}
	}
	return nil
}
func (tq *TeamQuery) loadTeamAPIKeys(ctx context.Context, query *TeamAPIKeyQuery, nodes []*Team, init func(*Team), assign func(*Team, *TeamAPIKey)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[uuid.UUID]*Team)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(teamapikey.FieldTeamID)
	}
	query.Where(predicate.TeamAPIKey(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(team.TeamAPIKeysColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.TeamID
		node, ok := nodeids[fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "team_id" returned %v for node %v`, fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (tq *TeamQuery) loadTeamTier(ctx context.Context, query *TierQuery, nodes []*Team, init func(*Team), assign func(*Team, *Tier)) error {
	ids := make([]string, 0, len(nodes))
	nodeids := make(map[string][]*Team)
	for i := range nodes {
		fk := nodes[i].Tier
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(tier.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "tier" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}
func (tq *TeamQuery) loadEnvs(ctx context.Context, query *EnvQuery, nodes []*Team, init func(*Team), assign func(*Team, *Env)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[uuid.UUID]*Team)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(env.FieldTeamID)
	}
	query.Where(predicate.Env(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(team.EnvsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.TeamID
		node, ok := nodeids[fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "team_id" returned %v for node %v`, fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (tq *TeamQuery) loadUsersTeams(ctx context.Context, query *UsersTeamsQuery, nodes []*Team, init func(*Team), assign func(*Team, *UsersTeams)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[uuid.UUID]*Team)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(usersteams.FieldTeamID)
	}
	query.Where(predicate.UsersTeams(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(team.UsersTeamsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.TeamID
		node, ok := nodeids[fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "team_id" returned %v for node %v`, fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}

func (tq *TeamQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := tq.querySpec()
	_spec.Node.Schema = tq.schemaConfig.Team
	ctx = internal.NewSchemaConfigContext(ctx, tq.schemaConfig)
	if len(tq.modifiers) > 0 {
		_spec.Modifiers = tq.modifiers
	}
	_spec.Node.Columns = tq.ctx.Fields
	if len(tq.ctx.Fields) > 0 {
		_spec.Unique = tq.ctx.Unique != nil && *tq.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, tq.driver, _spec)
}

func (tq *TeamQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(team.Table, team.Columns, sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID))
	_spec.From = tq.sql
	if unique := tq.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if tq.path != nil {
		_spec.Unique = true
	}
	if fields := tq.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, team.FieldID)
		for i := range fields {
			if fields[i] != team.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
		if tq.withTeamTier != nil {
			_spec.Node.AddColumnOnce(team.FieldTier)
		}
	}
	if ps := tq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := tq.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := tq.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := tq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (tq *TeamQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(tq.driver.Dialect())
	t1 := builder.Table(team.Table)
	columns := tq.ctx.Fields
	if len(columns) == 0 {
		columns = team.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if tq.sql != nil {
		selector = tq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if tq.ctx.Unique != nil && *tq.ctx.Unique {
		selector.Distinct()
	}
	t1.Schema(tq.schemaConfig.Team)
	ctx = internal.NewSchemaConfigContext(ctx, tq.schemaConfig)
	selector.WithContext(ctx)
	for _, m := range tq.modifiers {
		m(selector)
	}
	for _, p := range tq.predicates {
		p(selector)
	}
	for _, p := range tq.order {
		p(selector)
	}
	if offset := tq.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := tq.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// Modify adds a query modifier for attaching custom logic to queries.
func (tq *TeamQuery) Modify(modifiers ...func(s *sql.Selector)) *TeamSelect {
	tq.modifiers = append(tq.modifiers, modifiers...)
	return tq.Select()
}

// TeamGroupBy is the group-by builder for Team entities.
type TeamGroupBy struct {
	selector
	build *TeamQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (tgb *TeamGroupBy) Aggregate(fns ...AggregateFunc) *TeamGroupBy {
	tgb.fns = append(tgb.fns, fns...)
	return tgb
}

// Scan applies the selector query and scans the result into the given value.
func (tgb *TeamGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, tgb.build.ctx, "GroupBy")
	if err := tgb.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*TeamQuery, *TeamGroupBy](ctx, tgb.build, tgb, tgb.build.inters, v)
}

func (tgb *TeamGroupBy) sqlScan(ctx context.Context, root *TeamQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(tgb.fns))
	for _, fn := range tgb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*tgb.flds)+len(tgb.fns))
		for _, f := range *tgb.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*tgb.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := tgb.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// TeamSelect is the builder for selecting fields of Team entities.
type TeamSelect struct {
	*TeamQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (ts *TeamSelect) Aggregate(fns ...AggregateFunc) *TeamSelect {
	ts.fns = append(ts.fns, fns...)
	return ts
}

// Scan applies the selector query and scans the result into the given value.
func (ts *TeamSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, ts.ctx, "Select")
	if err := ts.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*TeamQuery, *TeamSelect](ctx, ts.TeamQuery, ts, ts.inters, v)
}

func (ts *TeamSelect) sqlScan(ctx context.Context, root *TeamQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(ts.fns))
	for _, fn := range ts.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*ts.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := ts.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// Modify adds a query modifier for attaching custom logic to queries.
func (ts *TeamSelect) Modify(modifiers ...func(s *sql.Selector)) *TeamSelect {
	ts.modifiers = append(ts.modifiers, modifiers...)
	return ts
}



================================================
File: models/team_update.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/teamapikey"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/tier"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"
	"github.com/google/uuid"
)

// TeamUpdate is the builder for updating Team entities.
type TeamUpdate struct {
	config
	hooks     []Hook
	mutation  *TeamMutation
	modifiers []func(*sql.UpdateBuilder)
}

// Where appends a list predicates to the TeamUpdate builder.
func (tu *TeamUpdate) Where(ps ...predicate.Team) *TeamUpdate {
	tu.mutation.Where(ps...)
	return tu
}

// SetIsBanned sets the "is_banned" field.
func (tu *TeamUpdate) SetIsBanned(b bool) *TeamUpdate {
	tu.mutation.SetIsBanned(b)
	return tu
}

// SetNillableIsBanned sets the "is_banned" field if the given value is not nil.
func (tu *TeamUpdate) SetNillableIsBanned(b *bool) *TeamUpdate {
	if b != nil {
		tu.SetIsBanned(*b)
	}
	return tu
}

// ClearIsBanned clears the value of the "is_banned" field.
func (tu *TeamUpdate) ClearIsBanned() *TeamUpdate {
	tu.mutation.ClearIsBanned()
	return tu
}

// SetIsBlocked sets the "is_blocked" field.
func (tu *TeamUpdate) SetIsBlocked(b bool) *TeamUpdate {
	tu.mutation.SetIsBlocked(b)
	return tu
}

// SetNillableIsBlocked sets the "is_blocked" field if the given value is not nil.
func (tu *TeamUpdate) SetNillableIsBlocked(b *bool) *TeamUpdate {
	if b != nil {
		tu.SetIsBlocked(*b)
	}
	return tu
}

// ClearIsBlocked clears the value of the "is_blocked" field.
func (tu *TeamUpdate) ClearIsBlocked() *TeamUpdate {
	tu.mutation.ClearIsBlocked()
	return tu
}

// SetBlockedReason sets the "blocked_reason" field.
func (tu *TeamUpdate) SetBlockedReason(s string) *TeamUpdate {
	tu.mutation.SetBlockedReason(s)
	return tu
}

// SetNillableBlockedReason sets the "blocked_reason" field if the given value is not nil.
func (tu *TeamUpdate) SetNillableBlockedReason(s *string) *TeamUpdate {
	if s != nil {
		tu.SetBlockedReason(*s)
	}
	return tu
}

// ClearBlockedReason clears the value of the "blocked_reason" field.
func (tu *TeamUpdate) ClearBlockedReason() *TeamUpdate {
	tu.mutation.ClearBlockedReason()
	return tu
}

// SetName sets the "name" field.
func (tu *TeamUpdate) SetName(s string) *TeamUpdate {
	tu.mutation.SetName(s)
	return tu
}

// SetNillableName sets the "name" field if the given value is not nil.
func (tu *TeamUpdate) SetNillableName(s *string) *TeamUpdate {
	if s != nil {
		tu.SetName(*s)
	}
	return tu
}

// SetTier sets the "tier" field.
func (tu *TeamUpdate) SetTier(s string) *TeamUpdate {
	tu.mutation.SetTier(s)
	return tu
}

// SetNillableTier sets the "tier" field if the given value is not nil.
func (tu *TeamUpdate) SetNillableTier(s *string) *TeamUpdate {
	if s != nil {
		tu.SetTier(*s)
	}
	return tu
}

// SetEmail sets the "email" field.
func (tu *TeamUpdate) SetEmail(s string) *TeamUpdate {
	tu.mutation.SetEmail(s)
	return tu
}

// SetNillableEmail sets the "email" field if the given value is not nil.
func (tu *TeamUpdate) SetNillableEmail(s *string) *TeamUpdate {
	if s != nil {
		tu.SetEmail(*s)
	}
	return tu
}

// AddUserIDs adds the "users" edge to the User entity by IDs.
func (tu *TeamUpdate) AddUserIDs(ids ...uuid.UUID) *TeamUpdate {
	tu.mutation.AddUserIDs(ids...)
	return tu
}

// AddUsers adds the "users" edges to the User entity.
func (tu *TeamUpdate) AddUsers(u ...*User) *TeamUpdate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return tu.AddUserIDs(ids...)
}

// AddTeamAPIKeyIDs adds the "team_api_keys" edge to the TeamAPIKey entity by IDs.
func (tu *TeamUpdate) AddTeamAPIKeyIDs(ids ...uuid.UUID) *TeamUpdate {
	tu.mutation.AddTeamAPIKeyIDs(ids...)
	return tu
}

// AddTeamAPIKeys adds the "team_api_keys" edges to the TeamAPIKey entity.
func (tu *TeamUpdate) AddTeamAPIKeys(t ...*TeamAPIKey) *TeamUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tu.AddTeamAPIKeyIDs(ids...)
}

// SetTeamTierID sets the "team_tier" edge to the Tier entity by ID.
func (tu *TeamUpdate) SetTeamTierID(id string) *TeamUpdate {
	tu.mutation.SetTeamTierID(id)
	return tu
}

// SetTeamTier sets the "team_tier" edge to the Tier entity.
func (tu *TeamUpdate) SetTeamTier(t *Tier) *TeamUpdate {
	return tu.SetTeamTierID(t.ID)
}

// AddEnvIDs adds the "envs" edge to the Env entity by IDs.
func (tu *TeamUpdate) AddEnvIDs(ids ...string) *TeamUpdate {
	tu.mutation.AddEnvIDs(ids...)
	return tu
}

// AddEnvs adds the "envs" edges to the Env entity.
func (tu *TeamUpdate) AddEnvs(e ...*Env) *TeamUpdate {
	ids := make([]string, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return tu.AddEnvIDs(ids...)
}

// AddUsersTeamIDs adds the "users_teams" edge to the UsersTeams entity by IDs.
func (tu *TeamUpdate) AddUsersTeamIDs(ids ...int) *TeamUpdate {
	tu.mutation.AddUsersTeamIDs(ids...)
	return tu
}

// AddUsersTeams adds the "users_teams" edges to the UsersTeams entity.
func (tu *TeamUpdate) AddUsersTeams(u ...*UsersTeams) *TeamUpdate {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return tu.AddUsersTeamIDs(ids...)
}

// Mutation returns the TeamMutation object of the builder.
func (tu *TeamUpdate) Mutation() *TeamMutation {
	return tu.mutation
}

// ClearUsers clears all "users" edges to the User entity.
func (tu *TeamUpdate) ClearUsers() *TeamUpdate {
	tu.mutation.ClearUsers()
	return tu
}

// RemoveUserIDs removes the "users" edge to User entities by IDs.
func (tu *TeamUpdate) RemoveUserIDs(ids ...uuid.UUID) *TeamUpdate {
	tu.mutation.RemoveUserIDs(ids...)
	return tu
}

// RemoveUsers removes "users" edges to User entities.
func (tu *TeamUpdate) RemoveUsers(u ...*User) *TeamUpdate {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return tu.RemoveUserIDs(ids...)
}

// ClearTeamAPIKeys clears all "team_api_keys" edges to the TeamAPIKey entity.
func (tu *TeamUpdate) ClearTeamAPIKeys() *TeamUpdate {
	tu.mutation.ClearTeamAPIKeys()
	return tu
}

// RemoveTeamAPIKeyIDs removes the "team_api_keys" edge to TeamAPIKey entities by IDs.
func (tu *TeamUpdate) RemoveTeamAPIKeyIDs(ids ...uuid.UUID) *TeamUpdate {
	tu.mutation.RemoveTeamAPIKeyIDs(ids...)
	return tu
}

// RemoveTeamAPIKeys removes "team_api_keys" edges to TeamAPIKey entities.
func (tu *TeamUpdate) RemoveTeamAPIKeys(t ...*TeamAPIKey) *TeamUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tu.RemoveTeamAPIKeyIDs(ids...)
}

// ClearTeamTier clears the "team_tier" edge to the Tier entity.
func (tu *TeamUpdate) ClearTeamTier() *TeamUpdate {
	tu.mutation.ClearTeamTier()
	return tu
}

// ClearEnvs clears all "envs" edges to the Env entity.
func (tu *TeamUpdate) ClearEnvs() *TeamUpdate {
	tu.mutation.ClearEnvs()
	return tu
}

// RemoveEnvIDs removes the "envs" edge to Env entities by IDs.
func (tu *TeamUpdate) RemoveEnvIDs(ids ...string) *TeamUpdate {
	tu.mutation.RemoveEnvIDs(ids...)
	return tu
}

// RemoveEnvs removes "envs" edges to Env entities.
func (tu *TeamUpdate) RemoveEnvs(e ...*Env) *TeamUpdate {
	ids := make([]string, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return tu.RemoveEnvIDs(ids...)
}

// ClearUsersTeams clears all "users_teams" edges to the UsersTeams entity.
func (tu *TeamUpdate) ClearUsersTeams() *TeamUpdate {
	tu.mutation.ClearUsersTeams()
	return tu
}

// RemoveUsersTeamIDs removes the "users_teams" edge to UsersTeams entities by IDs.
func (tu *TeamUpdate) RemoveUsersTeamIDs(ids ...int) *TeamUpdate {
	tu.mutation.RemoveUsersTeamIDs(ids...)
	return tu
}

// RemoveUsersTeams removes "users_teams" edges to UsersTeams entities.
func (tu *TeamUpdate) RemoveUsersTeams(u ...*UsersTeams) *TeamUpdate {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return tu.RemoveUsersTeamIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (tu *TeamUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, tu.sqlSave, tu.mutation, tu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (tu *TeamUpdate) SaveX(ctx context.Context) int {
	affected, err := tu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (tu *TeamUpdate) Exec(ctx context.Context) error {
	_, err := tu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (tu *TeamUpdate) ExecX(ctx context.Context) {
	if err := tu.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (tu *TeamUpdate) check() error {
	if v, ok := tu.mutation.Email(); ok {
		if err := team.EmailValidator(v); err != nil {
			return &ValidationError{Name: "email", err: fmt.Errorf(`models: validator failed for field "Team.email": %w`, err)}
		}
	}
	if _, ok := tu.mutation.TeamTierID(); tu.mutation.TeamTierCleared() && !ok {
		return errors.New(`models: clearing a required unique edge "Team.team_tier"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (tu *TeamUpdate) Modify(modifiers ...func(u *sql.UpdateBuilder)) *TeamUpdate {
	tu.modifiers = append(tu.modifiers, modifiers...)
	return tu
}

func (tu *TeamUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := tu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(team.Table, team.Columns, sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID))
	if ps := tu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := tu.mutation.IsBanned(); ok {
		_spec.SetField(team.FieldIsBanned, field.TypeBool, value)
	}
	if tu.mutation.IsBannedCleared() {
		_spec.ClearField(team.FieldIsBanned, field.TypeBool)
	}
	if value, ok := tu.mutation.IsBlocked(); ok {
		_spec.SetField(team.FieldIsBlocked, field.TypeBool, value)
	}
	if tu.mutation.IsBlockedCleared() {
		_spec.ClearField(team.FieldIsBlocked, field.TypeBool)
	}
	if value, ok := tu.mutation.BlockedReason(); ok {
		_spec.SetField(team.FieldBlockedReason, field.TypeString, value)
	}
	if tu.mutation.BlockedReasonCleared() {
		_spec.ClearField(team.FieldBlockedReason, field.TypeString)
	}
	if value, ok := tu.mutation.Name(); ok {
		_spec.SetField(team.FieldName, field.TypeString, value)
	}
	if value, ok := tu.mutation.Email(); ok {
		_spec.SetField(team.FieldEmail, field.TypeString, value)
	}
	if tu.mutation.UsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   team.UsersTable,
			Columns: team.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tu.schemaConfig.UsersTeams
		createE := &UsersTeamsCreate{config: tu.config, mutation: newUsersTeamsMutation(tu.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.RemovedUsersIDs(); len(nodes) > 0 && !tu.mutation.UsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   team.UsersTable,
			Columns: team.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tu.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &UsersTeamsCreate{config: tu.config, mutation: newUsersTeamsMutation(tu.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.UsersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   team.UsersTable,
			Columns: team.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tu.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &UsersTeamsCreate{config: tu.config, mutation: newUsersTeamsMutation(tu.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tu.mutation.TeamAPIKeysCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   team.TeamAPIKeysTable,
			Columns: []string{team.TeamAPIKeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tu.schemaConfig.TeamAPIKey
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.RemovedTeamAPIKeysIDs(); len(nodes) > 0 && !tu.mutation.TeamAPIKeysCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   team.TeamAPIKeysTable,
			Columns: []string{team.TeamAPIKeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tu.schemaConfig.TeamAPIKey
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.TeamAPIKeysIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   team.TeamAPIKeysTable,
			Columns: []string{team.TeamAPIKeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tu.schemaConfig.TeamAPIKey
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tu.mutation.TeamTierCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   team.TeamTierTable,
			Columns: []string{team.TeamTierColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tier.FieldID, field.TypeString),
			},
		}
		edge.Schema = tu.schemaConfig.Team
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.TeamTierIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   team.TeamTierTable,
			Columns: []string{team.TeamTierColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tier.FieldID, field.TypeString),
			},
		}
		edge.Schema = tu.schemaConfig.Team
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tu.mutation.EnvsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   team.EnvsTable,
			Columns: []string{team.EnvsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = tu.schemaConfig.Env
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.RemovedEnvsIDs(); len(nodes) > 0 && !tu.mutation.EnvsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   team.EnvsTable,
			Columns: []string{team.EnvsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = tu.schemaConfig.Env
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.EnvsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   team.EnvsTable,
			Columns: []string{team.EnvsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = tu.schemaConfig.Env
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tu.mutation.UsersTeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   team.UsersTeamsTable,
			Columns: []string{team.UsersTeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt),
			},
		}
		edge.Schema = tu.schemaConfig.UsersTeams
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.RemovedUsersTeamsIDs(); len(nodes) > 0 && !tu.mutation.UsersTeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   team.UsersTeamsTable,
			Columns: []string{team.UsersTeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt),
			},
		}
		edge.Schema = tu.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.UsersTeamsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   team.UsersTeamsTable,
			Columns: []string{team.UsersTeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt),
			},
		}
		edge.Schema = tu.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = tu.schemaConfig.Team
	ctx = internal.NewSchemaConfigContext(ctx, tu.schemaConfig)
	_spec.AddModifiers(tu.modifiers...)
	if n, err = sqlgraph.UpdateNodes(ctx, tu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{team.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	tu.mutation.done = true
	return n, nil
}

// TeamUpdateOne is the builder for updating a single Team entity.
type TeamUpdateOne struct {
	config
	fields    []string
	hooks     []Hook
	mutation  *TeamMutation
	modifiers []func(*sql.UpdateBuilder)
}

// SetIsBanned sets the "is_banned" field.
func (tuo *TeamUpdateOne) SetIsBanned(b bool) *TeamUpdateOne {
	tuo.mutation.SetIsBanned(b)
	return tuo
}

// SetNillableIsBanned sets the "is_banned" field if the given value is not nil.
func (tuo *TeamUpdateOne) SetNillableIsBanned(b *bool) *TeamUpdateOne {
	if b != nil {
		tuo.SetIsBanned(*b)
	}
	return tuo
}

// ClearIsBanned clears the value of the "is_banned" field.
func (tuo *TeamUpdateOne) ClearIsBanned() *TeamUpdateOne {
	tuo.mutation.ClearIsBanned()
	return tuo
}

// SetIsBlocked sets the "is_blocked" field.
func (tuo *TeamUpdateOne) SetIsBlocked(b bool) *TeamUpdateOne {
	tuo.mutation.SetIsBlocked(b)
	return tuo
}

// SetNillableIsBlocked sets the "is_blocked" field if the given value is not nil.
func (tuo *TeamUpdateOne) SetNillableIsBlocked(b *bool) *TeamUpdateOne {
	if b != nil {
		tuo.SetIsBlocked(*b)
	}
	return tuo
}

// ClearIsBlocked clears the value of the "is_blocked" field.
func (tuo *TeamUpdateOne) ClearIsBlocked() *TeamUpdateOne {
	tuo.mutation.ClearIsBlocked()
	return tuo
}

// SetBlockedReason sets the "blocked_reason" field.
func (tuo *TeamUpdateOne) SetBlockedReason(s string) *TeamUpdateOne {
	tuo.mutation.SetBlockedReason(s)
	return tuo
}

// SetNillableBlockedReason sets the "blocked_reason" field if the given value is not nil.
func (tuo *TeamUpdateOne) SetNillableBlockedReason(s *string) *TeamUpdateOne {
	if s != nil {
		tuo.SetBlockedReason(*s)
	}
	return tuo
}

// ClearBlockedReason clears the value of the "blocked_reason" field.
func (tuo *TeamUpdateOne) ClearBlockedReason() *TeamUpdateOne {
	tuo.mutation.ClearBlockedReason()
	return tuo
}

// SetName sets the "name" field.
func (tuo *TeamUpdateOne) SetName(s string) *TeamUpdateOne {
	tuo.mutation.SetName(s)
	return tuo
}

// SetNillableName sets the "name" field if the given value is not nil.
func (tuo *TeamUpdateOne) SetNillableName(s *string) *TeamUpdateOne {
	if s != nil {
		tuo.SetName(*s)
	}
	return tuo
}

// SetTier sets the "tier" field.
func (tuo *TeamUpdateOne) SetTier(s string) *TeamUpdateOne {
	tuo.mutation.SetTier(s)
	return tuo
}

// SetNillableTier sets the "tier" field if the given value is not nil.
func (tuo *TeamUpdateOne) SetNillableTier(s *string) *TeamUpdateOne {
	if s != nil {
		tuo.SetTier(*s)
	}
	return tuo
}

// SetEmail sets the "email" field.
func (tuo *TeamUpdateOne) SetEmail(s string) *TeamUpdateOne {
	tuo.mutation.SetEmail(s)
	return tuo
}

// SetNillableEmail sets the "email" field if the given value is not nil.
func (tuo *TeamUpdateOne) SetNillableEmail(s *string) *TeamUpdateOne {
	if s != nil {
		tuo.SetEmail(*s)
	}
	return tuo
}

// AddUserIDs adds the "users" edge to the User entity by IDs.
func (tuo *TeamUpdateOne) AddUserIDs(ids ...uuid.UUID) *TeamUpdateOne {
	tuo.mutation.AddUserIDs(ids...)
	return tuo
}

// AddUsers adds the "users" edges to the User entity.
func (tuo *TeamUpdateOne) AddUsers(u ...*User) *TeamUpdateOne {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return tuo.AddUserIDs(ids...)
}

// AddTeamAPIKeyIDs adds the "team_api_keys" edge to the TeamAPIKey entity by IDs.
func (tuo *TeamUpdateOne) AddTeamAPIKeyIDs(ids ...uuid.UUID) *TeamUpdateOne {
	tuo.mutation.AddTeamAPIKeyIDs(ids...)
	return tuo
}

// AddTeamAPIKeys adds the "team_api_keys" edges to the TeamAPIKey entity.
func (tuo *TeamUpdateOne) AddTeamAPIKeys(t ...*TeamAPIKey) *TeamUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tuo.AddTeamAPIKeyIDs(ids...)
}

// SetTeamTierID sets the "team_tier" edge to the Tier entity by ID.
func (tuo *TeamUpdateOne) SetTeamTierID(id string) *TeamUpdateOne {
	tuo.mutation.SetTeamTierID(id)
	return tuo
}

// SetTeamTier sets the "team_tier" edge to the Tier entity.
func (tuo *TeamUpdateOne) SetTeamTier(t *Tier) *TeamUpdateOne {
	return tuo.SetTeamTierID(t.ID)
}

// AddEnvIDs adds the "envs" edge to the Env entity by IDs.
func (tuo *TeamUpdateOne) AddEnvIDs(ids ...string) *TeamUpdateOne {
	tuo.mutation.AddEnvIDs(ids...)
	return tuo
}

// AddEnvs adds the "envs" edges to the Env entity.
func (tuo *TeamUpdateOne) AddEnvs(e ...*Env) *TeamUpdateOne {
	ids := make([]string, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return tuo.AddEnvIDs(ids...)
}

// AddUsersTeamIDs adds the "users_teams" edge to the UsersTeams entity by IDs.
func (tuo *TeamUpdateOne) AddUsersTeamIDs(ids ...int) *TeamUpdateOne {
	tuo.mutation.AddUsersTeamIDs(ids...)
	return tuo
}

// AddUsersTeams adds the "users_teams" edges to the UsersTeams entity.
func (tuo *TeamUpdateOne) AddUsersTeams(u ...*UsersTeams) *TeamUpdateOne {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return tuo.AddUsersTeamIDs(ids...)
}

// Mutation returns the TeamMutation object of the builder.
func (tuo *TeamUpdateOne) Mutation() *TeamMutation {
	return tuo.mutation
}

// ClearUsers clears all "users" edges to the User entity.
func (tuo *TeamUpdateOne) ClearUsers() *TeamUpdateOne {
	tuo.mutation.ClearUsers()
	return tuo
}

// RemoveUserIDs removes the "users" edge to User entities by IDs.
func (tuo *TeamUpdateOne) RemoveUserIDs(ids ...uuid.UUID) *TeamUpdateOne {
	tuo.mutation.RemoveUserIDs(ids...)
	return tuo
}

// RemoveUsers removes "users" edges to User entities.
func (tuo *TeamUpdateOne) RemoveUsers(u ...*User) *TeamUpdateOne {
	ids := make([]uuid.UUID, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return tuo.RemoveUserIDs(ids...)
}

// ClearTeamAPIKeys clears all "team_api_keys" edges to the TeamAPIKey entity.
func (tuo *TeamUpdateOne) ClearTeamAPIKeys() *TeamUpdateOne {
	tuo.mutation.ClearTeamAPIKeys()
	return tuo
}

// RemoveTeamAPIKeyIDs removes the "team_api_keys" edge to TeamAPIKey entities by IDs.
func (tuo *TeamUpdateOne) RemoveTeamAPIKeyIDs(ids ...uuid.UUID) *TeamUpdateOne {
	tuo.mutation.RemoveTeamAPIKeyIDs(ids...)
	return tuo
}

// RemoveTeamAPIKeys removes "team_api_keys" edges to TeamAPIKey entities.
func (tuo *TeamUpdateOne) RemoveTeamAPIKeys(t ...*TeamAPIKey) *TeamUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tuo.RemoveTeamAPIKeyIDs(ids...)
}

// ClearTeamTier clears the "team_tier" edge to the Tier entity.
func (tuo *TeamUpdateOne) ClearTeamTier() *TeamUpdateOne {
	tuo.mutation.ClearTeamTier()
	return tuo
}

// ClearEnvs clears all "envs" edges to the Env entity.
func (tuo *TeamUpdateOne) ClearEnvs() *TeamUpdateOne {
	tuo.mutation.ClearEnvs()
	return tuo
}

// RemoveEnvIDs removes the "envs" edge to Env entities by IDs.
func (tuo *TeamUpdateOne) RemoveEnvIDs(ids ...string) *TeamUpdateOne {
	tuo.mutation.RemoveEnvIDs(ids...)
	return tuo
}

// RemoveEnvs removes "envs" edges to Env entities.
func (tuo *TeamUpdateOne) RemoveEnvs(e ...*Env) *TeamUpdateOne {
	ids := make([]string, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return tuo.RemoveEnvIDs(ids...)
}

// ClearUsersTeams clears all "users_teams" edges to the UsersTeams entity.
func (tuo *TeamUpdateOne) ClearUsersTeams() *TeamUpdateOne {
	tuo.mutation.ClearUsersTeams()
	return tuo
}

// RemoveUsersTeamIDs removes the "users_teams" edge to UsersTeams entities by IDs.
func (tuo *TeamUpdateOne) RemoveUsersTeamIDs(ids ...int) *TeamUpdateOne {
	tuo.mutation.RemoveUsersTeamIDs(ids...)
	return tuo
}

// RemoveUsersTeams removes "users_teams" edges to UsersTeams entities.
func (tuo *TeamUpdateOne) RemoveUsersTeams(u ...*UsersTeams) *TeamUpdateOne {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return tuo.RemoveUsersTeamIDs(ids...)
}

// Where appends a list predicates to the TeamUpdate builder.
func (tuo *TeamUpdateOne) Where(ps ...predicate.Team) *TeamUpdateOne {
	tuo.mutation.Where(ps...)
	return tuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (tuo *TeamUpdateOne) Select(field string, fields ...string) *TeamUpdateOne {
	tuo.fields = append([]string{field}, fields...)
	return tuo
}

// Save executes the query and returns the updated Team entity.
func (tuo *TeamUpdateOne) Save(ctx context.Context) (*Team, error) {
	return withHooks(ctx, tuo.sqlSave, tuo.mutation, tuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (tuo *TeamUpdateOne) SaveX(ctx context.Context) *Team {
	node, err := tuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (tuo *TeamUpdateOne) Exec(ctx context.Context) error {
	_, err := tuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (tuo *TeamUpdateOne) ExecX(ctx context.Context) {
	if err := tuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (tuo *TeamUpdateOne) check() error {
	if v, ok := tuo.mutation.Email(); ok {
		if err := team.EmailValidator(v); err != nil {
			return &ValidationError{Name: "email", err: fmt.Errorf(`models: validator failed for field "Team.email": %w`, err)}
		}
	}
	if _, ok := tuo.mutation.TeamTierID(); tuo.mutation.TeamTierCleared() && !ok {
		return errors.New(`models: clearing a required unique edge "Team.team_tier"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (tuo *TeamUpdateOne) Modify(modifiers ...func(u *sql.UpdateBuilder)) *TeamUpdateOne {
	tuo.modifiers = append(tuo.modifiers, modifiers...)
	return tuo
}

func (tuo *TeamUpdateOne) sqlSave(ctx context.Context) (_node *Team, err error) {
	if err := tuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(team.Table, team.Columns, sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID))
	id, ok := tuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`models: missing "Team.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := tuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, team.FieldID)
		for _, f := range fields {
			if !team.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
			}
			if f != team.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := tuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := tuo.mutation.IsBanned(); ok {
		_spec.SetField(team.FieldIsBanned, field.TypeBool, value)
	}
	if tuo.mutation.IsBannedCleared() {
		_spec.ClearField(team.FieldIsBanned, field.TypeBool)
	}
	if value, ok := tuo.mutation.IsBlocked(); ok {
		_spec.SetField(team.FieldIsBlocked, field.TypeBool, value)
	}
	if tuo.mutation.IsBlockedCleared() {
		_spec.ClearField(team.FieldIsBlocked, field.TypeBool)
	}
	if value, ok := tuo.mutation.BlockedReason(); ok {
		_spec.SetField(team.FieldBlockedReason, field.TypeString, value)
	}
	if tuo.mutation.BlockedReasonCleared() {
		_spec.ClearField(team.FieldBlockedReason, field.TypeString)
	}
	if value, ok := tuo.mutation.Name(); ok {
		_spec.SetField(team.FieldName, field.TypeString, value)
	}
	if value, ok := tuo.mutation.Email(); ok {
		_spec.SetField(team.FieldEmail, field.TypeString, value)
	}
	if tuo.mutation.UsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   team.UsersTable,
			Columns: team.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tuo.schemaConfig.UsersTeams
		createE := &UsersTeamsCreate{config: tuo.config, mutation: newUsersTeamsMutation(tuo.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.RemovedUsersIDs(); len(nodes) > 0 && !tuo.mutation.UsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   team.UsersTable,
			Columns: team.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tuo.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &UsersTeamsCreate{config: tuo.config, mutation: newUsersTeamsMutation(tuo.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.UsersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   team.UsersTable,
			Columns: team.UsersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tuo.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &UsersTeamsCreate{config: tuo.config, mutation: newUsersTeamsMutation(tuo.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tuo.mutation.TeamAPIKeysCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   team.TeamAPIKeysTable,
			Columns: []string{team.TeamAPIKeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tuo.schemaConfig.TeamAPIKey
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.RemovedTeamAPIKeysIDs(); len(nodes) > 0 && !tuo.mutation.TeamAPIKeysCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   team.TeamAPIKeysTable,
			Columns: []string{team.TeamAPIKeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tuo.schemaConfig.TeamAPIKey
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.TeamAPIKeysIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   team.TeamAPIKeysTable,
			Columns: []string{team.TeamAPIKeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tuo.schemaConfig.TeamAPIKey
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tuo.mutation.TeamTierCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   team.TeamTierTable,
			Columns: []string{team.TeamTierColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tier.FieldID, field.TypeString),
			},
		}
		edge.Schema = tuo.schemaConfig.Team
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.TeamTierIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   team.TeamTierTable,
			Columns: []string{team.TeamTierColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(tier.FieldID, field.TypeString),
			},
		}
		edge.Schema = tuo.schemaConfig.Team
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tuo.mutation.EnvsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   team.EnvsTable,
			Columns: []string{team.EnvsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = tuo.schemaConfig.Env
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.RemovedEnvsIDs(); len(nodes) > 0 && !tuo.mutation.EnvsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   team.EnvsTable,
			Columns: []string{team.EnvsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = tuo.schemaConfig.Env
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.EnvsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   team.EnvsTable,
			Columns: []string{team.EnvsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = tuo.schemaConfig.Env
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if tuo.mutation.UsersTeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   team.UsersTeamsTable,
			Columns: []string{team.UsersTeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt),
			},
		}
		edge.Schema = tuo.schemaConfig.UsersTeams
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.RemovedUsersTeamsIDs(); len(nodes) > 0 && !tuo.mutation.UsersTeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   team.UsersTeamsTable,
			Columns: []string{team.UsersTeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt),
			},
		}
		edge.Schema = tuo.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.UsersTeamsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   team.UsersTeamsTable,
			Columns: []string{team.UsersTeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt),
			},
		}
		edge.Schema = tuo.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = tuo.schemaConfig.Team
	ctx = internal.NewSchemaConfigContext(ctx, tuo.schemaConfig)
	_spec.AddModifiers(tuo.modifiers...)
	_node = &Team{config: tuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, tuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{team.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	tuo.mutation.done = true
	return _node, nil
}



================================================
File: models/teamapikey.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/teamapikey"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/google/uuid"
)

// TeamAPIKey is the model entity for the TeamAPIKey schema.
type TeamAPIKey struct {
	config `json:"-"`
	// ID of the ent.
	ID uuid.UUID `json:"id,omitempty"`
	// APIKey holds the value of the "api_key" field.
	APIKey string `json:"-"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	// TeamID holds the value of the "team_id" field.
	TeamID uuid.UUID `json:"team_id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// CreatedBy holds the value of the "created_by" field.
	CreatedBy *uuid.UUID `json:"created_by,omitempty"`
	// LastUsed holds the value of the "last_used" field.
	LastUsed *time.Time `json:"last_used,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the TeamAPIKeyQuery when eager-loading is set.
	Edges        TeamAPIKeyEdges `json:"edges"`
	selectValues sql.SelectValues
}

// TeamAPIKeyEdges holds the relations/edges for other nodes in the graph.
type TeamAPIKeyEdges struct {
	// Team holds the value of the team edge.
	Team *Team `json:"team,omitempty"`
	// Creator holds the value of the creator edge.
	Creator *User `json:"creator,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// TeamOrErr returns the Team value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e TeamAPIKeyEdges) TeamOrErr() (*Team, error) {
	if e.loadedTypes[0] {
		if e.Team == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: team.Label}
		}
		return e.Team, nil
	}
	return nil, &NotLoadedError{edge: "team"}
}

// CreatorOrErr returns the Creator value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e TeamAPIKeyEdges) CreatorOrErr() (*User, error) {
	if e.loadedTypes[1] {
		if e.Creator == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: user.Label}
		}
		return e.Creator, nil
	}
	return nil, &NotLoadedError{edge: "creator"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*TeamAPIKey) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case teamapikey.FieldCreatedBy:
			values[i] = &sql.NullScanner{S: new(uuid.UUID)}
		case teamapikey.FieldAPIKey, teamapikey.FieldName:
			values[i] = new(sql.NullString)
		case teamapikey.FieldCreatedAt, teamapikey.FieldUpdatedAt, teamapikey.FieldLastUsed:
			values[i] = new(sql.NullTime)
		case teamapikey.FieldID, teamapikey.FieldTeamID:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the TeamAPIKey fields.
func (tak *TeamAPIKey) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case teamapikey.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				tak.ID = *value
			}
		case teamapikey.FieldAPIKey:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field api_key", values[i])
			} else if value.Valid {
				tak.APIKey = value.String
			}
		case teamapikey.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				tak.CreatedAt = value.Time
			}
		case teamapikey.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				tak.UpdatedAt = new(time.Time)
				*tak.UpdatedAt = value.Time
			}
		case teamapikey.FieldTeamID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field team_id", values[i])
			} else if value != nil {
				tak.TeamID = *value
			}
		case teamapikey.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				tak.Name = value.String
			}
		case teamapikey.FieldCreatedBy:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field created_by", values[i])
			} else if value.Valid {
				tak.CreatedBy = new(uuid.UUID)
				*tak.CreatedBy = *value.S.(*uuid.UUID)
			}
		case teamapikey.FieldLastUsed:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field last_used", values[i])
			} else if value.Valid {
				tak.LastUsed = new(time.Time)
				*tak.LastUsed = value.Time
			}
		default:
			tak.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the TeamAPIKey.
// This includes values selected through modifiers, order, etc.
func (tak *TeamAPIKey) Value(name string) (ent.Value, error) {
	return tak.selectValues.Get(name)
}

// QueryTeam queries the "team" edge of the TeamAPIKey entity.
func (tak *TeamAPIKey) QueryTeam() *TeamQuery {
	return NewTeamAPIKeyClient(tak.config).QueryTeam(tak)
}

// QueryCreator queries the "creator" edge of the TeamAPIKey entity.
func (tak *TeamAPIKey) QueryCreator() *UserQuery {
	return NewTeamAPIKeyClient(tak.config).QueryCreator(tak)
}

// Update returns a builder for updating this TeamAPIKey.
// Note that you need to call TeamAPIKey.Unwrap() before calling this method if this TeamAPIKey
// was returned from a transaction, and the transaction was committed or rolled back.
func (tak *TeamAPIKey) Update() *TeamAPIKeyUpdateOne {
	return NewTeamAPIKeyClient(tak.config).UpdateOne(tak)
}

// Unwrap unwraps the TeamAPIKey entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (tak *TeamAPIKey) Unwrap() *TeamAPIKey {
	_tx, ok := tak.config.driver.(*txDriver)
	if !ok {
		panic("models: TeamAPIKey is not a transactional entity")
	}
	tak.config.driver = _tx.drv
	return tak
}

// String implements the fmt.Stringer.
func (tak *TeamAPIKey) String() string {
	var builder strings.Builder
	builder.WriteString("TeamAPIKey(")
	builder.WriteString(fmt.Sprintf("id=%v, ", tak.ID))
	builder.WriteString("api_key=<sensitive>")
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(tak.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	if v := tak.UpdatedAt; v != nil {
		builder.WriteString("updated_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("team_id=")
	builder.WriteString(fmt.Sprintf("%v", tak.TeamID))
	builder.WriteString(", ")
	builder.WriteString("name=")
	builder.WriteString(tak.Name)
	builder.WriteString(", ")
	if v := tak.CreatedBy; v != nil {
		builder.WriteString("created_by=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := tak.LastUsed; v != nil {
		builder.WriteString("last_used=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteByte(')')
	return builder.String()
}

// TeamAPIKeys is a parsable slice of TeamAPIKey.
type TeamAPIKeys []*TeamAPIKey



================================================
File: models/teamapikey_create.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/teamapikey"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/google/uuid"
)

// TeamAPIKeyCreate is the builder for creating a TeamAPIKey entity.
type TeamAPIKeyCreate struct {
	config
	mutation *TeamAPIKeyMutation
	hooks    []Hook
	conflict []sql.ConflictOption
}

// SetAPIKey sets the "api_key" field.
func (takc *TeamAPIKeyCreate) SetAPIKey(s string) *TeamAPIKeyCreate {
	takc.mutation.SetAPIKey(s)
	return takc
}

// SetCreatedAt sets the "created_at" field.
func (takc *TeamAPIKeyCreate) SetCreatedAt(t time.Time) *TeamAPIKeyCreate {
	takc.mutation.SetCreatedAt(t)
	return takc
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (takc *TeamAPIKeyCreate) SetNillableCreatedAt(t *time.Time) *TeamAPIKeyCreate {
	if t != nil {
		takc.SetCreatedAt(*t)
	}
	return takc
}

// SetUpdatedAt sets the "updated_at" field.
func (takc *TeamAPIKeyCreate) SetUpdatedAt(t time.Time) *TeamAPIKeyCreate {
	takc.mutation.SetUpdatedAt(t)
	return takc
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (takc *TeamAPIKeyCreate) SetNillableUpdatedAt(t *time.Time) *TeamAPIKeyCreate {
	if t != nil {
		takc.SetUpdatedAt(*t)
	}
	return takc
}

// SetTeamID sets the "team_id" field.
func (takc *TeamAPIKeyCreate) SetTeamID(u uuid.UUID) *TeamAPIKeyCreate {
	takc.mutation.SetTeamID(u)
	return takc
}

// SetName sets the "name" field.
func (takc *TeamAPIKeyCreate) SetName(s string) *TeamAPIKeyCreate {
	takc.mutation.SetName(s)
	return takc
}

// SetNillableName sets the "name" field if the given value is not nil.
func (takc *TeamAPIKeyCreate) SetNillableName(s *string) *TeamAPIKeyCreate {
	if s != nil {
		takc.SetName(*s)
	}
	return takc
}

// SetCreatedBy sets the "created_by" field.
func (takc *TeamAPIKeyCreate) SetCreatedBy(u uuid.UUID) *TeamAPIKeyCreate {
	takc.mutation.SetCreatedBy(u)
	return takc
}

// SetNillableCreatedBy sets the "created_by" field if the given value is not nil.
func (takc *TeamAPIKeyCreate) SetNillableCreatedBy(u *uuid.UUID) *TeamAPIKeyCreate {
	if u != nil {
		takc.SetCreatedBy(*u)
	}
	return takc
}

// SetLastUsed sets the "last_used" field.
func (takc *TeamAPIKeyCreate) SetLastUsed(t time.Time) *TeamAPIKeyCreate {
	takc.mutation.SetLastUsed(t)
	return takc
}

// SetNillableLastUsed sets the "last_used" field if the given value is not nil.
func (takc *TeamAPIKeyCreate) SetNillableLastUsed(t *time.Time) *TeamAPIKeyCreate {
	if t != nil {
		takc.SetLastUsed(*t)
	}
	return takc
}

// SetID sets the "id" field.
func (takc *TeamAPIKeyCreate) SetID(u uuid.UUID) *TeamAPIKeyCreate {
	takc.mutation.SetID(u)
	return takc
}

// SetTeam sets the "team" edge to the Team entity.
func (takc *TeamAPIKeyCreate) SetTeam(t *Team) *TeamAPIKeyCreate {
	return takc.SetTeamID(t.ID)
}

// SetCreatorID sets the "creator" edge to the User entity by ID.
func (takc *TeamAPIKeyCreate) SetCreatorID(id uuid.UUID) *TeamAPIKeyCreate {
	takc.mutation.SetCreatorID(id)
	return takc
}

// SetNillableCreatorID sets the "creator" edge to the User entity by ID if the given value is not nil.
func (takc *TeamAPIKeyCreate) SetNillableCreatorID(id *uuid.UUID) *TeamAPIKeyCreate {
	if id != nil {
		takc = takc.SetCreatorID(*id)
	}
	return takc
}

// SetCreator sets the "creator" edge to the User entity.
func (takc *TeamAPIKeyCreate) SetCreator(u *User) *TeamAPIKeyCreate {
	return takc.SetCreatorID(u.ID)
}

// Mutation returns the TeamAPIKeyMutation object of the builder.
func (takc *TeamAPIKeyCreate) Mutation() *TeamAPIKeyMutation {
	return takc.mutation
}

// Save creates the TeamAPIKey in the database.
func (takc *TeamAPIKeyCreate) Save(ctx context.Context) (*TeamAPIKey, error) {
	takc.defaults()
	return withHooks(ctx, takc.sqlSave, takc.mutation, takc.hooks)
}

// SaveX calls Save and panics if Save returns an error.
func (takc *TeamAPIKeyCreate) SaveX(ctx context.Context) *TeamAPIKey {
	v, err := takc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (takc *TeamAPIKeyCreate) Exec(ctx context.Context) error {
	_, err := takc.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (takc *TeamAPIKeyCreate) ExecX(ctx context.Context) {
	if err := takc.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (takc *TeamAPIKeyCreate) defaults() {
	if _, ok := takc.mutation.CreatedAt(); !ok {
		v := teamapikey.DefaultCreatedAt()
		takc.mutation.SetCreatedAt(v)
	}
	if _, ok := takc.mutation.Name(); !ok {
		v := teamapikey.DefaultName
		takc.mutation.SetName(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (takc *TeamAPIKeyCreate) check() error {
	if _, ok := takc.mutation.APIKey(); !ok {
		return &ValidationError{Name: "api_key", err: errors.New(`models: missing required field "TeamAPIKey.api_key"`)}
	}
	if _, ok := takc.mutation.CreatedAt(); !ok {
		return &ValidationError{Name: "created_at", err: errors.New(`models: missing required field "TeamAPIKey.created_at"`)}
	}
	if _, ok := takc.mutation.TeamID(); !ok {
		return &ValidationError{Name: "team_id", err: errors.New(`models: missing required field "TeamAPIKey.team_id"`)}
	}
	if _, ok := takc.mutation.Name(); !ok {
		return &ValidationError{Name: "name", err: errors.New(`models: missing required field "TeamAPIKey.name"`)}
	}
	if _, ok := takc.mutation.TeamID(); !ok {
		return &ValidationError{Name: "team", err: errors.New(`models: missing required edge "TeamAPIKey.team"`)}
	}
	return nil
}

func (takc *TeamAPIKeyCreate) sqlSave(ctx context.Context) (*TeamAPIKey, error) {
	if err := takc.check(); err != nil {
		return nil, err
	}
	_node, _spec := takc.createSpec()
	if err := sqlgraph.CreateNode(ctx, takc.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	if _spec.ID.Value != nil {
		if id, ok := _spec.ID.Value.(*uuid.UUID); ok {
			_node.ID = *id
		} else if err := _node.ID.Scan(_spec.ID.Value); err != nil {
			return nil, err
		}
	}
	takc.mutation.id = &_node.ID
	takc.mutation.done = true
	return _node, nil
}

func (takc *TeamAPIKeyCreate) createSpec() (*TeamAPIKey, *sqlgraph.CreateSpec) {
	var (
		_node = &TeamAPIKey{config: takc.config}
		_spec = sqlgraph.NewCreateSpec(teamapikey.Table, sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID))
	)
	_spec.Schema = takc.schemaConfig.TeamAPIKey
	_spec.OnConflict = takc.conflict
	if id, ok := takc.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = &id
	}
	if value, ok := takc.mutation.APIKey(); ok {
		_spec.SetField(teamapikey.FieldAPIKey, field.TypeString, value)
		_node.APIKey = value
	}
	if value, ok := takc.mutation.CreatedAt(); ok {
		_spec.SetField(teamapikey.FieldCreatedAt, field.TypeTime, value)
		_node.CreatedAt = value
	}
	if value, ok := takc.mutation.UpdatedAt(); ok {
		_spec.SetField(teamapikey.FieldUpdatedAt, field.TypeTime, value)
		_node.UpdatedAt = &value
	}
	if value, ok := takc.mutation.Name(); ok {
		_spec.SetField(teamapikey.FieldName, field.TypeString, value)
		_node.Name = value
	}
	if value, ok := takc.mutation.LastUsed(); ok {
		_spec.SetField(teamapikey.FieldLastUsed, field.TypeTime, value)
		_node.LastUsed = &value
	}
	if nodes := takc.mutation.TeamIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   teamapikey.TeamTable,
			Columns: []string{teamapikey.TeamColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = takc.schemaConfig.TeamAPIKey
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.TeamID = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := takc.mutation.CreatorIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   teamapikey.CreatorTable,
			Columns: []string{teamapikey.CreatorColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = takc.schemaConfig.TeamAPIKey
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.CreatedBy = &nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.TeamAPIKey.Create().
//		SetAPIKey(v).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.TeamAPIKeyUpsert) {
//			SetAPIKey(v+v).
//		}).
//		Exec(ctx)
func (takc *TeamAPIKeyCreate) OnConflict(opts ...sql.ConflictOption) *TeamAPIKeyUpsertOne {
	takc.conflict = opts
	return &TeamAPIKeyUpsertOne{
		create: takc,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.TeamAPIKey.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (takc *TeamAPIKeyCreate) OnConflictColumns(columns ...string) *TeamAPIKeyUpsertOne {
	takc.conflict = append(takc.conflict, sql.ConflictColumns(columns...))
	return &TeamAPIKeyUpsertOne{
		create: takc,
	}
}

type (
	// TeamAPIKeyUpsertOne is the builder for "upsert"-ing
	//  one TeamAPIKey node.
	TeamAPIKeyUpsertOne struct {
		create *TeamAPIKeyCreate
	}

	// TeamAPIKeyUpsert is the "OnConflict" setter.
	TeamAPIKeyUpsert struct {
		*sql.UpdateSet
	}
)

// SetAPIKey sets the "api_key" field.
func (u *TeamAPIKeyUpsert) SetAPIKey(v string) *TeamAPIKeyUpsert {
	u.Set(teamapikey.FieldAPIKey, v)
	return u
}

// UpdateAPIKey sets the "api_key" field to the value that was provided on create.
func (u *TeamAPIKeyUpsert) UpdateAPIKey() *TeamAPIKeyUpsert {
	u.SetExcluded(teamapikey.FieldAPIKey)
	return u
}

// SetUpdatedAt sets the "updated_at" field.
func (u *TeamAPIKeyUpsert) SetUpdatedAt(v time.Time) *TeamAPIKeyUpsert {
	u.Set(teamapikey.FieldUpdatedAt, v)
	return u
}

// UpdateUpdatedAt sets the "updated_at" field to the value that was provided on create.
func (u *TeamAPIKeyUpsert) UpdateUpdatedAt() *TeamAPIKeyUpsert {
	u.SetExcluded(teamapikey.FieldUpdatedAt)
	return u
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (u *TeamAPIKeyUpsert) ClearUpdatedAt() *TeamAPIKeyUpsert {
	u.SetNull(teamapikey.FieldUpdatedAt)
	return u
}

// SetTeamID sets the "team_id" field.
func (u *TeamAPIKeyUpsert) SetTeamID(v uuid.UUID) *TeamAPIKeyUpsert {
	u.Set(teamapikey.FieldTeamID, v)
	return u
}

// UpdateTeamID sets the "team_id" field to the value that was provided on create.
func (u *TeamAPIKeyUpsert) UpdateTeamID() *TeamAPIKeyUpsert {
	u.SetExcluded(teamapikey.FieldTeamID)
	return u
}

// SetName sets the "name" field.
func (u *TeamAPIKeyUpsert) SetName(v string) *TeamAPIKeyUpsert {
	u.Set(teamapikey.FieldName, v)
	return u
}

// UpdateName sets the "name" field to the value that was provided on create.
func (u *TeamAPIKeyUpsert) UpdateName() *TeamAPIKeyUpsert {
	u.SetExcluded(teamapikey.FieldName)
	return u
}

// SetCreatedBy sets the "created_by" field.
func (u *TeamAPIKeyUpsert) SetCreatedBy(v uuid.UUID) *TeamAPIKeyUpsert {
	u.Set(teamapikey.FieldCreatedBy, v)
	return u
}

// UpdateCreatedBy sets the "created_by" field to the value that was provided on create.
func (u *TeamAPIKeyUpsert) UpdateCreatedBy() *TeamAPIKeyUpsert {
	u.SetExcluded(teamapikey.FieldCreatedBy)
	return u
}

// ClearCreatedBy clears the value of the "created_by" field.
func (u *TeamAPIKeyUpsert) ClearCreatedBy() *TeamAPIKeyUpsert {
	u.SetNull(teamapikey.FieldCreatedBy)
	return u
}

// SetLastUsed sets the "last_used" field.
func (u *TeamAPIKeyUpsert) SetLastUsed(v time.Time) *TeamAPIKeyUpsert {
	u.Set(teamapikey.FieldLastUsed, v)
	return u
}

// UpdateLastUsed sets the "last_used" field to the value that was provided on create.
func (u *TeamAPIKeyUpsert) UpdateLastUsed() *TeamAPIKeyUpsert {
	u.SetExcluded(teamapikey.FieldLastUsed)
	return u
}

// ClearLastUsed clears the value of the "last_used" field.
func (u *TeamAPIKeyUpsert) ClearLastUsed() *TeamAPIKeyUpsert {
	u.SetNull(teamapikey.FieldLastUsed)
	return u
}

// UpdateNewValues updates the mutable fields using the new values that were set on create except the ID field.
// Using this option is equivalent to using:
//
//	client.TeamAPIKey.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(teamapikey.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *TeamAPIKeyUpsertOne) UpdateNewValues() *TeamAPIKeyUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		if _, exists := u.create.mutation.ID(); exists {
			s.SetIgnore(teamapikey.FieldID)
		}
		if _, exists := u.create.mutation.CreatedAt(); exists {
			s.SetIgnore(teamapikey.FieldCreatedAt)
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.TeamAPIKey.Create().
//	    OnConflict(sql.ResolveWithIgnore()).
//	    Exec(ctx)
func (u *TeamAPIKeyUpsertOne) Ignore() *TeamAPIKeyUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *TeamAPIKeyUpsertOne) DoNothing() *TeamAPIKeyUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the TeamAPIKeyCreate.OnConflict
// documentation for more info.
func (u *TeamAPIKeyUpsertOne) Update(set func(*TeamAPIKeyUpsert)) *TeamAPIKeyUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&TeamAPIKeyUpsert{UpdateSet: update})
	}))
	return u
}

// SetAPIKey sets the "api_key" field.
func (u *TeamAPIKeyUpsertOne) SetAPIKey(v string) *TeamAPIKeyUpsertOne {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.SetAPIKey(v)
	})
}

// UpdateAPIKey sets the "api_key" field to the value that was provided on create.
func (u *TeamAPIKeyUpsertOne) UpdateAPIKey() *TeamAPIKeyUpsertOne {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.UpdateAPIKey()
	})
}

// SetUpdatedAt sets the "updated_at" field.
func (u *TeamAPIKeyUpsertOne) SetUpdatedAt(v time.Time) *TeamAPIKeyUpsertOne {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.SetUpdatedAt(v)
	})
}

// UpdateUpdatedAt sets the "updated_at" field to the value that was provided on create.
func (u *TeamAPIKeyUpsertOne) UpdateUpdatedAt() *TeamAPIKeyUpsertOne {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.UpdateUpdatedAt()
	})
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (u *TeamAPIKeyUpsertOne) ClearUpdatedAt() *TeamAPIKeyUpsertOne {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.ClearUpdatedAt()
	})
}

// SetTeamID sets the "team_id" field.
func (u *TeamAPIKeyUpsertOne) SetTeamID(v uuid.UUID) *TeamAPIKeyUpsertOne {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.SetTeamID(v)
	})
}

// UpdateTeamID sets the "team_id" field to the value that was provided on create.
func (u *TeamAPIKeyUpsertOne) UpdateTeamID() *TeamAPIKeyUpsertOne {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.UpdateTeamID()
	})
}

// SetName sets the "name" field.
func (u *TeamAPIKeyUpsertOne) SetName(v string) *TeamAPIKeyUpsertOne {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.SetName(v)
	})
}

// UpdateName sets the "name" field to the value that was provided on create.
func (u *TeamAPIKeyUpsertOne) UpdateName() *TeamAPIKeyUpsertOne {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.UpdateName()
	})
}

// SetCreatedBy sets the "created_by" field.
func (u *TeamAPIKeyUpsertOne) SetCreatedBy(v uuid.UUID) *TeamAPIKeyUpsertOne {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.SetCreatedBy(v)
	})
}

// UpdateCreatedBy sets the "created_by" field to the value that was provided on create.
func (u *TeamAPIKeyUpsertOne) UpdateCreatedBy() *TeamAPIKeyUpsertOne {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.UpdateCreatedBy()
	})
}

// ClearCreatedBy clears the value of the "created_by" field.
func (u *TeamAPIKeyUpsertOne) ClearCreatedBy() *TeamAPIKeyUpsertOne {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.ClearCreatedBy()
	})
}

// SetLastUsed sets the "last_used" field.
func (u *TeamAPIKeyUpsertOne) SetLastUsed(v time.Time) *TeamAPIKeyUpsertOne {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.SetLastUsed(v)
	})
}

// UpdateLastUsed sets the "last_used" field to the value that was provided on create.
func (u *TeamAPIKeyUpsertOne) UpdateLastUsed() *TeamAPIKeyUpsertOne {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.UpdateLastUsed()
	})
}

// ClearLastUsed clears the value of the "last_used" field.
func (u *TeamAPIKeyUpsertOne) ClearLastUsed() *TeamAPIKeyUpsertOne {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.ClearLastUsed()
	})
}

// Exec executes the query.
func (u *TeamAPIKeyUpsertOne) Exec(ctx context.Context) error {
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for TeamAPIKeyCreate.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *TeamAPIKeyUpsertOne) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}

// Exec executes the UPSERT query and returns the inserted/updated ID.
func (u *TeamAPIKeyUpsertOne) ID(ctx context.Context) (id uuid.UUID, err error) {
	if u.create.driver.Dialect() == dialect.MySQL {
		// In case of "ON CONFLICT", there is no way to get back non-numeric ID
		// fields from the database since MySQL does not support the RETURNING clause.
		return id, errors.New("models: TeamAPIKeyUpsertOne.ID is not supported by MySQL driver. Use TeamAPIKeyUpsertOne.Exec instead")
	}
	node, err := u.create.Save(ctx)
	if err != nil {
		return id, err
	}
	return node.ID, nil
}

// IDX is like ID, but panics if an error occurs.
func (u *TeamAPIKeyUpsertOne) IDX(ctx context.Context) uuid.UUID {
	id, err := u.ID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// TeamAPIKeyCreateBulk is the builder for creating many TeamAPIKey entities in bulk.
type TeamAPIKeyCreateBulk struct {
	config
	err      error
	builders []*TeamAPIKeyCreate
	conflict []sql.ConflictOption
}

// Save creates the TeamAPIKey entities in the database.
func (takcb *TeamAPIKeyCreateBulk) Save(ctx context.Context) ([]*TeamAPIKey, error) {
	if takcb.err != nil {
		return nil, takcb.err
	}
	specs := make([]*sqlgraph.CreateSpec, len(takcb.builders))
	nodes := make([]*TeamAPIKey, len(takcb.builders))
	mutators := make([]Mutator, len(takcb.builders))
	for i := range takcb.builders {
		func(i int, root context.Context) {
			builder := takcb.builders[i]
			builder.defaults()
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*TeamAPIKeyMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				var err error
				nodes[i], specs[i] = builder.createSpec()
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, takcb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					spec.OnConflict = takcb.conflict
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, takcb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{msg: err.Error(), wrap: err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, takcb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (takcb *TeamAPIKeyCreateBulk) SaveX(ctx context.Context) []*TeamAPIKey {
	v, err := takcb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (takcb *TeamAPIKeyCreateBulk) Exec(ctx context.Context) error {
	_, err := takcb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (takcb *TeamAPIKeyCreateBulk) ExecX(ctx context.Context) {
	if err := takcb.Exec(ctx); err != nil {
		panic(err)
	}
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.TeamAPIKey.CreateBulk(builders...).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.TeamAPIKeyUpsert) {
//			SetAPIKey(v+v).
//		}).
//		Exec(ctx)
func (takcb *TeamAPIKeyCreateBulk) OnConflict(opts ...sql.ConflictOption) *TeamAPIKeyUpsertBulk {
	takcb.conflict = opts
	return &TeamAPIKeyUpsertBulk{
		create: takcb,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.TeamAPIKey.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (takcb *TeamAPIKeyCreateBulk) OnConflictColumns(columns ...string) *TeamAPIKeyUpsertBulk {
	takcb.conflict = append(takcb.conflict, sql.ConflictColumns(columns...))
	return &TeamAPIKeyUpsertBulk{
		create: takcb,
	}
}

// TeamAPIKeyUpsertBulk is the builder for "upsert"-ing
// a bulk of TeamAPIKey nodes.
type TeamAPIKeyUpsertBulk struct {
	create *TeamAPIKeyCreateBulk
}

// UpdateNewValues updates the mutable fields using the new values that
// were set on create. Using this option is equivalent to using:
//
//	client.TeamAPIKey.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(teamapikey.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *TeamAPIKeyUpsertBulk) UpdateNewValues() *TeamAPIKeyUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		for _, b := range u.create.builders {
			if _, exists := b.mutation.ID(); exists {
				s.SetIgnore(teamapikey.FieldID)
			}
			if _, exists := b.mutation.CreatedAt(); exists {
				s.SetIgnore(teamapikey.FieldCreatedAt)
			}
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.TeamAPIKey.Create().
//		OnConflict(sql.ResolveWithIgnore()).
//		Exec(ctx)
func (u *TeamAPIKeyUpsertBulk) Ignore() *TeamAPIKeyUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *TeamAPIKeyUpsertBulk) DoNothing() *TeamAPIKeyUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the TeamAPIKeyCreateBulk.OnConflict
// documentation for more info.
func (u *TeamAPIKeyUpsertBulk) Update(set func(*TeamAPIKeyUpsert)) *TeamAPIKeyUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&TeamAPIKeyUpsert{UpdateSet: update})
	}))
	return u
}

// SetAPIKey sets the "api_key" field.
func (u *TeamAPIKeyUpsertBulk) SetAPIKey(v string) *TeamAPIKeyUpsertBulk {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.SetAPIKey(v)
	})
}

// UpdateAPIKey sets the "api_key" field to the value that was provided on create.
func (u *TeamAPIKeyUpsertBulk) UpdateAPIKey() *TeamAPIKeyUpsertBulk {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.UpdateAPIKey()
	})
}

// SetUpdatedAt sets the "updated_at" field.
func (u *TeamAPIKeyUpsertBulk) SetUpdatedAt(v time.Time) *TeamAPIKeyUpsertBulk {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.SetUpdatedAt(v)
	})
}

// UpdateUpdatedAt sets the "updated_at" field to the value that was provided on create.
func (u *TeamAPIKeyUpsertBulk) UpdateUpdatedAt() *TeamAPIKeyUpsertBulk {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.UpdateUpdatedAt()
	})
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (u *TeamAPIKeyUpsertBulk) ClearUpdatedAt() *TeamAPIKeyUpsertBulk {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.ClearUpdatedAt()
	})
}

// SetTeamID sets the "team_id" field.
func (u *TeamAPIKeyUpsertBulk) SetTeamID(v uuid.UUID) *TeamAPIKeyUpsertBulk {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.SetTeamID(v)
	})
}

// UpdateTeamID sets the "team_id" field to the value that was provided on create.
func (u *TeamAPIKeyUpsertBulk) UpdateTeamID() *TeamAPIKeyUpsertBulk {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.UpdateTeamID()
	})
}

// SetName sets the "name" field.
func (u *TeamAPIKeyUpsertBulk) SetName(v string) *TeamAPIKeyUpsertBulk {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.SetName(v)
	})
}

// UpdateName sets the "name" field to the value that was provided on create.
func (u *TeamAPIKeyUpsertBulk) UpdateName() *TeamAPIKeyUpsertBulk {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.UpdateName()
	})
}

// SetCreatedBy sets the "created_by" field.
func (u *TeamAPIKeyUpsertBulk) SetCreatedBy(v uuid.UUID) *TeamAPIKeyUpsertBulk {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.SetCreatedBy(v)
	})
}

// UpdateCreatedBy sets the "created_by" field to the value that was provided on create.
func (u *TeamAPIKeyUpsertBulk) UpdateCreatedBy() *TeamAPIKeyUpsertBulk {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.UpdateCreatedBy()
	})
}

// ClearCreatedBy clears the value of the "created_by" field.
func (u *TeamAPIKeyUpsertBulk) ClearCreatedBy() *TeamAPIKeyUpsertBulk {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.ClearCreatedBy()
	})
}

// SetLastUsed sets the "last_used" field.
func (u *TeamAPIKeyUpsertBulk) SetLastUsed(v time.Time) *TeamAPIKeyUpsertBulk {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.SetLastUsed(v)
	})
}

// UpdateLastUsed sets the "last_used" field to the value that was provided on create.
func (u *TeamAPIKeyUpsertBulk) UpdateLastUsed() *TeamAPIKeyUpsertBulk {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.UpdateLastUsed()
	})
}

// ClearLastUsed clears the value of the "last_used" field.
func (u *TeamAPIKeyUpsertBulk) ClearLastUsed() *TeamAPIKeyUpsertBulk {
	return u.Update(func(s *TeamAPIKeyUpsert) {
		s.ClearLastUsed()
	})
}

// Exec executes the query.
func (u *TeamAPIKeyUpsertBulk) Exec(ctx context.Context) error {
	if u.create.err != nil {
		return u.create.err
	}
	for i, b := range u.create.builders {
		if len(b.conflict) != 0 {
			return fmt.Errorf("models: OnConflict was set for builder %d. Set it on the TeamAPIKeyCreateBulk instead", i)
		}
	}
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for TeamAPIKeyCreateBulk.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *TeamAPIKeyUpsertBulk) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/teamapikey_delete.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/teamapikey"
)

// TeamAPIKeyDelete is the builder for deleting a TeamAPIKey entity.
type TeamAPIKeyDelete struct {
	config
	hooks    []Hook
	mutation *TeamAPIKeyMutation
}

// Where appends a list predicates to the TeamAPIKeyDelete builder.
func (takd *TeamAPIKeyDelete) Where(ps ...predicate.TeamAPIKey) *TeamAPIKeyDelete {
	takd.mutation.Where(ps...)
	return takd
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (takd *TeamAPIKeyDelete) Exec(ctx context.Context) (int, error) {
	return withHooks(ctx, takd.sqlExec, takd.mutation, takd.hooks)
}

// ExecX is like Exec, but panics if an error occurs.
func (takd *TeamAPIKeyDelete) ExecX(ctx context.Context) int {
	n, err := takd.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (takd *TeamAPIKeyDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := sqlgraph.NewDeleteSpec(teamapikey.Table, sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID))
	_spec.Node.Schema = takd.schemaConfig.TeamAPIKey
	ctx = internal.NewSchemaConfigContext(ctx, takd.schemaConfig)
	if ps := takd.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	affected, err := sqlgraph.DeleteNodes(ctx, takd.driver, _spec)
	if err != nil && sqlgraph.IsConstraintError(err) {
		err = &ConstraintError{msg: err.Error(), wrap: err}
	}
	takd.mutation.done = true
	return affected, err
}

// TeamAPIKeyDeleteOne is the builder for deleting a single TeamAPIKey entity.
type TeamAPIKeyDeleteOne struct {
	takd *TeamAPIKeyDelete
}

// Where appends a list predicates to the TeamAPIKeyDelete builder.
func (takdo *TeamAPIKeyDeleteOne) Where(ps ...predicate.TeamAPIKey) *TeamAPIKeyDeleteOne {
	takdo.takd.mutation.Where(ps...)
	return takdo
}

// Exec executes the deletion query.
func (takdo *TeamAPIKeyDeleteOne) Exec(ctx context.Context) error {
	n, err := takdo.takd.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{teamapikey.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (takdo *TeamAPIKeyDeleteOne) ExecX(ctx context.Context) {
	if err := takdo.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/teamapikey_query.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"fmt"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/teamapikey"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/google/uuid"
)

// TeamAPIKeyQuery is the builder for querying TeamAPIKey entities.
type TeamAPIKeyQuery struct {
	config
	ctx         *QueryContext
	order       []teamapikey.OrderOption
	inters      []Interceptor
	predicates  []predicate.TeamAPIKey
	withTeam    *TeamQuery
	withCreator *UserQuery
	modifiers   []func(*sql.Selector)
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the TeamAPIKeyQuery builder.
func (takq *TeamAPIKeyQuery) Where(ps ...predicate.TeamAPIKey) *TeamAPIKeyQuery {
	takq.predicates = append(takq.predicates, ps...)
	return takq
}

// Limit the number of records to be returned by this query.
func (takq *TeamAPIKeyQuery) Limit(limit int) *TeamAPIKeyQuery {
	takq.ctx.Limit = &limit
	return takq
}

// Offset to start from.
func (takq *TeamAPIKeyQuery) Offset(offset int) *TeamAPIKeyQuery {
	takq.ctx.Offset = &offset
	return takq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (takq *TeamAPIKeyQuery) Unique(unique bool) *TeamAPIKeyQuery {
	takq.ctx.Unique = &unique
	return takq
}

// Order specifies how the records should be ordered.
func (takq *TeamAPIKeyQuery) Order(o ...teamapikey.OrderOption) *TeamAPIKeyQuery {
	takq.order = append(takq.order, o...)
	return takq
}

// QueryTeam chains the current query on the "team" edge.
func (takq *TeamAPIKeyQuery) QueryTeam() *TeamQuery {
	query := (&TeamClient{config: takq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := takq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := takq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(teamapikey.Table, teamapikey.FieldID, selector),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, teamapikey.TeamTable, teamapikey.TeamColumn),
		)
		schemaConfig := takq.schemaConfig
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.TeamAPIKey
		fromU = sqlgraph.SetNeighbors(takq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCreator chains the current query on the "creator" edge.
func (takq *TeamAPIKeyQuery) QueryCreator() *UserQuery {
	query := (&UserClient{config: takq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := takq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := takq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(teamapikey.Table, teamapikey.FieldID, selector),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, teamapikey.CreatorTable, teamapikey.CreatorColumn),
		)
		schemaConfig := takq.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.TeamAPIKey
		fromU = sqlgraph.SetNeighbors(takq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first TeamAPIKey entity from the query.
// Returns a *NotFoundError when no TeamAPIKey was found.
func (takq *TeamAPIKeyQuery) First(ctx context.Context) (*TeamAPIKey, error) {
	nodes, err := takq.Limit(1).All(setContextOp(ctx, takq.ctx, "First"))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{teamapikey.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (takq *TeamAPIKeyQuery) FirstX(ctx context.Context) *TeamAPIKey {
	node, err := takq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first TeamAPIKey ID from the query.
// Returns a *NotFoundError when no TeamAPIKey ID was found.
func (takq *TeamAPIKeyQuery) FirstID(ctx context.Context) (id uuid.UUID, err error) {
	var ids []uuid.UUID
	if ids, err = takq.Limit(1).IDs(setContextOp(ctx, takq.ctx, "FirstID")); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{teamapikey.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (takq *TeamAPIKeyQuery) FirstIDX(ctx context.Context) uuid.UUID {
	id, err := takq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single TeamAPIKey entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one TeamAPIKey entity is found.
// Returns a *NotFoundError when no TeamAPIKey entities are found.
func (takq *TeamAPIKeyQuery) Only(ctx context.Context) (*TeamAPIKey, error) {
	nodes, err := takq.Limit(2).All(setContextOp(ctx, takq.ctx, "Only"))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{teamapikey.Label}
	default:
		return nil, &NotSingularError{teamapikey.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (takq *TeamAPIKeyQuery) OnlyX(ctx context.Context) *TeamAPIKey {
	node, err := takq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only TeamAPIKey ID in the query.
// Returns a *NotSingularError when more than one TeamAPIKey ID is found.
// Returns a *NotFoundError when no entities are found.
func (takq *TeamAPIKeyQuery) OnlyID(ctx context.Context) (id uuid.UUID, err error) {
	var ids []uuid.UUID
	if ids, err = takq.Limit(2).IDs(setContextOp(ctx, takq.ctx, "OnlyID")); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{teamapikey.Label}
	default:
		err = &NotSingularError{teamapikey.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (takq *TeamAPIKeyQuery) OnlyIDX(ctx context.Context) uuid.UUID {
	id, err := takq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of TeamAPIKeys.
func (takq *TeamAPIKeyQuery) All(ctx context.Context) ([]*TeamAPIKey, error) {
	ctx = setContextOp(ctx, takq.ctx, "All")
	if err := takq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*TeamAPIKey, *TeamAPIKeyQuery]()
	return withInterceptors[[]*TeamAPIKey](ctx, takq, qr, takq.inters)
}

// AllX is like All, but panics if an error occurs.
func (takq *TeamAPIKeyQuery) AllX(ctx context.Context) []*TeamAPIKey {
	nodes, err := takq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of TeamAPIKey IDs.
func (takq *TeamAPIKeyQuery) IDs(ctx context.Context) (ids []uuid.UUID, err error) {
	if takq.ctx.Unique == nil && takq.path != nil {
		takq.Unique(true)
	}
	ctx = setContextOp(ctx, takq.ctx, "IDs")
	if err = takq.Select(teamapikey.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (takq *TeamAPIKeyQuery) IDsX(ctx context.Context) []uuid.UUID {
	ids, err := takq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (takq *TeamAPIKeyQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, takq.ctx, "Count")
	if err := takq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, takq, querierCount[*TeamAPIKeyQuery](), takq.inters)
}

// CountX is like Count, but panics if an error occurs.
func (takq *TeamAPIKeyQuery) CountX(ctx context.Context) int {
	count, err := takq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (takq *TeamAPIKeyQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, takq.ctx, "Exist")
	switch _, err := takq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("models: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (takq *TeamAPIKeyQuery) ExistX(ctx context.Context) bool {
	exist, err := takq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the TeamAPIKeyQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (takq *TeamAPIKeyQuery) Clone() *TeamAPIKeyQuery {
	if takq == nil {
		return nil
	}
	return &TeamAPIKeyQuery{
		config:      takq.config,
		ctx:         takq.ctx.Clone(),
		order:       append([]teamapikey.OrderOption{}, takq.order...),
		inters:      append([]Interceptor{}, takq.inters...),
		predicates:  append([]predicate.TeamAPIKey{}, takq.predicates...),
		withTeam:    takq.withTeam.Clone(),
		withCreator: takq.withCreator.Clone(),
		// clone intermediate query.
		sql:  takq.sql.Clone(),
		path: takq.path,
	}
}

// WithTeam tells the query-builder to eager-load the nodes that are connected to
// the "team" edge. The optional arguments are used to configure the query builder of the edge.
func (takq *TeamAPIKeyQuery) WithTeam(opts ...func(*TeamQuery)) *TeamAPIKeyQuery {
	query := (&TeamClient{config: takq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	takq.withTeam = query
	return takq
}

// WithCreator tells the query-builder to eager-load the nodes that are connected to
// the "creator" edge. The optional arguments are used to configure the query builder of the edge.
func (takq *TeamAPIKeyQuery) WithCreator(opts ...func(*UserQuery)) *TeamAPIKeyQuery {
	query := (&UserClient{config: takq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	takq.withCreator = query
	return takq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		APIKey string `json:"api_key,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.TeamAPIKey.Query().
//		GroupBy(teamapikey.FieldAPIKey).
//		Aggregate(models.Count()).
//		Scan(ctx, &v)
func (takq *TeamAPIKeyQuery) GroupBy(field string, fields ...string) *TeamAPIKeyGroupBy {
	takq.ctx.Fields = append([]string{field}, fields...)
	grbuild := &TeamAPIKeyGroupBy{build: takq}
	grbuild.flds = &takq.ctx.Fields
	grbuild.label = teamapikey.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		APIKey string `json:"api_key,omitempty"`
//	}
//
//	client.TeamAPIKey.Query().
//		Select(teamapikey.FieldAPIKey).
//		Scan(ctx, &v)
func (takq *TeamAPIKeyQuery) Select(fields ...string) *TeamAPIKeySelect {
	takq.ctx.Fields = append(takq.ctx.Fields, fields...)
	sbuild := &TeamAPIKeySelect{TeamAPIKeyQuery: takq}
	sbuild.label = teamapikey.Label
	sbuild.flds, sbuild.scan = &takq.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a TeamAPIKeySelect configured with the given aggregations.
func (takq *TeamAPIKeyQuery) Aggregate(fns ...AggregateFunc) *TeamAPIKeySelect {
	return takq.Select().Aggregate(fns...)
}

func (takq *TeamAPIKeyQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range takq.inters {
		if inter == nil {
			return fmt.Errorf("models: uninitialized interceptor (forgotten import models/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, takq); err != nil {
				return err
			}
		}
	}
	for _, f := range takq.ctx.Fields {
		if !teamapikey.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
		}
	}
	if takq.path != nil {
		prev, err := takq.path(ctx)
		if err != nil {
			return err
		}
		takq.sql = prev
	}
	return nil
}

func (takq *TeamAPIKeyQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*TeamAPIKey, error) {
	var (
		nodes       = []*TeamAPIKey{}
		_spec       = takq.querySpec()
		loadedTypes = [2]bool{
			takq.withTeam != nil,
			takq.withCreator != nil,
		}
	)
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*TeamAPIKey).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &TeamAPIKey{config: takq.config}
		nodes = append(nodes, node)
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	_spec.Node.Schema = takq.schemaConfig.TeamAPIKey
	ctx = internal.NewSchemaConfigContext(ctx, takq.schemaConfig)
	if len(takq.modifiers) > 0 {
		_spec.Modifiers = takq.modifiers
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, takq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	if query := takq.withTeam; query != nil {
		if err := takq.loadTeam(ctx, query, nodes, nil,
			func(n *TeamAPIKey, e *Team) { n.Edges.Team = e }); err != nil {
			return nil, err
		}
	}
	if query := takq.withCreator; query != nil {
		if err := takq.loadCreator(ctx, query, nodes, nil,
			func(n *TeamAPIKey, e *User) { n.Edges.Creator = e }); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

func (takq *TeamAPIKeyQuery) loadTeam(ctx context.Context, query *TeamQuery, nodes []*TeamAPIKey, init func(*TeamAPIKey), assign func(*TeamAPIKey, *Team)) error {
	ids := make([]uuid.UUID, 0, len(nodes))
	nodeids := make(map[uuid.UUID][]*TeamAPIKey)
	for i := range nodes {
		fk := nodes[i].TeamID
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(team.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "team_id" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}
func (takq *TeamAPIKeyQuery) loadCreator(ctx context.Context, query *UserQuery, nodes []*TeamAPIKey, init func(*TeamAPIKey), assign func(*TeamAPIKey, *User)) error {
	ids := make([]uuid.UUID, 0, len(nodes))
	nodeids := make(map[uuid.UUID][]*TeamAPIKey)
	for i := range nodes {
		if nodes[i].CreatedBy == nil {
			continue
		}
		fk := *nodes[i].CreatedBy
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(user.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "created_by" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}

func (takq *TeamAPIKeyQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := takq.querySpec()
	_spec.Node.Schema = takq.schemaConfig.TeamAPIKey
	ctx = internal.NewSchemaConfigContext(ctx, takq.schemaConfig)
	if len(takq.modifiers) > 0 {
		_spec.Modifiers = takq.modifiers
	}
	_spec.Node.Columns = takq.ctx.Fields
	if len(takq.ctx.Fields) > 0 {
		_spec.Unique = takq.ctx.Unique != nil && *takq.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, takq.driver, _spec)
}

func (takq *TeamAPIKeyQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(teamapikey.Table, teamapikey.Columns, sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID))
	_spec.From = takq.sql
	if unique := takq.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if takq.path != nil {
		_spec.Unique = true
	}
	if fields := takq.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, teamapikey.FieldID)
		for i := range fields {
			if fields[i] != teamapikey.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
		if takq.withTeam != nil {
			_spec.Node.AddColumnOnce(teamapikey.FieldTeamID)
		}
		if takq.withCreator != nil {
			_spec.Node.AddColumnOnce(teamapikey.FieldCreatedBy)
		}
	}
	if ps := takq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := takq.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := takq.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := takq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (takq *TeamAPIKeyQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(takq.driver.Dialect())
	t1 := builder.Table(teamapikey.Table)
	columns := takq.ctx.Fields
	if len(columns) == 0 {
		columns = teamapikey.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if takq.sql != nil {
		selector = takq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if takq.ctx.Unique != nil && *takq.ctx.Unique {
		selector.Distinct()
	}
	t1.Schema(takq.schemaConfig.TeamAPIKey)
	ctx = internal.NewSchemaConfigContext(ctx, takq.schemaConfig)
	selector.WithContext(ctx)
	for _, m := range takq.modifiers {
		m(selector)
	}
	for _, p := range takq.predicates {
		p(selector)
	}
	for _, p := range takq.order {
		p(selector)
	}
	if offset := takq.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := takq.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// Modify adds a query modifier for attaching custom logic to queries.
func (takq *TeamAPIKeyQuery) Modify(modifiers ...func(s *sql.Selector)) *TeamAPIKeySelect {
	takq.modifiers = append(takq.modifiers, modifiers...)
	return takq.Select()
}

// TeamAPIKeyGroupBy is the group-by builder for TeamAPIKey entities.
type TeamAPIKeyGroupBy struct {
	selector
	build *TeamAPIKeyQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (takgb *TeamAPIKeyGroupBy) Aggregate(fns ...AggregateFunc) *TeamAPIKeyGroupBy {
	takgb.fns = append(takgb.fns, fns...)
	return takgb
}

// Scan applies the selector query and scans the result into the given value.
func (takgb *TeamAPIKeyGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, takgb.build.ctx, "GroupBy")
	if err := takgb.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*TeamAPIKeyQuery, *TeamAPIKeyGroupBy](ctx, takgb.build, takgb, takgb.build.inters, v)
}

func (takgb *TeamAPIKeyGroupBy) sqlScan(ctx context.Context, root *TeamAPIKeyQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(takgb.fns))
	for _, fn := range takgb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*takgb.flds)+len(takgb.fns))
		for _, f := range *takgb.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*takgb.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := takgb.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// TeamAPIKeySelect is the builder for selecting fields of TeamAPIKey entities.
type TeamAPIKeySelect struct {
	*TeamAPIKeyQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (taks *TeamAPIKeySelect) Aggregate(fns ...AggregateFunc) *TeamAPIKeySelect {
	taks.fns = append(taks.fns, fns...)
	return taks
}

// Scan applies the selector query and scans the result into the given value.
func (taks *TeamAPIKeySelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, taks.ctx, "Select")
	if err := taks.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*TeamAPIKeyQuery, *TeamAPIKeySelect](ctx, taks.TeamAPIKeyQuery, taks, taks.inters, v)
}

func (taks *TeamAPIKeySelect) sqlScan(ctx context.Context, root *TeamAPIKeyQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(taks.fns))
	for _, fn := range taks.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*taks.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := taks.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// Modify adds a query modifier for attaching custom logic to queries.
func (taks *TeamAPIKeySelect) Modify(modifiers ...func(s *sql.Selector)) *TeamAPIKeySelect {
	taks.modifiers = append(taks.modifiers, modifiers...)
	return taks
}



================================================
File: models/teamapikey_update.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/teamapikey"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/google/uuid"
)

// TeamAPIKeyUpdate is the builder for updating TeamAPIKey entities.
type TeamAPIKeyUpdate struct {
	config
	hooks     []Hook
	mutation  *TeamAPIKeyMutation
	modifiers []func(*sql.UpdateBuilder)
}

// Where appends a list predicates to the TeamAPIKeyUpdate builder.
func (taku *TeamAPIKeyUpdate) Where(ps ...predicate.TeamAPIKey) *TeamAPIKeyUpdate {
	taku.mutation.Where(ps...)
	return taku
}

// SetAPIKey sets the "api_key" field.
func (taku *TeamAPIKeyUpdate) SetAPIKey(s string) *TeamAPIKeyUpdate {
	taku.mutation.SetAPIKey(s)
	return taku
}

// SetNillableAPIKey sets the "api_key" field if the given value is not nil.
func (taku *TeamAPIKeyUpdate) SetNillableAPIKey(s *string) *TeamAPIKeyUpdate {
	if s != nil {
		taku.SetAPIKey(*s)
	}
	return taku
}

// SetUpdatedAt sets the "updated_at" field.
func (taku *TeamAPIKeyUpdate) SetUpdatedAt(t time.Time) *TeamAPIKeyUpdate {
	taku.mutation.SetUpdatedAt(t)
	return taku
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (taku *TeamAPIKeyUpdate) SetNillableUpdatedAt(t *time.Time) *TeamAPIKeyUpdate {
	if t != nil {
		taku.SetUpdatedAt(*t)
	}
	return taku
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (taku *TeamAPIKeyUpdate) ClearUpdatedAt() *TeamAPIKeyUpdate {
	taku.mutation.ClearUpdatedAt()
	return taku
}

// SetTeamID sets the "team_id" field.
func (taku *TeamAPIKeyUpdate) SetTeamID(u uuid.UUID) *TeamAPIKeyUpdate {
	taku.mutation.SetTeamID(u)
	return taku
}

// SetNillableTeamID sets the "team_id" field if the given value is not nil.
func (taku *TeamAPIKeyUpdate) SetNillableTeamID(u *uuid.UUID) *TeamAPIKeyUpdate {
	if u != nil {
		taku.SetTeamID(*u)
	}
	return taku
}

// SetName sets the "name" field.
func (taku *TeamAPIKeyUpdate) SetName(s string) *TeamAPIKeyUpdate {
	taku.mutation.SetName(s)
	return taku
}

// SetNillableName sets the "name" field if the given value is not nil.
func (taku *TeamAPIKeyUpdate) SetNillableName(s *string) *TeamAPIKeyUpdate {
	if s != nil {
		taku.SetName(*s)
	}
	return taku
}

// SetCreatedBy sets the "created_by" field.
func (taku *TeamAPIKeyUpdate) SetCreatedBy(u uuid.UUID) *TeamAPIKeyUpdate {
	taku.mutation.SetCreatedBy(u)
	return taku
}

// SetNillableCreatedBy sets the "created_by" field if the given value is not nil.
func (taku *TeamAPIKeyUpdate) SetNillableCreatedBy(u *uuid.UUID) *TeamAPIKeyUpdate {
	if u != nil {
		taku.SetCreatedBy(*u)
	}
	return taku
}

// ClearCreatedBy clears the value of the "created_by" field.
func (taku *TeamAPIKeyUpdate) ClearCreatedBy() *TeamAPIKeyUpdate {
	taku.mutation.ClearCreatedBy()
	return taku
}

// SetLastUsed sets the "last_used" field.
func (taku *TeamAPIKeyUpdate) SetLastUsed(t time.Time) *TeamAPIKeyUpdate {
	taku.mutation.SetLastUsed(t)
	return taku
}

// SetNillableLastUsed sets the "last_used" field if the given value is not nil.
func (taku *TeamAPIKeyUpdate) SetNillableLastUsed(t *time.Time) *TeamAPIKeyUpdate {
	if t != nil {
		taku.SetLastUsed(*t)
	}
	return taku
}

// ClearLastUsed clears the value of the "last_used" field.
func (taku *TeamAPIKeyUpdate) ClearLastUsed() *TeamAPIKeyUpdate {
	taku.mutation.ClearLastUsed()
	return taku
}

// SetTeam sets the "team" edge to the Team entity.
func (taku *TeamAPIKeyUpdate) SetTeam(t *Team) *TeamAPIKeyUpdate {
	return taku.SetTeamID(t.ID)
}

// SetCreatorID sets the "creator" edge to the User entity by ID.
func (taku *TeamAPIKeyUpdate) SetCreatorID(id uuid.UUID) *TeamAPIKeyUpdate {
	taku.mutation.SetCreatorID(id)
	return taku
}

// SetNillableCreatorID sets the "creator" edge to the User entity by ID if the given value is not nil.
func (taku *TeamAPIKeyUpdate) SetNillableCreatorID(id *uuid.UUID) *TeamAPIKeyUpdate {
	if id != nil {
		taku = taku.SetCreatorID(*id)
	}
	return taku
}

// SetCreator sets the "creator" edge to the User entity.
func (taku *TeamAPIKeyUpdate) SetCreator(u *User) *TeamAPIKeyUpdate {
	return taku.SetCreatorID(u.ID)
}

// Mutation returns the TeamAPIKeyMutation object of the builder.
func (taku *TeamAPIKeyUpdate) Mutation() *TeamAPIKeyMutation {
	return taku.mutation
}

// ClearTeam clears the "team" edge to the Team entity.
func (taku *TeamAPIKeyUpdate) ClearTeam() *TeamAPIKeyUpdate {
	taku.mutation.ClearTeam()
	return taku
}

// ClearCreator clears the "creator" edge to the User entity.
func (taku *TeamAPIKeyUpdate) ClearCreator() *TeamAPIKeyUpdate {
	taku.mutation.ClearCreator()
	return taku
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (taku *TeamAPIKeyUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, taku.sqlSave, taku.mutation, taku.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (taku *TeamAPIKeyUpdate) SaveX(ctx context.Context) int {
	affected, err := taku.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (taku *TeamAPIKeyUpdate) Exec(ctx context.Context) error {
	_, err := taku.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (taku *TeamAPIKeyUpdate) ExecX(ctx context.Context) {
	if err := taku.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (taku *TeamAPIKeyUpdate) check() error {
	if _, ok := taku.mutation.TeamID(); taku.mutation.TeamCleared() && !ok {
		return errors.New(`models: clearing a required unique edge "TeamAPIKey.team"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (taku *TeamAPIKeyUpdate) Modify(modifiers ...func(u *sql.UpdateBuilder)) *TeamAPIKeyUpdate {
	taku.modifiers = append(taku.modifiers, modifiers...)
	return taku
}

func (taku *TeamAPIKeyUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := taku.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(teamapikey.Table, teamapikey.Columns, sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID))
	if ps := taku.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := taku.mutation.APIKey(); ok {
		_spec.SetField(teamapikey.FieldAPIKey, field.TypeString, value)
	}
	if value, ok := taku.mutation.UpdatedAt(); ok {
		_spec.SetField(teamapikey.FieldUpdatedAt, field.TypeTime, value)
	}
	if taku.mutation.UpdatedAtCleared() {
		_spec.ClearField(teamapikey.FieldUpdatedAt, field.TypeTime)
	}
	if value, ok := taku.mutation.Name(); ok {
		_spec.SetField(teamapikey.FieldName, field.TypeString, value)
	}
	if value, ok := taku.mutation.LastUsed(); ok {
		_spec.SetField(teamapikey.FieldLastUsed, field.TypeTime, value)
	}
	if taku.mutation.LastUsedCleared() {
		_spec.ClearField(teamapikey.FieldLastUsed, field.TypeTime)
	}
	if taku.mutation.TeamCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   teamapikey.TeamTable,
			Columns: []string{teamapikey.TeamColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = taku.schemaConfig.TeamAPIKey
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := taku.mutation.TeamIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   teamapikey.TeamTable,
			Columns: []string{teamapikey.TeamColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = taku.schemaConfig.TeamAPIKey
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if taku.mutation.CreatorCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   teamapikey.CreatorTable,
			Columns: []string{teamapikey.CreatorColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = taku.schemaConfig.TeamAPIKey
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := taku.mutation.CreatorIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   teamapikey.CreatorTable,
			Columns: []string{teamapikey.CreatorColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = taku.schemaConfig.TeamAPIKey
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = taku.schemaConfig.TeamAPIKey
	ctx = internal.NewSchemaConfigContext(ctx, taku.schemaConfig)
	_spec.AddModifiers(taku.modifiers...)
	if n, err = sqlgraph.UpdateNodes(ctx, taku.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{teamapikey.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	taku.mutation.done = true
	return n, nil
}

// TeamAPIKeyUpdateOne is the builder for updating a single TeamAPIKey entity.
type TeamAPIKeyUpdateOne struct {
	config
	fields    []string
	hooks     []Hook
	mutation  *TeamAPIKeyMutation
	modifiers []func(*sql.UpdateBuilder)
}

// SetAPIKey sets the "api_key" field.
func (takuo *TeamAPIKeyUpdateOne) SetAPIKey(s string) *TeamAPIKeyUpdateOne {
	takuo.mutation.SetAPIKey(s)
	return takuo
}

// SetNillableAPIKey sets the "api_key" field if the given value is not nil.
func (takuo *TeamAPIKeyUpdateOne) SetNillableAPIKey(s *string) *TeamAPIKeyUpdateOne {
	if s != nil {
		takuo.SetAPIKey(*s)
	}
	return takuo
}

// SetUpdatedAt sets the "updated_at" field.
func (takuo *TeamAPIKeyUpdateOne) SetUpdatedAt(t time.Time) *TeamAPIKeyUpdateOne {
	takuo.mutation.SetUpdatedAt(t)
	return takuo
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (takuo *TeamAPIKeyUpdateOne) SetNillableUpdatedAt(t *time.Time) *TeamAPIKeyUpdateOne {
	if t != nil {
		takuo.SetUpdatedAt(*t)
	}
	return takuo
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (takuo *TeamAPIKeyUpdateOne) ClearUpdatedAt() *TeamAPIKeyUpdateOne {
	takuo.mutation.ClearUpdatedAt()
	return takuo
}

// SetTeamID sets the "team_id" field.
func (takuo *TeamAPIKeyUpdateOne) SetTeamID(u uuid.UUID) *TeamAPIKeyUpdateOne {
	takuo.mutation.SetTeamID(u)
	return takuo
}

// SetNillableTeamID sets the "team_id" field if the given value is not nil.
func (takuo *TeamAPIKeyUpdateOne) SetNillableTeamID(u *uuid.UUID) *TeamAPIKeyUpdateOne {
	if u != nil {
		takuo.SetTeamID(*u)
	}
	return takuo
}

// SetName sets the "name" field.
func (takuo *TeamAPIKeyUpdateOne) SetName(s string) *TeamAPIKeyUpdateOne {
	takuo.mutation.SetName(s)
	return takuo
}

// SetNillableName sets the "name" field if the given value is not nil.
func (takuo *TeamAPIKeyUpdateOne) SetNillableName(s *string) *TeamAPIKeyUpdateOne {
	if s != nil {
		takuo.SetName(*s)
	}
	return takuo
}

// SetCreatedBy sets the "created_by" field.
func (takuo *TeamAPIKeyUpdateOne) SetCreatedBy(u uuid.UUID) *TeamAPIKeyUpdateOne {
	takuo.mutation.SetCreatedBy(u)
	return takuo
}

// SetNillableCreatedBy sets the "created_by" field if the given value is not nil.
func (takuo *TeamAPIKeyUpdateOne) SetNillableCreatedBy(u *uuid.UUID) *TeamAPIKeyUpdateOne {
	if u != nil {
		takuo.SetCreatedBy(*u)
	}
	return takuo
}

// ClearCreatedBy clears the value of the "created_by" field.
func (takuo *TeamAPIKeyUpdateOne) ClearCreatedBy() *TeamAPIKeyUpdateOne {
	takuo.mutation.ClearCreatedBy()
	return takuo
}

// SetLastUsed sets the "last_used" field.
func (takuo *TeamAPIKeyUpdateOne) SetLastUsed(t time.Time) *TeamAPIKeyUpdateOne {
	takuo.mutation.SetLastUsed(t)
	return takuo
}

// SetNillableLastUsed sets the "last_used" field if the given value is not nil.
func (takuo *TeamAPIKeyUpdateOne) SetNillableLastUsed(t *time.Time) *TeamAPIKeyUpdateOne {
	if t != nil {
		takuo.SetLastUsed(*t)
	}
	return takuo
}

// ClearLastUsed clears the value of the "last_used" field.
func (takuo *TeamAPIKeyUpdateOne) ClearLastUsed() *TeamAPIKeyUpdateOne {
	takuo.mutation.ClearLastUsed()
	return takuo
}

// SetTeam sets the "team" edge to the Team entity.
func (takuo *TeamAPIKeyUpdateOne) SetTeam(t *Team) *TeamAPIKeyUpdateOne {
	return takuo.SetTeamID(t.ID)
}

// SetCreatorID sets the "creator" edge to the User entity by ID.
func (takuo *TeamAPIKeyUpdateOne) SetCreatorID(id uuid.UUID) *TeamAPIKeyUpdateOne {
	takuo.mutation.SetCreatorID(id)
	return takuo
}

// SetNillableCreatorID sets the "creator" edge to the User entity by ID if the given value is not nil.
func (takuo *TeamAPIKeyUpdateOne) SetNillableCreatorID(id *uuid.UUID) *TeamAPIKeyUpdateOne {
	if id != nil {
		takuo = takuo.SetCreatorID(*id)
	}
	return takuo
}

// SetCreator sets the "creator" edge to the User entity.
func (takuo *TeamAPIKeyUpdateOne) SetCreator(u *User) *TeamAPIKeyUpdateOne {
	return takuo.SetCreatorID(u.ID)
}

// Mutation returns the TeamAPIKeyMutation object of the builder.
func (takuo *TeamAPIKeyUpdateOne) Mutation() *TeamAPIKeyMutation {
	return takuo.mutation
}

// ClearTeam clears the "team" edge to the Team entity.
func (takuo *TeamAPIKeyUpdateOne) ClearTeam() *TeamAPIKeyUpdateOne {
	takuo.mutation.ClearTeam()
	return takuo
}

// ClearCreator clears the "creator" edge to the User entity.
func (takuo *TeamAPIKeyUpdateOne) ClearCreator() *TeamAPIKeyUpdateOne {
	takuo.mutation.ClearCreator()
	return takuo
}

// Where appends a list predicates to the TeamAPIKeyUpdate builder.
func (takuo *TeamAPIKeyUpdateOne) Where(ps ...predicate.TeamAPIKey) *TeamAPIKeyUpdateOne {
	takuo.mutation.Where(ps...)
	return takuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (takuo *TeamAPIKeyUpdateOne) Select(field string, fields ...string) *TeamAPIKeyUpdateOne {
	takuo.fields = append([]string{field}, fields...)
	return takuo
}

// Save executes the query and returns the updated TeamAPIKey entity.
func (takuo *TeamAPIKeyUpdateOne) Save(ctx context.Context) (*TeamAPIKey, error) {
	return withHooks(ctx, takuo.sqlSave, takuo.mutation, takuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (takuo *TeamAPIKeyUpdateOne) SaveX(ctx context.Context) *TeamAPIKey {
	node, err := takuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (takuo *TeamAPIKeyUpdateOne) Exec(ctx context.Context) error {
	_, err := takuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (takuo *TeamAPIKeyUpdateOne) ExecX(ctx context.Context) {
	if err := takuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (takuo *TeamAPIKeyUpdateOne) check() error {
	if _, ok := takuo.mutation.TeamID(); takuo.mutation.TeamCleared() && !ok {
		return errors.New(`models: clearing a required unique edge "TeamAPIKey.team"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (takuo *TeamAPIKeyUpdateOne) Modify(modifiers ...func(u *sql.UpdateBuilder)) *TeamAPIKeyUpdateOne {
	takuo.modifiers = append(takuo.modifiers, modifiers...)
	return takuo
}

func (takuo *TeamAPIKeyUpdateOne) sqlSave(ctx context.Context) (_node *TeamAPIKey, err error) {
	if err := takuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(teamapikey.Table, teamapikey.Columns, sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID))
	id, ok := takuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`models: missing "TeamAPIKey.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := takuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, teamapikey.FieldID)
		for _, f := range fields {
			if !teamapikey.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
			}
			if f != teamapikey.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := takuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := takuo.mutation.APIKey(); ok {
		_spec.SetField(teamapikey.FieldAPIKey, field.TypeString, value)
	}
	if value, ok := takuo.mutation.UpdatedAt(); ok {
		_spec.SetField(teamapikey.FieldUpdatedAt, field.TypeTime, value)
	}
	if takuo.mutation.UpdatedAtCleared() {
		_spec.ClearField(teamapikey.FieldUpdatedAt, field.TypeTime)
	}
	if value, ok := takuo.mutation.Name(); ok {
		_spec.SetField(teamapikey.FieldName, field.TypeString, value)
	}
	if value, ok := takuo.mutation.LastUsed(); ok {
		_spec.SetField(teamapikey.FieldLastUsed, field.TypeTime, value)
	}
	if takuo.mutation.LastUsedCleared() {
		_spec.ClearField(teamapikey.FieldLastUsed, field.TypeTime)
	}
	if takuo.mutation.TeamCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   teamapikey.TeamTable,
			Columns: []string{teamapikey.TeamColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = takuo.schemaConfig.TeamAPIKey
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := takuo.mutation.TeamIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   teamapikey.TeamTable,
			Columns: []string{teamapikey.TeamColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = takuo.schemaConfig.TeamAPIKey
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if takuo.mutation.CreatorCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   teamapikey.CreatorTable,
			Columns: []string{teamapikey.CreatorColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = takuo.schemaConfig.TeamAPIKey
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := takuo.mutation.CreatorIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   teamapikey.CreatorTable,
			Columns: []string{teamapikey.CreatorColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = takuo.schemaConfig.TeamAPIKey
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = takuo.schemaConfig.TeamAPIKey
	ctx = internal.NewSchemaConfigContext(ctx, takuo.schemaConfig)
	_spec.AddModifiers(takuo.modifiers...)
	_node = &TeamAPIKey{config: takuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, takuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{teamapikey.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	takuo.mutation.done = true
	return _node, nil
}



================================================
File: models/tier.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"fmt"
	"strings"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/tier"
)

// Tier is the model entity for the Tier schema.
type Tier struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// DiskMB holds the value of the "disk_mb" field.
	DiskMB int64 `json:"disk_mb,omitempty"`
	// The number of instances the team can run concurrently
	ConcurrentInstances int64 `json:"concurrent_instances,omitempty"`
	// MaxLengthHours holds the value of the "max_length_hours" field.
	MaxLengthHours int64 `json:"max_length_hours,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the TierQuery when eager-loading is set.
	Edges        TierEdges `json:"edges"`
	selectValues sql.SelectValues
}

// TierEdges holds the relations/edges for other nodes in the graph.
type TierEdges struct {
	// Teams holds the value of the teams edge.
	Teams []*Team `json:"teams,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [1]bool
}

// TeamsOrErr returns the Teams value or an error if the edge
// was not loaded in eager-loading.
func (e TierEdges) TeamsOrErr() ([]*Team, error) {
	if e.loadedTypes[0] {
		return e.Teams, nil
	}
	return nil, &NotLoadedError{edge: "teams"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Tier) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case tier.FieldDiskMB, tier.FieldConcurrentInstances, tier.FieldMaxLengthHours:
			values[i] = new(sql.NullInt64)
		case tier.FieldID, tier.FieldName:
			values[i] = new(sql.NullString)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Tier fields.
func (t *Tier) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case tier.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				t.ID = value.String
			}
		case tier.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				t.Name = value.String
			}
		case tier.FieldDiskMB:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field disk_mb", values[i])
			} else if value.Valid {
				t.DiskMB = value.Int64
			}
		case tier.FieldConcurrentInstances:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field concurrent_instances", values[i])
			} else if value.Valid {
				t.ConcurrentInstances = value.Int64
			}
		case tier.FieldMaxLengthHours:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field max_length_hours", values[i])
			} else if value.Valid {
				t.MaxLengthHours = value.Int64
			}
		default:
			t.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Tier.
// This includes values selected through modifiers, order, etc.
func (t *Tier) Value(name string) (ent.Value, error) {
	return t.selectValues.Get(name)
}

// QueryTeams queries the "teams" edge of the Tier entity.
func (t *Tier) QueryTeams() *TeamQuery {
	return NewTierClient(t.config).QueryTeams(t)
}

// Update returns a builder for updating this Tier.
// Note that you need to call Tier.Unwrap() before calling this method if this Tier
// was returned from a transaction, and the transaction was committed or rolled back.
func (t *Tier) Update() *TierUpdateOne {
	return NewTierClient(t.config).UpdateOne(t)
}

// Unwrap unwraps the Tier entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (t *Tier) Unwrap() *Tier {
	_tx, ok := t.config.driver.(*txDriver)
	if !ok {
		panic("models: Tier is not a transactional entity")
	}
	t.config.driver = _tx.drv
	return t
}

// String implements the fmt.Stringer.
func (t *Tier) String() string {
	var builder strings.Builder
	builder.WriteString("Tier(")
	builder.WriteString(fmt.Sprintf("id=%v, ", t.ID))
	builder.WriteString("name=")
	builder.WriteString(t.Name)
	builder.WriteString(", ")
	builder.WriteString("disk_mb=")
	builder.WriteString(fmt.Sprintf("%v", t.DiskMB))
	builder.WriteString(", ")
	builder.WriteString("concurrent_instances=")
	builder.WriteString(fmt.Sprintf("%v", t.ConcurrentInstances))
	builder.WriteString(", ")
	builder.WriteString("max_length_hours=")
	builder.WriteString(fmt.Sprintf("%v", t.MaxLengthHours))
	builder.WriteByte(')')
	return builder.String()
}

// Tiers is a parsable slice of Tier.
type Tiers []*Tier



================================================
File: models/tier_create.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/tier"
	"github.com/google/uuid"
)

// TierCreate is the builder for creating a Tier entity.
type TierCreate struct {
	config
	mutation *TierMutation
	hooks    []Hook
	conflict []sql.ConflictOption
}

// SetName sets the "name" field.
func (tc *TierCreate) SetName(s string) *TierCreate {
	tc.mutation.SetName(s)
	return tc
}

// SetDiskMB sets the "disk_mb" field.
func (tc *TierCreate) SetDiskMB(i int64) *TierCreate {
	tc.mutation.SetDiskMB(i)
	return tc
}

// SetConcurrentInstances sets the "concurrent_instances" field.
func (tc *TierCreate) SetConcurrentInstances(i int64) *TierCreate {
	tc.mutation.SetConcurrentInstances(i)
	return tc
}

// SetMaxLengthHours sets the "max_length_hours" field.
func (tc *TierCreate) SetMaxLengthHours(i int64) *TierCreate {
	tc.mutation.SetMaxLengthHours(i)
	return tc
}

// SetID sets the "id" field.
func (tc *TierCreate) SetID(s string) *TierCreate {
	tc.mutation.SetID(s)
	return tc
}

// AddTeamIDs adds the "teams" edge to the Team entity by IDs.
func (tc *TierCreate) AddTeamIDs(ids ...uuid.UUID) *TierCreate {
	tc.mutation.AddTeamIDs(ids...)
	return tc
}

// AddTeams adds the "teams" edges to the Team entity.
func (tc *TierCreate) AddTeams(t ...*Team) *TierCreate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tc.AddTeamIDs(ids...)
}

// Mutation returns the TierMutation object of the builder.
func (tc *TierCreate) Mutation() *TierMutation {
	return tc.mutation
}

// Save creates the Tier in the database.
func (tc *TierCreate) Save(ctx context.Context) (*Tier, error) {
	return withHooks(ctx, tc.sqlSave, tc.mutation, tc.hooks)
}

// SaveX calls Save and panics if Save returns an error.
func (tc *TierCreate) SaveX(ctx context.Context) *Tier {
	v, err := tc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (tc *TierCreate) Exec(ctx context.Context) error {
	_, err := tc.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (tc *TierCreate) ExecX(ctx context.Context) {
	if err := tc.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (tc *TierCreate) check() error {
	if _, ok := tc.mutation.Name(); !ok {
		return &ValidationError{Name: "name", err: errors.New(`models: missing required field "Tier.name"`)}
	}
	if _, ok := tc.mutation.DiskMB(); !ok {
		return &ValidationError{Name: "disk_mb", err: errors.New(`models: missing required field "Tier.disk_mb"`)}
	}
	if _, ok := tc.mutation.ConcurrentInstances(); !ok {
		return &ValidationError{Name: "concurrent_instances", err: errors.New(`models: missing required field "Tier.concurrent_instances"`)}
	}
	if _, ok := tc.mutation.MaxLengthHours(); !ok {
		return &ValidationError{Name: "max_length_hours", err: errors.New(`models: missing required field "Tier.max_length_hours"`)}
	}
	return nil
}

func (tc *TierCreate) sqlSave(ctx context.Context) (*Tier, error) {
	if err := tc.check(); err != nil {
		return nil, err
	}
	_node, _spec := tc.createSpec()
	if err := sqlgraph.CreateNode(ctx, tc.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	if _spec.ID.Value != nil {
		if id, ok := _spec.ID.Value.(string); ok {
			_node.ID = id
		} else {
			return nil, fmt.Errorf("unexpected Tier.ID type: %T", _spec.ID.Value)
		}
	}
	tc.mutation.id = &_node.ID
	tc.mutation.done = true
	return _node, nil
}

func (tc *TierCreate) createSpec() (*Tier, *sqlgraph.CreateSpec) {
	var (
		_node = &Tier{config: tc.config}
		_spec = sqlgraph.NewCreateSpec(tier.Table, sqlgraph.NewFieldSpec(tier.FieldID, field.TypeString))
	)
	_spec.Schema = tc.schemaConfig.Tier
	_spec.OnConflict = tc.conflict
	if id, ok := tc.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = id
	}
	if value, ok := tc.mutation.Name(); ok {
		_spec.SetField(tier.FieldName, field.TypeString, value)
		_node.Name = value
	}
	if value, ok := tc.mutation.DiskMB(); ok {
		_spec.SetField(tier.FieldDiskMB, field.TypeInt64, value)
		_node.DiskMB = value
	}
	if value, ok := tc.mutation.ConcurrentInstances(); ok {
		_spec.SetField(tier.FieldConcurrentInstances, field.TypeInt64, value)
		_node.ConcurrentInstances = value
	}
	if value, ok := tc.mutation.MaxLengthHours(); ok {
		_spec.SetField(tier.FieldMaxLengthHours, field.TypeInt64, value)
		_node.MaxLengthHours = value
	}
	if nodes := tc.mutation.TeamsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tier.TeamsTable,
			Columns: []string{tier.TeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tc.schemaConfig.Team
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.Tier.Create().
//		SetName(v).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.TierUpsert) {
//			SetName(v+v).
//		}).
//		Exec(ctx)
func (tc *TierCreate) OnConflict(opts ...sql.ConflictOption) *TierUpsertOne {
	tc.conflict = opts
	return &TierUpsertOne{
		create: tc,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.Tier.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (tc *TierCreate) OnConflictColumns(columns ...string) *TierUpsertOne {
	tc.conflict = append(tc.conflict, sql.ConflictColumns(columns...))
	return &TierUpsertOne{
		create: tc,
	}
}

type (
	// TierUpsertOne is the builder for "upsert"-ing
	//  one Tier node.
	TierUpsertOne struct {
		create *TierCreate
	}

	// TierUpsert is the "OnConflict" setter.
	TierUpsert struct {
		*sql.UpdateSet
	}
)

// SetName sets the "name" field.
func (u *TierUpsert) SetName(v string) *TierUpsert {
	u.Set(tier.FieldName, v)
	return u
}

// UpdateName sets the "name" field to the value that was provided on create.
func (u *TierUpsert) UpdateName() *TierUpsert {
	u.SetExcluded(tier.FieldName)
	return u
}

// SetDiskMB sets the "disk_mb" field.
func (u *TierUpsert) SetDiskMB(v int64) *TierUpsert {
	u.Set(tier.FieldDiskMB, v)
	return u
}

// UpdateDiskMB sets the "disk_mb" field to the value that was provided on create.
func (u *TierUpsert) UpdateDiskMB() *TierUpsert {
	u.SetExcluded(tier.FieldDiskMB)
	return u
}

// AddDiskMB adds v to the "disk_mb" field.
func (u *TierUpsert) AddDiskMB(v int64) *TierUpsert {
	u.Add(tier.FieldDiskMB, v)
	return u
}

// SetConcurrentInstances sets the "concurrent_instances" field.
func (u *TierUpsert) SetConcurrentInstances(v int64) *TierUpsert {
	u.Set(tier.FieldConcurrentInstances, v)
	return u
}

// UpdateConcurrentInstances sets the "concurrent_instances" field to the value that was provided on create.
func (u *TierUpsert) UpdateConcurrentInstances() *TierUpsert {
	u.SetExcluded(tier.FieldConcurrentInstances)
	return u
}

// AddConcurrentInstances adds v to the "concurrent_instances" field.
func (u *TierUpsert) AddConcurrentInstances(v int64) *TierUpsert {
	u.Add(tier.FieldConcurrentInstances, v)
	return u
}

// SetMaxLengthHours sets the "max_length_hours" field.
func (u *TierUpsert) SetMaxLengthHours(v int64) *TierUpsert {
	u.Set(tier.FieldMaxLengthHours, v)
	return u
}

// UpdateMaxLengthHours sets the "max_length_hours" field to the value that was provided on create.
func (u *TierUpsert) UpdateMaxLengthHours() *TierUpsert {
	u.SetExcluded(tier.FieldMaxLengthHours)
	return u
}

// AddMaxLengthHours adds v to the "max_length_hours" field.
func (u *TierUpsert) AddMaxLengthHours(v int64) *TierUpsert {
	u.Add(tier.FieldMaxLengthHours, v)
	return u
}

// UpdateNewValues updates the mutable fields using the new values that were set on create except the ID field.
// Using this option is equivalent to using:
//
//	client.Tier.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(tier.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *TierUpsertOne) UpdateNewValues() *TierUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		if _, exists := u.create.mutation.ID(); exists {
			s.SetIgnore(tier.FieldID)
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.Tier.Create().
//	    OnConflict(sql.ResolveWithIgnore()).
//	    Exec(ctx)
func (u *TierUpsertOne) Ignore() *TierUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *TierUpsertOne) DoNothing() *TierUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the TierCreate.OnConflict
// documentation for more info.
func (u *TierUpsertOne) Update(set func(*TierUpsert)) *TierUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&TierUpsert{UpdateSet: update})
	}))
	return u
}

// SetName sets the "name" field.
func (u *TierUpsertOne) SetName(v string) *TierUpsertOne {
	return u.Update(func(s *TierUpsert) {
		s.SetName(v)
	})
}

// UpdateName sets the "name" field to the value that was provided on create.
func (u *TierUpsertOne) UpdateName() *TierUpsertOne {
	return u.Update(func(s *TierUpsert) {
		s.UpdateName()
	})
}

// SetDiskMB sets the "disk_mb" field.
func (u *TierUpsertOne) SetDiskMB(v int64) *TierUpsertOne {
	return u.Update(func(s *TierUpsert) {
		s.SetDiskMB(v)
	})
}

// AddDiskMB adds v to the "disk_mb" field.
func (u *TierUpsertOne) AddDiskMB(v int64) *TierUpsertOne {
	return u.Update(func(s *TierUpsert) {
		s.AddDiskMB(v)
	})
}

// UpdateDiskMB sets the "disk_mb" field to the value that was provided on create.
func (u *TierUpsertOne) UpdateDiskMB() *TierUpsertOne {
	return u.Update(func(s *TierUpsert) {
		s.UpdateDiskMB()
	})
}

// SetConcurrentInstances sets the "concurrent_instances" field.
func (u *TierUpsertOne) SetConcurrentInstances(v int64) *TierUpsertOne {
	return u.Update(func(s *TierUpsert) {
		s.SetConcurrentInstances(v)
	})
}

// AddConcurrentInstances adds v to the "concurrent_instances" field.
func (u *TierUpsertOne) AddConcurrentInstances(v int64) *TierUpsertOne {
	return u.Update(func(s *TierUpsert) {
		s.AddConcurrentInstances(v)
	})
}

// UpdateConcurrentInstances sets the "concurrent_instances" field to the value that was provided on create.
func (u *TierUpsertOne) UpdateConcurrentInstances() *TierUpsertOne {
	return u.Update(func(s *TierUpsert) {
		s.UpdateConcurrentInstances()
	})
}

// SetMaxLengthHours sets the "max_length_hours" field.
func (u *TierUpsertOne) SetMaxLengthHours(v int64) *TierUpsertOne {
	return u.Update(func(s *TierUpsert) {
		s.SetMaxLengthHours(v)
	})
}

// AddMaxLengthHours adds v to the "max_length_hours" field.
func (u *TierUpsertOne) AddMaxLengthHours(v int64) *TierUpsertOne {
	return u.Update(func(s *TierUpsert) {
		s.AddMaxLengthHours(v)
	})
}

// UpdateMaxLengthHours sets the "max_length_hours" field to the value that was provided on create.
func (u *TierUpsertOne) UpdateMaxLengthHours() *TierUpsertOne {
	return u.Update(func(s *TierUpsert) {
		s.UpdateMaxLengthHours()
	})
}

// Exec executes the query.
func (u *TierUpsertOne) Exec(ctx context.Context) error {
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for TierCreate.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *TierUpsertOne) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}

// Exec executes the UPSERT query and returns the inserted/updated ID.
func (u *TierUpsertOne) ID(ctx context.Context) (id string, err error) {
	if u.create.driver.Dialect() == dialect.MySQL {
		// In case of "ON CONFLICT", there is no way to get back non-numeric ID
		// fields from the database since MySQL does not support the RETURNING clause.
		return id, errors.New("models: TierUpsertOne.ID is not supported by MySQL driver. Use TierUpsertOne.Exec instead")
	}
	node, err := u.create.Save(ctx)
	if err != nil {
		return id, err
	}
	return node.ID, nil
}

// IDX is like ID, but panics if an error occurs.
func (u *TierUpsertOne) IDX(ctx context.Context) string {
	id, err := u.ID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// TierCreateBulk is the builder for creating many Tier entities in bulk.
type TierCreateBulk struct {
	config
	err      error
	builders []*TierCreate
	conflict []sql.ConflictOption
}

// Save creates the Tier entities in the database.
func (tcb *TierCreateBulk) Save(ctx context.Context) ([]*Tier, error) {
	if tcb.err != nil {
		return nil, tcb.err
	}
	specs := make([]*sqlgraph.CreateSpec, len(tcb.builders))
	nodes := make([]*Tier, len(tcb.builders))
	mutators := make([]Mutator, len(tcb.builders))
	for i := range tcb.builders {
		func(i int, root context.Context) {
			builder := tcb.builders[i]
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*TierMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				var err error
				nodes[i], specs[i] = builder.createSpec()
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, tcb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					spec.OnConflict = tcb.conflict
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, tcb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{msg: err.Error(), wrap: err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, tcb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (tcb *TierCreateBulk) SaveX(ctx context.Context) []*Tier {
	v, err := tcb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (tcb *TierCreateBulk) Exec(ctx context.Context) error {
	_, err := tcb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (tcb *TierCreateBulk) ExecX(ctx context.Context) {
	if err := tcb.Exec(ctx); err != nil {
		panic(err)
	}
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.Tier.CreateBulk(builders...).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.TierUpsert) {
//			SetName(v+v).
//		}).
//		Exec(ctx)
func (tcb *TierCreateBulk) OnConflict(opts ...sql.ConflictOption) *TierUpsertBulk {
	tcb.conflict = opts
	return &TierUpsertBulk{
		create: tcb,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.Tier.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (tcb *TierCreateBulk) OnConflictColumns(columns ...string) *TierUpsertBulk {
	tcb.conflict = append(tcb.conflict, sql.ConflictColumns(columns...))
	return &TierUpsertBulk{
		create: tcb,
	}
}

// TierUpsertBulk is the builder for "upsert"-ing
// a bulk of Tier nodes.
type TierUpsertBulk struct {
	create *TierCreateBulk
}

// UpdateNewValues updates the mutable fields using the new values that
// were set on create. Using this option is equivalent to using:
//
//	client.Tier.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(tier.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *TierUpsertBulk) UpdateNewValues() *TierUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		for _, b := range u.create.builders {
			if _, exists := b.mutation.ID(); exists {
				s.SetIgnore(tier.FieldID)
			}
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.Tier.Create().
//		OnConflict(sql.ResolveWithIgnore()).
//		Exec(ctx)
func (u *TierUpsertBulk) Ignore() *TierUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *TierUpsertBulk) DoNothing() *TierUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the TierCreateBulk.OnConflict
// documentation for more info.
func (u *TierUpsertBulk) Update(set func(*TierUpsert)) *TierUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&TierUpsert{UpdateSet: update})
	}))
	return u
}

// SetName sets the "name" field.
func (u *TierUpsertBulk) SetName(v string) *TierUpsertBulk {
	return u.Update(func(s *TierUpsert) {
		s.SetName(v)
	})
}

// UpdateName sets the "name" field to the value that was provided on create.
func (u *TierUpsertBulk) UpdateName() *TierUpsertBulk {
	return u.Update(func(s *TierUpsert) {
		s.UpdateName()
	})
}

// SetDiskMB sets the "disk_mb" field.
func (u *TierUpsertBulk) SetDiskMB(v int64) *TierUpsertBulk {
	return u.Update(func(s *TierUpsert) {
		s.SetDiskMB(v)
	})
}

// AddDiskMB adds v to the "disk_mb" field.
func (u *TierUpsertBulk) AddDiskMB(v int64) *TierUpsertBulk {
	return u.Update(func(s *TierUpsert) {
		s.AddDiskMB(v)
	})
}

// UpdateDiskMB sets the "disk_mb" field to the value that was provided on create.
func (u *TierUpsertBulk) UpdateDiskMB() *TierUpsertBulk {
	return u.Update(func(s *TierUpsert) {
		s.UpdateDiskMB()
	})
}

// SetConcurrentInstances sets the "concurrent_instances" field.
func (u *TierUpsertBulk) SetConcurrentInstances(v int64) *TierUpsertBulk {
	return u.Update(func(s *TierUpsert) {
		s.SetConcurrentInstances(v)
	})
}

// AddConcurrentInstances adds v to the "concurrent_instances" field.
func (u *TierUpsertBulk) AddConcurrentInstances(v int64) *TierUpsertBulk {
	return u.Update(func(s *TierUpsert) {
		s.AddConcurrentInstances(v)
	})
}

// UpdateConcurrentInstances sets the "concurrent_instances" field to the value that was provided on create.
func (u *TierUpsertBulk) UpdateConcurrentInstances() *TierUpsertBulk {
	return u.Update(func(s *TierUpsert) {
		s.UpdateConcurrentInstances()
	})
}

// SetMaxLengthHours sets the "max_length_hours" field.
func (u *TierUpsertBulk) SetMaxLengthHours(v int64) *TierUpsertBulk {
	return u.Update(func(s *TierUpsert) {
		s.SetMaxLengthHours(v)
	})
}

// AddMaxLengthHours adds v to the "max_length_hours" field.
func (u *TierUpsertBulk) AddMaxLengthHours(v int64) *TierUpsertBulk {
	return u.Update(func(s *TierUpsert) {
		s.AddMaxLengthHours(v)
	})
}

// UpdateMaxLengthHours sets the "max_length_hours" field to the value that was provided on create.
func (u *TierUpsertBulk) UpdateMaxLengthHours() *TierUpsertBulk {
	return u.Update(func(s *TierUpsert) {
		s.UpdateMaxLengthHours()
	})
}

// Exec executes the query.
func (u *TierUpsertBulk) Exec(ctx context.Context) error {
	if u.create.err != nil {
		return u.create.err
	}
	for i, b := range u.create.builders {
		if len(b.conflict) != 0 {
			return fmt.Errorf("models: OnConflict was set for builder %d. Set it on the TierCreateBulk instead", i)
		}
	}
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for TierCreateBulk.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *TierUpsertBulk) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/tier_delete.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/tier"
)

// TierDelete is the builder for deleting a Tier entity.
type TierDelete struct {
	config
	hooks    []Hook
	mutation *TierMutation
}

// Where appends a list predicates to the TierDelete builder.
func (td *TierDelete) Where(ps ...predicate.Tier) *TierDelete {
	td.mutation.Where(ps...)
	return td
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (td *TierDelete) Exec(ctx context.Context) (int, error) {
	return withHooks(ctx, td.sqlExec, td.mutation, td.hooks)
}

// ExecX is like Exec, but panics if an error occurs.
func (td *TierDelete) ExecX(ctx context.Context) int {
	n, err := td.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (td *TierDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := sqlgraph.NewDeleteSpec(tier.Table, sqlgraph.NewFieldSpec(tier.FieldID, field.TypeString))
	_spec.Node.Schema = td.schemaConfig.Tier
	ctx = internal.NewSchemaConfigContext(ctx, td.schemaConfig)
	if ps := td.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	affected, err := sqlgraph.DeleteNodes(ctx, td.driver, _spec)
	if err != nil && sqlgraph.IsConstraintError(err) {
		err = &ConstraintError{msg: err.Error(), wrap: err}
	}
	td.mutation.done = true
	return affected, err
}

// TierDeleteOne is the builder for deleting a single Tier entity.
type TierDeleteOne struct {
	td *TierDelete
}

// Where appends a list predicates to the TierDelete builder.
func (tdo *TierDeleteOne) Where(ps ...predicate.Tier) *TierDeleteOne {
	tdo.td.mutation.Where(ps...)
	return tdo
}

// Exec executes the deletion query.
func (tdo *TierDeleteOne) Exec(ctx context.Context) error {
	n, err := tdo.td.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{tier.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (tdo *TierDeleteOne) ExecX(ctx context.Context) {
	if err := tdo.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/tier_query.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"database/sql/driver"
	"fmt"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/tier"
)

// TierQuery is the builder for querying Tier entities.
type TierQuery struct {
	config
	ctx        *QueryContext
	order      []tier.OrderOption
	inters     []Interceptor
	predicates []predicate.Tier
	withTeams  *TeamQuery
	modifiers  []func(*sql.Selector)
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the TierQuery builder.
func (tq *TierQuery) Where(ps ...predicate.Tier) *TierQuery {
	tq.predicates = append(tq.predicates, ps...)
	return tq
}

// Limit the number of records to be returned by this query.
func (tq *TierQuery) Limit(limit int) *TierQuery {
	tq.ctx.Limit = &limit
	return tq
}

// Offset to start from.
func (tq *TierQuery) Offset(offset int) *TierQuery {
	tq.ctx.Offset = &offset
	return tq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (tq *TierQuery) Unique(unique bool) *TierQuery {
	tq.ctx.Unique = &unique
	return tq
}

// Order specifies how the records should be ordered.
func (tq *TierQuery) Order(o ...tier.OrderOption) *TierQuery {
	tq.order = append(tq.order, o...)
	return tq
}

// QueryTeams chains the current query on the "teams" edge.
func (tq *TierQuery) QueryTeams() *TeamQuery {
	query := (&TeamClient{config: tq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := tq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := tq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(tier.Table, tier.FieldID, selector),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tier.TeamsTable, tier.TeamsColumn),
		)
		schemaConfig := tq.schemaConfig
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.Team
		fromU = sqlgraph.SetNeighbors(tq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first Tier entity from the query.
// Returns a *NotFoundError when no Tier was found.
func (tq *TierQuery) First(ctx context.Context) (*Tier, error) {
	nodes, err := tq.Limit(1).All(setContextOp(ctx, tq.ctx, "First"))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{tier.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (tq *TierQuery) FirstX(ctx context.Context) *Tier {
	node, err := tq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first Tier ID from the query.
// Returns a *NotFoundError when no Tier ID was found.
func (tq *TierQuery) FirstID(ctx context.Context) (id string, err error) {
	var ids []string
	if ids, err = tq.Limit(1).IDs(setContextOp(ctx, tq.ctx, "FirstID")); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{tier.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (tq *TierQuery) FirstIDX(ctx context.Context) string {
	id, err := tq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single Tier entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one Tier entity is found.
// Returns a *NotFoundError when no Tier entities are found.
func (tq *TierQuery) Only(ctx context.Context) (*Tier, error) {
	nodes, err := tq.Limit(2).All(setContextOp(ctx, tq.ctx, "Only"))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{tier.Label}
	default:
		return nil, &NotSingularError{tier.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (tq *TierQuery) OnlyX(ctx context.Context) *Tier {
	node, err := tq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only Tier ID in the query.
// Returns a *NotSingularError when more than one Tier ID is found.
// Returns a *NotFoundError when no entities are found.
func (tq *TierQuery) OnlyID(ctx context.Context) (id string, err error) {
	var ids []string
	if ids, err = tq.Limit(2).IDs(setContextOp(ctx, tq.ctx, "OnlyID")); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{tier.Label}
	default:
		err = &NotSingularError{tier.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (tq *TierQuery) OnlyIDX(ctx context.Context) string {
	id, err := tq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of Tiers.
func (tq *TierQuery) All(ctx context.Context) ([]*Tier, error) {
	ctx = setContextOp(ctx, tq.ctx, "All")
	if err := tq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*Tier, *TierQuery]()
	return withInterceptors[[]*Tier](ctx, tq, qr, tq.inters)
}

// AllX is like All, but panics if an error occurs.
func (tq *TierQuery) AllX(ctx context.Context) []*Tier {
	nodes, err := tq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of Tier IDs.
func (tq *TierQuery) IDs(ctx context.Context) (ids []string, err error) {
	if tq.ctx.Unique == nil && tq.path != nil {
		tq.Unique(true)
	}
	ctx = setContextOp(ctx, tq.ctx, "IDs")
	if err = tq.Select(tier.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (tq *TierQuery) IDsX(ctx context.Context) []string {
	ids, err := tq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (tq *TierQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, tq.ctx, "Count")
	if err := tq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, tq, querierCount[*TierQuery](), tq.inters)
}

// CountX is like Count, but panics if an error occurs.
func (tq *TierQuery) CountX(ctx context.Context) int {
	count, err := tq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (tq *TierQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, tq.ctx, "Exist")
	switch _, err := tq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("models: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (tq *TierQuery) ExistX(ctx context.Context) bool {
	exist, err := tq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the TierQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (tq *TierQuery) Clone() *TierQuery {
	if tq == nil {
		return nil
	}
	return &TierQuery{
		config:     tq.config,
		ctx:        tq.ctx.Clone(),
		order:      append([]tier.OrderOption{}, tq.order...),
		inters:     append([]Interceptor{}, tq.inters...),
		predicates: append([]predicate.Tier{}, tq.predicates...),
		withTeams:  tq.withTeams.Clone(),
		// clone intermediate query.
		sql:  tq.sql.Clone(),
		path: tq.path,
	}
}

// WithTeams tells the query-builder to eager-load the nodes that are connected to
// the "teams" edge. The optional arguments are used to configure the query builder of the edge.
func (tq *TierQuery) WithTeams(opts ...func(*TeamQuery)) *TierQuery {
	query := (&TeamClient{config: tq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	tq.withTeams = query
	return tq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		Name string `json:"name,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.Tier.Query().
//		GroupBy(tier.FieldName).
//		Aggregate(models.Count()).
//		Scan(ctx, &v)
func (tq *TierQuery) GroupBy(field string, fields ...string) *TierGroupBy {
	tq.ctx.Fields = append([]string{field}, fields...)
	grbuild := &TierGroupBy{build: tq}
	grbuild.flds = &tq.ctx.Fields
	grbuild.label = tier.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		Name string `json:"name,omitempty"`
//	}
//
//	client.Tier.Query().
//		Select(tier.FieldName).
//		Scan(ctx, &v)
func (tq *TierQuery) Select(fields ...string) *TierSelect {
	tq.ctx.Fields = append(tq.ctx.Fields, fields...)
	sbuild := &TierSelect{TierQuery: tq}
	sbuild.label = tier.Label
	sbuild.flds, sbuild.scan = &tq.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a TierSelect configured with the given aggregations.
func (tq *TierQuery) Aggregate(fns ...AggregateFunc) *TierSelect {
	return tq.Select().Aggregate(fns...)
}

func (tq *TierQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range tq.inters {
		if inter == nil {
			return fmt.Errorf("models: uninitialized interceptor (forgotten import models/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, tq); err != nil {
				return err
			}
		}
	}
	for _, f := range tq.ctx.Fields {
		if !tier.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
		}
	}
	if tq.path != nil {
		prev, err := tq.path(ctx)
		if err != nil {
			return err
		}
		tq.sql = prev
	}
	return nil
}

func (tq *TierQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*Tier, error) {
	var (
		nodes       = []*Tier{}
		_spec       = tq.querySpec()
		loadedTypes = [1]bool{
			tq.withTeams != nil,
		}
	)
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*Tier).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &Tier{config: tq.config}
		nodes = append(nodes, node)
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	_spec.Node.Schema = tq.schemaConfig.Tier
	ctx = internal.NewSchemaConfigContext(ctx, tq.schemaConfig)
	if len(tq.modifiers) > 0 {
		_spec.Modifiers = tq.modifiers
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, tq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	if query := tq.withTeams; query != nil {
		if err := tq.loadTeams(ctx, query, nodes,
			func(n *Tier) { n.Edges.Teams = []*Team{} },
			func(n *Tier, e *Team) { n.Edges.Teams = append(n.Edges.Teams, e) }); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

func (tq *TierQuery) loadTeams(ctx context.Context, query *TeamQuery, nodes []*Tier, init func(*Tier), assign func(*Tier, *Team)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*Tier)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(team.FieldTier)
	}
	query.Where(predicate.Team(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(tier.TeamsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.Tier
		node, ok := nodeids[fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "tier" returned %v for node %v`, fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}

func (tq *TierQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := tq.querySpec()
	_spec.Node.Schema = tq.schemaConfig.Tier
	ctx = internal.NewSchemaConfigContext(ctx, tq.schemaConfig)
	if len(tq.modifiers) > 0 {
		_spec.Modifiers = tq.modifiers
	}
	_spec.Node.Columns = tq.ctx.Fields
	if len(tq.ctx.Fields) > 0 {
		_spec.Unique = tq.ctx.Unique != nil && *tq.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, tq.driver, _spec)
}

func (tq *TierQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(tier.Table, tier.Columns, sqlgraph.NewFieldSpec(tier.FieldID, field.TypeString))
	_spec.From = tq.sql
	if unique := tq.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if tq.path != nil {
		_spec.Unique = true
	}
	if fields := tq.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, tier.FieldID)
		for i := range fields {
			if fields[i] != tier.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
	}
	if ps := tq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := tq.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := tq.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := tq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (tq *TierQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(tq.driver.Dialect())
	t1 := builder.Table(tier.Table)
	columns := tq.ctx.Fields
	if len(columns) == 0 {
		columns = tier.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if tq.sql != nil {
		selector = tq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if tq.ctx.Unique != nil && *tq.ctx.Unique {
		selector.Distinct()
	}
	t1.Schema(tq.schemaConfig.Tier)
	ctx = internal.NewSchemaConfigContext(ctx, tq.schemaConfig)
	selector.WithContext(ctx)
	for _, m := range tq.modifiers {
		m(selector)
	}
	for _, p := range tq.predicates {
		p(selector)
	}
	for _, p := range tq.order {
		p(selector)
	}
	if offset := tq.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := tq.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// Modify adds a query modifier for attaching custom logic to queries.
func (tq *TierQuery) Modify(modifiers ...func(s *sql.Selector)) *TierSelect {
	tq.modifiers = append(tq.modifiers, modifiers...)
	return tq.Select()
}

// TierGroupBy is the group-by builder for Tier entities.
type TierGroupBy struct {
	selector
	build *TierQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (tgb *TierGroupBy) Aggregate(fns ...AggregateFunc) *TierGroupBy {
	tgb.fns = append(tgb.fns, fns...)
	return tgb
}

// Scan applies the selector query and scans the result into the given value.
func (tgb *TierGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, tgb.build.ctx, "GroupBy")
	if err := tgb.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*TierQuery, *TierGroupBy](ctx, tgb.build, tgb, tgb.build.inters, v)
}

func (tgb *TierGroupBy) sqlScan(ctx context.Context, root *TierQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(tgb.fns))
	for _, fn := range tgb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*tgb.flds)+len(tgb.fns))
		for _, f := range *tgb.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*tgb.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := tgb.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// TierSelect is the builder for selecting fields of Tier entities.
type TierSelect struct {
	*TierQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (ts *TierSelect) Aggregate(fns ...AggregateFunc) *TierSelect {
	ts.fns = append(ts.fns, fns...)
	return ts
}

// Scan applies the selector query and scans the result into the given value.
func (ts *TierSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, ts.ctx, "Select")
	if err := ts.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*TierQuery, *TierSelect](ctx, ts.TierQuery, ts, ts.inters, v)
}

func (ts *TierSelect) sqlScan(ctx context.Context, root *TierQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(ts.fns))
	for _, fn := range ts.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*ts.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := ts.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// Modify adds a query modifier for attaching custom logic to queries.
func (ts *TierSelect) Modify(modifiers ...func(s *sql.Selector)) *TierSelect {
	ts.modifiers = append(ts.modifiers, modifiers...)
	return ts
}



================================================
File: models/tier_update.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/tier"
	"github.com/google/uuid"
)

// TierUpdate is the builder for updating Tier entities.
type TierUpdate struct {
	config
	hooks     []Hook
	mutation  *TierMutation
	modifiers []func(*sql.UpdateBuilder)
}

// Where appends a list predicates to the TierUpdate builder.
func (tu *TierUpdate) Where(ps ...predicate.Tier) *TierUpdate {
	tu.mutation.Where(ps...)
	return tu
}

// SetName sets the "name" field.
func (tu *TierUpdate) SetName(s string) *TierUpdate {
	tu.mutation.SetName(s)
	return tu
}

// SetNillableName sets the "name" field if the given value is not nil.
func (tu *TierUpdate) SetNillableName(s *string) *TierUpdate {
	if s != nil {
		tu.SetName(*s)
	}
	return tu
}

// SetDiskMB sets the "disk_mb" field.
func (tu *TierUpdate) SetDiskMB(i int64) *TierUpdate {
	tu.mutation.ResetDiskMB()
	tu.mutation.SetDiskMB(i)
	return tu
}

// SetNillableDiskMB sets the "disk_mb" field if the given value is not nil.
func (tu *TierUpdate) SetNillableDiskMB(i *int64) *TierUpdate {
	if i != nil {
		tu.SetDiskMB(*i)
	}
	return tu
}

// AddDiskMB adds i to the "disk_mb" field.
func (tu *TierUpdate) AddDiskMB(i int64) *TierUpdate {
	tu.mutation.AddDiskMB(i)
	return tu
}

// SetConcurrentInstances sets the "concurrent_instances" field.
func (tu *TierUpdate) SetConcurrentInstances(i int64) *TierUpdate {
	tu.mutation.ResetConcurrentInstances()
	tu.mutation.SetConcurrentInstances(i)
	return tu
}

// SetNillableConcurrentInstances sets the "concurrent_instances" field if the given value is not nil.
func (tu *TierUpdate) SetNillableConcurrentInstances(i *int64) *TierUpdate {
	if i != nil {
		tu.SetConcurrentInstances(*i)
	}
	return tu
}

// AddConcurrentInstances adds i to the "concurrent_instances" field.
func (tu *TierUpdate) AddConcurrentInstances(i int64) *TierUpdate {
	tu.mutation.AddConcurrentInstances(i)
	return tu
}

// SetMaxLengthHours sets the "max_length_hours" field.
func (tu *TierUpdate) SetMaxLengthHours(i int64) *TierUpdate {
	tu.mutation.ResetMaxLengthHours()
	tu.mutation.SetMaxLengthHours(i)
	return tu
}

// SetNillableMaxLengthHours sets the "max_length_hours" field if the given value is not nil.
func (tu *TierUpdate) SetNillableMaxLengthHours(i *int64) *TierUpdate {
	if i != nil {
		tu.SetMaxLengthHours(*i)
	}
	return tu
}

// AddMaxLengthHours adds i to the "max_length_hours" field.
func (tu *TierUpdate) AddMaxLengthHours(i int64) *TierUpdate {
	tu.mutation.AddMaxLengthHours(i)
	return tu
}

// AddTeamIDs adds the "teams" edge to the Team entity by IDs.
func (tu *TierUpdate) AddTeamIDs(ids ...uuid.UUID) *TierUpdate {
	tu.mutation.AddTeamIDs(ids...)
	return tu
}

// AddTeams adds the "teams" edges to the Team entity.
func (tu *TierUpdate) AddTeams(t ...*Team) *TierUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tu.AddTeamIDs(ids...)
}

// Mutation returns the TierMutation object of the builder.
func (tu *TierUpdate) Mutation() *TierMutation {
	return tu.mutation
}

// ClearTeams clears all "teams" edges to the Team entity.
func (tu *TierUpdate) ClearTeams() *TierUpdate {
	tu.mutation.ClearTeams()
	return tu
}

// RemoveTeamIDs removes the "teams" edge to Team entities by IDs.
func (tu *TierUpdate) RemoveTeamIDs(ids ...uuid.UUID) *TierUpdate {
	tu.mutation.RemoveTeamIDs(ids...)
	return tu
}

// RemoveTeams removes "teams" edges to Team entities.
func (tu *TierUpdate) RemoveTeams(t ...*Team) *TierUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tu.RemoveTeamIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (tu *TierUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, tu.sqlSave, tu.mutation, tu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (tu *TierUpdate) SaveX(ctx context.Context) int {
	affected, err := tu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (tu *TierUpdate) Exec(ctx context.Context) error {
	_, err := tu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (tu *TierUpdate) ExecX(ctx context.Context) {
	if err := tu.Exec(ctx); err != nil {
		panic(err)
	}
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (tu *TierUpdate) Modify(modifiers ...func(u *sql.UpdateBuilder)) *TierUpdate {
	tu.modifiers = append(tu.modifiers, modifiers...)
	return tu
}

func (tu *TierUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := sqlgraph.NewUpdateSpec(tier.Table, tier.Columns, sqlgraph.NewFieldSpec(tier.FieldID, field.TypeString))
	if ps := tu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := tu.mutation.Name(); ok {
		_spec.SetField(tier.FieldName, field.TypeString, value)
	}
	if value, ok := tu.mutation.DiskMB(); ok {
		_spec.SetField(tier.FieldDiskMB, field.TypeInt64, value)
	}
	if value, ok := tu.mutation.AddedDiskMB(); ok {
		_spec.AddField(tier.FieldDiskMB, field.TypeInt64, value)
	}
	if value, ok := tu.mutation.ConcurrentInstances(); ok {
		_spec.SetField(tier.FieldConcurrentInstances, field.TypeInt64, value)
	}
	if value, ok := tu.mutation.AddedConcurrentInstances(); ok {
		_spec.AddField(tier.FieldConcurrentInstances, field.TypeInt64, value)
	}
	if value, ok := tu.mutation.MaxLengthHours(); ok {
		_spec.SetField(tier.FieldMaxLengthHours, field.TypeInt64, value)
	}
	if value, ok := tu.mutation.AddedMaxLengthHours(); ok {
		_spec.AddField(tier.FieldMaxLengthHours, field.TypeInt64, value)
	}
	if tu.mutation.TeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tier.TeamsTable,
			Columns: []string{tier.TeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tu.schemaConfig.Team
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.RemovedTeamsIDs(); len(nodes) > 0 && !tu.mutation.TeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tier.TeamsTable,
			Columns: []string{tier.TeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tu.schemaConfig.Team
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tu.mutation.TeamsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tier.TeamsTable,
			Columns: []string{tier.TeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tu.schemaConfig.Team
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = tu.schemaConfig.Tier
	ctx = internal.NewSchemaConfigContext(ctx, tu.schemaConfig)
	_spec.AddModifiers(tu.modifiers...)
	if n, err = sqlgraph.UpdateNodes(ctx, tu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{tier.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	tu.mutation.done = true
	return n, nil
}

// TierUpdateOne is the builder for updating a single Tier entity.
type TierUpdateOne struct {
	config
	fields    []string
	hooks     []Hook
	mutation  *TierMutation
	modifiers []func(*sql.UpdateBuilder)
}

// SetName sets the "name" field.
func (tuo *TierUpdateOne) SetName(s string) *TierUpdateOne {
	tuo.mutation.SetName(s)
	return tuo
}

// SetNillableName sets the "name" field if the given value is not nil.
func (tuo *TierUpdateOne) SetNillableName(s *string) *TierUpdateOne {
	if s != nil {
		tuo.SetName(*s)
	}
	return tuo
}

// SetDiskMB sets the "disk_mb" field.
func (tuo *TierUpdateOne) SetDiskMB(i int64) *TierUpdateOne {
	tuo.mutation.ResetDiskMB()
	tuo.mutation.SetDiskMB(i)
	return tuo
}

// SetNillableDiskMB sets the "disk_mb" field if the given value is not nil.
func (tuo *TierUpdateOne) SetNillableDiskMB(i *int64) *TierUpdateOne {
	if i != nil {
		tuo.SetDiskMB(*i)
	}
	return tuo
}

// AddDiskMB adds i to the "disk_mb" field.
func (tuo *TierUpdateOne) AddDiskMB(i int64) *TierUpdateOne {
	tuo.mutation.AddDiskMB(i)
	return tuo
}

// SetConcurrentInstances sets the "concurrent_instances" field.
func (tuo *TierUpdateOne) SetConcurrentInstances(i int64) *TierUpdateOne {
	tuo.mutation.ResetConcurrentInstances()
	tuo.mutation.SetConcurrentInstances(i)
	return tuo
}

// SetNillableConcurrentInstances sets the "concurrent_instances" field if the given value is not nil.
func (tuo *TierUpdateOne) SetNillableConcurrentInstances(i *int64) *TierUpdateOne {
	if i != nil {
		tuo.SetConcurrentInstances(*i)
	}
	return tuo
}

// AddConcurrentInstances adds i to the "concurrent_instances" field.
func (tuo *TierUpdateOne) AddConcurrentInstances(i int64) *TierUpdateOne {
	tuo.mutation.AddConcurrentInstances(i)
	return tuo
}

// SetMaxLengthHours sets the "max_length_hours" field.
func (tuo *TierUpdateOne) SetMaxLengthHours(i int64) *TierUpdateOne {
	tuo.mutation.ResetMaxLengthHours()
	tuo.mutation.SetMaxLengthHours(i)
	return tuo
}

// SetNillableMaxLengthHours sets the "max_length_hours" field if the given value is not nil.
func (tuo *TierUpdateOne) SetNillableMaxLengthHours(i *int64) *TierUpdateOne {
	if i != nil {
		tuo.SetMaxLengthHours(*i)
	}
	return tuo
}

// AddMaxLengthHours adds i to the "max_length_hours" field.
func (tuo *TierUpdateOne) AddMaxLengthHours(i int64) *TierUpdateOne {
	tuo.mutation.AddMaxLengthHours(i)
	return tuo
}

// AddTeamIDs adds the "teams" edge to the Team entity by IDs.
func (tuo *TierUpdateOne) AddTeamIDs(ids ...uuid.UUID) *TierUpdateOne {
	tuo.mutation.AddTeamIDs(ids...)
	return tuo
}

// AddTeams adds the "teams" edges to the Team entity.
func (tuo *TierUpdateOne) AddTeams(t ...*Team) *TierUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tuo.AddTeamIDs(ids...)
}

// Mutation returns the TierMutation object of the builder.
func (tuo *TierUpdateOne) Mutation() *TierMutation {
	return tuo.mutation
}

// ClearTeams clears all "teams" edges to the Team entity.
func (tuo *TierUpdateOne) ClearTeams() *TierUpdateOne {
	tuo.mutation.ClearTeams()
	return tuo
}

// RemoveTeamIDs removes the "teams" edge to Team entities by IDs.
func (tuo *TierUpdateOne) RemoveTeamIDs(ids ...uuid.UUID) *TierUpdateOne {
	tuo.mutation.RemoveTeamIDs(ids...)
	return tuo
}

// RemoveTeams removes "teams" edges to Team entities.
func (tuo *TierUpdateOne) RemoveTeams(t ...*Team) *TierUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return tuo.RemoveTeamIDs(ids...)
}

// Where appends a list predicates to the TierUpdate builder.
func (tuo *TierUpdateOne) Where(ps ...predicate.Tier) *TierUpdateOne {
	tuo.mutation.Where(ps...)
	return tuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (tuo *TierUpdateOne) Select(field string, fields ...string) *TierUpdateOne {
	tuo.fields = append([]string{field}, fields...)
	return tuo
}

// Save executes the query and returns the updated Tier entity.
func (tuo *TierUpdateOne) Save(ctx context.Context) (*Tier, error) {
	return withHooks(ctx, tuo.sqlSave, tuo.mutation, tuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (tuo *TierUpdateOne) SaveX(ctx context.Context) *Tier {
	node, err := tuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (tuo *TierUpdateOne) Exec(ctx context.Context) error {
	_, err := tuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (tuo *TierUpdateOne) ExecX(ctx context.Context) {
	if err := tuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (tuo *TierUpdateOne) Modify(modifiers ...func(u *sql.UpdateBuilder)) *TierUpdateOne {
	tuo.modifiers = append(tuo.modifiers, modifiers...)
	return tuo
}

func (tuo *TierUpdateOne) sqlSave(ctx context.Context) (_node *Tier, err error) {
	_spec := sqlgraph.NewUpdateSpec(tier.Table, tier.Columns, sqlgraph.NewFieldSpec(tier.FieldID, field.TypeString))
	id, ok := tuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`models: missing "Tier.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := tuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, tier.FieldID)
		for _, f := range fields {
			if !tier.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
			}
			if f != tier.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := tuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := tuo.mutation.Name(); ok {
		_spec.SetField(tier.FieldName, field.TypeString, value)
	}
	if value, ok := tuo.mutation.DiskMB(); ok {
		_spec.SetField(tier.FieldDiskMB, field.TypeInt64, value)
	}
	if value, ok := tuo.mutation.AddedDiskMB(); ok {
		_spec.AddField(tier.FieldDiskMB, field.TypeInt64, value)
	}
	if value, ok := tuo.mutation.ConcurrentInstances(); ok {
		_spec.SetField(tier.FieldConcurrentInstances, field.TypeInt64, value)
	}
	if value, ok := tuo.mutation.AddedConcurrentInstances(); ok {
		_spec.AddField(tier.FieldConcurrentInstances, field.TypeInt64, value)
	}
	if value, ok := tuo.mutation.MaxLengthHours(); ok {
		_spec.SetField(tier.FieldMaxLengthHours, field.TypeInt64, value)
	}
	if value, ok := tuo.mutation.AddedMaxLengthHours(); ok {
		_spec.AddField(tier.FieldMaxLengthHours, field.TypeInt64, value)
	}
	if tuo.mutation.TeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tier.TeamsTable,
			Columns: []string{tier.TeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tuo.schemaConfig.Team
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.RemovedTeamsIDs(); len(nodes) > 0 && !tuo.mutation.TeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tier.TeamsTable,
			Columns: []string{tier.TeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tuo.schemaConfig.Team
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := tuo.mutation.TeamsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   tier.TeamsTable,
			Columns: []string{tier.TeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = tuo.schemaConfig.Team
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = tuo.schemaConfig.Tier
	ctx = internal.NewSchemaConfigContext(ctx, tuo.schemaConfig)
	_spec.AddModifiers(tuo.modifiers...)
	_node = &Tier{config: tuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, tuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{tier.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	tuo.mutation.done = true
	return _node, nil
}



================================================
File: models/tx.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"sync"

	"entgo.io/ent/dialect"
)

// Tx is a transactional client that is created by calling Client.Tx().
type Tx struct {
	config
	// AccessToken is the client for interacting with the AccessToken builders.
	AccessToken *AccessTokenClient
	// Env is the client for interacting with the Env builders.
	Env *EnvClient
	// EnvAlias is the client for interacting with the EnvAlias builders.
	EnvAlias *EnvAliasClient
	// EnvBuild is the client for interacting with the EnvBuild builders.
	EnvBuild *EnvBuildClient
	// Snapshot is the client for interacting with the Snapshot builders.
	Snapshot *SnapshotClient
	// Team is the client for interacting with the Team builders.
	Team *TeamClient
	// TeamAPIKey is the client for interacting with the TeamAPIKey builders.
	TeamAPIKey *TeamAPIKeyClient
	// Tier is the client for interacting with the Tier builders.
	Tier *TierClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UsersTeams is the client for interacting with the UsersTeams builders.
	UsersTeams *UsersTeamsClient

	// lazily loaded.
	client     *Client
	clientOnce sync.Once
	// ctx lives for the life of the transaction. It is
	// the same context used by the underlying connection.
	ctx context.Context
}

type (
	// Committer is the interface that wraps the Commit method.
	Committer interface {
		Commit(context.Context, *Tx) error
	}

	// The CommitFunc type is an adapter to allow the use of ordinary
	// function as a Committer. If f is a function with the appropriate
	// signature, CommitFunc(f) is a Committer that calls f.
	CommitFunc func(context.Context, *Tx) error

	// CommitHook defines the "commit middleware". A function that gets a Committer
	// and returns a Committer. For example:
	//
	//	hook := func(next ent.Committer) ent.Committer {
	//		return ent.CommitFunc(func(ctx context.Context, tx *ent.Tx) error {
	//			// Do some stuff before.
	//			if err := next.Commit(ctx, tx); err != nil {
	//				return err
	//			}
	//			// Do some stuff after.
	//			return nil
	//		})
	//	}
	//
	CommitHook func(Committer) Committer
)

// Commit calls f(ctx, m).
func (f CommitFunc) Commit(ctx context.Context, tx *Tx) error {
	return f(ctx, tx)
}

// Commit commits the transaction.
func (tx *Tx) Commit() error {
	txDriver := tx.config.driver.(*txDriver)
	var fn Committer = CommitFunc(func(context.Context, *Tx) error {
		return txDriver.tx.Commit()
	})
	txDriver.mu.Lock()
	hooks := append([]CommitHook(nil), txDriver.onCommit...)
	txDriver.mu.Unlock()
	for i := len(hooks) - 1; i >= 0; i-- {
		fn = hooks[i](fn)
	}
	return fn.Commit(tx.ctx, tx)
}

// OnCommit adds a hook to call on commit.
func (tx *Tx) OnCommit(f CommitHook) {
	txDriver := tx.config.driver.(*txDriver)
	txDriver.mu.Lock()
	txDriver.onCommit = append(txDriver.onCommit, f)
	txDriver.mu.Unlock()
}

type (
	// Rollbacker is the interface that wraps the Rollback method.
	Rollbacker interface {
		Rollback(context.Context, *Tx) error
	}

	// The RollbackFunc type is an adapter to allow the use of ordinary
	// function as a Rollbacker. If f is a function with the appropriate
	// signature, RollbackFunc(f) is a Rollbacker that calls f.
	RollbackFunc func(context.Context, *Tx) error

	// RollbackHook defines the "rollback middleware". A function that gets a Rollbacker
	// and returns a Rollbacker. For example:
	//
	//	hook := func(next ent.Rollbacker) ent.Rollbacker {
	//		return ent.RollbackFunc(func(ctx context.Context, tx *ent.Tx) error {
	//			// Do some stuff before.
	//			if err := next.Rollback(ctx, tx); err != nil {
	//				return err
	//			}
	//			// Do some stuff after.
	//			return nil
	//		})
	//	}
	//
	RollbackHook func(Rollbacker) Rollbacker
)

// Rollback calls f(ctx, m).
func (f RollbackFunc) Rollback(ctx context.Context, tx *Tx) error {
	return f(ctx, tx)
}

// Rollback rollbacks the transaction.
func (tx *Tx) Rollback() error {
	txDriver := tx.config.driver.(*txDriver)
	var fn Rollbacker = RollbackFunc(func(context.Context, *Tx) error {
		return txDriver.tx.Rollback()
	})
	txDriver.mu.Lock()
	hooks := append([]RollbackHook(nil), txDriver.onRollback...)
	txDriver.mu.Unlock()
	for i := len(hooks) - 1; i >= 0; i-- {
		fn = hooks[i](fn)
	}
	return fn.Rollback(tx.ctx, tx)
}

// OnRollback adds a hook to call on rollback.
func (tx *Tx) OnRollback(f RollbackHook) {
	txDriver := tx.config.driver.(*txDriver)
	txDriver.mu.Lock()
	txDriver.onRollback = append(txDriver.onRollback, f)
	txDriver.mu.Unlock()
}

// Client returns a Client that binds to current transaction.
func (tx *Tx) Client() *Client {
	tx.clientOnce.Do(func() {
		tx.client = &Client{config: tx.config}
		tx.client.init()
	})
	return tx.client
}

func (tx *Tx) init() {
	tx.AccessToken = NewAccessTokenClient(tx.config)
	tx.Env = NewEnvClient(tx.config)
	tx.EnvAlias = NewEnvAliasClient(tx.config)
	tx.EnvBuild = NewEnvBuildClient(tx.config)
	tx.Snapshot = NewSnapshotClient(tx.config)
	tx.Team = NewTeamClient(tx.config)
	tx.TeamAPIKey = NewTeamAPIKeyClient(tx.config)
	tx.Tier = NewTierClient(tx.config)
	tx.User = NewUserClient(tx.config)
	tx.UsersTeams = NewUsersTeamsClient(tx.config)
}

// txDriver wraps the given dialect.Tx with a nop dialect.Driver implementation.
// The idea is to support transactions without adding any extra code to the builders.
// When a builder calls to driver.Tx(), it gets the same dialect.Tx instance.
// Commit and Rollback are nop for the internal builders and the user must call one
// of them in order to commit or rollback the transaction.
//
// If a closed transaction is embedded in one of the generated entities, and the entity
// applies a query, for example: AccessToken.QueryXXX(), the query will be executed
// through the driver which created this transaction.
//
// Note that txDriver is not goroutine safe.
type txDriver struct {
	// the driver we started the transaction from.
	drv dialect.Driver
	// tx is the underlying transaction.
	tx dialect.Tx
	// completion hooks.
	mu         sync.Mutex
	onCommit   []CommitHook
	onRollback []RollbackHook
}

// newTx creates a new transactional driver.
func newTx(ctx context.Context, drv dialect.Driver) (*txDriver, error) {
	tx, err := drv.Tx(ctx)
	if err != nil {
		return nil, err
	}
	return &txDriver{tx: tx, drv: drv}, nil
}

// Tx returns the transaction wrapper (txDriver) to avoid Commit or Rollback calls
// from the internal builders. Should be called only by the internal builders.
func (tx *txDriver) Tx(context.Context) (dialect.Tx, error) { return tx, nil }

// Dialect returns the dialect of the driver we started the transaction from.
func (tx *txDriver) Dialect() string { return tx.drv.Dialect() }

// Close is a nop close.
func (*txDriver) Close() error { return nil }

// Commit is a nop commit for the internal builders.
// User must call `Tx.Commit` in order to commit the transaction.
func (*txDriver) Commit() error { return nil }

// Rollback is a nop rollback for the internal builders.
// User must call `Tx.Rollback` in order to rollback the transaction.
func (*txDriver) Rollback() error { return nil }

// Exec calls tx.Exec.
func (tx *txDriver) Exec(ctx context.Context, query string, args, v any) error {
	return tx.tx.Exec(ctx, query, args, v)
}

// Query calls tx.Query.
func (tx *txDriver) Query(ctx context.Context, query string, args, v any) error {
	return tx.tx.Query(ctx, query, args, v)
}

var _ dialect.Driver = (*txDriver)(nil)



================================================
File: models/user.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"fmt"
	"strings"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/google/uuid"
)

// User is the model entity for the User schema.
type User struct {
	config `json:"-"`
	// ID of the ent.
	ID uuid.UUID `json:"id,omitempty"`
	// Email holds the value of the "email" field.
	Email string `json:"email,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the UserQuery when eager-loading is set.
	Edges        UserEdges `json:"edges"`
	selectValues sql.SelectValues
}

// UserEdges holds the relations/edges for other nodes in the graph.
type UserEdges struct {
	// Teams holds the value of the teams edge.
	Teams []*Team `json:"teams,omitempty"`
	// CreatedEnvs holds the value of the created_envs edge.
	CreatedEnvs []*Env `json:"created_envs,omitempty"`
	// AccessTokens holds the value of the access_tokens edge.
	AccessTokens []*AccessToken `json:"access_tokens,omitempty"`
	// CreatedAPIKeys holds the value of the created_api_keys edge.
	CreatedAPIKeys []*TeamAPIKey `json:"created_api_keys,omitempty"`
	// UsersTeams holds the value of the users_teams edge.
	UsersTeams []*UsersTeams `json:"users_teams,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [5]bool
}

// TeamsOrErr returns the Teams value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) TeamsOrErr() ([]*Team, error) {
	if e.loadedTypes[0] {
		return e.Teams, nil
	}
	return nil, &NotLoadedError{edge: "teams"}
}

// CreatedEnvsOrErr returns the CreatedEnvs value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) CreatedEnvsOrErr() ([]*Env, error) {
	if e.loadedTypes[1] {
		return e.CreatedEnvs, nil
	}
	return nil, &NotLoadedError{edge: "created_envs"}
}

// AccessTokensOrErr returns the AccessTokens value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) AccessTokensOrErr() ([]*AccessToken, error) {
	if e.loadedTypes[2] {
		return e.AccessTokens, nil
	}
	return nil, &NotLoadedError{edge: "access_tokens"}
}

// CreatedAPIKeysOrErr returns the CreatedAPIKeys value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) CreatedAPIKeysOrErr() ([]*TeamAPIKey, error) {
	if e.loadedTypes[3] {
		return e.CreatedAPIKeys, nil
	}
	return nil, &NotLoadedError{edge: "created_api_keys"}
}

// UsersTeamsOrErr returns the UsersTeams value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) UsersTeamsOrErr() ([]*UsersTeams, error) {
	if e.loadedTypes[4] {
		return e.UsersTeams, nil
	}
	return nil, &NotLoadedError{edge: "users_teams"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*User) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case user.FieldEmail:
			values[i] = new(sql.NullString)
		case user.FieldID:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the User fields.
func (u *User) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case user.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				u.ID = *value
			}
		case user.FieldEmail:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field email", values[i])
			} else if value.Valid {
				u.Email = value.String
			}
		default:
			u.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the User.
// This includes values selected through modifiers, order, etc.
func (u *User) Value(name string) (ent.Value, error) {
	return u.selectValues.Get(name)
}

// QueryTeams queries the "teams" edge of the User entity.
func (u *User) QueryTeams() *TeamQuery {
	return NewUserClient(u.config).QueryTeams(u)
}

// QueryCreatedEnvs queries the "created_envs" edge of the User entity.
func (u *User) QueryCreatedEnvs() *EnvQuery {
	return NewUserClient(u.config).QueryCreatedEnvs(u)
}

// QueryAccessTokens queries the "access_tokens" edge of the User entity.
func (u *User) QueryAccessTokens() *AccessTokenQuery {
	return NewUserClient(u.config).QueryAccessTokens(u)
}

// QueryCreatedAPIKeys queries the "created_api_keys" edge of the User entity.
func (u *User) QueryCreatedAPIKeys() *TeamAPIKeyQuery {
	return NewUserClient(u.config).QueryCreatedAPIKeys(u)
}

// QueryUsersTeams queries the "users_teams" edge of the User entity.
func (u *User) QueryUsersTeams() *UsersTeamsQuery {
	return NewUserClient(u.config).QueryUsersTeams(u)
}

// Update returns a builder for updating this User.
// Note that you need to call User.Unwrap() before calling this method if this User
// was returned from a transaction, and the transaction was committed or rolled back.
func (u *User) Update() *UserUpdateOne {
	return NewUserClient(u.config).UpdateOne(u)
}

// Unwrap unwraps the User entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (u *User) Unwrap() *User {
	_tx, ok := u.config.driver.(*txDriver)
	if !ok {
		panic("models: User is not a transactional entity")
	}
	u.config.driver = _tx.drv
	return u
}

// String implements the fmt.Stringer.
func (u *User) String() string {
	var builder strings.Builder
	builder.WriteString("User(")
	builder.WriteString(fmt.Sprintf("id=%v, ", u.ID))
	builder.WriteString("email=")
	builder.WriteString(u.Email)
	builder.WriteByte(')')
	return builder.String()
}

// Users is a parsable slice of User.
type Users []*User



================================================
File: models/user_create.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/accesstoken"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/teamapikey"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"
	"github.com/google/uuid"
)

// UserCreate is the builder for creating a User entity.
type UserCreate struct {
	config
	mutation *UserMutation
	hooks    []Hook
	conflict []sql.ConflictOption
}

// SetEmail sets the "email" field.
func (uc *UserCreate) SetEmail(s string) *UserCreate {
	uc.mutation.SetEmail(s)
	return uc
}

// SetID sets the "id" field.
func (uc *UserCreate) SetID(u uuid.UUID) *UserCreate {
	uc.mutation.SetID(u)
	return uc
}

// AddTeamIDs adds the "teams" edge to the Team entity by IDs.
func (uc *UserCreate) AddTeamIDs(ids ...uuid.UUID) *UserCreate {
	uc.mutation.AddTeamIDs(ids...)
	return uc
}

// AddTeams adds the "teams" edges to the Team entity.
func (uc *UserCreate) AddTeams(t ...*Team) *UserCreate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uc.AddTeamIDs(ids...)
}

// AddCreatedEnvIDs adds the "created_envs" edge to the Env entity by IDs.
func (uc *UserCreate) AddCreatedEnvIDs(ids ...string) *UserCreate {
	uc.mutation.AddCreatedEnvIDs(ids...)
	return uc
}

// AddCreatedEnvs adds the "created_envs" edges to the Env entity.
func (uc *UserCreate) AddCreatedEnvs(e ...*Env) *UserCreate {
	ids := make([]string, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return uc.AddCreatedEnvIDs(ids...)
}

// AddAccessTokenIDs adds the "access_tokens" edge to the AccessToken entity by IDs.
func (uc *UserCreate) AddAccessTokenIDs(ids ...string) *UserCreate {
	uc.mutation.AddAccessTokenIDs(ids...)
	return uc
}

// AddAccessTokens adds the "access_tokens" edges to the AccessToken entity.
func (uc *UserCreate) AddAccessTokens(a ...*AccessToken) *UserCreate {
	ids := make([]string, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uc.AddAccessTokenIDs(ids...)
}

// AddCreatedAPIKeyIDs adds the "created_api_keys" edge to the TeamAPIKey entity by IDs.
func (uc *UserCreate) AddCreatedAPIKeyIDs(ids ...uuid.UUID) *UserCreate {
	uc.mutation.AddCreatedAPIKeyIDs(ids...)
	return uc
}

// AddCreatedAPIKeys adds the "created_api_keys" edges to the TeamAPIKey entity.
func (uc *UserCreate) AddCreatedAPIKeys(t ...*TeamAPIKey) *UserCreate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uc.AddCreatedAPIKeyIDs(ids...)
}

// AddUsersTeamIDs adds the "users_teams" edge to the UsersTeams entity by IDs.
func (uc *UserCreate) AddUsersTeamIDs(ids ...int) *UserCreate {
	uc.mutation.AddUsersTeamIDs(ids...)
	return uc
}

// AddUsersTeams adds the "users_teams" edges to the UsersTeams entity.
func (uc *UserCreate) AddUsersTeams(u ...*UsersTeams) *UserCreate {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uc.AddUsersTeamIDs(ids...)
}

// Mutation returns the UserMutation object of the builder.
func (uc *UserCreate) Mutation() *UserMutation {
	return uc.mutation
}

// Save creates the User in the database.
func (uc *UserCreate) Save(ctx context.Context) (*User, error) {
	return withHooks(ctx, uc.sqlSave, uc.mutation, uc.hooks)
}

// SaveX calls Save and panics if Save returns an error.
func (uc *UserCreate) SaveX(ctx context.Context) *User {
	v, err := uc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (uc *UserCreate) Exec(ctx context.Context) error {
	_, err := uc.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (uc *UserCreate) ExecX(ctx context.Context) {
	if err := uc.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (uc *UserCreate) check() error {
	if _, ok := uc.mutation.Email(); !ok {
		return &ValidationError{Name: "email", err: errors.New(`models: missing required field "User.email"`)}
	}
	if v, ok := uc.mutation.Email(); ok {
		if err := user.EmailValidator(v); err != nil {
			return &ValidationError{Name: "email", err: fmt.Errorf(`models: validator failed for field "User.email": %w`, err)}
		}
	}
	return nil
}

func (uc *UserCreate) sqlSave(ctx context.Context) (*User, error) {
	if err := uc.check(); err != nil {
		return nil, err
	}
	_node, _spec := uc.createSpec()
	if err := sqlgraph.CreateNode(ctx, uc.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	if _spec.ID.Value != nil {
		if id, ok := _spec.ID.Value.(*uuid.UUID); ok {
			_node.ID = *id
		} else if err := _node.ID.Scan(_spec.ID.Value); err != nil {
			return nil, err
		}
	}
	uc.mutation.id = &_node.ID
	uc.mutation.done = true
	return _node, nil
}

func (uc *UserCreate) createSpec() (*User, *sqlgraph.CreateSpec) {
	var (
		_node = &User{config: uc.config}
		_spec = sqlgraph.NewCreateSpec(user.Table, sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID))
	)
	_spec.Schema = uc.schemaConfig.User
	_spec.OnConflict = uc.conflict
	if id, ok := uc.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = &id
	}
	if value, ok := uc.mutation.Email(); ok {
		_spec.SetField(user.FieldEmail, field.TypeString, value)
		_node.Email = value
	}
	if nodes := uc.mutation.TeamsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   user.TeamsTable,
			Columns: user.TeamsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = uc.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &UsersTeamsCreate{config: uc.config, mutation: newUsersTeamsMutation(uc.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := uc.mutation.CreatedEnvsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreatedEnvsTable,
			Columns: []string{user.CreatedEnvsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = uc.schemaConfig.Env
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := uc.mutation.AccessTokensIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.AccessTokensTable,
			Columns: []string{user.AccessTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(accesstoken.FieldID, field.TypeString),
			},
		}
		edge.Schema = uc.schemaConfig.AccessToken
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := uc.mutation.CreatedAPIKeysIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreatedAPIKeysTable,
			Columns: []string{user.CreatedAPIKeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = uc.schemaConfig.TeamAPIKey
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := uc.mutation.UsersTeamsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.UsersTeamsTable,
			Columns: []string{user.UsersTeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt),
			},
		}
		edge.Schema = uc.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.User.Create().
//		SetEmail(v).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.UserUpsert) {
//			SetEmail(v+v).
//		}).
//		Exec(ctx)
func (uc *UserCreate) OnConflict(opts ...sql.ConflictOption) *UserUpsertOne {
	uc.conflict = opts
	return &UserUpsertOne{
		create: uc,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.User.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (uc *UserCreate) OnConflictColumns(columns ...string) *UserUpsertOne {
	uc.conflict = append(uc.conflict, sql.ConflictColumns(columns...))
	return &UserUpsertOne{
		create: uc,
	}
}

type (
	// UserUpsertOne is the builder for "upsert"-ing
	//  one User node.
	UserUpsertOne struct {
		create *UserCreate
	}

	// UserUpsert is the "OnConflict" setter.
	UserUpsert struct {
		*sql.UpdateSet
	}
)

// SetEmail sets the "email" field.
func (u *UserUpsert) SetEmail(v string) *UserUpsert {
	u.Set(user.FieldEmail, v)
	return u
}

// UpdateEmail sets the "email" field to the value that was provided on create.
func (u *UserUpsert) UpdateEmail() *UserUpsert {
	u.SetExcluded(user.FieldEmail)
	return u
}

// UpdateNewValues updates the mutable fields using the new values that were set on create except the ID field.
// Using this option is equivalent to using:
//
//	client.User.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(user.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *UserUpsertOne) UpdateNewValues() *UserUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		if _, exists := u.create.mutation.ID(); exists {
			s.SetIgnore(user.FieldID)
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.User.Create().
//	    OnConflict(sql.ResolveWithIgnore()).
//	    Exec(ctx)
func (u *UserUpsertOne) Ignore() *UserUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *UserUpsertOne) DoNothing() *UserUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the UserCreate.OnConflict
// documentation for more info.
func (u *UserUpsertOne) Update(set func(*UserUpsert)) *UserUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&UserUpsert{UpdateSet: update})
	}))
	return u
}

// SetEmail sets the "email" field.
func (u *UserUpsertOne) SetEmail(v string) *UserUpsertOne {
	return u.Update(func(s *UserUpsert) {
		s.SetEmail(v)
	})
}

// UpdateEmail sets the "email" field to the value that was provided on create.
func (u *UserUpsertOne) UpdateEmail() *UserUpsertOne {
	return u.Update(func(s *UserUpsert) {
		s.UpdateEmail()
	})
}

// Exec executes the query.
func (u *UserUpsertOne) Exec(ctx context.Context) error {
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for UserCreate.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *UserUpsertOne) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}

// Exec executes the UPSERT query and returns the inserted/updated ID.
func (u *UserUpsertOne) ID(ctx context.Context) (id uuid.UUID, err error) {
	if u.create.driver.Dialect() == dialect.MySQL {
		// In case of "ON CONFLICT", there is no way to get back non-numeric ID
		// fields from the database since MySQL does not support the RETURNING clause.
		return id, errors.New("models: UserUpsertOne.ID is not supported by MySQL driver. Use UserUpsertOne.Exec instead")
	}
	node, err := u.create.Save(ctx)
	if err != nil {
		return id, err
	}
	return node.ID, nil
}

// IDX is like ID, but panics if an error occurs.
func (u *UserUpsertOne) IDX(ctx context.Context) uuid.UUID {
	id, err := u.ID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// UserCreateBulk is the builder for creating many User entities in bulk.
type UserCreateBulk struct {
	config
	err      error
	builders []*UserCreate
	conflict []sql.ConflictOption
}

// Save creates the User entities in the database.
func (ucb *UserCreateBulk) Save(ctx context.Context) ([]*User, error) {
	if ucb.err != nil {
		return nil, ucb.err
	}
	specs := make([]*sqlgraph.CreateSpec, len(ucb.builders))
	nodes := make([]*User, len(ucb.builders))
	mutators := make([]Mutator, len(ucb.builders))
	for i := range ucb.builders {
		func(i int, root context.Context) {
			builder := ucb.builders[i]
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*UserMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				var err error
				nodes[i], specs[i] = builder.createSpec()
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, ucb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					spec.OnConflict = ucb.conflict
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, ucb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{msg: err.Error(), wrap: err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, ucb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (ucb *UserCreateBulk) SaveX(ctx context.Context) []*User {
	v, err := ucb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (ucb *UserCreateBulk) Exec(ctx context.Context) error {
	_, err := ucb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ucb *UserCreateBulk) ExecX(ctx context.Context) {
	if err := ucb.Exec(ctx); err != nil {
		panic(err)
	}
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.User.CreateBulk(builders...).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.UserUpsert) {
//			SetEmail(v+v).
//		}).
//		Exec(ctx)
func (ucb *UserCreateBulk) OnConflict(opts ...sql.ConflictOption) *UserUpsertBulk {
	ucb.conflict = opts
	return &UserUpsertBulk{
		create: ucb,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.User.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (ucb *UserCreateBulk) OnConflictColumns(columns ...string) *UserUpsertBulk {
	ucb.conflict = append(ucb.conflict, sql.ConflictColumns(columns...))
	return &UserUpsertBulk{
		create: ucb,
	}
}

// UserUpsertBulk is the builder for "upsert"-ing
// a bulk of User nodes.
type UserUpsertBulk struct {
	create *UserCreateBulk
}

// UpdateNewValues updates the mutable fields using the new values that
// were set on create. Using this option is equivalent to using:
//
//	client.User.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(user.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *UserUpsertBulk) UpdateNewValues() *UserUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		for _, b := range u.create.builders {
			if _, exists := b.mutation.ID(); exists {
				s.SetIgnore(user.FieldID)
			}
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.User.Create().
//		OnConflict(sql.ResolveWithIgnore()).
//		Exec(ctx)
func (u *UserUpsertBulk) Ignore() *UserUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *UserUpsertBulk) DoNothing() *UserUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the UserCreateBulk.OnConflict
// documentation for more info.
func (u *UserUpsertBulk) Update(set func(*UserUpsert)) *UserUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&UserUpsert{UpdateSet: update})
	}))
	return u
}

// SetEmail sets the "email" field.
func (u *UserUpsertBulk) SetEmail(v string) *UserUpsertBulk {
	return u.Update(func(s *UserUpsert) {
		s.SetEmail(v)
	})
}

// UpdateEmail sets the "email" field to the value that was provided on create.
func (u *UserUpsertBulk) UpdateEmail() *UserUpsertBulk {
	return u.Update(func(s *UserUpsert) {
		s.UpdateEmail()
	})
}

// Exec executes the query.
func (u *UserUpsertBulk) Exec(ctx context.Context) error {
	if u.create.err != nil {
		return u.create.err
	}
	for i, b := range u.create.builders {
		if len(b.conflict) != 0 {
			return fmt.Errorf("models: OnConflict was set for builder %d. Set it on the UserCreateBulk instead", i)
		}
	}
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for UserCreateBulk.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *UserUpsertBulk) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/user_delete.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
)

// UserDelete is the builder for deleting a User entity.
type UserDelete struct {
	config
	hooks    []Hook
	mutation *UserMutation
}

// Where appends a list predicates to the UserDelete builder.
func (ud *UserDelete) Where(ps ...predicate.User) *UserDelete {
	ud.mutation.Where(ps...)
	return ud
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (ud *UserDelete) Exec(ctx context.Context) (int, error) {
	return withHooks(ctx, ud.sqlExec, ud.mutation, ud.hooks)
}

// ExecX is like Exec, but panics if an error occurs.
func (ud *UserDelete) ExecX(ctx context.Context) int {
	n, err := ud.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (ud *UserDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := sqlgraph.NewDeleteSpec(user.Table, sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID))
	_spec.Node.Schema = ud.schemaConfig.User
	ctx = internal.NewSchemaConfigContext(ctx, ud.schemaConfig)
	if ps := ud.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	affected, err := sqlgraph.DeleteNodes(ctx, ud.driver, _spec)
	if err != nil && sqlgraph.IsConstraintError(err) {
		err = &ConstraintError{msg: err.Error(), wrap: err}
	}
	ud.mutation.done = true
	return affected, err
}

// UserDeleteOne is the builder for deleting a single User entity.
type UserDeleteOne struct {
	ud *UserDelete
}

// Where appends a list predicates to the UserDelete builder.
func (udo *UserDeleteOne) Where(ps ...predicate.User) *UserDeleteOne {
	udo.ud.mutation.Where(ps...)
	return udo
}

// Exec executes the deletion query.
func (udo *UserDeleteOne) Exec(ctx context.Context) error {
	n, err := udo.ud.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{user.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (udo *UserDeleteOne) ExecX(ctx context.Context) {
	if err := udo.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/user_query.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"database/sql/driver"
	"fmt"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/accesstoken"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/teamapikey"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"
	"github.com/google/uuid"
)

// UserQuery is the builder for querying User entities.
type UserQuery struct {
	config
	ctx                *QueryContext
	order              []user.OrderOption
	inters             []Interceptor
	predicates         []predicate.User
	withTeams          *TeamQuery
	withCreatedEnvs    *EnvQuery
	withAccessTokens   *AccessTokenQuery
	withCreatedAPIKeys *TeamAPIKeyQuery
	withUsersTeams     *UsersTeamsQuery
	modifiers          []func(*sql.Selector)
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the UserQuery builder.
func (uq *UserQuery) Where(ps ...predicate.User) *UserQuery {
	uq.predicates = append(uq.predicates, ps...)
	return uq
}

// Limit the number of records to be returned by this query.
func (uq *UserQuery) Limit(limit int) *UserQuery {
	uq.ctx.Limit = &limit
	return uq
}

// Offset to start from.
func (uq *UserQuery) Offset(offset int) *UserQuery {
	uq.ctx.Offset = &offset
	return uq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (uq *UserQuery) Unique(unique bool) *UserQuery {
	uq.ctx.Unique = &unique
	return uq
}

// Order specifies how the records should be ordered.
func (uq *UserQuery) Order(o ...user.OrderOption) *UserQuery {
	uq.order = append(uq.order, o...)
	return uq
}

// QueryTeams chains the current query on the "teams" edge.
func (uq *UserQuery) QueryTeams() *TeamQuery {
	query := (&TeamClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.TeamsTable, user.TeamsPrimaryKey...),
		)
		schemaConfig := uq.schemaConfig
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.UsersTeams
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCreatedEnvs chains the current query on the "created_envs" edge.
func (uq *UserQuery) QueryCreatedEnvs() *EnvQuery {
	query := (&EnvClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(env.Table, env.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedEnvsTable, user.CreatedEnvsColumn),
		)
		schemaConfig := uq.schemaConfig
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.Env
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryAccessTokens chains the current query on the "access_tokens" edge.
func (uq *UserQuery) QueryAccessTokens() *AccessTokenQuery {
	query := (&AccessTokenClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(accesstoken.Table, accesstoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AccessTokensTable, user.AccessTokensColumn),
		)
		schemaConfig := uq.schemaConfig
		step.To.Schema = schemaConfig.AccessToken
		step.Edge.Schema = schemaConfig.AccessToken
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCreatedAPIKeys chains the current query on the "created_api_keys" edge.
func (uq *UserQuery) QueryCreatedAPIKeys() *TeamAPIKeyQuery {
	query := (&TeamAPIKeyClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(teamapikey.Table, teamapikey.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedAPIKeysTable, user.CreatedAPIKeysColumn),
		)
		schemaConfig := uq.schemaConfig
		step.To.Schema = schemaConfig.TeamAPIKey
		step.Edge.Schema = schemaConfig.TeamAPIKey
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryUsersTeams chains the current query on the "users_teams" edge.
func (uq *UserQuery) QueryUsersTeams() *UsersTeamsQuery {
	query := (&UsersTeamsClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(usersteams.Table, usersteams.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.UsersTeamsTable, user.UsersTeamsColumn),
		)
		schemaConfig := uq.schemaConfig
		step.To.Schema = schemaConfig.UsersTeams
		step.Edge.Schema = schemaConfig.UsersTeams
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first User entity from the query.
// Returns a *NotFoundError when no User was found.
func (uq *UserQuery) First(ctx context.Context) (*User, error) {
	nodes, err := uq.Limit(1).All(setContextOp(ctx, uq.ctx, "First"))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{user.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (uq *UserQuery) FirstX(ctx context.Context) *User {
	node, err := uq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first User ID from the query.
// Returns a *NotFoundError when no User ID was found.
func (uq *UserQuery) FirstID(ctx context.Context) (id uuid.UUID, err error) {
	var ids []uuid.UUID
	if ids, err = uq.Limit(1).IDs(setContextOp(ctx, uq.ctx, "FirstID")); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{user.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (uq *UserQuery) FirstIDX(ctx context.Context) uuid.UUID {
	id, err := uq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single User entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one User entity is found.
// Returns a *NotFoundError when no User entities are found.
func (uq *UserQuery) Only(ctx context.Context) (*User, error) {
	nodes, err := uq.Limit(2).All(setContextOp(ctx, uq.ctx, "Only"))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{user.Label}
	default:
		return nil, &NotSingularError{user.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (uq *UserQuery) OnlyX(ctx context.Context) *User {
	node, err := uq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only User ID in the query.
// Returns a *NotSingularError when more than one User ID is found.
// Returns a *NotFoundError when no entities are found.
func (uq *UserQuery) OnlyID(ctx context.Context) (id uuid.UUID, err error) {
	var ids []uuid.UUID
	if ids, err = uq.Limit(2).IDs(setContextOp(ctx, uq.ctx, "OnlyID")); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{user.Label}
	default:
		err = &NotSingularError{user.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (uq *UserQuery) OnlyIDX(ctx context.Context) uuid.UUID {
	id, err := uq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of Users.
func (uq *UserQuery) All(ctx context.Context) ([]*User, error) {
	ctx = setContextOp(ctx, uq.ctx, "All")
	if err := uq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*User, *UserQuery]()
	return withInterceptors[[]*User](ctx, uq, qr, uq.inters)
}

// AllX is like All, but panics if an error occurs.
func (uq *UserQuery) AllX(ctx context.Context) []*User {
	nodes, err := uq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of User IDs.
func (uq *UserQuery) IDs(ctx context.Context) (ids []uuid.UUID, err error) {
	if uq.ctx.Unique == nil && uq.path != nil {
		uq.Unique(true)
	}
	ctx = setContextOp(ctx, uq.ctx, "IDs")
	if err = uq.Select(user.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (uq *UserQuery) IDsX(ctx context.Context) []uuid.UUID {
	ids, err := uq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (uq *UserQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, uq.ctx, "Count")
	if err := uq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, uq, querierCount[*UserQuery](), uq.inters)
}

// CountX is like Count, but panics if an error occurs.
func (uq *UserQuery) CountX(ctx context.Context) int {
	count, err := uq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (uq *UserQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, uq.ctx, "Exist")
	switch _, err := uq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("models: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (uq *UserQuery) ExistX(ctx context.Context) bool {
	exist, err := uq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the UserQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (uq *UserQuery) Clone() *UserQuery {
	if uq == nil {
		return nil
	}
	return &UserQuery{
		config:             uq.config,
		ctx:                uq.ctx.Clone(),
		order:              append([]user.OrderOption{}, uq.order...),
		inters:             append([]Interceptor{}, uq.inters...),
		predicates:         append([]predicate.User{}, uq.predicates...),
		withTeams:          uq.withTeams.Clone(),
		withCreatedEnvs:    uq.withCreatedEnvs.Clone(),
		withAccessTokens:   uq.withAccessTokens.Clone(),
		withCreatedAPIKeys: uq.withCreatedAPIKeys.Clone(),
		withUsersTeams:     uq.withUsersTeams.Clone(),
		// clone intermediate query.
		sql:  uq.sql.Clone(),
		path: uq.path,
	}
}

// WithTeams tells the query-builder to eager-load the nodes that are connected to
// the "teams" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithTeams(opts ...func(*TeamQuery)) *UserQuery {
	query := (&TeamClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withTeams = query
	return uq
}

// WithCreatedEnvs tells the query-builder to eager-load the nodes that are connected to
// the "created_envs" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithCreatedEnvs(opts ...func(*EnvQuery)) *UserQuery {
	query := (&EnvClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withCreatedEnvs = query
	return uq
}

// WithAccessTokens tells the query-builder to eager-load the nodes that are connected to
// the "access_tokens" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithAccessTokens(opts ...func(*AccessTokenQuery)) *UserQuery {
	query := (&AccessTokenClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withAccessTokens = query
	return uq
}

// WithCreatedAPIKeys tells the query-builder to eager-load the nodes that are connected to
// the "created_api_keys" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithCreatedAPIKeys(opts ...func(*TeamAPIKeyQuery)) *UserQuery {
	query := (&TeamAPIKeyClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withCreatedAPIKeys = query
	return uq
}

// WithUsersTeams tells the query-builder to eager-load the nodes that are connected to
// the "users_teams" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithUsersTeams(opts ...func(*UsersTeamsQuery)) *UserQuery {
	query := (&UsersTeamsClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withUsersTeams = query
	return uq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		Email string `json:"email,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.User.Query().
//		GroupBy(user.FieldEmail).
//		Aggregate(models.Count()).
//		Scan(ctx, &v)
func (uq *UserQuery) GroupBy(field string, fields ...string) *UserGroupBy {
	uq.ctx.Fields = append([]string{field}, fields...)
	grbuild := &UserGroupBy{build: uq}
	grbuild.flds = &uq.ctx.Fields
	grbuild.label = user.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		Email string `json:"email,omitempty"`
//	}
//
//	client.User.Query().
//		Select(user.FieldEmail).
//		Scan(ctx, &v)
func (uq *UserQuery) Select(fields ...string) *UserSelect {
	uq.ctx.Fields = append(uq.ctx.Fields, fields...)
	sbuild := &UserSelect{UserQuery: uq}
	sbuild.label = user.Label
	sbuild.flds, sbuild.scan = &uq.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a UserSelect configured with the given aggregations.
func (uq *UserQuery) Aggregate(fns ...AggregateFunc) *UserSelect {
	return uq.Select().Aggregate(fns...)
}

func (uq *UserQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range uq.inters {
		if inter == nil {
			return fmt.Errorf("models: uninitialized interceptor (forgotten import models/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, uq); err != nil {
				return err
			}
		}
	}
	for _, f := range uq.ctx.Fields {
		if !user.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
		}
	}
	if uq.path != nil {
		prev, err := uq.path(ctx)
		if err != nil {
			return err
		}
		uq.sql = prev
	}
	return nil
}

func (uq *UserQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*User, error) {
	var (
		nodes       = []*User{}
		_spec       = uq.querySpec()
		loadedTypes = [5]bool{
			uq.withTeams != nil,
			uq.withCreatedEnvs != nil,
			uq.withAccessTokens != nil,
			uq.withCreatedAPIKeys != nil,
			uq.withUsersTeams != nil,
		}
	)
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*User).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &User{config: uq.config}
		nodes = append(nodes, node)
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	_spec.Node.Schema = uq.schemaConfig.User
	ctx = internal.NewSchemaConfigContext(ctx, uq.schemaConfig)
	if len(uq.modifiers) > 0 {
		_spec.Modifiers = uq.modifiers
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, uq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	if query := uq.withTeams; query != nil {
		if err := uq.loadTeams(ctx, query, nodes,
			func(n *User) { n.Edges.Teams = []*Team{} },
			func(n *User, e *Team) { n.Edges.Teams = append(n.Edges.Teams, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withCreatedEnvs; query != nil {
		if err := uq.loadCreatedEnvs(ctx, query, nodes,
			func(n *User) { n.Edges.CreatedEnvs = []*Env{} },
			func(n *User, e *Env) { n.Edges.CreatedEnvs = append(n.Edges.CreatedEnvs, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withAccessTokens; query != nil {
		if err := uq.loadAccessTokens(ctx, query, nodes,
			func(n *User) { n.Edges.AccessTokens = []*AccessToken{} },
			func(n *User, e *AccessToken) { n.Edges.AccessTokens = append(n.Edges.AccessTokens, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withCreatedAPIKeys; query != nil {
		if err := uq.loadCreatedAPIKeys(ctx, query, nodes,
			func(n *User) { n.Edges.CreatedAPIKeys = []*TeamAPIKey{} },
			func(n *User, e *TeamAPIKey) { n.Edges.CreatedAPIKeys = append(n.Edges.CreatedAPIKeys, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withUsersTeams; query != nil {
		if err := uq.loadUsersTeams(ctx, query, nodes,
			func(n *User) { n.Edges.UsersTeams = []*UsersTeams{} },
			func(n *User, e *UsersTeams) { n.Edges.UsersTeams = append(n.Edges.UsersTeams, e) }); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

func (uq *UserQuery) loadTeams(ctx context.Context, query *TeamQuery, nodes []*User, init func(*User), assign func(*User, *Team)) error {
	edgeIDs := make([]driver.Value, len(nodes))
	byID := make(map[uuid.UUID]*User)
	nids := make(map[uuid.UUID]map[*User]struct{})
	for i, node := range nodes {
		edgeIDs[i] = node.ID
		byID[node.ID] = node
		if init != nil {
			init(node)
		}
	}
	query.Where(func(s *sql.Selector) {
		joinT := sql.Table(user.TeamsTable)
		joinT.Schema(uq.schemaConfig.UsersTeams)
		s.Join(joinT).On(s.C(team.FieldID), joinT.C(user.TeamsPrimaryKey[0]))
		s.Where(sql.InValues(joinT.C(user.TeamsPrimaryKey[1]), edgeIDs...))
		columns := s.SelectedColumns()
		s.Select(joinT.C(user.TeamsPrimaryKey[1]))
		s.AppendSelect(columns...)
		s.SetDistinct(false)
	})
	if err := query.prepareQuery(ctx); err != nil {
		return err
	}
	qr := QuerierFunc(func(ctx context.Context, q Query) (Value, error) {
		return query.sqlAll(ctx, func(_ context.Context, spec *sqlgraph.QuerySpec) {
			assign := spec.Assign
			values := spec.ScanValues
			spec.ScanValues = func(columns []string) ([]any, error) {
				values, err := values(columns[1:])
				if err != nil {
					return nil, err
				}
				return append([]any{new(uuid.UUID)}, values...), nil
			}
			spec.Assign = func(columns []string, values []any) error {
				outValue := *values[0].(*uuid.UUID)
				inValue := *values[1].(*uuid.UUID)
				if nids[inValue] == nil {
					nids[inValue] = map[*User]struct{}{byID[outValue]: {}}
					return assign(columns[1:], values[1:])
				}
				nids[inValue][byID[outValue]] = struct{}{}
				return nil
			}
		})
	})
	neighbors, err := withInterceptors[[]*Team](ctx, query, qr, query.inters)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected "teams" node returned %v`, n.ID)
		}
		for kn := range nodes {
			assign(kn, n)
		}
	}
	return nil
}
func (uq *UserQuery) loadCreatedEnvs(ctx context.Context, query *EnvQuery, nodes []*User, init func(*User), assign func(*User, *Env)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[uuid.UUID]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(env.FieldCreatedBy)
	}
	query.Where(predicate.Env(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.CreatedEnvsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.CreatedBy
		if fk == nil {
			return fmt.Errorf(`foreign-key "created_by" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "created_by" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadAccessTokens(ctx context.Context, query *AccessTokenQuery, nodes []*User, init func(*User), assign func(*User, *AccessToken)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[uuid.UUID]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(accesstoken.FieldUserID)
	}
	query.Where(predicate.AccessToken(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.AccessTokensColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.UserID
		node, ok := nodeids[fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "user_id" returned %v for node %v`, fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadCreatedAPIKeys(ctx context.Context, query *TeamAPIKeyQuery, nodes []*User, init func(*User), assign func(*User, *TeamAPIKey)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[uuid.UUID]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(teamapikey.FieldCreatedBy)
	}
	query.Where(predicate.TeamAPIKey(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.CreatedAPIKeysColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.CreatedBy
		if fk == nil {
			return fmt.Errorf(`foreign-key "created_by" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "created_by" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadUsersTeams(ctx context.Context, query *UsersTeamsQuery, nodes []*User, init func(*User), assign func(*User, *UsersTeams)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[uuid.UUID]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(usersteams.FieldUserID)
	}
	query.Where(predicate.UsersTeams(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.UsersTeamsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.UserID
		node, ok := nodeids[fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "user_id" returned %v for node %v`, fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}

func (uq *UserQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := uq.querySpec()
	_spec.Node.Schema = uq.schemaConfig.User
	ctx = internal.NewSchemaConfigContext(ctx, uq.schemaConfig)
	if len(uq.modifiers) > 0 {
		_spec.Modifiers = uq.modifiers
	}
	_spec.Node.Columns = uq.ctx.Fields
	if len(uq.ctx.Fields) > 0 {
		_spec.Unique = uq.ctx.Unique != nil && *uq.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, uq.driver, _spec)
}

func (uq *UserQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(user.Table, user.Columns, sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID))
	_spec.From = uq.sql
	if unique := uq.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if uq.path != nil {
		_spec.Unique = true
	}
	if fields := uq.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, user.FieldID)
		for i := range fields {
			if fields[i] != user.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
	}
	if ps := uq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := uq.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := uq.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := uq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (uq *UserQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(uq.driver.Dialect())
	t1 := builder.Table(user.Table)
	columns := uq.ctx.Fields
	if len(columns) == 0 {
		columns = user.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if uq.sql != nil {
		selector = uq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if uq.ctx.Unique != nil && *uq.ctx.Unique {
		selector.Distinct()
	}
	t1.Schema(uq.schemaConfig.User)
	ctx = internal.NewSchemaConfigContext(ctx, uq.schemaConfig)
	selector.WithContext(ctx)
	for _, m := range uq.modifiers {
		m(selector)
	}
	for _, p := range uq.predicates {
		p(selector)
	}
	for _, p := range uq.order {
		p(selector)
	}
	if offset := uq.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := uq.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// Modify adds a query modifier for attaching custom logic to queries.
func (uq *UserQuery) Modify(modifiers ...func(s *sql.Selector)) *UserSelect {
	uq.modifiers = append(uq.modifiers, modifiers...)
	return uq.Select()
}

// UserGroupBy is the group-by builder for User entities.
type UserGroupBy struct {
	selector
	build *UserQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (ugb *UserGroupBy) Aggregate(fns ...AggregateFunc) *UserGroupBy {
	ugb.fns = append(ugb.fns, fns...)
	return ugb
}

// Scan applies the selector query and scans the result into the given value.
func (ugb *UserGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, ugb.build.ctx, "GroupBy")
	if err := ugb.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*UserQuery, *UserGroupBy](ctx, ugb.build, ugb, ugb.build.inters, v)
}

func (ugb *UserGroupBy) sqlScan(ctx context.Context, root *UserQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(ugb.fns))
	for _, fn := range ugb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*ugb.flds)+len(ugb.fns))
		for _, f := range *ugb.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*ugb.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := ugb.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// UserSelect is the builder for selecting fields of User entities.
type UserSelect struct {
	*UserQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (us *UserSelect) Aggregate(fns ...AggregateFunc) *UserSelect {
	us.fns = append(us.fns, fns...)
	return us
}

// Scan applies the selector query and scans the result into the given value.
func (us *UserSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, us.ctx, "Select")
	if err := us.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*UserQuery, *UserSelect](ctx, us.UserQuery, us, us.inters, v)
}

func (us *UserSelect) sqlScan(ctx context.Context, root *UserQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(us.fns))
	for _, fn := range us.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*us.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := us.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// Modify adds a query modifier for attaching custom logic to queries.
func (us *UserSelect) Modify(modifiers ...func(s *sql.Selector)) *UserSelect {
	us.modifiers = append(us.modifiers, modifiers...)
	return us
}



================================================
File: models/user_update.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/accesstoken"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/env"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/teamapikey"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"
	"github.com/google/uuid"
)

// UserUpdate is the builder for updating User entities.
type UserUpdate struct {
	config
	hooks     []Hook
	mutation  *UserMutation
	modifiers []func(*sql.UpdateBuilder)
}

// Where appends a list predicates to the UserUpdate builder.
func (uu *UserUpdate) Where(ps ...predicate.User) *UserUpdate {
	uu.mutation.Where(ps...)
	return uu
}

// SetEmail sets the "email" field.
func (uu *UserUpdate) SetEmail(s string) *UserUpdate {
	uu.mutation.SetEmail(s)
	return uu
}

// SetNillableEmail sets the "email" field if the given value is not nil.
func (uu *UserUpdate) SetNillableEmail(s *string) *UserUpdate {
	if s != nil {
		uu.SetEmail(*s)
	}
	return uu
}

// AddTeamIDs adds the "teams" edge to the Team entity by IDs.
func (uu *UserUpdate) AddTeamIDs(ids ...uuid.UUID) *UserUpdate {
	uu.mutation.AddTeamIDs(ids...)
	return uu
}

// AddTeams adds the "teams" edges to the Team entity.
func (uu *UserUpdate) AddTeams(t ...*Team) *UserUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uu.AddTeamIDs(ids...)
}

// AddCreatedEnvIDs adds the "created_envs" edge to the Env entity by IDs.
func (uu *UserUpdate) AddCreatedEnvIDs(ids ...string) *UserUpdate {
	uu.mutation.AddCreatedEnvIDs(ids...)
	return uu
}

// AddCreatedEnvs adds the "created_envs" edges to the Env entity.
func (uu *UserUpdate) AddCreatedEnvs(e ...*Env) *UserUpdate {
	ids := make([]string, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return uu.AddCreatedEnvIDs(ids...)
}

// AddAccessTokenIDs adds the "access_tokens" edge to the AccessToken entity by IDs.
func (uu *UserUpdate) AddAccessTokenIDs(ids ...string) *UserUpdate {
	uu.mutation.AddAccessTokenIDs(ids...)
	return uu
}

// AddAccessTokens adds the "access_tokens" edges to the AccessToken entity.
func (uu *UserUpdate) AddAccessTokens(a ...*AccessToken) *UserUpdate {
	ids := make([]string, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uu.AddAccessTokenIDs(ids...)
}

// AddCreatedAPIKeyIDs adds the "created_api_keys" edge to the TeamAPIKey entity by IDs.
func (uu *UserUpdate) AddCreatedAPIKeyIDs(ids ...uuid.UUID) *UserUpdate {
	uu.mutation.AddCreatedAPIKeyIDs(ids...)
	return uu
}

// AddCreatedAPIKeys adds the "created_api_keys" edges to the TeamAPIKey entity.
func (uu *UserUpdate) AddCreatedAPIKeys(t ...*TeamAPIKey) *UserUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uu.AddCreatedAPIKeyIDs(ids...)
}

// AddUsersTeamIDs adds the "users_teams" edge to the UsersTeams entity by IDs.
func (uu *UserUpdate) AddUsersTeamIDs(ids ...int) *UserUpdate {
	uu.mutation.AddUsersTeamIDs(ids...)
	return uu
}

// AddUsersTeams adds the "users_teams" edges to the UsersTeams entity.
func (uu *UserUpdate) AddUsersTeams(u ...*UsersTeams) *UserUpdate {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uu.AddUsersTeamIDs(ids...)
}

// Mutation returns the UserMutation object of the builder.
func (uu *UserUpdate) Mutation() *UserMutation {
	return uu.mutation
}

// ClearTeams clears all "teams" edges to the Team entity.
func (uu *UserUpdate) ClearTeams() *UserUpdate {
	uu.mutation.ClearTeams()
	return uu
}

// RemoveTeamIDs removes the "teams" edge to Team entities by IDs.
func (uu *UserUpdate) RemoveTeamIDs(ids ...uuid.UUID) *UserUpdate {
	uu.mutation.RemoveTeamIDs(ids...)
	return uu
}

// RemoveTeams removes "teams" edges to Team entities.
func (uu *UserUpdate) RemoveTeams(t ...*Team) *UserUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uu.RemoveTeamIDs(ids...)
}

// ClearCreatedEnvs clears all "created_envs" edges to the Env entity.
func (uu *UserUpdate) ClearCreatedEnvs() *UserUpdate {
	uu.mutation.ClearCreatedEnvs()
	return uu
}

// RemoveCreatedEnvIDs removes the "created_envs" edge to Env entities by IDs.
func (uu *UserUpdate) RemoveCreatedEnvIDs(ids ...string) *UserUpdate {
	uu.mutation.RemoveCreatedEnvIDs(ids...)
	return uu
}

// RemoveCreatedEnvs removes "created_envs" edges to Env entities.
func (uu *UserUpdate) RemoveCreatedEnvs(e ...*Env) *UserUpdate {
	ids := make([]string, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return uu.RemoveCreatedEnvIDs(ids...)
}

// ClearAccessTokens clears all "access_tokens" edges to the AccessToken entity.
func (uu *UserUpdate) ClearAccessTokens() *UserUpdate {
	uu.mutation.ClearAccessTokens()
	return uu
}

// RemoveAccessTokenIDs removes the "access_tokens" edge to AccessToken entities by IDs.
func (uu *UserUpdate) RemoveAccessTokenIDs(ids ...string) *UserUpdate {
	uu.mutation.RemoveAccessTokenIDs(ids...)
	return uu
}

// RemoveAccessTokens removes "access_tokens" edges to AccessToken entities.
func (uu *UserUpdate) RemoveAccessTokens(a ...*AccessToken) *UserUpdate {
	ids := make([]string, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uu.RemoveAccessTokenIDs(ids...)
}

// ClearCreatedAPIKeys clears all "created_api_keys" edges to the TeamAPIKey entity.
func (uu *UserUpdate) ClearCreatedAPIKeys() *UserUpdate {
	uu.mutation.ClearCreatedAPIKeys()
	return uu
}

// RemoveCreatedAPIKeyIDs removes the "created_api_keys" edge to TeamAPIKey entities by IDs.
func (uu *UserUpdate) RemoveCreatedAPIKeyIDs(ids ...uuid.UUID) *UserUpdate {
	uu.mutation.RemoveCreatedAPIKeyIDs(ids...)
	return uu
}

// RemoveCreatedAPIKeys removes "created_api_keys" edges to TeamAPIKey entities.
func (uu *UserUpdate) RemoveCreatedAPIKeys(t ...*TeamAPIKey) *UserUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uu.RemoveCreatedAPIKeyIDs(ids...)
}

// ClearUsersTeams clears all "users_teams" edges to the UsersTeams entity.
func (uu *UserUpdate) ClearUsersTeams() *UserUpdate {
	uu.mutation.ClearUsersTeams()
	return uu
}

// RemoveUsersTeamIDs removes the "users_teams" edge to UsersTeams entities by IDs.
func (uu *UserUpdate) RemoveUsersTeamIDs(ids ...int) *UserUpdate {
	uu.mutation.RemoveUsersTeamIDs(ids...)
	return uu
}

// RemoveUsersTeams removes "users_teams" edges to UsersTeams entities.
func (uu *UserUpdate) RemoveUsersTeams(u ...*UsersTeams) *UserUpdate {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uu.RemoveUsersTeamIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (uu *UserUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, uu.sqlSave, uu.mutation, uu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (uu *UserUpdate) SaveX(ctx context.Context) int {
	affected, err := uu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (uu *UserUpdate) Exec(ctx context.Context) error {
	_, err := uu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (uu *UserUpdate) ExecX(ctx context.Context) {
	if err := uu.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (uu *UserUpdate) check() error {
	if v, ok := uu.mutation.Email(); ok {
		if err := user.EmailValidator(v); err != nil {
			return &ValidationError{Name: "email", err: fmt.Errorf(`models: validator failed for field "User.email": %w`, err)}
		}
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (uu *UserUpdate) Modify(modifiers ...func(u *sql.UpdateBuilder)) *UserUpdate {
	uu.modifiers = append(uu.modifiers, modifiers...)
	return uu
}

func (uu *UserUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := uu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(user.Table, user.Columns, sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID))
	if ps := uu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := uu.mutation.Email(); ok {
		_spec.SetField(user.FieldEmail, field.TypeString, value)
	}
	if uu.mutation.TeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   user.TeamsTable,
			Columns: user.TeamsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = uu.schemaConfig.UsersTeams
		createE := &UsersTeamsCreate{config: uu.config, mutation: newUsersTeamsMutation(uu.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedTeamsIDs(); len(nodes) > 0 && !uu.mutation.TeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   user.TeamsTable,
			Columns: user.TeamsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = uu.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &UsersTeamsCreate{config: uu.config, mutation: newUsersTeamsMutation(uu.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.TeamsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   user.TeamsTable,
			Columns: user.TeamsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = uu.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &UsersTeamsCreate{config: uu.config, mutation: newUsersTeamsMutation(uu.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.CreatedEnvsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreatedEnvsTable,
			Columns: []string{user.CreatedEnvsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = uu.schemaConfig.Env
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedCreatedEnvsIDs(); len(nodes) > 0 && !uu.mutation.CreatedEnvsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreatedEnvsTable,
			Columns: []string{user.CreatedEnvsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = uu.schemaConfig.Env
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.CreatedEnvsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreatedEnvsTable,
			Columns: []string{user.CreatedEnvsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = uu.schemaConfig.Env
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.AccessTokensCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.AccessTokensTable,
			Columns: []string{user.AccessTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(accesstoken.FieldID, field.TypeString),
			},
		}
		edge.Schema = uu.schemaConfig.AccessToken
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedAccessTokensIDs(); len(nodes) > 0 && !uu.mutation.AccessTokensCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.AccessTokensTable,
			Columns: []string{user.AccessTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(accesstoken.FieldID, field.TypeString),
			},
		}
		edge.Schema = uu.schemaConfig.AccessToken
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.AccessTokensIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.AccessTokensTable,
			Columns: []string{user.AccessTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(accesstoken.FieldID, field.TypeString),
			},
		}
		edge.Schema = uu.schemaConfig.AccessToken
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.CreatedAPIKeysCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreatedAPIKeysTable,
			Columns: []string{user.CreatedAPIKeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = uu.schemaConfig.TeamAPIKey
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedCreatedAPIKeysIDs(); len(nodes) > 0 && !uu.mutation.CreatedAPIKeysCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreatedAPIKeysTable,
			Columns: []string{user.CreatedAPIKeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = uu.schemaConfig.TeamAPIKey
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.CreatedAPIKeysIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreatedAPIKeysTable,
			Columns: []string{user.CreatedAPIKeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = uu.schemaConfig.TeamAPIKey
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.UsersTeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.UsersTeamsTable,
			Columns: []string{user.UsersTeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt),
			},
		}
		edge.Schema = uu.schemaConfig.UsersTeams
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedUsersTeamsIDs(); len(nodes) > 0 && !uu.mutation.UsersTeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.UsersTeamsTable,
			Columns: []string{user.UsersTeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt),
			},
		}
		edge.Schema = uu.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.UsersTeamsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.UsersTeamsTable,
			Columns: []string{user.UsersTeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt),
			},
		}
		edge.Schema = uu.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = uu.schemaConfig.User
	ctx = internal.NewSchemaConfigContext(ctx, uu.schemaConfig)
	_spec.AddModifiers(uu.modifiers...)
	if n, err = sqlgraph.UpdateNodes(ctx, uu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{user.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	uu.mutation.done = true
	return n, nil
}

// UserUpdateOne is the builder for updating a single User entity.
type UserUpdateOne struct {
	config
	fields    []string
	hooks     []Hook
	mutation  *UserMutation
	modifiers []func(*sql.UpdateBuilder)
}

// SetEmail sets the "email" field.
func (uuo *UserUpdateOne) SetEmail(s string) *UserUpdateOne {
	uuo.mutation.SetEmail(s)
	return uuo
}

// SetNillableEmail sets the "email" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableEmail(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetEmail(*s)
	}
	return uuo
}

// AddTeamIDs adds the "teams" edge to the Team entity by IDs.
func (uuo *UserUpdateOne) AddTeamIDs(ids ...uuid.UUID) *UserUpdateOne {
	uuo.mutation.AddTeamIDs(ids...)
	return uuo
}

// AddTeams adds the "teams" edges to the Team entity.
func (uuo *UserUpdateOne) AddTeams(t ...*Team) *UserUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uuo.AddTeamIDs(ids...)
}

// AddCreatedEnvIDs adds the "created_envs" edge to the Env entity by IDs.
func (uuo *UserUpdateOne) AddCreatedEnvIDs(ids ...string) *UserUpdateOne {
	uuo.mutation.AddCreatedEnvIDs(ids...)
	return uuo
}

// AddCreatedEnvs adds the "created_envs" edges to the Env entity.
func (uuo *UserUpdateOne) AddCreatedEnvs(e ...*Env) *UserUpdateOne {
	ids := make([]string, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return uuo.AddCreatedEnvIDs(ids...)
}

// AddAccessTokenIDs adds the "access_tokens" edge to the AccessToken entity by IDs.
func (uuo *UserUpdateOne) AddAccessTokenIDs(ids ...string) *UserUpdateOne {
	uuo.mutation.AddAccessTokenIDs(ids...)
	return uuo
}

// AddAccessTokens adds the "access_tokens" edges to the AccessToken entity.
func (uuo *UserUpdateOne) AddAccessTokens(a ...*AccessToken) *UserUpdateOne {
	ids := make([]string, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uuo.AddAccessTokenIDs(ids...)
}

// AddCreatedAPIKeyIDs adds the "created_api_keys" edge to the TeamAPIKey entity by IDs.
func (uuo *UserUpdateOne) AddCreatedAPIKeyIDs(ids ...uuid.UUID) *UserUpdateOne {
	uuo.mutation.AddCreatedAPIKeyIDs(ids...)
	return uuo
}

// AddCreatedAPIKeys adds the "created_api_keys" edges to the TeamAPIKey entity.
func (uuo *UserUpdateOne) AddCreatedAPIKeys(t ...*TeamAPIKey) *UserUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uuo.AddCreatedAPIKeyIDs(ids...)
}

// AddUsersTeamIDs adds the "users_teams" edge to the UsersTeams entity by IDs.
func (uuo *UserUpdateOne) AddUsersTeamIDs(ids ...int) *UserUpdateOne {
	uuo.mutation.AddUsersTeamIDs(ids...)
	return uuo
}

// AddUsersTeams adds the "users_teams" edges to the UsersTeams entity.
func (uuo *UserUpdateOne) AddUsersTeams(u ...*UsersTeams) *UserUpdateOne {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uuo.AddUsersTeamIDs(ids...)
}

// Mutation returns the UserMutation object of the builder.
func (uuo *UserUpdateOne) Mutation() *UserMutation {
	return uuo.mutation
}

// ClearTeams clears all "teams" edges to the Team entity.
func (uuo *UserUpdateOne) ClearTeams() *UserUpdateOne {
	uuo.mutation.ClearTeams()
	return uuo
}

// RemoveTeamIDs removes the "teams" edge to Team entities by IDs.
func (uuo *UserUpdateOne) RemoveTeamIDs(ids ...uuid.UUID) *UserUpdateOne {
	uuo.mutation.RemoveTeamIDs(ids...)
	return uuo
}

// RemoveTeams removes "teams" edges to Team entities.
func (uuo *UserUpdateOne) RemoveTeams(t ...*Team) *UserUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uuo.RemoveTeamIDs(ids...)
}

// ClearCreatedEnvs clears all "created_envs" edges to the Env entity.
func (uuo *UserUpdateOne) ClearCreatedEnvs() *UserUpdateOne {
	uuo.mutation.ClearCreatedEnvs()
	return uuo
}

// RemoveCreatedEnvIDs removes the "created_envs" edge to Env entities by IDs.
func (uuo *UserUpdateOne) RemoveCreatedEnvIDs(ids ...string) *UserUpdateOne {
	uuo.mutation.RemoveCreatedEnvIDs(ids...)
	return uuo
}

// RemoveCreatedEnvs removes "created_envs" edges to Env entities.
func (uuo *UserUpdateOne) RemoveCreatedEnvs(e ...*Env) *UserUpdateOne {
	ids := make([]string, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return uuo.RemoveCreatedEnvIDs(ids...)
}

// ClearAccessTokens clears all "access_tokens" edges to the AccessToken entity.
func (uuo *UserUpdateOne) ClearAccessTokens() *UserUpdateOne {
	uuo.mutation.ClearAccessTokens()
	return uuo
}

// RemoveAccessTokenIDs removes the "access_tokens" edge to AccessToken entities by IDs.
func (uuo *UserUpdateOne) RemoveAccessTokenIDs(ids ...string) *UserUpdateOne {
	uuo.mutation.RemoveAccessTokenIDs(ids...)
	return uuo
}

// RemoveAccessTokens removes "access_tokens" edges to AccessToken entities.
func (uuo *UserUpdateOne) RemoveAccessTokens(a ...*AccessToken) *UserUpdateOne {
	ids := make([]string, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uuo.RemoveAccessTokenIDs(ids...)
}

// ClearCreatedAPIKeys clears all "created_api_keys" edges to the TeamAPIKey entity.
func (uuo *UserUpdateOne) ClearCreatedAPIKeys() *UserUpdateOne {
	uuo.mutation.ClearCreatedAPIKeys()
	return uuo
}

// RemoveCreatedAPIKeyIDs removes the "created_api_keys" edge to TeamAPIKey entities by IDs.
func (uuo *UserUpdateOne) RemoveCreatedAPIKeyIDs(ids ...uuid.UUID) *UserUpdateOne {
	uuo.mutation.RemoveCreatedAPIKeyIDs(ids...)
	return uuo
}

// RemoveCreatedAPIKeys removes "created_api_keys" edges to TeamAPIKey entities.
func (uuo *UserUpdateOne) RemoveCreatedAPIKeys(t ...*TeamAPIKey) *UserUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uuo.RemoveCreatedAPIKeyIDs(ids...)
}

// ClearUsersTeams clears all "users_teams" edges to the UsersTeams entity.
func (uuo *UserUpdateOne) ClearUsersTeams() *UserUpdateOne {
	uuo.mutation.ClearUsersTeams()
	return uuo
}

// RemoveUsersTeamIDs removes the "users_teams" edge to UsersTeams entities by IDs.
func (uuo *UserUpdateOne) RemoveUsersTeamIDs(ids ...int) *UserUpdateOne {
	uuo.mutation.RemoveUsersTeamIDs(ids...)
	return uuo
}

// RemoveUsersTeams removes "users_teams" edges to UsersTeams entities.
func (uuo *UserUpdateOne) RemoveUsersTeams(u ...*UsersTeams) *UserUpdateOne {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uuo.RemoveUsersTeamIDs(ids...)
}

// Where appends a list predicates to the UserUpdate builder.
func (uuo *UserUpdateOne) Where(ps ...predicate.User) *UserUpdateOne {
	uuo.mutation.Where(ps...)
	return uuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (uuo *UserUpdateOne) Select(field string, fields ...string) *UserUpdateOne {
	uuo.fields = append([]string{field}, fields...)
	return uuo
}

// Save executes the query and returns the updated User entity.
func (uuo *UserUpdateOne) Save(ctx context.Context) (*User, error) {
	return withHooks(ctx, uuo.sqlSave, uuo.mutation, uuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (uuo *UserUpdateOne) SaveX(ctx context.Context) *User {
	node, err := uuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (uuo *UserUpdateOne) Exec(ctx context.Context) error {
	_, err := uuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (uuo *UserUpdateOne) ExecX(ctx context.Context) {
	if err := uuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (uuo *UserUpdateOne) check() error {
	if v, ok := uuo.mutation.Email(); ok {
		if err := user.EmailValidator(v); err != nil {
			return &ValidationError{Name: "email", err: fmt.Errorf(`models: validator failed for field "User.email": %w`, err)}
		}
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (uuo *UserUpdateOne) Modify(modifiers ...func(u *sql.UpdateBuilder)) *UserUpdateOne {
	uuo.modifiers = append(uuo.modifiers, modifiers...)
	return uuo
}

func (uuo *UserUpdateOne) sqlSave(ctx context.Context) (_node *User, err error) {
	if err := uuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(user.Table, user.Columns, sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID))
	id, ok := uuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`models: missing "User.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := uuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, user.FieldID)
		for _, f := range fields {
			if !user.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
			}
			if f != user.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := uuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := uuo.mutation.Email(); ok {
		_spec.SetField(user.FieldEmail, field.TypeString, value)
	}
	if uuo.mutation.TeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   user.TeamsTable,
			Columns: user.TeamsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = uuo.schemaConfig.UsersTeams
		createE := &UsersTeamsCreate{config: uuo.config, mutation: newUsersTeamsMutation(uuo.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedTeamsIDs(); len(nodes) > 0 && !uuo.mutation.TeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   user.TeamsTable,
			Columns: user.TeamsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = uuo.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &UsersTeamsCreate{config: uuo.config, mutation: newUsersTeamsMutation(uuo.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.TeamsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   user.TeamsTable,
			Columns: user.TeamsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = uuo.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &UsersTeamsCreate{config: uuo.config, mutation: newUsersTeamsMutation(uuo.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.CreatedEnvsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreatedEnvsTable,
			Columns: []string{user.CreatedEnvsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = uuo.schemaConfig.Env
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedCreatedEnvsIDs(); len(nodes) > 0 && !uuo.mutation.CreatedEnvsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreatedEnvsTable,
			Columns: []string{user.CreatedEnvsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = uuo.schemaConfig.Env
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.CreatedEnvsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreatedEnvsTable,
			Columns: []string{user.CreatedEnvsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(env.FieldID, field.TypeString),
			},
		}
		edge.Schema = uuo.schemaConfig.Env
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.AccessTokensCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.AccessTokensTable,
			Columns: []string{user.AccessTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(accesstoken.FieldID, field.TypeString),
			},
		}
		edge.Schema = uuo.schemaConfig.AccessToken
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedAccessTokensIDs(); len(nodes) > 0 && !uuo.mutation.AccessTokensCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.AccessTokensTable,
			Columns: []string{user.AccessTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(accesstoken.FieldID, field.TypeString),
			},
		}
		edge.Schema = uuo.schemaConfig.AccessToken
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.AccessTokensIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.AccessTokensTable,
			Columns: []string{user.AccessTokensColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(accesstoken.FieldID, field.TypeString),
			},
		}
		edge.Schema = uuo.schemaConfig.AccessToken
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.CreatedAPIKeysCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreatedAPIKeysTable,
			Columns: []string{user.CreatedAPIKeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = uuo.schemaConfig.TeamAPIKey
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedCreatedAPIKeysIDs(); len(nodes) > 0 && !uuo.mutation.CreatedAPIKeysCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreatedAPIKeysTable,
			Columns: []string{user.CreatedAPIKeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = uuo.schemaConfig.TeamAPIKey
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.CreatedAPIKeysIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreatedAPIKeysTable,
			Columns: []string{user.CreatedAPIKeysColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(teamapikey.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = uuo.schemaConfig.TeamAPIKey
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.UsersTeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.UsersTeamsTable,
			Columns: []string{user.UsersTeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt),
			},
		}
		edge.Schema = uuo.schemaConfig.UsersTeams
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedUsersTeamsIDs(); len(nodes) > 0 && !uuo.mutation.UsersTeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.UsersTeamsTable,
			Columns: []string{user.UsersTeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt),
			},
		}
		edge.Schema = uuo.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.UsersTeamsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.UsersTeamsTable,
			Columns: []string{user.UsersTeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt),
			},
		}
		edge.Schema = uuo.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = uuo.schemaConfig.User
	ctx = internal.NewSchemaConfigContext(ctx, uuo.schemaConfig)
	_spec.AddModifiers(uuo.modifiers...)
	_node = &User{config: uuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, uuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{user.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	uuo.mutation.done = true
	return _node, nil
}



================================================
File: models/usersteams.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"fmt"
	"strings"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"
	"github.com/google/uuid"
)

// UsersTeams is the model entity for the UsersTeams schema.
type UsersTeams struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// UserID holds the value of the "user_id" field.
	UserID uuid.UUID `json:"user_id,omitempty"`
	// TeamID holds the value of the "team_id" field.
	TeamID uuid.UUID `json:"team_id,omitempty"`
	// IsDefault holds the value of the "is_default" field.
	IsDefault bool `json:"is_default,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the UsersTeamsQuery when eager-loading is set.
	Edges        UsersTeamsEdges `json:"edges"`
	selectValues sql.SelectValues
}

// UsersTeamsEdges holds the relations/edges for other nodes in the graph.
type UsersTeamsEdges struct {
	// Users holds the value of the users edge.
	Users *User `json:"users,omitempty"`
	// Teams holds the value of the teams edge.
	Teams *Team `json:"teams,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// UsersOrErr returns the Users value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e UsersTeamsEdges) UsersOrErr() (*User, error) {
	if e.loadedTypes[0] {
		if e.Users == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: user.Label}
		}
		return e.Users, nil
	}
	return nil, &NotLoadedError{edge: "users"}
}

// TeamsOrErr returns the Teams value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e UsersTeamsEdges) TeamsOrErr() (*Team, error) {
	if e.loadedTypes[1] {
		if e.Teams == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: team.Label}
		}
		return e.Teams, nil
	}
	return nil, &NotLoadedError{edge: "teams"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*UsersTeams) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case usersteams.FieldIsDefault:
			values[i] = new(sql.NullBool)
		case usersteams.FieldID:
			values[i] = new(sql.NullInt64)
		case usersteams.FieldUserID, usersteams.FieldTeamID:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the UsersTeams fields.
func (ut *UsersTeams) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case usersteams.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			ut.ID = int(value.Int64)
		case usersteams.FieldUserID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field user_id", values[i])
			} else if value != nil {
				ut.UserID = *value
			}
		case usersteams.FieldTeamID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field team_id", values[i])
			} else if value != nil {
				ut.TeamID = *value
			}
		case usersteams.FieldIsDefault:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_default", values[i])
			} else if value.Valid {
				ut.IsDefault = value.Bool
			}
		default:
			ut.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the UsersTeams.
// This includes values selected through modifiers, order, etc.
func (ut *UsersTeams) Value(name string) (ent.Value, error) {
	return ut.selectValues.Get(name)
}

// QueryUsers queries the "users" edge of the UsersTeams entity.
func (ut *UsersTeams) QueryUsers() *UserQuery {
	return NewUsersTeamsClient(ut.config).QueryUsers(ut)
}

// QueryTeams queries the "teams" edge of the UsersTeams entity.
func (ut *UsersTeams) QueryTeams() *TeamQuery {
	return NewUsersTeamsClient(ut.config).QueryTeams(ut)
}

// Update returns a builder for updating this UsersTeams.
// Note that you need to call UsersTeams.Unwrap() before calling this method if this UsersTeams
// was returned from a transaction, and the transaction was committed or rolled back.
func (ut *UsersTeams) Update() *UsersTeamsUpdateOne {
	return NewUsersTeamsClient(ut.config).UpdateOne(ut)
}

// Unwrap unwraps the UsersTeams entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (ut *UsersTeams) Unwrap() *UsersTeams {
	_tx, ok := ut.config.driver.(*txDriver)
	if !ok {
		panic("models: UsersTeams is not a transactional entity")
	}
	ut.config.driver = _tx.drv
	return ut
}

// String implements the fmt.Stringer.
func (ut *UsersTeams) String() string {
	var builder strings.Builder
	builder.WriteString("UsersTeams(")
	builder.WriteString(fmt.Sprintf("id=%v, ", ut.ID))
	builder.WriteString("user_id=")
	builder.WriteString(fmt.Sprintf("%v", ut.UserID))
	builder.WriteString(", ")
	builder.WriteString("team_id=")
	builder.WriteString(fmt.Sprintf("%v", ut.TeamID))
	builder.WriteString(", ")
	builder.WriteString("is_default=")
	builder.WriteString(fmt.Sprintf("%v", ut.IsDefault))
	builder.WriteByte(')')
	return builder.String()
}

// UsersTeamsSlice is a parsable slice of UsersTeams.
type UsersTeamsSlice []*UsersTeams



================================================
File: models/usersteams_create.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"
	"github.com/google/uuid"
)

// UsersTeamsCreate is the builder for creating a UsersTeams entity.
type UsersTeamsCreate struct {
	config
	mutation *UsersTeamsMutation
	hooks    []Hook
	conflict []sql.ConflictOption
}

// SetUserID sets the "user_id" field.
func (utc *UsersTeamsCreate) SetUserID(u uuid.UUID) *UsersTeamsCreate {
	utc.mutation.SetUserID(u)
	return utc
}

// SetTeamID sets the "team_id" field.
func (utc *UsersTeamsCreate) SetTeamID(u uuid.UUID) *UsersTeamsCreate {
	utc.mutation.SetTeamID(u)
	return utc
}

// SetIsDefault sets the "is_default" field.
func (utc *UsersTeamsCreate) SetIsDefault(b bool) *UsersTeamsCreate {
	utc.mutation.SetIsDefault(b)
	return utc
}

// SetNillableIsDefault sets the "is_default" field if the given value is not nil.
func (utc *UsersTeamsCreate) SetNillableIsDefault(b *bool) *UsersTeamsCreate {
	if b != nil {
		utc.SetIsDefault(*b)
	}
	return utc
}

// SetUsersID sets the "users" edge to the User entity by ID.
func (utc *UsersTeamsCreate) SetUsersID(id uuid.UUID) *UsersTeamsCreate {
	utc.mutation.SetUsersID(id)
	return utc
}

// SetUsers sets the "users" edge to the User entity.
func (utc *UsersTeamsCreate) SetUsers(u *User) *UsersTeamsCreate {
	return utc.SetUsersID(u.ID)
}

// SetTeamsID sets the "teams" edge to the Team entity by ID.
func (utc *UsersTeamsCreate) SetTeamsID(id uuid.UUID) *UsersTeamsCreate {
	utc.mutation.SetTeamsID(id)
	return utc
}

// SetTeams sets the "teams" edge to the Team entity.
func (utc *UsersTeamsCreate) SetTeams(t *Team) *UsersTeamsCreate {
	return utc.SetTeamsID(t.ID)
}

// Mutation returns the UsersTeamsMutation object of the builder.
func (utc *UsersTeamsCreate) Mutation() *UsersTeamsMutation {
	return utc.mutation
}

// Save creates the UsersTeams in the database.
func (utc *UsersTeamsCreate) Save(ctx context.Context) (*UsersTeams, error) {
	utc.defaults()
	return withHooks(ctx, utc.sqlSave, utc.mutation, utc.hooks)
}

// SaveX calls Save and panics if Save returns an error.
func (utc *UsersTeamsCreate) SaveX(ctx context.Context) *UsersTeams {
	v, err := utc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (utc *UsersTeamsCreate) Exec(ctx context.Context) error {
	_, err := utc.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (utc *UsersTeamsCreate) ExecX(ctx context.Context) {
	if err := utc.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (utc *UsersTeamsCreate) defaults() {
	if _, ok := utc.mutation.IsDefault(); !ok {
		v := usersteams.DefaultIsDefault
		utc.mutation.SetIsDefault(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (utc *UsersTeamsCreate) check() error {
	if _, ok := utc.mutation.UserID(); !ok {
		return &ValidationError{Name: "user_id", err: errors.New(`models: missing required field "UsersTeams.user_id"`)}
	}
	if _, ok := utc.mutation.TeamID(); !ok {
		return &ValidationError{Name: "team_id", err: errors.New(`models: missing required field "UsersTeams.team_id"`)}
	}
	if _, ok := utc.mutation.IsDefault(); !ok {
		return &ValidationError{Name: "is_default", err: errors.New(`models: missing required field "UsersTeams.is_default"`)}
	}
	if _, ok := utc.mutation.UsersID(); !ok {
		return &ValidationError{Name: "users", err: errors.New(`models: missing required edge "UsersTeams.users"`)}
	}
	if _, ok := utc.mutation.TeamsID(); !ok {
		return &ValidationError{Name: "teams", err: errors.New(`models: missing required edge "UsersTeams.teams"`)}
	}
	return nil
}

func (utc *UsersTeamsCreate) sqlSave(ctx context.Context) (*UsersTeams, error) {
	if err := utc.check(); err != nil {
		return nil, err
	}
	_node, _spec := utc.createSpec()
	if err := sqlgraph.CreateNode(ctx, utc.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	id := _spec.ID.Value.(int64)
	_node.ID = int(id)
	utc.mutation.id = &_node.ID
	utc.mutation.done = true
	return _node, nil
}

func (utc *UsersTeamsCreate) createSpec() (*UsersTeams, *sqlgraph.CreateSpec) {
	var (
		_node = &UsersTeams{config: utc.config}
		_spec = sqlgraph.NewCreateSpec(usersteams.Table, sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt))
	)
	_spec.Schema = utc.schemaConfig.UsersTeams
	_spec.OnConflict = utc.conflict
	if value, ok := utc.mutation.IsDefault(); ok {
		_spec.SetField(usersteams.FieldIsDefault, field.TypeBool, value)
		_node.IsDefault = value
	}
	if nodes := utc.mutation.UsersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   usersteams.UsersTable,
			Columns: []string{usersteams.UsersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = utc.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.UserID = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := utc.mutation.TeamsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   usersteams.TeamsTable,
			Columns: []string{usersteams.TeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = utc.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.TeamID = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.UsersTeams.Create().
//		SetUserID(v).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.UsersTeamsUpsert) {
//			SetUserID(v+v).
//		}).
//		Exec(ctx)
func (utc *UsersTeamsCreate) OnConflict(opts ...sql.ConflictOption) *UsersTeamsUpsertOne {
	utc.conflict = opts
	return &UsersTeamsUpsertOne{
		create: utc,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.UsersTeams.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (utc *UsersTeamsCreate) OnConflictColumns(columns ...string) *UsersTeamsUpsertOne {
	utc.conflict = append(utc.conflict, sql.ConflictColumns(columns...))
	return &UsersTeamsUpsertOne{
		create: utc,
	}
}

type (
	// UsersTeamsUpsertOne is the builder for "upsert"-ing
	//  one UsersTeams node.
	UsersTeamsUpsertOne struct {
		create *UsersTeamsCreate
	}

	// UsersTeamsUpsert is the "OnConflict" setter.
	UsersTeamsUpsert struct {
		*sql.UpdateSet
	}
)

// SetUserID sets the "user_id" field.
func (u *UsersTeamsUpsert) SetUserID(v uuid.UUID) *UsersTeamsUpsert {
	u.Set(usersteams.FieldUserID, v)
	return u
}

// UpdateUserID sets the "user_id" field to the value that was provided on create.
func (u *UsersTeamsUpsert) UpdateUserID() *UsersTeamsUpsert {
	u.SetExcluded(usersteams.FieldUserID)
	return u
}

// SetTeamID sets the "team_id" field.
func (u *UsersTeamsUpsert) SetTeamID(v uuid.UUID) *UsersTeamsUpsert {
	u.Set(usersteams.FieldTeamID, v)
	return u
}

// UpdateTeamID sets the "team_id" field to the value that was provided on create.
func (u *UsersTeamsUpsert) UpdateTeamID() *UsersTeamsUpsert {
	u.SetExcluded(usersteams.FieldTeamID)
	return u
}

// SetIsDefault sets the "is_default" field.
func (u *UsersTeamsUpsert) SetIsDefault(v bool) *UsersTeamsUpsert {
	u.Set(usersteams.FieldIsDefault, v)
	return u
}

// UpdateIsDefault sets the "is_default" field to the value that was provided on create.
func (u *UsersTeamsUpsert) UpdateIsDefault() *UsersTeamsUpsert {
	u.SetExcluded(usersteams.FieldIsDefault)
	return u
}

// UpdateNewValues updates the mutable fields using the new values that were set on create.
// Using this option is equivalent to using:
//
//	client.UsersTeams.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//		).
//		Exec(ctx)
func (u *UsersTeamsUpsertOne) UpdateNewValues() *UsersTeamsUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.UsersTeams.Create().
//	    OnConflict(sql.ResolveWithIgnore()).
//	    Exec(ctx)
func (u *UsersTeamsUpsertOne) Ignore() *UsersTeamsUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *UsersTeamsUpsertOne) DoNothing() *UsersTeamsUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the UsersTeamsCreate.OnConflict
// documentation for more info.
func (u *UsersTeamsUpsertOne) Update(set func(*UsersTeamsUpsert)) *UsersTeamsUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&UsersTeamsUpsert{UpdateSet: update})
	}))
	return u
}

// SetUserID sets the "user_id" field.
func (u *UsersTeamsUpsertOne) SetUserID(v uuid.UUID) *UsersTeamsUpsertOne {
	return u.Update(func(s *UsersTeamsUpsert) {
		s.SetUserID(v)
	})
}

// UpdateUserID sets the "user_id" field to the value that was provided on create.
func (u *UsersTeamsUpsertOne) UpdateUserID() *UsersTeamsUpsertOne {
	return u.Update(func(s *UsersTeamsUpsert) {
		s.UpdateUserID()
	})
}

// SetTeamID sets the "team_id" field.
func (u *UsersTeamsUpsertOne) SetTeamID(v uuid.UUID) *UsersTeamsUpsertOne {
	return u.Update(func(s *UsersTeamsUpsert) {
		s.SetTeamID(v)
	})
}

// UpdateTeamID sets the "team_id" field to the value that was provided on create.
func (u *UsersTeamsUpsertOne) UpdateTeamID() *UsersTeamsUpsertOne {
	return u.Update(func(s *UsersTeamsUpsert) {
		s.UpdateTeamID()
	})
}

// SetIsDefault sets the "is_default" field.
func (u *UsersTeamsUpsertOne) SetIsDefault(v bool) *UsersTeamsUpsertOne {
	return u.Update(func(s *UsersTeamsUpsert) {
		s.SetIsDefault(v)
	})
}

// UpdateIsDefault sets the "is_default" field to the value that was provided on create.
func (u *UsersTeamsUpsertOne) UpdateIsDefault() *UsersTeamsUpsertOne {
	return u.Update(func(s *UsersTeamsUpsert) {
		s.UpdateIsDefault()
	})
}

// Exec executes the query.
func (u *UsersTeamsUpsertOne) Exec(ctx context.Context) error {
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for UsersTeamsCreate.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *UsersTeamsUpsertOne) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}

// Exec executes the UPSERT query and returns the inserted/updated ID.
func (u *UsersTeamsUpsertOne) ID(ctx context.Context) (id int, err error) {
	node, err := u.create.Save(ctx)
	if err != nil {
		return id, err
	}
	return node.ID, nil
}

// IDX is like ID, but panics if an error occurs.
func (u *UsersTeamsUpsertOne) IDX(ctx context.Context) int {
	id, err := u.ID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// UsersTeamsCreateBulk is the builder for creating many UsersTeams entities in bulk.
type UsersTeamsCreateBulk struct {
	config
	err      error
	builders []*UsersTeamsCreate
	conflict []sql.ConflictOption
}

// Save creates the UsersTeams entities in the database.
func (utcb *UsersTeamsCreateBulk) Save(ctx context.Context) ([]*UsersTeams, error) {
	if utcb.err != nil {
		return nil, utcb.err
	}
	specs := make([]*sqlgraph.CreateSpec, len(utcb.builders))
	nodes := make([]*UsersTeams, len(utcb.builders))
	mutators := make([]Mutator, len(utcb.builders))
	for i := range utcb.builders {
		func(i int, root context.Context) {
			builder := utcb.builders[i]
			builder.defaults()
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*UsersTeamsMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				var err error
				nodes[i], specs[i] = builder.createSpec()
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, utcb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					spec.OnConflict = utcb.conflict
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, utcb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{msg: err.Error(), wrap: err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				if specs[i].ID.Value != nil {
					id := specs[i].ID.Value.(int64)
					nodes[i].ID = int(id)
				}
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, utcb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (utcb *UsersTeamsCreateBulk) SaveX(ctx context.Context) []*UsersTeams {
	v, err := utcb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (utcb *UsersTeamsCreateBulk) Exec(ctx context.Context) error {
	_, err := utcb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (utcb *UsersTeamsCreateBulk) ExecX(ctx context.Context) {
	if err := utcb.Exec(ctx); err != nil {
		panic(err)
	}
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.UsersTeams.CreateBulk(builders...).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.UsersTeamsUpsert) {
//			SetUserID(v+v).
//		}).
//		Exec(ctx)
func (utcb *UsersTeamsCreateBulk) OnConflict(opts ...sql.ConflictOption) *UsersTeamsUpsertBulk {
	utcb.conflict = opts
	return &UsersTeamsUpsertBulk{
		create: utcb,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.UsersTeams.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (utcb *UsersTeamsCreateBulk) OnConflictColumns(columns ...string) *UsersTeamsUpsertBulk {
	utcb.conflict = append(utcb.conflict, sql.ConflictColumns(columns...))
	return &UsersTeamsUpsertBulk{
		create: utcb,
	}
}

// UsersTeamsUpsertBulk is the builder for "upsert"-ing
// a bulk of UsersTeams nodes.
type UsersTeamsUpsertBulk struct {
	create *UsersTeamsCreateBulk
}

// UpdateNewValues updates the mutable fields using the new values that
// were set on create. Using this option is equivalent to using:
//
//	client.UsersTeams.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//		).
//		Exec(ctx)
func (u *UsersTeamsUpsertBulk) UpdateNewValues() *UsersTeamsUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.UsersTeams.Create().
//		OnConflict(sql.ResolveWithIgnore()).
//		Exec(ctx)
func (u *UsersTeamsUpsertBulk) Ignore() *UsersTeamsUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *UsersTeamsUpsertBulk) DoNothing() *UsersTeamsUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the UsersTeamsCreateBulk.OnConflict
// documentation for more info.
func (u *UsersTeamsUpsertBulk) Update(set func(*UsersTeamsUpsert)) *UsersTeamsUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&UsersTeamsUpsert{UpdateSet: update})
	}))
	return u
}

// SetUserID sets the "user_id" field.
func (u *UsersTeamsUpsertBulk) SetUserID(v uuid.UUID) *UsersTeamsUpsertBulk {
	return u.Update(func(s *UsersTeamsUpsert) {
		s.SetUserID(v)
	})
}

// UpdateUserID sets the "user_id" field to the value that was provided on create.
func (u *UsersTeamsUpsertBulk) UpdateUserID() *UsersTeamsUpsertBulk {
	return u.Update(func(s *UsersTeamsUpsert) {
		s.UpdateUserID()
	})
}

// SetTeamID sets the "team_id" field.
func (u *UsersTeamsUpsertBulk) SetTeamID(v uuid.UUID) *UsersTeamsUpsertBulk {
	return u.Update(func(s *UsersTeamsUpsert) {
		s.SetTeamID(v)
	})
}

// UpdateTeamID sets the "team_id" field to the value that was provided on create.
func (u *UsersTeamsUpsertBulk) UpdateTeamID() *UsersTeamsUpsertBulk {
	return u.Update(func(s *UsersTeamsUpsert) {
		s.UpdateTeamID()
	})
}

// SetIsDefault sets the "is_default" field.
func (u *UsersTeamsUpsertBulk) SetIsDefault(v bool) *UsersTeamsUpsertBulk {
	return u.Update(func(s *UsersTeamsUpsert) {
		s.SetIsDefault(v)
	})
}

// UpdateIsDefault sets the "is_default" field to the value that was provided on create.
func (u *UsersTeamsUpsertBulk) UpdateIsDefault() *UsersTeamsUpsertBulk {
	return u.Update(func(s *UsersTeamsUpsert) {
		s.UpdateIsDefault()
	})
}

// Exec executes the query.
func (u *UsersTeamsUpsertBulk) Exec(ctx context.Context) error {
	if u.create.err != nil {
		return u.create.err
	}
	for i, b := range u.create.builders {
		if len(b.conflict) != 0 {
			return fmt.Errorf("models: OnConflict was set for builder %d. Set it on the UsersTeamsCreateBulk instead", i)
		}
	}
	if len(u.create.conflict) == 0 {
		return errors.New("models: missing options for UsersTeamsCreateBulk.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *UsersTeamsUpsertBulk) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/usersteams_delete.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"
)

// UsersTeamsDelete is the builder for deleting a UsersTeams entity.
type UsersTeamsDelete struct {
	config
	hooks    []Hook
	mutation *UsersTeamsMutation
}

// Where appends a list predicates to the UsersTeamsDelete builder.
func (utd *UsersTeamsDelete) Where(ps ...predicate.UsersTeams) *UsersTeamsDelete {
	utd.mutation.Where(ps...)
	return utd
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (utd *UsersTeamsDelete) Exec(ctx context.Context) (int, error) {
	return withHooks(ctx, utd.sqlExec, utd.mutation, utd.hooks)
}

// ExecX is like Exec, but panics if an error occurs.
func (utd *UsersTeamsDelete) ExecX(ctx context.Context) int {
	n, err := utd.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (utd *UsersTeamsDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := sqlgraph.NewDeleteSpec(usersteams.Table, sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt))
	_spec.Node.Schema = utd.schemaConfig.UsersTeams
	ctx = internal.NewSchemaConfigContext(ctx, utd.schemaConfig)
	if ps := utd.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	affected, err := sqlgraph.DeleteNodes(ctx, utd.driver, _spec)
	if err != nil && sqlgraph.IsConstraintError(err) {
		err = &ConstraintError{msg: err.Error(), wrap: err}
	}
	utd.mutation.done = true
	return affected, err
}

// UsersTeamsDeleteOne is the builder for deleting a single UsersTeams entity.
type UsersTeamsDeleteOne struct {
	utd *UsersTeamsDelete
}

// Where appends a list predicates to the UsersTeamsDelete builder.
func (utdo *UsersTeamsDeleteOne) Where(ps ...predicate.UsersTeams) *UsersTeamsDeleteOne {
	utdo.utd.mutation.Where(ps...)
	return utdo
}

// Exec executes the deletion query.
func (utdo *UsersTeamsDeleteOne) Exec(ctx context.Context) error {
	n, err := utdo.utd.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{usersteams.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (utdo *UsersTeamsDeleteOne) ExecX(ctx context.Context) {
	if err := utdo.Exec(ctx); err != nil {
		panic(err)
	}
}



================================================
File: models/usersteams_query.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"fmt"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"
	"github.com/google/uuid"
)

// UsersTeamsQuery is the builder for querying UsersTeams entities.
type UsersTeamsQuery struct {
	config
	ctx        *QueryContext
	order      []usersteams.OrderOption
	inters     []Interceptor
	predicates []predicate.UsersTeams
	withUsers  *UserQuery
	withTeams  *TeamQuery
	modifiers  []func(*sql.Selector)
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the UsersTeamsQuery builder.
func (utq *UsersTeamsQuery) Where(ps ...predicate.UsersTeams) *UsersTeamsQuery {
	utq.predicates = append(utq.predicates, ps...)
	return utq
}

// Limit the number of records to be returned by this query.
func (utq *UsersTeamsQuery) Limit(limit int) *UsersTeamsQuery {
	utq.ctx.Limit = &limit
	return utq
}

// Offset to start from.
func (utq *UsersTeamsQuery) Offset(offset int) *UsersTeamsQuery {
	utq.ctx.Offset = &offset
	return utq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (utq *UsersTeamsQuery) Unique(unique bool) *UsersTeamsQuery {
	utq.ctx.Unique = &unique
	return utq
}

// Order specifies how the records should be ordered.
func (utq *UsersTeamsQuery) Order(o ...usersteams.OrderOption) *UsersTeamsQuery {
	utq.order = append(utq.order, o...)
	return utq
}

// QueryUsers chains the current query on the "users" edge.
func (utq *UsersTeamsQuery) QueryUsers() *UserQuery {
	query := (&UserClient{config: utq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := utq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := utq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(usersteams.Table, usersteams.FieldID, selector),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, usersteams.UsersTable, usersteams.UsersColumn),
		)
		schemaConfig := utq.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.UsersTeams
		fromU = sqlgraph.SetNeighbors(utq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryTeams chains the current query on the "teams" edge.
func (utq *UsersTeamsQuery) QueryTeams() *TeamQuery {
	query := (&TeamClient{config: utq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := utq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := utq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(usersteams.Table, usersteams.FieldID, selector),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, usersteams.TeamsTable, usersteams.TeamsColumn),
		)
		schemaConfig := utq.schemaConfig
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.UsersTeams
		fromU = sqlgraph.SetNeighbors(utq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first UsersTeams entity from the query.
// Returns a *NotFoundError when no UsersTeams was found.
func (utq *UsersTeamsQuery) First(ctx context.Context) (*UsersTeams, error) {
	nodes, err := utq.Limit(1).All(setContextOp(ctx, utq.ctx, "First"))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{usersteams.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (utq *UsersTeamsQuery) FirstX(ctx context.Context) *UsersTeams {
	node, err := utq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first UsersTeams ID from the query.
// Returns a *NotFoundError when no UsersTeams ID was found.
func (utq *UsersTeamsQuery) FirstID(ctx context.Context) (id int, err error) {
	var ids []int
	if ids, err = utq.Limit(1).IDs(setContextOp(ctx, utq.ctx, "FirstID")); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{usersteams.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (utq *UsersTeamsQuery) FirstIDX(ctx context.Context) int {
	id, err := utq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single UsersTeams entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one UsersTeams entity is found.
// Returns a *NotFoundError when no UsersTeams entities are found.
func (utq *UsersTeamsQuery) Only(ctx context.Context) (*UsersTeams, error) {
	nodes, err := utq.Limit(2).All(setContextOp(ctx, utq.ctx, "Only"))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{usersteams.Label}
	default:
		return nil, &NotSingularError{usersteams.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (utq *UsersTeamsQuery) OnlyX(ctx context.Context) *UsersTeams {
	node, err := utq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only UsersTeams ID in the query.
// Returns a *NotSingularError when more than one UsersTeams ID is found.
// Returns a *NotFoundError when no entities are found.
func (utq *UsersTeamsQuery) OnlyID(ctx context.Context) (id int, err error) {
	var ids []int
	if ids, err = utq.Limit(2).IDs(setContextOp(ctx, utq.ctx, "OnlyID")); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{usersteams.Label}
	default:
		err = &NotSingularError{usersteams.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (utq *UsersTeamsQuery) OnlyIDX(ctx context.Context) int {
	id, err := utq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of UsersTeamsSlice.
func (utq *UsersTeamsQuery) All(ctx context.Context) ([]*UsersTeams, error) {
	ctx = setContextOp(ctx, utq.ctx, "All")
	if err := utq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*UsersTeams, *UsersTeamsQuery]()
	return withInterceptors[[]*UsersTeams](ctx, utq, qr, utq.inters)
}

// AllX is like All, but panics if an error occurs.
func (utq *UsersTeamsQuery) AllX(ctx context.Context) []*UsersTeams {
	nodes, err := utq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of UsersTeams IDs.
func (utq *UsersTeamsQuery) IDs(ctx context.Context) (ids []int, err error) {
	if utq.ctx.Unique == nil && utq.path != nil {
		utq.Unique(true)
	}
	ctx = setContextOp(ctx, utq.ctx, "IDs")
	if err = utq.Select(usersteams.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (utq *UsersTeamsQuery) IDsX(ctx context.Context) []int {
	ids, err := utq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (utq *UsersTeamsQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, utq.ctx, "Count")
	if err := utq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, utq, querierCount[*UsersTeamsQuery](), utq.inters)
}

// CountX is like Count, but panics if an error occurs.
func (utq *UsersTeamsQuery) CountX(ctx context.Context) int {
	count, err := utq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (utq *UsersTeamsQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, utq.ctx, "Exist")
	switch _, err := utq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("models: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (utq *UsersTeamsQuery) ExistX(ctx context.Context) bool {
	exist, err := utq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the UsersTeamsQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (utq *UsersTeamsQuery) Clone() *UsersTeamsQuery {
	if utq == nil {
		return nil
	}
	return &UsersTeamsQuery{
		config:     utq.config,
		ctx:        utq.ctx.Clone(),
		order:      append([]usersteams.OrderOption{}, utq.order...),
		inters:     append([]Interceptor{}, utq.inters...),
		predicates: append([]predicate.UsersTeams{}, utq.predicates...),
		withUsers:  utq.withUsers.Clone(),
		withTeams:  utq.withTeams.Clone(),
		// clone intermediate query.
		sql:  utq.sql.Clone(),
		path: utq.path,
	}
}

// WithUsers tells the query-builder to eager-load the nodes that are connected to
// the "users" edge. The optional arguments are used to configure the query builder of the edge.
func (utq *UsersTeamsQuery) WithUsers(opts ...func(*UserQuery)) *UsersTeamsQuery {
	query := (&UserClient{config: utq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	utq.withUsers = query
	return utq
}

// WithTeams tells the query-builder to eager-load the nodes that are connected to
// the "teams" edge. The optional arguments are used to configure the query builder of the edge.
func (utq *UsersTeamsQuery) WithTeams(opts ...func(*TeamQuery)) *UsersTeamsQuery {
	query := (&TeamClient{config: utq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	utq.withTeams = query
	return utq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		UserID uuid.UUID `json:"user_id,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.UsersTeams.Query().
//		GroupBy(usersteams.FieldUserID).
//		Aggregate(models.Count()).
//		Scan(ctx, &v)
func (utq *UsersTeamsQuery) GroupBy(field string, fields ...string) *UsersTeamsGroupBy {
	utq.ctx.Fields = append([]string{field}, fields...)
	grbuild := &UsersTeamsGroupBy{build: utq}
	grbuild.flds = &utq.ctx.Fields
	grbuild.label = usersteams.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		UserID uuid.UUID `json:"user_id,omitempty"`
//	}
//
//	client.UsersTeams.Query().
//		Select(usersteams.FieldUserID).
//		Scan(ctx, &v)
func (utq *UsersTeamsQuery) Select(fields ...string) *UsersTeamsSelect {
	utq.ctx.Fields = append(utq.ctx.Fields, fields...)
	sbuild := &UsersTeamsSelect{UsersTeamsQuery: utq}
	sbuild.label = usersteams.Label
	sbuild.flds, sbuild.scan = &utq.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a UsersTeamsSelect configured with the given aggregations.
func (utq *UsersTeamsQuery) Aggregate(fns ...AggregateFunc) *UsersTeamsSelect {
	return utq.Select().Aggregate(fns...)
}

func (utq *UsersTeamsQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range utq.inters {
		if inter == nil {
			return fmt.Errorf("models: uninitialized interceptor (forgotten import models/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, utq); err != nil {
				return err
			}
		}
	}
	for _, f := range utq.ctx.Fields {
		if !usersteams.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
		}
	}
	if utq.path != nil {
		prev, err := utq.path(ctx)
		if err != nil {
			return err
		}
		utq.sql = prev
	}
	return nil
}

func (utq *UsersTeamsQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*UsersTeams, error) {
	var (
		nodes       = []*UsersTeams{}
		_spec       = utq.querySpec()
		loadedTypes = [2]bool{
			utq.withUsers != nil,
			utq.withTeams != nil,
		}
	)
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*UsersTeams).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &UsersTeams{config: utq.config}
		nodes = append(nodes, node)
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	_spec.Node.Schema = utq.schemaConfig.UsersTeams
	ctx = internal.NewSchemaConfigContext(ctx, utq.schemaConfig)
	if len(utq.modifiers) > 0 {
		_spec.Modifiers = utq.modifiers
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, utq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	if query := utq.withUsers; query != nil {
		if err := utq.loadUsers(ctx, query, nodes, nil,
			func(n *UsersTeams, e *User) { n.Edges.Users = e }); err != nil {
			return nil, err
		}
	}
	if query := utq.withTeams; query != nil {
		if err := utq.loadTeams(ctx, query, nodes, nil,
			func(n *UsersTeams, e *Team) { n.Edges.Teams = e }); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

func (utq *UsersTeamsQuery) loadUsers(ctx context.Context, query *UserQuery, nodes []*UsersTeams, init func(*UsersTeams), assign func(*UsersTeams, *User)) error {
	ids := make([]uuid.UUID, 0, len(nodes))
	nodeids := make(map[uuid.UUID][]*UsersTeams)
	for i := range nodes {
		fk := nodes[i].UserID
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(user.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "user_id" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}
func (utq *UsersTeamsQuery) loadTeams(ctx context.Context, query *TeamQuery, nodes []*UsersTeams, init func(*UsersTeams), assign func(*UsersTeams, *Team)) error {
	ids := make([]uuid.UUID, 0, len(nodes))
	nodeids := make(map[uuid.UUID][]*UsersTeams)
	for i := range nodes {
		fk := nodes[i].TeamID
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(team.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "team_id" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}

func (utq *UsersTeamsQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := utq.querySpec()
	_spec.Node.Schema = utq.schemaConfig.UsersTeams
	ctx = internal.NewSchemaConfigContext(ctx, utq.schemaConfig)
	if len(utq.modifiers) > 0 {
		_spec.Modifiers = utq.modifiers
	}
	_spec.Node.Columns = utq.ctx.Fields
	if len(utq.ctx.Fields) > 0 {
		_spec.Unique = utq.ctx.Unique != nil && *utq.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, utq.driver, _spec)
}

func (utq *UsersTeamsQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(usersteams.Table, usersteams.Columns, sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt))
	_spec.From = utq.sql
	if unique := utq.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if utq.path != nil {
		_spec.Unique = true
	}
	if fields := utq.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, usersteams.FieldID)
		for i := range fields {
			if fields[i] != usersteams.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
		if utq.withUsers != nil {
			_spec.Node.AddColumnOnce(usersteams.FieldUserID)
		}
		if utq.withTeams != nil {
			_spec.Node.AddColumnOnce(usersteams.FieldTeamID)
		}
	}
	if ps := utq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := utq.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := utq.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := utq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (utq *UsersTeamsQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(utq.driver.Dialect())
	t1 := builder.Table(usersteams.Table)
	columns := utq.ctx.Fields
	if len(columns) == 0 {
		columns = usersteams.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if utq.sql != nil {
		selector = utq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if utq.ctx.Unique != nil && *utq.ctx.Unique {
		selector.Distinct()
	}
	t1.Schema(utq.schemaConfig.UsersTeams)
	ctx = internal.NewSchemaConfigContext(ctx, utq.schemaConfig)
	selector.WithContext(ctx)
	for _, m := range utq.modifiers {
		m(selector)
	}
	for _, p := range utq.predicates {
		p(selector)
	}
	for _, p := range utq.order {
		p(selector)
	}
	if offset := utq.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := utq.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// Modify adds a query modifier for attaching custom logic to queries.
func (utq *UsersTeamsQuery) Modify(modifiers ...func(s *sql.Selector)) *UsersTeamsSelect {
	utq.modifiers = append(utq.modifiers, modifiers...)
	return utq.Select()
}

// UsersTeamsGroupBy is the group-by builder for UsersTeams entities.
type UsersTeamsGroupBy struct {
	selector
	build *UsersTeamsQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (utgb *UsersTeamsGroupBy) Aggregate(fns ...AggregateFunc) *UsersTeamsGroupBy {
	utgb.fns = append(utgb.fns, fns...)
	return utgb
}

// Scan applies the selector query and scans the result into the given value.
func (utgb *UsersTeamsGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, utgb.build.ctx, "GroupBy")
	if err := utgb.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*UsersTeamsQuery, *UsersTeamsGroupBy](ctx, utgb.build, utgb, utgb.build.inters, v)
}

func (utgb *UsersTeamsGroupBy) sqlScan(ctx context.Context, root *UsersTeamsQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(utgb.fns))
	for _, fn := range utgb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*utgb.flds)+len(utgb.fns))
		for _, f := range *utgb.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*utgb.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := utgb.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// UsersTeamsSelect is the builder for selecting fields of UsersTeams entities.
type UsersTeamsSelect struct {
	*UsersTeamsQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (uts *UsersTeamsSelect) Aggregate(fns ...AggregateFunc) *UsersTeamsSelect {
	uts.fns = append(uts.fns, fns...)
	return uts
}

// Scan applies the selector query and scans the result into the given value.
func (uts *UsersTeamsSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, uts.ctx, "Select")
	if err := uts.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*UsersTeamsQuery, *UsersTeamsSelect](ctx, uts.UsersTeamsQuery, uts, uts.inters, v)
}

func (uts *UsersTeamsSelect) sqlScan(ctx context.Context, root *UsersTeamsQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(uts.fns))
	for _, fn := range uts.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*uts.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := uts.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// Modify adds a query modifier for attaching custom logic to queries.
func (uts *UsersTeamsSelect) Modify(modifiers ...func(s *sql.Selector)) *UsersTeamsSelect {
	uts.modifiers = append(uts.modifiers, modifiers...)
	return uts
}



================================================
File: models/usersteams_update.go
================================================
// Code generated by ent, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/team"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/user"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/usersteams"
	"github.com/google/uuid"
)

// UsersTeamsUpdate is the builder for updating UsersTeams entities.
type UsersTeamsUpdate struct {
	config
	hooks     []Hook
	mutation  *UsersTeamsMutation
	modifiers []func(*sql.UpdateBuilder)
}

// Where appends a list predicates to the UsersTeamsUpdate builder.
func (utu *UsersTeamsUpdate) Where(ps ...predicate.UsersTeams) *UsersTeamsUpdate {
	utu.mutation.Where(ps...)
	return utu
}

// SetUserID sets the "user_id" field.
func (utu *UsersTeamsUpdate) SetUserID(u uuid.UUID) *UsersTeamsUpdate {
	utu.mutation.SetUserID(u)
	return utu
}

// SetNillableUserID sets the "user_id" field if the given value is not nil.
func (utu *UsersTeamsUpdate) SetNillableUserID(u *uuid.UUID) *UsersTeamsUpdate {
	if u != nil {
		utu.SetUserID(*u)
	}
	return utu
}

// SetTeamID sets the "team_id" field.
func (utu *UsersTeamsUpdate) SetTeamID(u uuid.UUID) *UsersTeamsUpdate {
	utu.mutation.SetTeamID(u)
	return utu
}

// SetNillableTeamID sets the "team_id" field if the given value is not nil.
func (utu *UsersTeamsUpdate) SetNillableTeamID(u *uuid.UUID) *UsersTeamsUpdate {
	if u != nil {
		utu.SetTeamID(*u)
	}
	return utu
}

// SetIsDefault sets the "is_default" field.
func (utu *UsersTeamsUpdate) SetIsDefault(b bool) *UsersTeamsUpdate {
	utu.mutation.SetIsDefault(b)
	return utu
}

// SetNillableIsDefault sets the "is_default" field if the given value is not nil.
func (utu *UsersTeamsUpdate) SetNillableIsDefault(b *bool) *UsersTeamsUpdate {
	if b != nil {
		utu.SetIsDefault(*b)
	}
	return utu
}

// SetUsersID sets the "users" edge to the User entity by ID.
func (utu *UsersTeamsUpdate) SetUsersID(id uuid.UUID) *UsersTeamsUpdate {
	utu.mutation.SetUsersID(id)
	return utu
}

// SetUsers sets the "users" edge to the User entity.
func (utu *UsersTeamsUpdate) SetUsers(u *User) *UsersTeamsUpdate {
	return utu.SetUsersID(u.ID)
}

// SetTeamsID sets the "teams" edge to the Team entity by ID.
func (utu *UsersTeamsUpdate) SetTeamsID(id uuid.UUID) *UsersTeamsUpdate {
	utu.mutation.SetTeamsID(id)
	return utu
}

// SetTeams sets the "teams" edge to the Team entity.
func (utu *UsersTeamsUpdate) SetTeams(t *Team) *UsersTeamsUpdate {
	return utu.SetTeamsID(t.ID)
}

// Mutation returns the UsersTeamsMutation object of the builder.
func (utu *UsersTeamsUpdate) Mutation() *UsersTeamsMutation {
	return utu.mutation
}

// ClearUsers clears the "users" edge to the User entity.
func (utu *UsersTeamsUpdate) ClearUsers() *UsersTeamsUpdate {
	utu.mutation.ClearUsers()
	return utu
}

// ClearTeams clears the "teams" edge to the Team entity.
func (utu *UsersTeamsUpdate) ClearTeams() *UsersTeamsUpdate {
	utu.mutation.ClearTeams()
	return utu
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (utu *UsersTeamsUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, utu.sqlSave, utu.mutation, utu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (utu *UsersTeamsUpdate) SaveX(ctx context.Context) int {
	affected, err := utu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (utu *UsersTeamsUpdate) Exec(ctx context.Context) error {
	_, err := utu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (utu *UsersTeamsUpdate) ExecX(ctx context.Context) {
	if err := utu.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (utu *UsersTeamsUpdate) check() error {
	if _, ok := utu.mutation.UsersID(); utu.mutation.UsersCleared() && !ok {
		return errors.New(`models: clearing a required unique edge "UsersTeams.users"`)
	}
	if _, ok := utu.mutation.TeamsID(); utu.mutation.TeamsCleared() && !ok {
		return errors.New(`models: clearing a required unique edge "UsersTeams.teams"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (utu *UsersTeamsUpdate) Modify(modifiers ...func(u *sql.UpdateBuilder)) *UsersTeamsUpdate {
	utu.modifiers = append(utu.modifiers, modifiers...)
	return utu
}

func (utu *UsersTeamsUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := utu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(usersteams.Table, usersteams.Columns, sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt))
	if ps := utu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := utu.mutation.IsDefault(); ok {
		_spec.SetField(usersteams.FieldIsDefault, field.TypeBool, value)
	}
	if utu.mutation.UsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   usersteams.UsersTable,
			Columns: []string{usersteams.UsersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = utu.schemaConfig.UsersTeams
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := utu.mutation.UsersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   usersteams.UsersTable,
			Columns: []string{usersteams.UsersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = utu.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if utu.mutation.TeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   usersteams.TeamsTable,
			Columns: []string{usersteams.TeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = utu.schemaConfig.UsersTeams
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := utu.mutation.TeamsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   usersteams.TeamsTable,
			Columns: []string{usersteams.TeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = utu.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = utu.schemaConfig.UsersTeams
	ctx = internal.NewSchemaConfigContext(ctx, utu.schemaConfig)
	_spec.AddModifiers(utu.modifiers...)
	if n, err = sqlgraph.UpdateNodes(ctx, utu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{usersteams.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	utu.mutation.done = true
	return n, nil
}

// UsersTeamsUpdateOne is the builder for updating a single UsersTeams entity.
type UsersTeamsUpdateOne struct {
	config
	fields    []string
	hooks     []Hook
	mutation  *UsersTeamsMutation
	modifiers []func(*sql.UpdateBuilder)
}

// SetUserID sets the "user_id" field.
func (utuo *UsersTeamsUpdateOne) SetUserID(u uuid.UUID) *UsersTeamsUpdateOne {
	utuo.mutation.SetUserID(u)
	return utuo
}

// SetNillableUserID sets the "user_id" field if the given value is not nil.
func (utuo *UsersTeamsUpdateOne) SetNillableUserID(u *uuid.UUID) *UsersTeamsUpdateOne {
	if u != nil {
		utuo.SetUserID(*u)
	}
	return utuo
}

// SetTeamID sets the "team_id" field.
func (utuo *UsersTeamsUpdateOne) SetTeamID(u uuid.UUID) *UsersTeamsUpdateOne {
	utuo.mutation.SetTeamID(u)
	return utuo
}

// SetNillableTeamID sets the "team_id" field if the given value is not nil.
func (utuo *UsersTeamsUpdateOne) SetNillableTeamID(u *uuid.UUID) *UsersTeamsUpdateOne {
	if u != nil {
		utuo.SetTeamID(*u)
	}
	return utuo
}

// SetIsDefault sets the "is_default" field.
func (utuo *UsersTeamsUpdateOne) SetIsDefault(b bool) *UsersTeamsUpdateOne {
	utuo.mutation.SetIsDefault(b)
	return utuo
}

// SetNillableIsDefault sets the "is_default" field if the given value is not nil.
func (utuo *UsersTeamsUpdateOne) SetNillableIsDefault(b *bool) *UsersTeamsUpdateOne {
	if b != nil {
		utuo.SetIsDefault(*b)
	}
	return utuo
}

// SetUsersID sets the "users" edge to the User entity by ID.
func (utuo *UsersTeamsUpdateOne) SetUsersID(id uuid.UUID) *UsersTeamsUpdateOne {
	utuo.mutation.SetUsersID(id)
	return utuo
}

// SetUsers sets the "users" edge to the User entity.
func (utuo *UsersTeamsUpdateOne) SetUsers(u *User) *UsersTeamsUpdateOne {
	return utuo.SetUsersID(u.ID)
}

// SetTeamsID sets the "teams" edge to the Team entity by ID.
func (utuo *UsersTeamsUpdateOne) SetTeamsID(id uuid.UUID) *UsersTeamsUpdateOne {
	utuo.mutation.SetTeamsID(id)
	return utuo
}

// SetTeams sets the "teams" edge to the Team entity.
func (utuo *UsersTeamsUpdateOne) SetTeams(t *Team) *UsersTeamsUpdateOne {
	return utuo.SetTeamsID(t.ID)
}

// Mutation returns the UsersTeamsMutation object of the builder.
func (utuo *UsersTeamsUpdateOne) Mutation() *UsersTeamsMutation {
	return utuo.mutation
}

// ClearUsers clears the "users" edge to the User entity.
func (utuo *UsersTeamsUpdateOne) ClearUsers() *UsersTeamsUpdateOne {
	utuo.mutation.ClearUsers()
	return utuo
}

// ClearTeams clears the "teams" edge to the Team entity.
func (utuo *UsersTeamsUpdateOne) ClearTeams() *UsersTeamsUpdateOne {
	utuo.mutation.ClearTeams()
	return utuo
}

// Where appends a list predicates to the UsersTeamsUpdate builder.
func (utuo *UsersTeamsUpdateOne) Where(ps ...predicate.UsersTeams) *UsersTeamsUpdateOne {
	utuo.mutation.Where(ps...)
	return utuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (utuo *UsersTeamsUpdateOne) Select(field string, fields ...string) *UsersTeamsUpdateOne {
	utuo.fields = append([]string{field}, fields...)
	return utuo
}

// Save executes the query and returns the updated UsersTeams entity.
func (utuo *UsersTeamsUpdateOne) Save(ctx context.Context) (*UsersTeams, error) {
	return withHooks(ctx, utuo.sqlSave, utuo.mutation, utuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (utuo *UsersTeamsUpdateOne) SaveX(ctx context.Context) *UsersTeams {
	node, err := utuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (utuo *UsersTeamsUpdateOne) Exec(ctx context.Context) error {
	_, err := utuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (utuo *UsersTeamsUpdateOne) ExecX(ctx context.Context) {
	if err := utuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (utuo *UsersTeamsUpdateOne) check() error {
	if _, ok := utuo.mutation.UsersID(); utuo.mutation.UsersCleared() && !ok {
		return errors.New(`models: clearing a required unique edge "UsersTeams.users"`)
	}
	if _, ok := utuo.mutation.TeamsID(); utuo.mutation.TeamsCleared() && !ok {
		return errors.New(`models: clearing a required unique edge "UsersTeams.teams"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (utuo *UsersTeamsUpdateOne) Modify(modifiers ...func(u *sql.UpdateBuilder)) *UsersTeamsUpdateOne {
	utuo.modifiers = append(utuo.modifiers, modifiers...)
	return utuo
}

func (utuo *UsersTeamsUpdateOne) sqlSave(ctx context.Context) (_node *UsersTeams, err error) {
	if err := utuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(usersteams.Table, usersteams.Columns, sqlgraph.NewFieldSpec(usersteams.FieldID, field.TypeInt))
	id, ok := utuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`models: missing "UsersTeams.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := utuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, usersteams.FieldID)
		for _, f := range fields {
			if !usersteams.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("models: invalid field %q for query", f)}
			}
			if f != usersteams.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := utuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := utuo.mutation.IsDefault(); ok {
		_spec.SetField(usersteams.FieldIsDefault, field.TypeBool, value)
	}
	if utuo.mutation.UsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   usersteams.UsersTable,
			Columns: []string{usersteams.UsersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = utuo.schemaConfig.UsersTeams
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := utuo.mutation.UsersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   usersteams.UsersTable,
			Columns: []string{usersteams.UsersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = utuo.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if utuo.mutation.TeamsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   usersteams.TeamsTable,
			Columns: []string{usersteams.TeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = utuo.schemaConfig.UsersTeams
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := utuo.mutation.TeamsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   usersteams.TeamsTable,
			Columns: []string{usersteams.TeamsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(team.FieldID, field.TypeUUID),
			},
		}
		edge.Schema = utuo.schemaConfig.UsersTeams
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_spec.Node.Schema = utuo.schemaConfig.UsersTeams
	ctx = internal.NewSchemaConfigContext(ctx, utuo.schemaConfig)
	_spec.AddModifiers(utuo.modifiers...)
	_node = &UsersTeams{config: utuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, utuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{usersteams.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	utuo.mutation.done = true
	return _node, nil
}



================================================
File: models/accesstoken/accesstoken.go
================================================
// Code generated by ent, DO NOT EDIT.

package accesstoken

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the accesstoken type in the database.
	Label = "access_token"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "access_token"
	// FieldUserID holds the string denoting the user_id field in the database.
	FieldUserID = "user_id"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// EdgeUser holds the string denoting the user edge name in mutations.
	EdgeUser = "user"
	// UserFieldID holds the string denoting the ID field of the User.
	UserFieldID = "id"
	// Table holds the table name of the accesstoken in the database.
	Table = "access_tokens"
	// UserTable is the table that holds the user relation/edge.
	UserTable = "access_tokens"
	// UserInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	UserInverseTable = "users"
	// UserColumn is the table column denoting the user relation/edge.
	UserColumn = "user_id"
)

// Columns holds all SQL columns for accesstoken fields.
var Columns = []string{
	FieldID,
	FieldUserID,
	FieldCreatedAt,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

// OrderOption defines the ordering options for the AccessToken queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByUserID orders the results by the user_id field.
func ByUserID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUserID, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUserField orders the results by user field.
func ByUserField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newUserStep(), sql.OrderByField(field, opts...))
	}
}
func newUserStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(UserInverseTable, UserFieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, UserTable, UserColumn),
	)
}



================================================
File: models/accesstoken/where.go
================================================
// Code generated by ent, DO NOT EDIT.

package accesstoken

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/google/uuid"
)

// ID filters vertices based on their ID field.
func ID(id string) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id string) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id string) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...string) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...string) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id string) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id string) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id string) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id string) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldLTE(FieldID, id))
}

// IDEqualFold applies the EqualFold predicate on the ID field.
func IDEqualFold(id string) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldEqualFold(FieldID, id))
}

// IDContainsFold applies the ContainsFold predicate on the ID field.
func IDContainsFold(id string) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldContainsFold(FieldID, id))
}

// UserID applies equality check predicate on the "user_id" field. It's identical to UserIDEQ.
func UserID(v uuid.UUID) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldEQ(FieldUserID, v))
}

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldEQ(FieldCreatedAt, v))
}

// UserIDEQ applies the EQ predicate on the "user_id" field.
func UserIDEQ(v uuid.UUID) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldEQ(FieldUserID, v))
}

// UserIDNEQ applies the NEQ predicate on the "user_id" field.
func UserIDNEQ(v uuid.UUID) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldNEQ(FieldUserID, v))
}

// UserIDIn applies the In predicate on the "user_id" field.
func UserIDIn(vs ...uuid.UUID) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldIn(FieldUserID, vs...))
}

// UserIDNotIn applies the NotIn predicate on the "user_id" field.
func UserIDNotIn(vs ...uuid.UUID) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldNotIn(FieldUserID, vs...))
}

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldEQ(FieldCreatedAt, v))
}

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldNEQ(FieldCreatedAt, v))
}

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldIn(FieldCreatedAt, vs...))
}

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldNotIn(FieldCreatedAt, vs...))
}

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldGT(FieldCreatedAt, v))
}

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldGTE(FieldCreatedAt, v))
}

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldLT(FieldCreatedAt, v))
}

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.AccessToken {
	return predicate.AccessToken(sql.FieldLTE(FieldCreatedAt, v))
}

// CreatedAtIsNil applies the IsNil predicate on the "created_at" field.
func CreatedAtIsNil() predicate.AccessToken {
	return predicate.AccessToken(sql.FieldIsNull(FieldCreatedAt))
}

// CreatedAtNotNil applies the NotNil predicate on the "created_at" field.
func CreatedAtNotNil() predicate.AccessToken {
	return predicate.AccessToken(sql.FieldNotNull(FieldCreatedAt))
}

// HasUser applies the HasEdge predicate on the "user" edge.
func HasUser() predicate.AccessToken {
	return predicate.AccessToken(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, UserTable, UserColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.AccessToken
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasUserWith applies the HasEdge predicate on the "user" edge with a given conditions (other predicates).
func HasUserWith(preds ...predicate.User) predicate.AccessToken {
	return predicate.AccessToken(func(s *sql.Selector) {
		step := newUserStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.AccessToken
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.AccessToken) predicate.AccessToken {
	return predicate.AccessToken(sql.AndPredicates(predicates...))
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.AccessToken) predicate.AccessToken {
	return predicate.AccessToken(sql.OrPredicates(predicates...))
}

// Not applies the not operator on the given predicate.
func Not(p predicate.AccessToken) predicate.AccessToken {
	return predicate.AccessToken(sql.NotPredicates(p))
}



================================================
File: models/chmodels/clickhouse.go
================================================
package chmodels

type ClickhouseColumn struct {
	Database string `ch:"database"`
	Table    string `ch:"table"`
	Name     string `ch:"name"`
	Type     string `ch:"type"`
	Position uint64 `ch:"position"`
}



================================================
File: models/chmodels/metrics.go
================================================
package chmodels

import "time"

type Metrics struct {
	Timestamp      time.Time `ch:"timestamp"`
	SandboxID      string    `ch:"sandbox_id"`
	TeamID         string    `ch:"team_id"`
	CPUCount       uint32    `ch:"cpu_count"`
	CPUUsedPercent float32   `ch:"cpu_used_pct"`
	MemTotalMiB    uint64    `ch:"mem_total_mib"`
	MemUsedMiB     uint64    `ch:"mem_used_mib"`
}



================================================
File: models/enttest/enttest.go
================================================
// Code generated by ent, DO NOT EDIT.

package enttest

import (
	"context"

	"github.com/e2b-dev/infra/packages/shared/pkg/models"
	// required by schema hooks.
	_ "github.com/e2b-dev/infra/packages/shared/pkg/models/runtime"

	"entgo.io/ent/dialect/sql/schema"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/migrate"
)

type (
	// TestingT is the interface that is shared between
	// testing.T and testing.B and used by enttest.
	TestingT interface {
		FailNow()
		Error(...any)
	}

	// Option configures client creation.
	Option func(*options)

	options struct {
		opts        []models.Option
		migrateOpts []schema.MigrateOption
	}
)

// WithOptions forwards options to client creation.
func WithOptions(opts ...models.Option) Option {
	return func(o *options) {
		o.opts = append(o.opts, opts...)
	}
}

// WithMigrateOptions forwards options to auto migration.
func WithMigrateOptions(opts ...schema.MigrateOption) Option {
	return func(o *options) {
		o.migrateOpts = append(o.migrateOpts, opts...)
	}
}

func newOptions(opts []Option) *options {
	o := &options{}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

// Open calls models.Open and auto-run migration.
func Open(t TestingT, driverName, dataSourceName string, opts ...Option) *models.Client {
	o := newOptions(opts)
	c, err := models.Open(driverName, dataSourceName, o.opts...)
	if err != nil {
		t.Error(err)
		t.FailNow()
	}
	migrateSchema(t, c, o)
	return c
}

// NewClient calls models.NewClient and auto-run migration.
func NewClient(t TestingT, opts ...Option) *models.Client {
	o := newOptions(opts)
	c := models.NewClient(o.opts...)
	migrateSchema(t, c, o)
	return c
}
func migrateSchema(t TestingT, c *models.Client, o *options) {
	tables, err := schema.CopyTables(migrate.Tables)
	if err != nil {
		t.Error(err)
		t.FailNow()
	}
	if err := migrate.Create(context.Background(), c.Schema, tables, o.migrateOpts...); err != nil {
		t.Error(err)
		t.FailNow()
	}
}



================================================
File: models/env/env.go
================================================
// Code generated by ent, DO NOT EDIT.

package env

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the env type in the database.
	Label = "env"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// FieldTeamID holds the string denoting the team_id field in the database.
	FieldTeamID = "team_id"
	// FieldCreatedBy holds the string denoting the created_by field in the database.
	FieldCreatedBy = "created_by"
	// FieldPublic holds the string denoting the public field in the database.
	FieldPublic = "public"
	// FieldBuildCount holds the string denoting the build_count field in the database.
	FieldBuildCount = "build_count"
	// FieldSpawnCount holds the string denoting the spawn_count field in the database.
	FieldSpawnCount = "spawn_count"
	// FieldLastSpawnedAt holds the string denoting the last_spawned_at field in the database.
	FieldLastSpawnedAt = "last_spawned_at"
	// EdgeTeam holds the string denoting the team edge name in mutations.
	EdgeTeam = "team"
	// EdgeCreator holds the string denoting the creator edge name in mutations.
	EdgeCreator = "creator"
	// EdgeEnvAliases holds the string denoting the env_aliases edge name in mutations.
	EdgeEnvAliases = "env_aliases"
	// EdgeBuilds holds the string denoting the builds edge name in mutations.
	EdgeBuilds = "builds"
	// EdgeSnapshots holds the string denoting the snapshots edge name in mutations.
	EdgeSnapshots = "snapshots"
	// EnvAliasFieldID holds the string denoting the ID field of the EnvAlias.
	EnvAliasFieldID = "alias"
	// Table holds the table name of the env in the database.
	Table = "envs"
	// TeamTable is the table that holds the team relation/edge.
	TeamTable = "envs"
	// TeamInverseTable is the table name for the Team entity.
	// It exists in this package in order to avoid circular dependency with the "team" package.
	TeamInverseTable = "teams"
	// TeamColumn is the table column denoting the team relation/edge.
	TeamColumn = "team_id"
	// CreatorTable is the table that holds the creator relation/edge.
	CreatorTable = "envs"
	// CreatorInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	CreatorInverseTable = "users"
	// CreatorColumn is the table column denoting the creator relation/edge.
	CreatorColumn = "created_by"
	// EnvAliasesTable is the table that holds the env_aliases relation/edge.
	EnvAliasesTable = "env_aliases"
	// EnvAliasesInverseTable is the table name for the EnvAlias entity.
	// It exists in this package in order to avoid circular dependency with the "envalias" package.
	EnvAliasesInverseTable = "env_aliases"
	// EnvAliasesColumn is the table column denoting the env_aliases relation/edge.
	EnvAliasesColumn = "env_id"
	// BuildsTable is the table that holds the builds relation/edge.
	BuildsTable = "env_builds"
	// BuildsInverseTable is the table name for the EnvBuild entity.
	// It exists in this package in order to avoid circular dependency with the "envbuild" package.
	BuildsInverseTable = "env_builds"
	// BuildsColumn is the table column denoting the builds relation/edge.
	BuildsColumn = "env_id"
	// SnapshotsTable is the table that holds the snapshots relation/edge.
	SnapshotsTable = "snapshots"
	// SnapshotsInverseTable is the table name for the Snapshot entity.
	// It exists in this package in order to avoid circular dependency with the "snapshot" package.
	SnapshotsInverseTable = "snapshots"
	// SnapshotsColumn is the table column denoting the snapshots relation/edge.
	SnapshotsColumn = "env_id"
)

// Columns holds all SQL columns for env fields.
var Columns = []string{
	FieldID,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldTeamID,
	FieldCreatedBy,
	FieldPublic,
	FieldBuildCount,
	FieldSpawnCount,
	FieldLastSpawnedAt,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
	// DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
	DefaultUpdatedAt func() time.Time
	// DefaultBuildCount holds the default value on creation for the "build_count" field.
	DefaultBuildCount int32
	// DefaultSpawnCount holds the default value on creation for the "spawn_count" field.
	DefaultSpawnCount int64
)

// OrderOption defines the ordering options for the Env queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByTeamID orders the results by the team_id field.
func ByTeamID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTeamID, opts...).ToFunc()
}

// ByCreatedBy orders the results by the created_by field.
func ByCreatedBy(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedBy, opts...).ToFunc()
}

// ByPublic orders the results by the public field.
func ByPublic(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPublic, opts...).ToFunc()
}

// ByBuildCount orders the results by the build_count field.
func ByBuildCount(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBuildCount, opts...).ToFunc()
}

// BySpawnCount orders the results by the spawn_count field.
func BySpawnCount(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSpawnCount, opts...).ToFunc()
}

// ByLastSpawnedAt orders the results by the last_spawned_at field.
func ByLastSpawnedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldLastSpawnedAt, opts...).ToFunc()
}

// ByTeamField orders the results by team field.
func ByTeamField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTeamStep(), sql.OrderByField(field, opts...))
	}
}

// ByCreatorField orders the results by creator field.
func ByCreatorField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCreatorStep(), sql.OrderByField(field, opts...))
	}
}

// ByEnvAliasesCount orders the results by env_aliases count.
func ByEnvAliasesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newEnvAliasesStep(), opts...)
	}
}

// ByEnvAliases orders the results by env_aliases terms.
func ByEnvAliases(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newEnvAliasesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByBuildsCount orders the results by builds count.
func ByBuildsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newBuildsStep(), opts...)
	}
}

// ByBuilds orders the results by builds terms.
func ByBuilds(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newBuildsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// BySnapshotsCount orders the results by snapshots count.
func BySnapshotsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newSnapshotsStep(), opts...)
	}
}

// BySnapshots orders the results by snapshots terms.
func BySnapshots(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newSnapshotsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newTeamStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TeamInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, TeamTable, TeamColumn),
	)
}
func newCreatorStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CreatorInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, CreatorTable, CreatorColumn),
	)
}
func newEnvAliasesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(EnvAliasesInverseTable, EnvAliasFieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, EnvAliasesTable, EnvAliasesColumn),
	)
}
func newBuildsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(BuildsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, BuildsTable, BuildsColumn),
	)
}
func newSnapshotsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(SnapshotsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, SnapshotsTable, SnapshotsColumn),
	)
}



================================================
File: models/env/where.go
================================================
// Code generated by ent, DO NOT EDIT.

package env

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/google/uuid"
)

// ID filters vertices based on their ID field.
func ID(id string) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id string) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id string) predicate.Env {
	return predicate.Env(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...string) predicate.Env {
	return predicate.Env(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...string) predicate.Env {
	return predicate.Env(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id string) predicate.Env {
	return predicate.Env(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id string) predicate.Env {
	return predicate.Env(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id string) predicate.Env {
	return predicate.Env(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id string) predicate.Env {
	return predicate.Env(sql.FieldLTE(FieldID, id))
}

// IDEqualFold applies the EqualFold predicate on the ID field.
func IDEqualFold(id string) predicate.Env {
	return predicate.Env(sql.FieldEqualFold(FieldID, id))
}

// IDContainsFold applies the ContainsFold predicate on the ID field.
func IDContainsFold(id string) predicate.Env {
	return predicate.Env(sql.FieldContainsFold(FieldID, id))
}

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldCreatedAt, v))
}

// UpdatedAt applies equality check predicate on the "updated_at" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldUpdatedAt, v))
}

// TeamID applies equality check predicate on the "team_id" field. It's identical to TeamIDEQ.
func TeamID(v uuid.UUID) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldTeamID, v))
}

// CreatedBy applies equality check predicate on the "created_by" field. It's identical to CreatedByEQ.
func CreatedBy(v uuid.UUID) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldCreatedBy, v))
}

// Public applies equality check predicate on the "public" field. It's identical to PublicEQ.
func Public(v bool) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldPublic, v))
}

// BuildCount applies equality check predicate on the "build_count" field. It's identical to BuildCountEQ.
func BuildCount(v int32) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldBuildCount, v))
}

// SpawnCount applies equality check predicate on the "spawn_count" field. It's identical to SpawnCountEQ.
func SpawnCount(v int64) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldSpawnCount, v))
}

// LastSpawnedAt applies equality check predicate on the "last_spawned_at" field. It's identical to LastSpawnedAtEQ.
func LastSpawnedAt(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldLastSpawnedAt, v))
}

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldCreatedAt, v))
}

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldNEQ(FieldCreatedAt, v))
}

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.Env {
	return predicate.Env(sql.FieldIn(FieldCreatedAt, vs...))
}

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.Env {
	return predicate.Env(sql.FieldNotIn(FieldCreatedAt, vs...))
}

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldGT(FieldCreatedAt, v))
}

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldGTE(FieldCreatedAt, v))
}

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldLT(FieldCreatedAt, v))
}

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldLTE(FieldCreatedAt, v))
}

// UpdatedAtEQ applies the EQ predicate on the "updated_at" field.
func UpdatedAtEQ(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldUpdatedAt, v))
}

// UpdatedAtNEQ applies the NEQ predicate on the "updated_at" field.
func UpdatedAtNEQ(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldNEQ(FieldUpdatedAt, v))
}

// UpdatedAtIn applies the In predicate on the "updated_at" field.
func UpdatedAtIn(vs ...time.Time) predicate.Env {
	return predicate.Env(sql.FieldIn(FieldUpdatedAt, vs...))
}

// UpdatedAtNotIn applies the NotIn predicate on the "updated_at" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.Env {
	return predicate.Env(sql.FieldNotIn(FieldUpdatedAt, vs...))
}

// UpdatedAtGT applies the GT predicate on the "updated_at" field.
func UpdatedAtGT(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldGT(FieldUpdatedAt, v))
}

// UpdatedAtGTE applies the GTE predicate on the "updated_at" field.
func UpdatedAtGTE(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldGTE(FieldUpdatedAt, v))
}

// UpdatedAtLT applies the LT predicate on the "updated_at" field.
func UpdatedAtLT(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldLT(FieldUpdatedAt, v))
}

// UpdatedAtLTE applies the LTE predicate on the "updated_at" field.
func UpdatedAtLTE(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldLTE(FieldUpdatedAt, v))
}

// TeamIDEQ applies the EQ predicate on the "team_id" field.
func TeamIDEQ(v uuid.UUID) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldTeamID, v))
}

// TeamIDNEQ applies the NEQ predicate on the "team_id" field.
func TeamIDNEQ(v uuid.UUID) predicate.Env {
	return predicate.Env(sql.FieldNEQ(FieldTeamID, v))
}

// TeamIDIn applies the In predicate on the "team_id" field.
func TeamIDIn(vs ...uuid.UUID) predicate.Env {
	return predicate.Env(sql.FieldIn(FieldTeamID, vs...))
}

// TeamIDNotIn applies the NotIn predicate on the "team_id" field.
func TeamIDNotIn(vs ...uuid.UUID) predicate.Env {
	return predicate.Env(sql.FieldNotIn(FieldTeamID, vs...))
}

// CreatedByEQ applies the EQ predicate on the "created_by" field.
func CreatedByEQ(v uuid.UUID) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldCreatedBy, v))
}

// CreatedByNEQ applies the NEQ predicate on the "created_by" field.
func CreatedByNEQ(v uuid.UUID) predicate.Env {
	return predicate.Env(sql.FieldNEQ(FieldCreatedBy, v))
}

// CreatedByIn applies the In predicate on the "created_by" field.
func CreatedByIn(vs ...uuid.UUID) predicate.Env {
	return predicate.Env(sql.FieldIn(FieldCreatedBy, vs...))
}

// CreatedByNotIn applies the NotIn predicate on the "created_by" field.
func CreatedByNotIn(vs ...uuid.UUID) predicate.Env {
	return predicate.Env(sql.FieldNotIn(FieldCreatedBy, vs...))
}

// CreatedByIsNil applies the IsNil predicate on the "created_by" field.
func CreatedByIsNil() predicate.Env {
	return predicate.Env(sql.FieldIsNull(FieldCreatedBy))
}

// CreatedByNotNil applies the NotNil predicate on the "created_by" field.
func CreatedByNotNil() predicate.Env {
	return predicate.Env(sql.FieldNotNull(FieldCreatedBy))
}

// PublicEQ applies the EQ predicate on the "public" field.
func PublicEQ(v bool) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldPublic, v))
}

// PublicNEQ applies the NEQ predicate on the "public" field.
func PublicNEQ(v bool) predicate.Env {
	return predicate.Env(sql.FieldNEQ(FieldPublic, v))
}

// BuildCountEQ applies the EQ predicate on the "build_count" field.
func BuildCountEQ(v int32) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldBuildCount, v))
}

// BuildCountNEQ applies the NEQ predicate on the "build_count" field.
func BuildCountNEQ(v int32) predicate.Env {
	return predicate.Env(sql.FieldNEQ(FieldBuildCount, v))
}

// BuildCountIn applies the In predicate on the "build_count" field.
func BuildCountIn(vs ...int32) predicate.Env {
	return predicate.Env(sql.FieldIn(FieldBuildCount, vs...))
}

// BuildCountNotIn applies the NotIn predicate on the "build_count" field.
func BuildCountNotIn(vs ...int32) predicate.Env {
	return predicate.Env(sql.FieldNotIn(FieldBuildCount, vs...))
}

// BuildCountGT applies the GT predicate on the "build_count" field.
func BuildCountGT(v int32) predicate.Env {
	return predicate.Env(sql.FieldGT(FieldBuildCount, v))
}

// BuildCountGTE applies the GTE predicate on the "build_count" field.
func BuildCountGTE(v int32) predicate.Env {
	return predicate.Env(sql.FieldGTE(FieldBuildCount, v))
}

// BuildCountLT applies the LT predicate on the "build_count" field.
func BuildCountLT(v int32) predicate.Env {
	return predicate.Env(sql.FieldLT(FieldBuildCount, v))
}

// BuildCountLTE applies the LTE predicate on the "build_count" field.
func BuildCountLTE(v int32) predicate.Env {
	return predicate.Env(sql.FieldLTE(FieldBuildCount, v))
}

// SpawnCountEQ applies the EQ predicate on the "spawn_count" field.
func SpawnCountEQ(v int64) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldSpawnCount, v))
}

// SpawnCountNEQ applies the NEQ predicate on the "spawn_count" field.
func SpawnCountNEQ(v int64) predicate.Env {
	return predicate.Env(sql.FieldNEQ(FieldSpawnCount, v))
}

// SpawnCountIn applies the In predicate on the "spawn_count" field.
func SpawnCountIn(vs ...int64) predicate.Env {
	return predicate.Env(sql.FieldIn(FieldSpawnCount, vs...))
}

// SpawnCountNotIn applies the NotIn predicate on the "spawn_count" field.
func SpawnCountNotIn(vs ...int64) predicate.Env {
	return predicate.Env(sql.FieldNotIn(FieldSpawnCount, vs...))
}

// SpawnCountGT applies the GT predicate on the "spawn_count" field.
func SpawnCountGT(v int64) predicate.Env {
	return predicate.Env(sql.FieldGT(FieldSpawnCount, v))
}

// SpawnCountGTE applies the GTE predicate on the "spawn_count" field.
func SpawnCountGTE(v int64) predicate.Env {
	return predicate.Env(sql.FieldGTE(FieldSpawnCount, v))
}

// SpawnCountLT applies the LT predicate on the "spawn_count" field.
func SpawnCountLT(v int64) predicate.Env {
	return predicate.Env(sql.FieldLT(FieldSpawnCount, v))
}

// SpawnCountLTE applies the LTE predicate on the "spawn_count" field.
func SpawnCountLTE(v int64) predicate.Env {
	return predicate.Env(sql.FieldLTE(FieldSpawnCount, v))
}

// LastSpawnedAtEQ applies the EQ predicate on the "last_spawned_at" field.
func LastSpawnedAtEQ(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldEQ(FieldLastSpawnedAt, v))
}

// LastSpawnedAtNEQ applies the NEQ predicate on the "last_spawned_at" field.
func LastSpawnedAtNEQ(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldNEQ(FieldLastSpawnedAt, v))
}

// LastSpawnedAtIn applies the In predicate on the "last_spawned_at" field.
func LastSpawnedAtIn(vs ...time.Time) predicate.Env {
	return predicate.Env(sql.FieldIn(FieldLastSpawnedAt, vs...))
}

// LastSpawnedAtNotIn applies the NotIn predicate on the "last_spawned_at" field.
func LastSpawnedAtNotIn(vs ...time.Time) predicate.Env {
	return predicate.Env(sql.FieldNotIn(FieldLastSpawnedAt, vs...))
}

// LastSpawnedAtGT applies the GT predicate on the "last_spawned_at" field.
func LastSpawnedAtGT(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldGT(FieldLastSpawnedAt, v))
}

// LastSpawnedAtGTE applies the GTE predicate on the "last_spawned_at" field.
func LastSpawnedAtGTE(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldGTE(FieldLastSpawnedAt, v))
}

// LastSpawnedAtLT applies the LT predicate on the "last_spawned_at" field.
func LastSpawnedAtLT(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldLT(FieldLastSpawnedAt, v))
}

// LastSpawnedAtLTE applies the LTE predicate on the "last_spawned_at" field.
func LastSpawnedAtLTE(v time.Time) predicate.Env {
	return predicate.Env(sql.FieldLTE(FieldLastSpawnedAt, v))
}

// LastSpawnedAtIsNil applies the IsNil predicate on the "last_spawned_at" field.
func LastSpawnedAtIsNil() predicate.Env {
	return predicate.Env(sql.FieldIsNull(FieldLastSpawnedAt))
}

// LastSpawnedAtNotNil applies the NotNil predicate on the "last_spawned_at" field.
func LastSpawnedAtNotNil() predicate.Env {
	return predicate.Env(sql.FieldNotNull(FieldLastSpawnedAt))
}

// HasTeam applies the HasEdge predicate on the "team" edge.
func HasTeam() predicate.Env {
	return predicate.Env(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, TeamTable, TeamColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.Env
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasTeamWith applies the HasEdge predicate on the "team" edge with a given conditions (other predicates).
func HasTeamWith(preds ...predicate.Team) predicate.Env {
	return predicate.Env(func(s *sql.Selector) {
		step := newTeamStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.Env
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasCreator applies the HasEdge predicate on the "creator" edge.
func HasCreator() predicate.Env {
	return predicate.Env(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, CreatorTable, CreatorColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.Env
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasCreatorWith applies the HasEdge predicate on the "creator" edge with a given conditions (other predicates).
func HasCreatorWith(preds ...predicate.User) predicate.Env {
	return predicate.Env(func(s *sql.Selector) {
		step := newCreatorStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.Env
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasEnvAliases applies the HasEdge predicate on the "env_aliases" edge.
func HasEnvAliases() predicate.Env {
	return predicate.Env(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, EnvAliasesTable, EnvAliasesColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.EnvAlias
		step.Edge.Schema = schemaConfig.EnvAlias
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasEnvAliasesWith applies the HasEdge predicate on the "env_aliases" edge with a given conditions (other predicates).
func HasEnvAliasesWith(preds ...predicate.EnvAlias) predicate.Env {
	return predicate.Env(func(s *sql.Selector) {
		step := newEnvAliasesStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.EnvAlias
		step.Edge.Schema = schemaConfig.EnvAlias
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasBuilds applies the HasEdge predicate on the "builds" edge.
func HasBuilds() predicate.Env {
	return predicate.Env(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, BuildsTable, BuildsColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.EnvBuild
		step.Edge.Schema = schemaConfig.EnvBuild
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasBuildsWith applies the HasEdge predicate on the "builds" edge with a given conditions (other predicates).
func HasBuildsWith(preds ...predicate.EnvBuild) predicate.Env {
	return predicate.Env(func(s *sql.Selector) {
		step := newBuildsStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.EnvBuild
		step.Edge.Schema = schemaConfig.EnvBuild
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasSnapshots applies the HasEdge predicate on the "snapshots" edge.
func HasSnapshots() predicate.Env {
	return predicate.Env(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, SnapshotsTable, SnapshotsColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Snapshot
		step.Edge.Schema = schemaConfig.Snapshot
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasSnapshotsWith applies the HasEdge predicate on the "snapshots" edge with a given conditions (other predicates).
func HasSnapshotsWith(preds ...predicate.Snapshot) predicate.Env {
	return predicate.Env(func(s *sql.Selector) {
		step := newSnapshotsStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Snapshot
		step.Edge.Schema = schemaConfig.Snapshot
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Env) predicate.Env {
	return predicate.Env(sql.AndPredicates(predicates...))
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Env) predicate.Env {
	return predicate.Env(sql.OrPredicates(predicates...))
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Env) predicate.Env {
	return predicate.Env(sql.NotPredicates(p))
}



================================================
File: models/envalias/envalias.go
================================================
// Code generated by ent, DO NOT EDIT.

package envalias

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the envalias type in the database.
	Label = "env_alias"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "alias"
	// FieldEnvID holds the string denoting the env_id field in the database.
	FieldEnvID = "env_id"
	// FieldIsRenamable holds the string denoting the is_renamable field in the database.
	FieldIsRenamable = "is_renamable"
	// EdgeEnv holds the string denoting the env edge name in mutations.
	EdgeEnv = "env"
	// EnvFieldID holds the string denoting the ID field of the Env.
	EnvFieldID = "id"
	// Table holds the table name of the envalias in the database.
	Table = "env_aliases"
	// EnvTable is the table that holds the env relation/edge.
	EnvTable = "env_aliases"
	// EnvInverseTable is the table name for the Env entity.
	// It exists in this package in order to avoid circular dependency with the "env" package.
	EnvInverseTable = "envs"
	// EnvColumn is the table column denoting the env relation/edge.
	EnvColumn = "env_id"
)

// Columns holds all SQL columns for envalias fields.
var Columns = []string{
	FieldID,
	FieldEnvID,
	FieldIsRenamable,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultIsRenamable holds the default value on creation for the "is_renamable" field.
	DefaultIsRenamable bool
)

// OrderOption defines the ordering options for the EnvAlias queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByEnvID orders the results by the env_id field.
func ByEnvID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEnvID, opts...).ToFunc()
}

// ByIsRenamable orders the results by the is_renamable field.
func ByIsRenamable(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIsRenamable, opts...).ToFunc()
}

// ByEnvField orders the results by env field.
func ByEnvField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newEnvStep(), sql.OrderByField(field, opts...))
	}
}
func newEnvStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(EnvInverseTable, EnvFieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, EnvTable, EnvColumn),
	)
}



================================================
File: models/envalias/where.go
================================================
// Code generated by ent, DO NOT EDIT.

package envalias

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
)

// ID filters vertices based on their ID field.
func ID(id string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldLTE(FieldID, id))
}

// IDEqualFold applies the EqualFold predicate on the ID field.
func IDEqualFold(id string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldEqualFold(FieldID, id))
}

// IDContainsFold applies the ContainsFold predicate on the ID field.
func IDContainsFold(id string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldContainsFold(FieldID, id))
}

// EnvID applies equality check predicate on the "env_id" field. It's identical to EnvIDEQ.
func EnvID(v string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldEQ(FieldEnvID, v))
}

// IsRenamable applies equality check predicate on the "is_renamable" field. It's identical to IsRenamableEQ.
func IsRenamable(v bool) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldEQ(FieldIsRenamable, v))
}

// EnvIDEQ applies the EQ predicate on the "env_id" field.
func EnvIDEQ(v string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldEQ(FieldEnvID, v))
}

// EnvIDNEQ applies the NEQ predicate on the "env_id" field.
func EnvIDNEQ(v string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldNEQ(FieldEnvID, v))
}

// EnvIDIn applies the In predicate on the "env_id" field.
func EnvIDIn(vs ...string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldIn(FieldEnvID, vs...))
}

// EnvIDNotIn applies the NotIn predicate on the "env_id" field.
func EnvIDNotIn(vs ...string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldNotIn(FieldEnvID, vs...))
}

// EnvIDGT applies the GT predicate on the "env_id" field.
func EnvIDGT(v string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldGT(FieldEnvID, v))
}

// EnvIDGTE applies the GTE predicate on the "env_id" field.
func EnvIDGTE(v string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldGTE(FieldEnvID, v))
}

// EnvIDLT applies the LT predicate on the "env_id" field.
func EnvIDLT(v string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldLT(FieldEnvID, v))
}

// EnvIDLTE applies the LTE predicate on the "env_id" field.
func EnvIDLTE(v string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldLTE(FieldEnvID, v))
}

// EnvIDContains applies the Contains predicate on the "env_id" field.
func EnvIDContains(v string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldContains(FieldEnvID, v))
}

// EnvIDHasPrefix applies the HasPrefix predicate on the "env_id" field.
func EnvIDHasPrefix(v string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldHasPrefix(FieldEnvID, v))
}

// EnvIDHasSuffix applies the HasSuffix predicate on the "env_id" field.
func EnvIDHasSuffix(v string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldHasSuffix(FieldEnvID, v))
}

// EnvIDEqualFold applies the EqualFold predicate on the "env_id" field.
func EnvIDEqualFold(v string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldEqualFold(FieldEnvID, v))
}

// EnvIDContainsFold applies the ContainsFold predicate on the "env_id" field.
func EnvIDContainsFold(v string) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldContainsFold(FieldEnvID, v))
}

// IsRenamableEQ applies the EQ predicate on the "is_renamable" field.
func IsRenamableEQ(v bool) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldEQ(FieldIsRenamable, v))
}

// IsRenamableNEQ applies the NEQ predicate on the "is_renamable" field.
func IsRenamableNEQ(v bool) predicate.EnvAlias {
	return predicate.EnvAlias(sql.FieldNEQ(FieldIsRenamable, v))
}

// HasEnv applies the HasEdge predicate on the "env" edge.
func HasEnv() predicate.EnvAlias {
	return predicate.EnvAlias(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, EnvTable, EnvColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.EnvAlias
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasEnvWith applies the HasEdge predicate on the "env" edge with a given conditions (other predicates).
func HasEnvWith(preds ...predicate.Env) predicate.EnvAlias {
	return predicate.EnvAlias(func(s *sql.Selector) {
		step := newEnvStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.EnvAlias
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.EnvAlias) predicate.EnvAlias {
	return predicate.EnvAlias(sql.AndPredicates(predicates...))
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.EnvAlias) predicate.EnvAlias {
	return predicate.EnvAlias(sql.OrPredicates(predicates...))
}

// Not applies the not operator on the given predicate.
func Not(p predicate.EnvAlias) predicate.EnvAlias {
	return predicate.EnvAlias(sql.NotPredicates(p))
}



================================================
File: models/envbuild/envbuild.go
================================================
// Code generated by ent, DO NOT EDIT.

package envbuild

import (
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the envbuild type in the database.
	Label = "env_build"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// FieldFinishedAt holds the string denoting the finished_at field in the database.
	FieldFinishedAt = "finished_at"
	// FieldEnvID holds the string denoting the env_id field in the database.
	FieldEnvID = "env_id"
	// FieldStatus holds the string denoting the status field in the database.
	FieldStatus = "status"
	// FieldDockerfile holds the string denoting the dockerfile field in the database.
	FieldDockerfile = "dockerfile"
	// FieldStartCmd holds the string denoting the start_cmd field in the database.
	FieldStartCmd = "start_cmd"
	// FieldVcpu holds the string denoting the vcpu field in the database.
	FieldVcpu = "vcpu"
	// FieldRAMMB holds the string denoting the ram_mb field in the database.
	FieldRAMMB = "ram_mb"
	// FieldFreeDiskSizeMB holds the string denoting the free_disk_size_mb field in the database.
	FieldFreeDiskSizeMB = "free_disk_size_mb"
	// FieldTotalDiskSizeMB holds the string denoting the total_disk_size_mb field in the database.
	FieldTotalDiskSizeMB = "total_disk_size_mb"
	// FieldKernelVersion holds the string denoting the kernel_version field in the database.
	FieldKernelVersion = "kernel_version"
	// FieldFirecrackerVersion holds the string denoting the firecracker_version field in the database.
	FieldFirecrackerVersion = "firecracker_version"
	// FieldEnvdVersion holds the string denoting the envd_version field in the database.
	FieldEnvdVersion = "envd_version"
	// EdgeEnv holds the string denoting the env edge name in mutations.
	EdgeEnv = "env"
	// Table holds the table name of the envbuild in the database.
	Table = "env_builds"
	// EnvTable is the table that holds the env relation/edge.
	EnvTable = "env_builds"
	// EnvInverseTable is the table name for the Env entity.
	// It exists in this package in order to avoid circular dependency with the "env" package.
	EnvInverseTable = "envs"
	// EnvColumn is the table column denoting the env relation/edge.
	EnvColumn = "env_id"
)

// Columns holds all SQL columns for envbuild fields.
var Columns = []string{
	FieldID,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldFinishedAt,
	FieldEnvID,
	FieldStatus,
	FieldDockerfile,
	FieldStartCmd,
	FieldVcpu,
	FieldRAMMB,
	FieldFreeDiskSizeMB,
	FieldTotalDiskSizeMB,
	FieldKernelVersion,
	FieldFirecrackerVersion,
	FieldEnvdVersion,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
	// DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
	DefaultUpdatedAt func() time.Time
	// DefaultKernelVersion holds the default value on creation for the "kernel_version" field.
	DefaultKernelVersion string
	// DefaultFirecrackerVersion holds the default value on creation for the "firecracker_version" field.
	DefaultFirecrackerVersion string
)

// Status defines the type for the "status" enum field.
type Status string

// StatusWaiting is the default value of the Status enum.
const DefaultStatus = StatusWaiting

// Status values.
const (
	StatusWaiting  Status = "waiting"
	StatusBuilding Status = "building"
	StatusFailed   Status = "failed"
	StatusSuccess  Status = "success"
	StatusUploaded Status = "uploaded"
)

func (s Status) String() string {
	return string(s)
}

// StatusValidator is a validator for the "status" field enum values. It is called by the builders before save.
func StatusValidator(s Status) error {
	switch s {
	case StatusWaiting, StatusBuilding, StatusFailed, StatusSuccess, StatusUploaded:
		return nil
	default:
		return fmt.Errorf("envbuild: invalid enum value for status field: %q", s)
	}
}

// OrderOption defines the ordering options for the EnvBuild queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByFinishedAt orders the results by the finished_at field.
func ByFinishedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldFinishedAt, opts...).ToFunc()
}

// ByEnvID orders the results by the env_id field.
func ByEnvID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEnvID, opts...).ToFunc()
}

// ByStatus orders the results by the status field.
func ByStatus(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStatus, opts...).ToFunc()
}

// ByDockerfile orders the results by the dockerfile field.
func ByDockerfile(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDockerfile, opts...).ToFunc()
}

// ByStartCmd orders the results by the start_cmd field.
func ByStartCmd(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStartCmd, opts...).ToFunc()
}

// ByVcpu orders the results by the vcpu field.
func ByVcpu(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldVcpu, opts...).ToFunc()
}

// ByRAMMB orders the results by the ram_mb field.
func ByRAMMB(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldRAMMB, opts...).ToFunc()
}

// ByFreeDiskSizeMB orders the results by the free_disk_size_mb field.
func ByFreeDiskSizeMB(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldFreeDiskSizeMB, opts...).ToFunc()
}

// ByTotalDiskSizeMB orders the results by the total_disk_size_mb field.
func ByTotalDiskSizeMB(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTotalDiskSizeMB, opts...).ToFunc()
}

// ByKernelVersion orders the results by the kernel_version field.
func ByKernelVersion(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldKernelVersion, opts...).ToFunc()
}

// ByFirecrackerVersion orders the results by the firecracker_version field.
func ByFirecrackerVersion(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldFirecrackerVersion, opts...).ToFunc()
}

// ByEnvdVersion orders the results by the envd_version field.
func ByEnvdVersion(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEnvdVersion, opts...).ToFunc()
}

// ByEnvField orders the results by env field.
func ByEnvField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newEnvStep(), sql.OrderByField(field, opts...))
	}
}
func newEnvStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(EnvInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, EnvTable, EnvColumn),
	)
}



================================================
File: models/envbuild/where.go
================================================
// Code generated by ent, DO NOT EDIT.

package envbuild

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/google/uuid"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLTE(FieldID, id))
}

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldCreatedAt, v))
}

// UpdatedAt applies equality check predicate on the "updated_at" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldUpdatedAt, v))
}

// FinishedAt applies equality check predicate on the "finished_at" field. It's identical to FinishedAtEQ.
func FinishedAt(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldFinishedAt, v))
}

// EnvID applies equality check predicate on the "env_id" field. It's identical to EnvIDEQ.
func EnvID(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldEnvID, v))
}

// Dockerfile applies equality check predicate on the "dockerfile" field. It's identical to DockerfileEQ.
func Dockerfile(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldDockerfile, v))
}

// StartCmd applies equality check predicate on the "start_cmd" field. It's identical to StartCmdEQ.
func StartCmd(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldStartCmd, v))
}

// Vcpu applies equality check predicate on the "vcpu" field. It's identical to VcpuEQ.
func Vcpu(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldVcpu, v))
}

// RAMMB applies equality check predicate on the "ram_mb" field. It's identical to RAMMBEQ.
func RAMMB(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldRAMMB, v))
}

// FreeDiskSizeMB applies equality check predicate on the "free_disk_size_mb" field. It's identical to FreeDiskSizeMBEQ.
func FreeDiskSizeMB(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldFreeDiskSizeMB, v))
}

// TotalDiskSizeMB applies equality check predicate on the "total_disk_size_mb" field. It's identical to TotalDiskSizeMBEQ.
func TotalDiskSizeMB(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldTotalDiskSizeMB, v))
}

// KernelVersion applies equality check predicate on the "kernel_version" field. It's identical to KernelVersionEQ.
func KernelVersion(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldKernelVersion, v))
}

// FirecrackerVersion applies equality check predicate on the "firecracker_version" field. It's identical to FirecrackerVersionEQ.
func FirecrackerVersion(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldFirecrackerVersion, v))
}

// EnvdVersion applies equality check predicate on the "envd_version" field. It's identical to EnvdVersionEQ.
func EnvdVersion(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldEnvdVersion, v))
}

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldCreatedAt, v))
}

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNEQ(FieldCreatedAt, v))
}

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIn(FieldCreatedAt, vs...))
}

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotIn(FieldCreatedAt, vs...))
}

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGT(FieldCreatedAt, v))
}

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGTE(FieldCreatedAt, v))
}

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLT(FieldCreatedAt, v))
}

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLTE(FieldCreatedAt, v))
}

// UpdatedAtEQ applies the EQ predicate on the "updated_at" field.
func UpdatedAtEQ(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldUpdatedAt, v))
}

// UpdatedAtNEQ applies the NEQ predicate on the "updated_at" field.
func UpdatedAtNEQ(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNEQ(FieldUpdatedAt, v))
}

// UpdatedAtIn applies the In predicate on the "updated_at" field.
func UpdatedAtIn(vs ...time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIn(FieldUpdatedAt, vs...))
}

// UpdatedAtNotIn applies the NotIn predicate on the "updated_at" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotIn(FieldUpdatedAt, vs...))
}

// UpdatedAtGT applies the GT predicate on the "updated_at" field.
func UpdatedAtGT(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGT(FieldUpdatedAt, v))
}

// UpdatedAtGTE applies the GTE predicate on the "updated_at" field.
func UpdatedAtGTE(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGTE(FieldUpdatedAt, v))
}

// UpdatedAtLT applies the LT predicate on the "updated_at" field.
func UpdatedAtLT(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLT(FieldUpdatedAt, v))
}

// UpdatedAtLTE applies the LTE predicate on the "updated_at" field.
func UpdatedAtLTE(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLTE(FieldUpdatedAt, v))
}

// FinishedAtEQ applies the EQ predicate on the "finished_at" field.
func FinishedAtEQ(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldFinishedAt, v))
}

// FinishedAtNEQ applies the NEQ predicate on the "finished_at" field.
func FinishedAtNEQ(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNEQ(FieldFinishedAt, v))
}

// FinishedAtIn applies the In predicate on the "finished_at" field.
func FinishedAtIn(vs ...time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIn(FieldFinishedAt, vs...))
}

// FinishedAtNotIn applies the NotIn predicate on the "finished_at" field.
func FinishedAtNotIn(vs ...time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotIn(FieldFinishedAt, vs...))
}

// FinishedAtGT applies the GT predicate on the "finished_at" field.
func FinishedAtGT(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGT(FieldFinishedAt, v))
}

// FinishedAtGTE applies the GTE predicate on the "finished_at" field.
func FinishedAtGTE(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGTE(FieldFinishedAt, v))
}

// FinishedAtLT applies the LT predicate on the "finished_at" field.
func FinishedAtLT(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLT(FieldFinishedAt, v))
}

// FinishedAtLTE applies the LTE predicate on the "finished_at" field.
func FinishedAtLTE(v time.Time) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLTE(FieldFinishedAt, v))
}

// FinishedAtIsNil applies the IsNil predicate on the "finished_at" field.
func FinishedAtIsNil() predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIsNull(FieldFinishedAt))
}

// FinishedAtNotNil applies the NotNil predicate on the "finished_at" field.
func FinishedAtNotNil() predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotNull(FieldFinishedAt))
}

// EnvIDEQ applies the EQ predicate on the "env_id" field.
func EnvIDEQ(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldEnvID, v))
}

// EnvIDNEQ applies the NEQ predicate on the "env_id" field.
func EnvIDNEQ(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNEQ(FieldEnvID, v))
}

// EnvIDIn applies the In predicate on the "env_id" field.
func EnvIDIn(vs ...string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIn(FieldEnvID, vs...))
}

// EnvIDNotIn applies the NotIn predicate on the "env_id" field.
func EnvIDNotIn(vs ...string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotIn(FieldEnvID, vs...))
}

// EnvIDGT applies the GT predicate on the "env_id" field.
func EnvIDGT(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGT(FieldEnvID, v))
}

// EnvIDGTE applies the GTE predicate on the "env_id" field.
func EnvIDGTE(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGTE(FieldEnvID, v))
}

// EnvIDLT applies the LT predicate on the "env_id" field.
func EnvIDLT(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLT(FieldEnvID, v))
}

// EnvIDLTE applies the LTE predicate on the "env_id" field.
func EnvIDLTE(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLTE(FieldEnvID, v))
}

// EnvIDContains applies the Contains predicate on the "env_id" field.
func EnvIDContains(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldContains(FieldEnvID, v))
}

// EnvIDHasPrefix applies the HasPrefix predicate on the "env_id" field.
func EnvIDHasPrefix(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldHasPrefix(FieldEnvID, v))
}

// EnvIDHasSuffix applies the HasSuffix predicate on the "env_id" field.
func EnvIDHasSuffix(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldHasSuffix(FieldEnvID, v))
}

// EnvIDIsNil applies the IsNil predicate on the "env_id" field.
func EnvIDIsNil() predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIsNull(FieldEnvID))
}

// EnvIDNotNil applies the NotNil predicate on the "env_id" field.
func EnvIDNotNil() predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotNull(FieldEnvID))
}

// EnvIDEqualFold applies the EqualFold predicate on the "env_id" field.
func EnvIDEqualFold(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEqualFold(FieldEnvID, v))
}

// EnvIDContainsFold applies the ContainsFold predicate on the "env_id" field.
func EnvIDContainsFold(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldContainsFold(FieldEnvID, v))
}

// StatusEQ applies the EQ predicate on the "status" field.
func StatusEQ(v Status) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldStatus, v))
}

// StatusNEQ applies the NEQ predicate on the "status" field.
func StatusNEQ(v Status) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNEQ(FieldStatus, v))
}

// StatusIn applies the In predicate on the "status" field.
func StatusIn(vs ...Status) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIn(FieldStatus, vs...))
}

// StatusNotIn applies the NotIn predicate on the "status" field.
func StatusNotIn(vs ...Status) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotIn(FieldStatus, vs...))
}

// DockerfileEQ applies the EQ predicate on the "dockerfile" field.
func DockerfileEQ(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldDockerfile, v))
}

// DockerfileNEQ applies the NEQ predicate on the "dockerfile" field.
func DockerfileNEQ(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNEQ(FieldDockerfile, v))
}

// DockerfileIn applies the In predicate on the "dockerfile" field.
func DockerfileIn(vs ...string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIn(FieldDockerfile, vs...))
}

// DockerfileNotIn applies the NotIn predicate on the "dockerfile" field.
func DockerfileNotIn(vs ...string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotIn(FieldDockerfile, vs...))
}

// DockerfileGT applies the GT predicate on the "dockerfile" field.
func DockerfileGT(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGT(FieldDockerfile, v))
}

// DockerfileGTE applies the GTE predicate on the "dockerfile" field.
func DockerfileGTE(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGTE(FieldDockerfile, v))
}

// DockerfileLT applies the LT predicate on the "dockerfile" field.
func DockerfileLT(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLT(FieldDockerfile, v))
}

// DockerfileLTE applies the LTE predicate on the "dockerfile" field.
func DockerfileLTE(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLTE(FieldDockerfile, v))
}

// DockerfileContains applies the Contains predicate on the "dockerfile" field.
func DockerfileContains(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldContains(FieldDockerfile, v))
}

// DockerfileHasPrefix applies the HasPrefix predicate on the "dockerfile" field.
func DockerfileHasPrefix(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldHasPrefix(FieldDockerfile, v))
}

// DockerfileHasSuffix applies the HasSuffix predicate on the "dockerfile" field.
func DockerfileHasSuffix(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldHasSuffix(FieldDockerfile, v))
}

// DockerfileIsNil applies the IsNil predicate on the "dockerfile" field.
func DockerfileIsNil() predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIsNull(FieldDockerfile))
}

// DockerfileNotNil applies the NotNil predicate on the "dockerfile" field.
func DockerfileNotNil() predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotNull(FieldDockerfile))
}

// DockerfileEqualFold applies the EqualFold predicate on the "dockerfile" field.
func DockerfileEqualFold(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEqualFold(FieldDockerfile, v))
}

// DockerfileContainsFold applies the ContainsFold predicate on the "dockerfile" field.
func DockerfileContainsFold(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldContainsFold(FieldDockerfile, v))
}

// StartCmdEQ applies the EQ predicate on the "start_cmd" field.
func StartCmdEQ(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldStartCmd, v))
}

// StartCmdNEQ applies the NEQ predicate on the "start_cmd" field.
func StartCmdNEQ(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNEQ(FieldStartCmd, v))
}

// StartCmdIn applies the In predicate on the "start_cmd" field.
func StartCmdIn(vs ...string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIn(FieldStartCmd, vs...))
}

// StartCmdNotIn applies the NotIn predicate on the "start_cmd" field.
func StartCmdNotIn(vs ...string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotIn(FieldStartCmd, vs...))
}

// StartCmdGT applies the GT predicate on the "start_cmd" field.
func StartCmdGT(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGT(FieldStartCmd, v))
}

// StartCmdGTE applies the GTE predicate on the "start_cmd" field.
func StartCmdGTE(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGTE(FieldStartCmd, v))
}

// StartCmdLT applies the LT predicate on the "start_cmd" field.
func StartCmdLT(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLT(FieldStartCmd, v))
}

// StartCmdLTE applies the LTE predicate on the "start_cmd" field.
func StartCmdLTE(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLTE(FieldStartCmd, v))
}

// StartCmdContains applies the Contains predicate on the "start_cmd" field.
func StartCmdContains(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldContains(FieldStartCmd, v))
}

// StartCmdHasPrefix applies the HasPrefix predicate on the "start_cmd" field.
func StartCmdHasPrefix(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldHasPrefix(FieldStartCmd, v))
}

// StartCmdHasSuffix applies the HasSuffix predicate on the "start_cmd" field.
func StartCmdHasSuffix(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldHasSuffix(FieldStartCmd, v))
}

// StartCmdIsNil applies the IsNil predicate on the "start_cmd" field.
func StartCmdIsNil() predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIsNull(FieldStartCmd))
}

// StartCmdNotNil applies the NotNil predicate on the "start_cmd" field.
func StartCmdNotNil() predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotNull(FieldStartCmd))
}

// StartCmdEqualFold applies the EqualFold predicate on the "start_cmd" field.
func StartCmdEqualFold(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEqualFold(FieldStartCmd, v))
}

// StartCmdContainsFold applies the ContainsFold predicate on the "start_cmd" field.
func StartCmdContainsFold(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldContainsFold(FieldStartCmd, v))
}

// VcpuEQ applies the EQ predicate on the "vcpu" field.
func VcpuEQ(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldVcpu, v))
}

// VcpuNEQ applies the NEQ predicate on the "vcpu" field.
func VcpuNEQ(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNEQ(FieldVcpu, v))
}

// VcpuIn applies the In predicate on the "vcpu" field.
func VcpuIn(vs ...int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIn(FieldVcpu, vs...))
}

// VcpuNotIn applies the NotIn predicate on the "vcpu" field.
func VcpuNotIn(vs ...int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotIn(FieldVcpu, vs...))
}

// VcpuGT applies the GT predicate on the "vcpu" field.
func VcpuGT(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGT(FieldVcpu, v))
}

// VcpuGTE applies the GTE predicate on the "vcpu" field.
func VcpuGTE(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGTE(FieldVcpu, v))
}

// VcpuLT applies the LT predicate on the "vcpu" field.
func VcpuLT(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLT(FieldVcpu, v))
}

// VcpuLTE applies the LTE predicate on the "vcpu" field.
func VcpuLTE(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLTE(FieldVcpu, v))
}

// RAMMBEQ applies the EQ predicate on the "ram_mb" field.
func RAMMBEQ(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldRAMMB, v))
}

// RAMMBNEQ applies the NEQ predicate on the "ram_mb" field.
func RAMMBNEQ(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNEQ(FieldRAMMB, v))
}

// RAMMBIn applies the In predicate on the "ram_mb" field.
func RAMMBIn(vs ...int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIn(FieldRAMMB, vs...))
}

// RAMMBNotIn applies the NotIn predicate on the "ram_mb" field.
func RAMMBNotIn(vs ...int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotIn(FieldRAMMB, vs...))
}

// RAMMBGT applies the GT predicate on the "ram_mb" field.
func RAMMBGT(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGT(FieldRAMMB, v))
}

// RAMMBGTE applies the GTE predicate on the "ram_mb" field.
func RAMMBGTE(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGTE(FieldRAMMB, v))
}

// RAMMBLT applies the LT predicate on the "ram_mb" field.
func RAMMBLT(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLT(FieldRAMMB, v))
}

// RAMMBLTE applies the LTE predicate on the "ram_mb" field.
func RAMMBLTE(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLTE(FieldRAMMB, v))
}

// FreeDiskSizeMBEQ applies the EQ predicate on the "free_disk_size_mb" field.
func FreeDiskSizeMBEQ(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldFreeDiskSizeMB, v))
}

// FreeDiskSizeMBNEQ applies the NEQ predicate on the "free_disk_size_mb" field.
func FreeDiskSizeMBNEQ(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNEQ(FieldFreeDiskSizeMB, v))
}

// FreeDiskSizeMBIn applies the In predicate on the "free_disk_size_mb" field.
func FreeDiskSizeMBIn(vs ...int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIn(FieldFreeDiskSizeMB, vs...))
}

// FreeDiskSizeMBNotIn applies the NotIn predicate on the "free_disk_size_mb" field.
func FreeDiskSizeMBNotIn(vs ...int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotIn(FieldFreeDiskSizeMB, vs...))
}

// FreeDiskSizeMBGT applies the GT predicate on the "free_disk_size_mb" field.
func FreeDiskSizeMBGT(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGT(FieldFreeDiskSizeMB, v))
}

// FreeDiskSizeMBGTE applies the GTE predicate on the "free_disk_size_mb" field.
func FreeDiskSizeMBGTE(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGTE(FieldFreeDiskSizeMB, v))
}

// FreeDiskSizeMBLT applies the LT predicate on the "free_disk_size_mb" field.
func FreeDiskSizeMBLT(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLT(FieldFreeDiskSizeMB, v))
}

// FreeDiskSizeMBLTE applies the LTE predicate on the "free_disk_size_mb" field.
func FreeDiskSizeMBLTE(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLTE(FieldFreeDiskSizeMB, v))
}

// TotalDiskSizeMBEQ applies the EQ predicate on the "total_disk_size_mb" field.
func TotalDiskSizeMBEQ(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldTotalDiskSizeMB, v))
}

// TotalDiskSizeMBNEQ applies the NEQ predicate on the "total_disk_size_mb" field.
func TotalDiskSizeMBNEQ(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNEQ(FieldTotalDiskSizeMB, v))
}

// TotalDiskSizeMBIn applies the In predicate on the "total_disk_size_mb" field.
func TotalDiskSizeMBIn(vs ...int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIn(FieldTotalDiskSizeMB, vs...))
}

// TotalDiskSizeMBNotIn applies the NotIn predicate on the "total_disk_size_mb" field.
func TotalDiskSizeMBNotIn(vs ...int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotIn(FieldTotalDiskSizeMB, vs...))
}

// TotalDiskSizeMBGT applies the GT predicate on the "total_disk_size_mb" field.
func TotalDiskSizeMBGT(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGT(FieldTotalDiskSizeMB, v))
}

// TotalDiskSizeMBGTE applies the GTE predicate on the "total_disk_size_mb" field.
func TotalDiskSizeMBGTE(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGTE(FieldTotalDiskSizeMB, v))
}

// TotalDiskSizeMBLT applies the LT predicate on the "total_disk_size_mb" field.
func TotalDiskSizeMBLT(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLT(FieldTotalDiskSizeMB, v))
}

// TotalDiskSizeMBLTE applies the LTE predicate on the "total_disk_size_mb" field.
func TotalDiskSizeMBLTE(v int64) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLTE(FieldTotalDiskSizeMB, v))
}

// TotalDiskSizeMBIsNil applies the IsNil predicate on the "total_disk_size_mb" field.
func TotalDiskSizeMBIsNil() predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIsNull(FieldTotalDiskSizeMB))
}

// TotalDiskSizeMBNotNil applies the NotNil predicate on the "total_disk_size_mb" field.
func TotalDiskSizeMBNotNil() predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotNull(FieldTotalDiskSizeMB))
}

// KernelVersionEQ applies the EQ predicate on the "kernel_version" field.
func KernelVersionEQ(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldKernelVersion, v))
}

// KernelVersionNEQ applies the NEQ predicate on the "kernel_version" field.
func KernelVersionNEQ(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNEQ(FieldKernelVersion, v))
}

// KernelVersionIn applies the In predicate on the "kernel_version" field.
func KernelVersionIn(vs ...string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIn(FieldKernelVersion, vs...))
}

// KernelVersionNotIn applies the NotIn predicate on the "kernel_version" field.
func KernelVersionNotIn(vs ...string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotIn(FieldKernelVersion, vs...))
}

// KernelVersionGT applies the GT predicate on the "kernel_version" field.
func KernelVersionGT(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGT(FieldKernelVersion, v))
}

// KernelVersionGTE applies the GTE predicate on the "kernel_version" field.
func KernelVersionGTE(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGTE(FieldKernelVersion, v))
}

// KernelVersionLT applies the LT predicate on the "kernel_version" field.
func KernelVersionLT(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLT(FieldKernelVersion, v))
}

// KernelVersionLTE applies the LTE predicate on the "kernel_version" field.
func KernelVersionLTE(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLTE(FieldKernelVersion, v))
}

// KernelVersionContains applies the Contains predicate on the "kernel_version" field.
func KernelVersionContains(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldContains(FieldKernelVersion, v))
}

// KernelVersionHasPrefix applies the HasPrefix predicate on the "kernel_version" field.
func KernelVersionHasPrefix(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldHasPrefix(FieldKernelVersion, v))
}

// KernelVersionHasSuffix applies the HasSuffix predicate on the "kernel_version" field.
func KernelVersionHasSuffix(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldHasSuffix(FieldKernelVersion, v))
}

// KernelVersionEqualFold applies the EqualFold predicate on the "kernel_version" field.
func KernelVersionEqualFold(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEqualFold(FieldKernelVersion, v))
}

// KernelVersionContainsFold applies the ContainsFold predicate on the "kernel_version" field.
func KernelVersionContainsFold(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldContainsFold(FieldKernelVersion, v))
}

// FirecrackerVersionEQ applies the EQ predicate on the "firecracker_version" field.
func FirecrackerVersionEQ(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldFirecrackerVersion, v))
}

// FirecrackerVersionNEQ applies the NEQ predicate on the "firecracker_version" field.
func FirecrackerVersionNEQ(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNEQ(FieldFirecrackerVersion, v))
}

// FirecrackerVersionIn applies the In predicate on the "firecracker_version" field.
func FirecrackerVersionIn(vs ...string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIn(FieldFirecrackerVersion, vs...))
}

// FirecrackerVersionNotIn applies the NotIn predicate on the "firecracker_version" field.
func FirecrackerVersionNotIn(vs ...string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotIn(FieldFirecrackerVersion, vs...))
}

// FirecrackerVersionGT applies the GT predicate on the "firecracker_version" field.
func FirecrackerVersionGT(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGT(FieldFirecrackerVersion, v))
}

// FirecrackerVersionGTE applies the GTE predicate on the "firecracker_version" field.
func FirecrackerVersionGTE(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGTE(FieldFirecrackerVersion, v))
}

// FirecrackerVersionLT applies the LT predicate on the "firecracker_version" field.
func FirecrackerVersionLT(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLT(FieldFirecrackerVersion, v))
}

// FirecrackerVersionLTE applies the LTE predicate on the "firecracker_version" field.
func FirecrackerVersionLTE(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLTE(FieldFirecrackerVersion, v))
}

// FirecrackerVersionContains applies the Contains predicate on the "firecracker_version" field.
func FirecrackerVersionContains(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldContains(FieldFirecrackerVersion, v))
}

// FirecrackerVersionHasPrefix applies the HasPrefix predicate on the "firecracker_version" field.
func FirecrackerVersionHasPrefix(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldHasPrefix(FieldFirecrackerVersion, v))
}

// FirecrackerVersionHasSuffix applies the HasSuffix predicate on the "firecracker_version" field.
func FirecrackerVersionHasSuffix(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldHasSuffix(FieldFirecrackerVersion, v))
}

// FirecrackerVersionEqualFold applies the EqualFold predicate on the "firecracker_version" field.
func FirecrackerVersionEqualFold(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEqualFold(FieldFirecrackerVersion, v))
}

// FirecrackerVersionContainsFold applies the ContainsFold predicate on the "firecracker_version" field.
func FirecrackerVersionContainsFold(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldContainsFold(FieldFirecrackerVersion, v))
}

// EnvdVersionEQ applies the EQ predicate on the "envd_version" field.
func EnvdVersionEQ(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEQ(FieldEnvdVersion, v))
}

// EnvdVersionNEQ applies the NEQ predicate on the "envd_version" field.
func EnvdVersionNEQ(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNEQ(FieldEnvdVersion, v))
}

// EnvdVersionIn applies the In predicate on the "envd_version" field.
func EnvdVersionIn(vs ...string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIn(FieldEnvdVersion, vs...))
}

// EnvdVersionNotIn applies the NotIn predicate on the "envd_version" field.
func EnvdVersionNotIn(vs ...string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotIn(FieldEnvdVersion, vs...))
}

// EnvdVersionGT applies the GT predicate on the "envd_version" field.
func EnvdVersionGT(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGT(FieldEnvdVersion, v))
}

// EnvdVersionGTE applies the GTE predicate on the "envd_version" field.
func EnvdVersionGTE(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldGTE(FieldEnvdVersion, v))
}

// EnvdVersionLT applies the LT predicate on the "envd_version" field.
func EnvdVersionLT(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLT(FieldEnvdVersion, v))
}

// EnvdVersionLTE applies the LTE predicate on the "envd_version" field.
func EnvdVersionLTE(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldLTE(FieldEnvdVersion, v))
}

// EnvdVersionContains applies the Contains predicate on the "envd_version" field.
func EnvdVersionContains(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldContains(FieldEnvdVersion, v))
}

// EnvdVersionHasPrefix applies the HasPrefix predicate on the "envd_version" field.
func EnvdVersionHasPrefix(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldHasPrefix(FieldEnvdVersion, v))
}

// EnvdVersionHasSuffix applies the HasSuffix predicate on the "envd_version" field.
func EnvdVersionHasSuffix(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldHasSuffix(FieldEnvdVersion, v))
}

// EnvdVersionIsNil applies the IsNil predicate on the "envd_version" field.
func EnvdVersionIsNil() predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldIsNull(FieldEnvdVersion))
}

// EnvdVersionNotNil applies the NotNil predicate on the "envd_version" field.
func EnvdVersionNotNil() predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldNotNull(FieldEnvdVersion))
}

// EnvdVersionEqualFold applies the EqualFold predicate on the "envd_version" field.
func EnvdVersionEqualFold(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldEqualFold(FieldEnvdVersion, v))
}

// EnvdVersionContainsFold applies the ContainsFold predicate on the "envd_version" field.
func EnvdVersionContainsFold(v string) predicate.EnvBuild {
	return predicate.EnvBuild(sql.FieldContainsFold(FieldEnvdVersion, v))
}

// HasEnv applies the HasEdge predicate on the "env" edge.
func HasEnv() predicate.EnvBuild {
	return predicate.EnvBuild(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, EnvTable, EnvColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.EnvBuild
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasEnvWith applies the HasEdge predicate on the "env" edge with a given conditions (other predicates).
func HasEnvWith(preds ...predicate.Env) predicate.EnvBuild {
	return predicate.EnvBuild(func(s *sql.Selector) {
		step := newEnvStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.EnvBuild
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.EnvBuild) predicate.EnvBuild {
	return predicate.EnvBuild(sql.AndPredicates(predicates...))
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.EnvBuild) predicate.EnvBuild {
	return predicate.EnvBuild(sql.OrPredicates(predicates...))
}

// Not applies the not operator on the given predicate.
func Not(p predicate.EnvBuild) predicate.EnvBuild {
	return predicate.EnvBuild(sql.NotPredicates(p))
}



================================================
File: models/hook/hook.go
================================================
// Code generated by ent, DO NOT EDIT.

package hook

import (
	"context"
	"fmt"

	"github.com/e2b-dev/infra/packages/shared/pkg/models"
)

// The AccessTokenFunc type is an adapter to allow the use of ordinary
// function as AccessToken mutator.
type AccessTokenFunc func(context.Context, *models.AccessTokenMutation) (models.Value, error)

// Mutate calls f(ctx, m).
func (f AccessTokenFunc) Mutate(ctx context.Context, m models.Mutation) (models.Value, error) {
	if mv, ok := m.(*models.AccessTokenMutation); ok {
		return f(ctx, mv)
	}
	return nil, fmt.Errorf("unexpected mutation type %T. expect *models.AccessTokenMutation", m)
}

// The EnvFunc type is an adapter to allow the use of ordinary
// function as Env mutator.
type EnvFunc func(context.Context, *models.EnvMutation) (models.Value, error)

// Mutate calls f(ctx, m).
func (f EnvFunc) Mutate(ctx context.Context, m models.Mutation) (models.Value, error) {
	if mv, ok := m.(*models.EnvMutation); ok {
		return f(ctx, mv)
	}
	return nil, fmt.Errorf("unexpected mutation type %T. expect *models.EnvMutation", m)
}

// The EnvAliasFunc type is an adapter to allow the use of ordinary
// function as EnvAlias mutator.
type EnvAliasFunc func(context.Context, *models.EnvAliasMutation) (models.Value, error)

// Mutate calls f(ctx, m).
func (f EnvAliasFunc) Mutate(ctx context.Context, m models.Mutation) (models.Value, error) {
	if mv, ok := m.(*models.EnvAliasMutation); ok {
		return f(ctx, mv)
	}
	return nil, fmt.Errorf("unexpected mutation type %T. expect *models.EnvAliasMutation", m)
}

// The EnvBuildFunc type is an adapter to allow the use of ordinary
// function as EnvBuild mutator.
type EnvBuildFunc func(context.Context, *models.EnvBuildMutation) (models.Value, error)

// Mutate calls f(ctx, m).
func (f EnvBuildFunc) Mutate(ctx context.Context, m models.Mutation) (models.Value, error) {
	if mv, ok := m.(*models.EnvBuildMutation); ok {
		return f(ctx, mv)
	}
	return nil, fmt.Errorf("unexpected mutation type %T. expect *models.EnvBuildMutation", m)
}

// The SnapshotFunc type is an adapter to allow the use of ordinary
// function as Snapshot mutator.
type SnapshotFunc func(context.Context, *models.SnapshotMutation) (models.Value, error)

// Mutate calls f(ctx, m).
func (f SnapshotFunc) Mutate(ctx context.Context, m models.Mutation) (models.Value, error) {
	if mv, ok := m.(*models.SnapshotMutation); ok {
		return f(ctx, mv)
	}
	return nil, fmt.Errorf("unexpected mutation type %T. expect *models.SnapshotMutation", m)
}

// The TeamFunc type is an adapter to allow the use of ordinary
// function as Team mutator.
type TeamFunc func(context.Context, *models.TeamMutation) (models.Value, error)

// Mutate calls f(ctx, m).
func (f TeamFunc) Mutate(ctx context.Context, m models.Mutation) (models.Value, error) {
	if mv, ok := m.(*models.TeamMutation); ok {
		return f(ctx, mv)
	}
	return nil, fmt.Errorf("unexpected mutation type %T. expect *models.TeamMutation", m)
}

// The TeamAPIKeyFunc type is an adapter to allow the use of ordinary
// function as TeamAPIKey mutator.
type TeamAPIKeyFunc func(context.Context, *models.TeamAPIKeyMutation) (models.Value, error)

// Mutate calls f(ctx, m).
func (f TeamAPIKeyFunc) Mutate(ctx context.Context, m models.Mutation) (models.Value, error) {
	if mv, ok := m.(*models.TeamAPIKeyMutation); ok {
		return f(ctx, mv)
	}
	return nil, fmt.Errorf("unexpected mutation type %T. expect *models.TeamAPIKeyMutation", m)
}

// The TierFunc type is an adapter to allow the use of ordinary
// function as Tier mutator.
type TierFunc func(context.Context, *models.TierMutation) (models.Value, error)

// Mutate calls f(ctx, m).
func (f TierFunc) Mutate(ctx context.Context, m models.Mutation) (models.Value, error) {
	if mv, ok := m.(*models.TierMutation); ok {
		return f(ctx, mv)
	}
	return nil, fmt.Errorf("unexpected mutation type %T. expect *models.TierMutation", m)
}

// The UserFunc type is an adapter to allow the use of ordinary
// function as User mutator.
type UserFunc func(context.Context, *models.UserMutation) (models.Value, error)

// Mutate calls f(ctx, m).
func (f UserFunc) Mutate(ctx context.Context, m models.Mutation) (models.Value, error) {
	if mv, ok := m.(*models.UserMutation); ok {
		return f(ctx, mv)
	}
	return nil, fmt.Errorf("unexpected mutation type %T. expect *models.UserMutation", m)
}

// The UsersTeamsFunc type is an adapter to allow the use of ordinary
// function as UsersTeams mutator.
type UsersTeamsFunc func(context.Context, *models.UsersTeamsMutation) (models.Value, error)

// Mutate calls f(ctx, m).
func (f UsersTeamsFunc) Mutate(ctx context.Context, m models.Mutation) (models.Value, error) {
	if mv, ok := m.(*models.UsersTeamsMutation); ok {
		return f(ctx, mv)
	}
	return nil, fmt.Errorf("unexpected mutation type %T. expect *models.UsersTeamsMutation", m)
}

// Condition is a hook condition function.
type Condition func(context.Context, models.Mutation) bool

// And groups conditions with the AND operator.
func And(first, second Condition, rest ...Condition) Condition {
	return func(ctx context.Context, m models.Mutation) bool {
		if !first(ctx, m) || !second(ctx, m) {
			return false
		}
		for _, cond := range rest {
			if !cond(ctx, m) {
				return false
			}
		}
		return true
	}
}

// Or groups conditions with the OR operator.
func Or(first, second Condition, rest ...Condition) Condition {
	return func(ctx context.Context, m models.Mutation) bool {
		if first(ctx, m) || second(ctx, m) {
			return true
		}
		for _, cond := range rest {
			if cond(ctx, m) {
				return true
			}
		}
		return false
	}
}

// Not negates a given condition.
func Not(cond Condition) Condition {
	return func(ctx context.Context, m models.Mutation) bool {
		return !cond(ctx, m)
	}
}

// HasOp is a condition testing mutation operation.
func HasOp(op models.Op) Condition {
	return func(_ context.Context, m models.Mutation) bool {
		return m.Op().Is(op)
	}
}

// HasAddedFields is a condition validating `.AddedField` on fields.
func HasAddedFields(field string, fields ...string) Condition {
	return func(_ context.Context, m models.Mutation) bool {
		if _, exists := m.AddedField(field); !exists {
			return false
		}
		for _, field := range fields {
			if _, exists := m.AddedField(field); !exists {
				return false
			}
		}
		return true
	}
}

// HasClearedFields is a condition validating `.FieldCleared` on fields.
func HasClearedFields(field string, fields ...string) Condition {
	return func(_ context.Context, m models.Mutation) bool {
		if exists := m.FieldCleared(field); !exists {
			return false
		}
		for _, field := range fields {
			if exists := m.FieldCleared(field); !exists {
				return false
			}
		}
		return true
	}
}

// HasFields is a condition validating `.Field` on fields.
func HasFields(field string, fields ...string) Condition {
	return func(_ context.Context, m models.Mutation) bool {
		if _, exists := m.Field(field); !exists {
			return false
		}
		for _, field := range fields {
			if _, exists := m.Field(field); !exists {
				return false
			}
		}
		return true
	}
}

// If executes the given hook under condition.
//
//	hook.If(ComputeAverage, And(HasFields(...), HasAddedFields(...)))
func If(hk models.Hook, cond Condition) models.Hook {
	return func(next models.Mutator) models.Mutator {
		return models.MutateFunc(func(ctx context.Context, m models.Mutation) (models.Value, error) {
			if cond(ctx, m) {
				return hk(next).Mutate(ctx, m)
			}
			return next.Mutate(ctx, m)
		})
	}
}

// On executes the given hook only for the given operation.
//
//	hook.On(Log, models.Delete|models.Create)
func On(hk models.Hook, op models.Op) models.Hook {
	return If(hk, HasOp(op))
}

// Unless skips the given hook only for the given operation.
//
//	hook.Unless(Log, models.Update|models.UpdateOne)
func Unless(hk models.Hook, op models.Op) models.Hook {
	return If(hk, Not(HasOp(op)))
}

// FixedError is a hook returning a fixed error.
func FixedError(err error) models.Hook {
	return func(models.Mutator) models.Mutator {
		return models.MutateFunc(func(context.Context, models.Mutation) (models.Value, error) {
			return nil, err
		})
	}
}

// Reject returns a hook that rejects all operations that match op.
//
//	func (T) Hooks() []models.Hook {
//		return []models.Hook{
//			Reject(models.Delete|models.Update),
//		}
//	}
func Reject(op models.Op) models.Hook {
	hk := FixedError(fmt.Errorf("%s operation is not allowed", op))
	return On(hk, op)
}

// Chain acts as a list of hooks and is effectively immutable.
// Once created, it will always hold the same set of hooks in the same order.
type Chain struct {
	hooks []models.Hook
}

// NewChain creates a new chain of hooks.
func NewChain(hooks ...models.Hook) Chain {
	return Chain{append([]models.Hook(nil), hooks...)}
}

// Hook chains the list of hooks and returns the final hook.
func (c Chain) Hook() models.Hook {
	return func(mutator models.Mutator) models.Mutator {
		for i := len(c.hooks) - 1; i >= 0; i-- {
			mutator = c.hooks[i](mutator)
		}
		return mutator
	}
}

// Append extends a chain, adding the specified hook
// as the last ones in the mutation flow.
func (c Chain) Append(hooks ...models.Hook) Chain {
	newHooks := make([]models.Hook, 0, len(c.hooks)+len(hooks))
	newHooks = append(newHooks, c.hooks...)
	newHooks = append(newHooks, hooks...)
	return Chain{newHooks}
}

// Extend extends a chain, adding the specified chain
// as the last ones in the mutation flow.
func (c Chain) Extend(chain Chain) Chain {
	return c.Append(chain.hooks...)
}



================================================
File: models/internal/schemaconfig.go
================================================
// Code generated by ent, DO NOT EDIT.

package internal

import "context"

// SchemaConfig represents alternative schema names for all tables
// that can be passed at runtime.
type SchemaConfig struct {
	AccessToken string // AccessToken table.
	Env         string // Env table.
	EnvAlias    string // EnvAlias table.
	EnvBuild    string // EnvBuild table.
	Snapshot    string // Snapshot table.
	Team        string // Team table.
	TeamAPIKey  string // TeamAPIKey table.
	Tier        string // Tier table.
	User        string // User table.
	UsersTeams  string // UsersTeams table.
}

type schemaCtxKey struct{}

// SchemaConfigFromContext returns a SchemaConfig stored inside a context, or empty if there isn't one.
func SchemaConfigFromContext(ctx context.Context) SchemaConfig {
	config, _ := ctx.Value(schemaCtxKey{}).(SchemaConfig)
	return config
}

// NewSchemaConfigContext returns a new context with the given SchemaConfig attached.
func NewSchemaConfigContext(parent context.Context, config SchemaConfig) context.Context {
	return context.WithValue(parent, schemaCtxKey{}, config)
}



================================================
File: models/migrate/migrate.go
================================================
// Code generated by ent, DO NOT EDIT.

package migrate

import (
	"context"
	"fmt"
	"io"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql/schema"
)

var (
	// WithGlobalUniqueID sets the universal ids options to the migration.
	// If this option is enabled, ent migration will allocate a 1<<32 range
	// for the ids of each entity (table).
	// Note that this option cannot be applied on tables that already exist.
	WithGlobalUniqueID = schema.WithGlobalUniqueID
	// WithDropColumn sets the drop column option to the migration.
	// If this option is enabled, ent migration will drop old columns
	// that were used for both fields and edges. This defaults to false.
	WithDropColumn = schema.WithDropColumn
	// WithDropIndex sets the drop index option to the migration.
	// If this option is enabled, ent migration will drop old indexes
	// that were defined in the schema. This defaults to false.
	// Note that unique constraints are defined using `UNIQUE INDEX`,
	// and therefore, it's recommended to enable this option to get more
	// flexibility in the schema changes.
	WithDropIndex = schema.WithDropIndex
	// WithForeignKeys enables creating foreign-key in schema DDL. This defaults to true.
	WithForeignKeys = schema.WithForeignKeys
)

// Schema is the API for creating, migrating and dropping a schema.
type Schema struct {
	drv dialect.Driver
}

// NewSchema creates a new schema client.
func NewSchema(drv dialect.Driver) *Schema { return &Schema{drv: drv} }

// Create creates all schema resources.
func (s *Schema) Create(ctx context.Context, opts ...schema.MigrateOption) error {
	return Create(ctx, s, Tables, opts...)
}

// Create creates all table resources using the given schema driver.
func Create(ctx context.Context, s *Schema, tables []*schema.Table, opts ...schema.MigrateOption) error {
	migrate, err := schema.NewMigrate(s.drv, opts...)
	if err != nil {
		return fmt.Errorf("ent/migrate: %w", err)
	}
	return migrate.Create(ctx, tables...)
}

// WriteTo writes the schema changes to w instead of running them against the database.
//
//	if err := client.Schema.WriteTo(context.Background(), os.Stdout); err != nil {
//		log.Fatal(err)
//	}
func (s *Schema) WriteTo(ctx context.Context, w io.Writer, opts ...schema.MigrateOption) error {
	return Create(ctx, &Schema{drv: &schema.WriteDriver{Writer: w, Driver: s.drv}}, Tables, opts...)
}



================================================
File: models/migrate/schema.go
================================================
// Code generated by ent, DO NOT EDIT.

package migrate

import (
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/dialect/sql/schema"
	"entgo.io/ent/schema/field"
)

var (
	// AccessTokensColumns holds the columns for the "access_tokens" table.
	AccessTokensColumns = []*schema.Column{
		{Name: "access_token", Type: field.TypeString, Unique: true, SchemaType: map[string]string{"postgres": "text"}},
		{Name: "created_at", Type: field.TypeTime, Nullable: true, Default: "CURRENT_TIMESTAMP"},
		{Name: "user_id", Type: field.TypeUUID},
	}
	// AccessTokensTable holds the schema information for the "access_tokens" table.
	AccessTokensTable = &schema.Table{
		Name:       "access_tokens",
		Columns:    AccessTokensColumns,
		PrimaryKey: []*schema.Column{AccessTokensColumns[0]},
		ForeignKeys: []*schema.ForeignKey{
			{
				Symbol:     "access_tokens_users_access_tokens",
				Columns:    []*schema.Column{AccessTokensColumns[2]},
				RefColumns: []*schema.Column{UsersColumns[0]},
				OnDelete:   schema.Cascade,
			},
		},
	}
	// EnvsColumns holds the columns for the "envs" table.
	EnvsColumns = []*schema.Column{
		{Name: "id", Type: field.TypeString, Unique: true, SchemaType: map[string]string{"postgres": "text"}},
		{Name: "created_at", Type: field.TypeTime, Default: "CURRENT_TIMESTAMP"},
		{Name: "updated_at", Type: field.TypeTime},
		{Name: "public", Type: field.TypeBool, Default: "false"},
		{Name: "build_count", Type: field.TypeInt32, Default: 1},
		{Name: "spawn_count", Type: field.TypeInt64, Comment: "Number of times the env was spawned", Default: 0},
		{Name: "last_spawned_at", Type: field.TypeTime, Nullable: true, Comment: "Timestamp of the last time the env was spawned"},
		{Name: "team_id", Type: field.TypeUUID},
		{Name: "created_by", Type: field.TypeUUID, Nullable: true},
	}
	// EnvsTable holds the schema information for the "envs" table.
	EnvsTable = &schema.Table{
		Name:       "envs",
		Columns:    EnvsColumns,
		PrimaryKey: []*schema.Column{EnvsColumns[0]},
		ForeignKeys: []*schema.ForeignKey{
			{
				Symbol:     "envs_teams_envs",
				Columns:    []*schema.Column{EnvsColumns[7]},
				RefColumns: []*schema.Column{TeamsColumns[0]},
				OnDelete:   schema.NoAction,
			},
			{
				Symbol:     "envs_users_created_envs",
				Columns:    []*schema.Column{EnvsColumns[8]},
				RefColumns: []*schema.Column{UsersColumns[0]},
				OnDelete:   schema.SetNull,
			},
		},
	}
	// EnvAliasesColumns holds the columns for the "env_aliases" table.
	EnvAliasesColumns = []*schema.Column{
		{Name: "alias", Type: field.TypeString, Unique: true, SchemaType: map[string]string{"postgres": "text"}},
		{Name: "is_renamable", Type: field.TypeBool, Default: true},
		{Name: "env_id", Type: field.TypeString, SchemaType: map[string]string{"postgres": "text"}},
	}
	// EnvAliasesTable holds the schema information for the "env_aliases" table.
	EnvAliasesTable = &schema.Table{
		Name:       "env_aliases",
		Columns:    EnvAliasesColumns,
		PrimaryKey: []*schema.Column{EnvAliasesColumns[0]},
		ForeignKeys: []*schema.ForeignKey{
			{
				Symbol:     "env_aliases_envs_env_aliases",
				Columns:    []*schema.Column{EnvAliasesColumns[2]},
				RefColumns: []*schema.Column{EnvsColumns[0]},
				OnDelete:   schema.Cascade,
			},
		},
	}
	// EnvBuildsColumns holds the columns for the "env_builds" table.
	EnvBuildsColumns = []*schema.Column{
		{Name: "id", Type: field.TypeUUID, Unique: true, Default: "gen_random_uuid()"},
		{Name: "created_at", Type: field.TypeTime, Default: "CURRENT_TIMESTAMP"},
		{Name: "updated_at", Type: field.TypeTime},
		{Name: "finished_at", Type: field.TypeTime, Nullable: true},
		{Name: "status", Type: field.TypeEnum, Enums: []string{"waiting", "building", "failed", "success", "uploaded"}, Default: "waiting", SchemaType: map[string]string{"postgres": "text"}},
		{Name: "dockerfile", Type: field.TypeString, Nullable: true, SchemaType: map[string]string{"postgres": "text"}},
		{Name: "start_cmd", Type: field.TypeString, Nullable: true, SchemaType: map[string]string{"postgres": "text"}},
		{Name: "vcpu", Type: field.TypeInt64},
		{Name: "ram_mb", Type: field.TypeInt64},
		{Name: "free_disk_size_mb", Type: field.TypeInt64},
		{Name: "total_disk_size_mb", Type: field.TypeInt64, Nullable: true},
		{Name: "kernel_version", Type: field.TypeString, Default: "vmlinux-6.1.102", SchemaType: map[string]string{"postgres": "text"}},
		{Name: "firecracker_version", Type: field.TypeString, Default: "v1.10.1_1fcdaec", SchemaType: map[string]string{"postgres": "text"}},
		{Name: "envd_version", Type: field.TypeString, Nullable: true, SchemaType: map[string]string{"postgres": "text"}},
		{Name: "env_id", Type: field.TypeString, Nullable: true, SchemaType: map[string]string{"postgres": "text"}},
	}
	// EnvBuildsTable holds the schema information for the "env_builds" table.
	EnvBuildsTable = &schema.Table{
		Name:       "env_builds",
		Columns:    EnvBuildsColumns,
		PrimaryKey: []*schema.Column{EnvBuildsColumns[0]},
		ForeignKeys: []*schema.ForeignKey{
			{
				Symbol:     "env_builds_envs_builds",
				Columns:    []*schema.Column{EnvBuildsColumns[14]},
				RefColumns: []*schema.Column{EnvsColumns[0]},
				OnDelete:   schema.Cascade,
			},
		},
	}
	// SnapshotsColumns holds the columns for the "snapshots" table.
	SnapshotsColumns = []*schema.Column{
		{Name: "id", Type: field.TypeUUID, Unique: true, Default: "gen_random_uuid()"},
		{Name: "created_at", Type: field.TypeTime, Default: "CURRENT_TIMESTAMP"},
		{Name: "base_env_id", Type: field.TypeString, SchemaType: map[string]string{"postgres": "text"}},
		{Name: "sandbox_id", Type: field.TypeString, Unique: true, SchemaType: map[string]string{"postgres": "text"}},
		{Name: "metadata", Type: field.TypeJSON, SchemaType: map[string]string{"postgres": "jsonb"}},
		{Name: "env_id", Type: field.TypeString, SchemaType: map[string]string{"postgres": "text"}},
	}
	// SnapshotsTable holds the schema information for the "snapshots" table.
	SnapshotsTable = &schema.Table{
		Name:       "snapshots",
		Columns:    SnapshotsColumns,
		PrimaryKey: []*schema.Column{SnapshotsColumns[0]},
		ForeignKeys: []*schema.ForeignKey{
			{
				Symbol:     "snapshots_envs_snapshots",
				Columns:    []*schema.Column{SnapshotsColumns[5]},
				RefColumns: []*schema.Column{EnvsColumns[0]},
				OnDelete:   schema.Cascade,
			},
		},
	}
	// TeamsColumns holds the columns for the "teams" table.
	TeamsColumns = []*schema.Column{
		{Name: "id", Type: field.TypeUUID, Unique: true, Default: "gen_random_uuid()"},
		{Name: "created_at", Type: field.TypeTime, Default: "CURRENT_TIMESTAMP"},
		{Name: "is_banned", Type: field.TypeBool, Nullable: true, Default: "false"},
		{Name: "is_blocked", Type: field.TypeBool, Nullable: true, Default: "false"},
		{Name: "blocked_reason", Type: field.TypeString, Nullable: true, SchemaType: map[string]string{"postgres": "text"}},
		{Name: "name", Type: field.TypeString, SchemaType: map[string]string{"postgres": "text"}},
		{Name: "email", Type: field.TypeString, Size: 255, SchemaType: map[string]string{"postgres": "character varying(255)"}},
		{Name: "tier", Type: field.TypeString, SchemaType: map[string]string{"postgres": "text"}},
	}
	// TeamsTable holds the schema information for the "teams" table.
	TeamsTable = &schema.Table{
		Name:       "teams",
		Columns:    TeamsColumns,
		PrimaryKey: []*schema.Column{TeamsColumns[0]},
		ForeignKeys: []*schema.ForeignKey{
			{
				Symbol:     "teams_tiers_teams",
				Columns:    []*schema.Column{TeamsColumns[7]},
				RefColumns: []*schema.Column{TiersColumns[0]},
				OnDelete:   schema.NoAction,
			},
		},
	}
	// TeamAPIKeysColumns holds the columns for the "team_api_keys" table.
	TeamAPIKeysColumns = []*schema.Column{
		{Name: "id", Type: field.TypeUUID, Unique: true, Default: "gen_random_uuid()"},
		{Name: "api_key", Type: field.TypeString, Unique: true, SchemaType: map[string]string{"postgres": "character varying(44)"}},
		{Name: "created_at", Type: field.TypeTime, Default: "CURRENT_TIMESTAMP"},
		{Name: "updated_at", Type: field.TypeTime, Nullable: true},
		{Name: "name", Type: field.TypeString, Default: "Unnamed API Key", SchemaType: map[string]string{"postgres": "text"}},
		{Name: "last_used", Type: field.TypeTime, Nullable: true},
		{Name: "team_id", Type: field.TypeUUID},
		{Name: "created_by", Type: field.TypeUUID, Nullable: true},
	}
	// TeamAPIKeysTable holds the schema information for the "team_api_keys" table.
	TeamAPIKeysTable = &schema.Table{
		Name:       "team_api_keys",
		Columns:    TeamAPIKeysColumns,
		PrimaryKey: []*schema.Column{TeamAPIKeysColumns[0]},
		ForeignKeys: []*schema.ForeignKey{
			{
				Symbol:     "team_api_keys_teams_team_api_keys",
				Columns:    []*schema.Column{TeamAPIKeysColumns[6]},
				RefColumns: []*schema.Column{TeamsColumns[0]},
				OnDelete:   schema.Cascade,
			},
			{
				Symbol:     "team_api_keys_users_created_api_keys",
				Columns:    []*schema.Column{TeamAPIKeysColumns[7]},
				RefColumns: []*schema.Column{UsersColumns[0]},
				OnDelete:   schema.SetNull,
			},
		},
	}
	// TiersColumns holds the columns for the "tiers" table.
	TiersColumns = []*schema.Column{
		{Name: "id", Type: field.TypeString, Unique: true, SchemaType: map[string]string{"postgres": "text"}},
		{Name: "name", Type: field.TypeString, SchemaType: map[string]string{"postgres": "text"}},
		{Name: "disk_mb", Type: field.TypeInt64, Default: "512"},
		{Name: "concurrent_instances", Type: field.TypeInt64, Comment: "The number of instances the team can run concurrently"},
		{Name: "max_length_hours", Type: field.TypeInt64},
	}
	// TiersTable holds the schema information for the "tiers" table.
	TiersTable = &schema.Table{
		Name:       "tiers",
		Columns:    TiersColumns,
		PrimaryKey: []*schema.Column{TiersColumns[0]},
	}
	// UsersColumns holds the columns for the "users" table.
	UsersColumns = []*schema.Column{
		{Name: "id", Type: field.TypeUUID, Unique: true, Default: "gen_random_uuid()"},
		{Name: "email", Type: field.TypeString, Size: 255, SchemaType: map[string]string{"postgres": "character varying(255)"}},
	}
	// UsersTable holds the schema information for the "users" table.
	UsersTable = &schema.Table{
		Name:       "users",
		Columns:    UsersColumns,
		PrimaryKey: []*schema.Column{UsersColumns[0]},
	}
	// UsersTeamsColumns holds the columns for the "users_teams" table.
	UsersTeamsColumns = []*schema.Column{
		{Name: "id", Type: field.TypeInt, Increment: true},
		{Name: "is_default", Type: field.TypeBool, Default: false},
		{Name: "user_id", Type: field.TypeUUID},
		{Name: "team_id", Type: field.TypeUUID},
	}
	// UsersTeamsTable holds the schema information for the "users_teams" table.
	UsersTeamsTable = &schema.Table{
		Name:       "users_teams",
		Columns:    UsersTeamsColumns,
		PrimaryKey: []*schema.Column{UsersTeamsColumns[0]},
		ForeignKeys: []*schema.ForeignKey{
			{
				Symbol:     "users_teams_users_users",
				Columns:    []*schema.Column{UsersTeamsColumns[2]},
				RefColumns: []*schema.Column{UsersColumns[0]},
				OnDelete:   schema.Cascade,
			},
			{
				Symbol:     "users_teams_teams_teams",
				Columns:    []*schema.Column{UsersTeamsColumns[3]},
				RefColumns: []*schema.Column{TeamsColumns[0]},
				OnDelete:   schema.Cascade,
			},
		},
		Indexes: []*schema.Index{
			{
				Name:    "usersteams_team_id_user_id",
				Unique:  true,
				Columns: []*schema.Column{UsersTeamsColumns[3], UsersTeamsColumns[2]},
			},
		},
	}
	// Tables holds all the tables in the schema.
	Tables = []*schema.Table{
		AccessTokensTable,
		EnvsTable,
		EnvAliasesTable,
		EnvBuildsTable,
		SnapshotsTable,
		TeamsTable,
		TeamAPIKeysTable,
		TiersTable,
		UsersTable,
		UsersTeamsTable,
	}
)

func init() {
	AccessTokensTable.ForeignKeys[0].RefTable = UsersTable
	AccessTokensTable.Annotation = &entsql.Annotation{}
	EnvsTable.ForeignKeys[0].RefTable = TeamsTable
	EnvsTable.ForeignKeys[1].RefTable = UsersTable
	EnvsTable.Annotation = &entsql.Annotation{}
	EnvAliasesTable.ForeignKeys[0].RefTable = EnvsTable
	EnvAliasesTable.Annotation = &entsql.Annotation{
		Table: "env_aliases",
	}
	EnvBuildsTable.ForeignKeys[0].RefTable = EnvsTable
	EnvBuildsTable.Annotation = &entsql.Annotation{}
	SnapshotsTable.ForeignKeys[0].RefTable = EnvsTable
	SnapshotsTable.Annotation = &entsql.Annotation{}
	TeamsTable.ForeignKeys[0].RefTable = TiersTable
	TeamsTable.Annotation = &entsql.Annotation{}
	TeamAPIKeysTable.ForeignKeys[0].RefTable = TeamsTable
	TeamAPIKeysTable.ForeignKeys[1].RefTable = UsersTable
	TeamAPIKeysTable.Annotation = &entsql.Annotation{}
	TiersTable.Annotation = &entsql.Annotation{}
	TiersTable.Annotation.Checks = map[string]string{
		"tiers_concurrent_sessions_check": "concurrent_instances > 0",
		"tiers_disk_mb_check":             "disk_mb > 0",
	}
	UsersTable.Annotation = &entsql.Annotation{}
	UsersTeamsTable.ForeignKeys[0].RefTable = UsersTable
	UsersTeamsTable.ForeignKeys[1].RefTable = TeamsTable
	UsersTeamsTable.Annotation = &entsql.Annotation{}
}



================================================
File: models/predicate/predicate.go
================================================
// Code generated by ent, DO NOT EDIT.

package predicate

import (
	"entgo.io/ent/dialect/sql"
)

// AccessToken is the predicate function for accesstoken builders.
type AccessToken func(*sql.Selector)

// Env is the predicate function for env builders.
type Env func(*sql.Selector)

// EnvAlias is the predicate function for envalias builders.
type EnvAlias func(*sql.Selector)

// EnvBuild is the predicate function for envbuild builders.
type EnvBuild func(*sql.Selector)

// Snapshot is the predicate function for snapshot builders.
type Snapshot func(*sql.Selector)

// Team is the predicate function for team builders.
type Team func(*sql.Selector)

// TeamAPIKey is the predicate function for teamapikey builders.
type TeamAPIKey func(*sql.Selector)

// Tier is the predicate function for tier builders.
type Tier func(*sql.Selector)

// User is the predicate function for user builders.
type User func(*sql.Selector)

// UsersTeams is the predicate function for usersteams builders.
type UsersTeams func(*sql.Selector)



================================================
File: models/runtime/runtime.go
================================================
// Code generated by ent, DO NOT EDIT.

package runtime

// The schema-stitching logic is generated in github.com/e2b-dev/infra/packages/shared/pkg/models/runtime.go

const (
	Version = "v0.12.5"                                         // Version of ent codegen.
	Sum     = "h1:KREM5E4CSoej4zeGa88Ou/gfturAnpUv0mzAjch1sj4=" // Sum of ent codegen.
)



================================================
File: models/snapshot/snapshot.go
================================================
// Code generated by ent, DO NOT EDIT.

package snapshot

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the snapshot type in the database.
	Label = "snapshot"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldBaseEnvID holds the string denoting the base_env_id field in the database.
	FieldBaseEnvID = "base_env_id"
	// FieldEnvID holds the string denoting the env_id field in the database.
	FieldEnvID = "env_id"
	// FieldSandboxID holds the string denoting the sandbox_id field in the database.
	FieldSandboxID = "sandbox_id"
	// FieldMetadata holds the string denoting the metadata field in the database.
	FieldMetadata = "metadata"
	// EdgeEnv holds the string denoting the env edge name in mutations.
	EdgeEnv = "env"
	// Table holds the table name of the snapshot in the database.
	Table = "snapshots"
	// EnvTable is the table that holds the env relation/edge.
	EnvTable = "snapshots"
	// EnvInverseTable is the table name for the Env entity.
	// It exists in this package in order to avoid circular dependency with the "env" package.
	EnvInverseTable = "envs"
	// EnvColumn is the table column denoting the env relation/edge.
	EnvColumn = "env_id"
)

// Columns holds all SQL columns for snapshot fields.
var Columns = []string{
	FieldID,
	FieldCreatedAt,
	FieldBaseEnvID,
	FieldEnvID,
	FieldSandboxID,
	FieldMetadata,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
)

// OrderOption defines the ordering options for the Snapshot queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByBaseEnvID orders the results by the base_env_id field.
func ByBaseEnvID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBaseEnvID, opts...).ToFunc()
}

// ByEnvID orders the results by the env_id field.
func ByEnvID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEnvID, opts...).ToFunc()
}

// BySandboxID orders the results by the sandbox_id field.
func BySandboxID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSandboxID, opts...).ToFunc()
}

// ByEnvField orders the results by env field.
func ByEnvField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newEnvStep(), sql.OrderByField(field, opts...))
	}
}
func newEnvStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(EnvInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, EnvTable, EnvColumn),
	)
}



================================================
File: models/snapshot/where.go
================================================
// Code generated by ent, DO NOT EDIT.

package snapshot

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/google/uuid"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldLTE(FieldID, id))
}

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldEQ(FieldCreatedAt, v))
}

// BaseEnvID applies equality check predicate on the "base_env_id" field. It's identical to BaseEnvIDEQ.
func BaseEnvID(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldEQ(FieldBaseEnvID, v))
}

// EnvID applies equality check predicate on the "env_id" field. It's identical to EnvIDEQ.
func EnvID(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldEQ(FieldEnvID, v))
}

// SandboxID applies equality check predicate on the "sandbox_id" field. It's identical to SandboxIDEQ.
func SandboxID(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldEQ(FieldSandboxID, v))
}

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldEQ(FieldCreatedAt, v))
}

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldNEQ(FieldCreatedAt, v))
}

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldIn(FieldCreatedAt, vs...))
}

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldNotIn(FieldCreatedAt, vs...))
}

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldGT(FieldCreatedAt, v))
}

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldGTE(FieldCreatedAt, v))
}

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldLT(FieldCreatedAt, v))
}

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldLTE(FieldCreatedAt, v))
}

// BaseEnvIDEQ applies the EQ predicate on the "base_env_id" field.
func BaseEnvIDEQ(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldEQ(FieldBaseEnvID, v))
}

// BaseEnvIDNEQ applies the NEQ predicate on the "base_env_id" field.
func BaseEnvIDNEQ(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldNEQ(FieldBaseEnvID, v))
}

// BaseEnvIDIn applies the In predicate on the "base_env_id" field.
func BaseEnvIDIn(vs ...string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldIn(FieldBaseEnvID, vs...))
}

// BaseEnvIDNotIn applies the NotIn predicate on the "base_env_id" field.
func BaseEnvIDNotIn(vs ...string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldNotIn(FieldBaseEnvID, vs...))
}

// BaseEnvIDGT applies the GT predicate on the "base_env_id" field.
func BaseEnvIDGT(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldGT(FieldBaseEnvID, v))
}

// BaseEnvIDGTE applies the GTE predicate on the "base_env_id" field.
func BaseEnvIDGTE(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldGTE(FieldBaseEnvID, v))
}

// BaseEnvIDLT applies the LT predicate on the "base_env_id" field.
func BaseEnvIDLT(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldLT(FieldBaseEnvID, v))
}

// BaseEnvIDLTE applies the LTE predicate on the "base_env_id" field.
func BaseEnvIDLTE(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldLTE(FieldBaseEnvID, v))
}

// BaseEnvIDContains applies the Contains predicate on the "base_env_id" field.
func BaseEnvIDContains(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldContains(FieldBaseEnvID, v))
}

// BaseEnvIDHasPrefix applies the HasPrefix predicate on the "base_env_id" field.
func BaseEnvIDHasPrefix(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldHasPrefix(FieldBaseEnvID, v))
}

// BaseEnvIDHasSuffix applies the HasSuffix predicate on the "base_env_id" field.
func BaseEnvIDHasSuffix(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldHasSuffix(FieldBaseEnvID, v))
}

// BaseEnvIDEqualFold applies the EqualFold predicate on the "base_env_id" field.
func BaseEnvIDEqualFold(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldEqualFold(FieldBaseEnvID, v))
}

// BaseEnvIDContainsFold applies the ContainsFold predicate on the "base_env_id" field.
func BaseEnvIDContainsFold(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldContainsFold(FieldBaseEnvID, v))
}

// EnvIDEQ applies the EQ predicate on the "env_id" field.
func EnvIDEQ(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldEQ(FieldEnvID, v))
}

// EnvIDNEQ applies the NEQ predicate on the "env_id" field.
func EnvIDNEQ(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldNEQ(FieldEnvID, v))
}

// EnvIDIn applies the In predicate on the "env_id" field.
func EnvIDIn(vs ...string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldIn(FieldEnvID, vs...))
}

// EnvIDNotIn applies the NotIn predicate on the "env_id" field.
func EnvIDNotIn(vs ...string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldNotIn(FieldEnvID, vs...))
}

// EnvIDGT applies the GT predicate on the "env_id" field.
func EnvIDGT(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldGT(FieldEnvID, v))
}

// EnvIDGTE applies the GTE predicate on the "env_id" field.
func EnvIDGTE(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldGTE(FieldEnvID, v))
}

// EnvIDLT applies the LT predicate on the "env_id" field.
func EnvIDLT(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldLT(FieldEnvID, v))
}

// EnvIDLTE applies the LTE predicate on the "env_id" field.
func EnvIDLTE(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldLTE(FieldEnvID, v))
}

// EnvIDContains applies the Contains predicate on the "env_id" field.
func EnvIDContains(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldContains(FieldEnvID, v))
}

// EnvIDHasPrefix applies the HasPrefix predicate on the "env_id" field.
func EnvIDHasPrefix(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldHasPrefix(FieldEnvID, v))
}

// EnvIDHasSuffix applies the HasSuffix predicate on the "env_id" field.
func EnvIDHasSuffix(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldHasSuffix(FieldEnvID, v))
}

// EnvIDEqualFold applies the EqualFold predicate on the "env_id" field.
func EnvIDEqualFold(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldEqualFold(FieldEnvID, v))
}

// EnvIDContainsFold applies the ContainsFold predicate on the "env_id" field.
func EnvIDContainsFold(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldContainsFold(FieldEnvID, v))
}

// SandboxIDEQ applies the EQ predicate on the "sandbox_id" field.
func SandboxIDEQ(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldEQ(FieldSandboxID, v))
}

// SandboxIDNEQ applies the NEQ predicate on the "sandbox_id" field.
func SandboxIDNEQ(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldNEQ(FieldSandboxID, v))
}

// SandboxIDIn applies the In predicate on the "sandbox_id" field.
func SandboxIDIn(vs ...string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldIn(FieldSandboxID, vs...))
}

// SandboxIDNotIn applies the NotIn predicate on the "sandbox_id" field.
func SandboxIDNotIn(vs ...string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldNotIn(FieldSandboxID, vs...))
}

// SandboxIDGT applies the GT predicate on the "sandbox_id" field.
func SandboxIDGT(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldGT(FieldSandboxID, v))
}

// SandboxIDGTE applies the GTE predicate on the "sandbox_id" field.
func SandboxIDGTE(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldGTE(FieldSandboxID, v))
}

// SandboxIDLT applies the LT predicate on the "sandbox_id" field.
func SandboxIDLT(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldLT(FieldSandboxID, v))
}

// SandboxIDLTE applies the LTE predicate on the "sandbox_id" field.
func SandboxIDLTE(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldLTE(FieldSandboxID, v))
}

// SandboxIDContains applies the Contains predicate on the "sandbox_id" field.
func SandboxIDContains(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldContains(FieldSandboxID, v))
}

// SandboxIDHasPrefix applies the HasPrefix predicate on the "sandbox_id" field.
func SandboxIDHasPrefix(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldHasPrefix(FieldSandboxID, v))
}

// SandboxIDHasSuffix applies the HasSuffix predicate on the "sandbox_id" field.
func SandboxIDHasSuffix(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldHasSuffix(FieldSandboxID, v))
}

// SandboxIDEqualFold applies the EqualFold predicate on the "sandbox_id" field.
func SandboxIDEqualFold(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldEqualFold(FieldSandboxID, v))
}

// SandboxIDContainsFold applies the ContainsFold predicate on the "sandbox_id" field.
func SandboxIDContainsFold(v string) predicate.Snapshot {
	return predicate.Snapshot(sql.FieldContainsFold(FieldSandboxID, v))
}

// HasEnv applies the HasEdge predicate on the "env" edge.
func HasEnv() predicate.Snapshot {
	return predicate.Snapshot(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, EnvTable, EnvColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.Snapshot
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasEnvWith applies the HasEdge predicate on the "env" edge with a given conditions (other predicates).
func HasEnvWith(preds ...predicate.Env) predicate.Snapshot {
	return predicate.Snapshot(func(s *sql.Selector) {
		step := newEnvStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.Snapshot
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Snapshot) predicate.Snapshot {
	return predicate.Snapshot(sql.AndPredicates(predicates...))
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Snapshot) predicate.Snapshot {
	return predicate.Snapshot(sql.OrPredicates(predicates...))
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Snapshot) predicate.Snapshot {
	return predicate.Snapshot(sql.NotPredicates(p))
}



================================================
File: models/team/team.go
================================================
// Code generated by ent, DO NOT EDIT.

package team

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the team type in the database.
	Label = "team"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldIsBanned holds the string denoting the is_banned field in the database.
	FieldIsBanned = "is_banned"
	// FieldIsBlocked holds the string denoting the is_blocked field in the database.
	FieldIsBlocked = "is_blocked"
	// FieldBlockedReason holds the string denoting the blocked_reason field in the database.
	FieldBlockedReason = "blocked_reason"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// FieldTier holds the string denoting the tier field in the database.
	FieldTier = "tier"
	// FieldEmail holds the string denoting the email field in the database.
	FieldEmail = "email"
	// EdgeUsers holds the string denoting the users edge name in mutations.
	EdgeUsers = "users"
	// EdgeTeamAPIKeys holds the string denoting the team_api_keys edge name in mutations.
	EdgeTeamAPIKeys = "team_api_keys"
	// EdgeTeamTier holds the string denoting the team_tier edge name in mutations.
	EdgeTeamTier = "team_tier"
	// EdgeEnvs holds the string denoting the envs edge name in mutations.
	EdgeEnvs = "envs"
	// EdgeUsersTeams holds the string denoting the users_teams edge name in mutations.
	EdgeUsersTeams = "users_teams"
	// Table holds the table name of the team in the database.
	Table = "teams"
	// UsersTable is the table that holds the users relation/edge. The primary key declared below.
	UsersTable = "users_teams"
	// UsersInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	UsersInverseTable = "users"
	// TeamAPIKeysTable is the table that holds the team_api_keys relation/edge.
	TeamAPIKeysTable = "team_api_keys"
	// TeamAPIKeysInverseTable is the table name for the TeamAPIKey entity.
	// It exists in this package in order to avoid circular dependency with the "teamapikey" package.
	TeamAPIKeysInverseTable = "team_api_keys"
	// TeamAPIKeysColumn is the table column denoting the team_api_keys relation/edge.
	TeamAPIKeysColumn = "team_id"
	// TeamTierTable is the table that holds the team_tier relation/edge.
	TeamTierTable = "teams"
	// TeamTierInverseTable is the table name for the Tier entity.
	// It exists in this package in order to avoid circular dependency with the "tier" package.
	TeamTierInverseTable = "tiers"
	// TeamTierColumn is the table column denoting the team_tier relation/edge.
	TeamTierColumn = "tier"
	// EnvsTable is the table that holds the envs relation/edge.
	EnvsTable = "envs"
	// EnvsInverseTable is the table name for the Env entity.
	// It exists in this package in order to avoid circular dependency with the "env" package.
	EnvsInverseTable = "envs"
	// EnvsColumn is the table column denoting the envs relation/edge.
	EnvsColumn = "team_id"
	// UsersTeamsTable is the table that holds the users_teams relation/edge.
	UsersTeamsTable = "users_teams"
	// UsersTeamsInverseTable is the table name for the UsersTeams entity.
	// It exists in this package in order to avoid circular dependency with the "usersteams" package.
	UsersTeamsInverseTable = "users_teams"
	// UsersTeamsColumn is the table column denoting the users_teams relation/edge.
	UsersTeamsColumn = "team_id"
)

// Columns holds all SQL columns for team fields.
var Columns = []string{
	FieldID,
	FieldCreatedAt,
	FieldIsBanned,
	FieldIsBlocked,
	FieldBlockedReason,
	FieldName,
	FieldTier,
	FieldEmail,
}

var (
	// UsersPrimaryKey and UsersColumn2 are the table columns denoting the
	// primary key for the users relation (M2M).
	UsersPrimaryKey = []string{"team_id", "user_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
	// EmailValidator is a validator for the "email" field. It is called by the builders before save.
	EmailValidator func(string) error
)

// OrderOption defines the ordering options for the Team queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByIsBanned orders the results by the is_banned field.
func ByIsBanned(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIsBanned, opts...).ToFunc()
}

// ByIsBlocked orders the results by the is_blocked field.
func ByIsBlocked(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIsBlocked, opts...).ToFunc()
}

// ByBlockedReason orders the results by the blocked_reason field.
func ByBlockedReason(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBlockedReason, opts...).ToFunc()
}

// ByName orders the results by the name field.
func ByName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldName, opts...).ToFunc()
}

// ByTier orders the results by the tier field.
func ByTier(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTier, opts...).ToFunc()
}

// ByEmail orders the results by the email field.
func ByEmail(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEmail, opts...).ToFunc()
}

// ByUsersCount orders the results by users count.
func ByUsersCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newUsersStep(), opts...)
	}
}

// ByUsers orders the results by users terms.
func ByUsers(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newUsersStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByTeamAPIKeysCount orders the results by team_api_keys count.
func ByTeamAPIKeysCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newTeamAPIKeysStep(), opts...)
	}
}

// ByTeamAPIKeys orders the results by team_api_keys terms.
func ByTeamAPIKeys(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTeamAPIKeysStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByTeamTierField orders the results by team_tier field.
func ByTeamTierField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTeamTierStep(), sql.OrderByField(field, opts...))
	}
}

// ByEnvsCount orders the results by envs count.
func ByEnvsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newEnvsStep(), opts...)
	}
}

// ByEnvs orders the results by envs terms.
func ByEnvs(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newEnvsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByUsersTeamsCount orders the results by users_teams count.
func ByUsersTeamsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newUsersTeamsStep(), opts...)
	}
}

// ByUsersTeams orders the results by users_teams terms.
func ByUsersTeams(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newUsersTeamsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newUsersStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(UsersInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, false, UsersTable, UsersPrimaryKey...),
	)
}
func newTeamAPIKeysStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TeamAPIKeysInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, TeamAPIKeysTable, TeamAPIKeysColumn),
	)
}
func newTeamTierStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TeamTierInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, TeamTierTable, TeamTierColumn),
	)
}
func newEnvsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(EnvsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, EnvsTable, EnvsColumn),
	)
}
func newUsersTeamsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(UsersTeamsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, true, UsersTeamsTable, UsersTeamsColumn),
	)
}



================================================
File: models/team/where.go
================================================
// Code generated by ent, DO NOT EDIT.

package team

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/google/uuid"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.Team {
	return predicate.Team(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.Team {
	return predicate.Team(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.Team {
	return predicate.Team(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.Team {
	return predicate.Team(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.Team {
	return predicate.Team(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.Team {
	return predicate.Team(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.Team {
	return predicate.Team(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.Team {
	return predicate.Team(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.Team {
	return predicate.Team(sql.FieldLTE(FieldID, id))
}

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.Team {
	return predicate.Team(sql.FieldEQ(FieldCreatedAt, v))
}

// IsBanned applies equality check predicate on the "is_banned" field. It's identical to IsBannedEQ.
func IsBanned(v bool) predicate.Team {
	return predicate.Team(sql.FieldEQ(FieldIsBanned, v))
}

// IsBlocked applies equality check predicate on the "is_blocked" field. It's identical to IsBlockedEQ.
func IsBlocked(v bool) predicate.Team {
	return predicate.Team(sql.FieldEQ(FieldIsBlocked, v))
}

// BlockedReason applies equality check predicate on the "blocked_reason" field. It's identical to BlockedReasonEQ.
func BlockedReason(v string) predicate.Team {
	return predicate.Team(sql.FieldEQ(FieldBlockedReason, v))
}

// Name applies equality check predicate on the "name" field. It's identical to NameEQ.
func Name(v string) predicate.Team {
	return predicate.Team(sql.FieldEQ(FieldName, v))
}

// Tier applies equality check predicate on the "tier" field. It's identical to TierEQ.
func Tier(v string) predicate.Team {
	return predicate.Team(sql.FieldEQ(FieldTier, v))
}

// Email applies equality check predicate on the "email" field. It's identical to EmailEQ.
func Email(v string) predicate.Team {
	return predicate.Team(sql.FieldEQ(FieldEmail, v))
}

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.Team {
	return predicate.Team(sql.FieldEQ(FieldCreatedAt, v))
}

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.Team {
	return predicate.Team(sql.FieldNEQ(FieldCreatedAt, v))
}

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.Team {
	return predicate.Team(sql.FieldIn(FieldCreatedAt, vs...))
}

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.Team {
	return predicate.Team(sql.FieldNotIn(FieldCreatedAt, vs...))
}

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.Team {
	return predicate.Team(sql.FieldGT(FieldCreatedAt, v))
}

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.Team {
	return predicate.Team(sql.FieldGTE(FieldCreatedAt, v))
}

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.Team {
	return predicate.Team(sql.FieldLT(FieldCreatedAt, v))
}

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.Team {
	return predicate.Team(sql.FieldLTE(FieldCreatedAt, v))
}

// IsBannedEQ applies the EQ predicate on the "is_banned" field.
func IsBannedEQ(v bool) predicate.Team {
	return predicate.Team(sql.FieldEQ(FieldIsBanned, v))
}

// IsBannedNEQ applies the NEQ predicate on the "is_banned" field.
func IsBannedNEQ(v bool) predicate.Team {
	return predicate.Team(sql.FieldNEQ(FieldIsBanned, v))
}

// IsBannedIsNil applies the IsNil predicate on the "is_banned" field.
func IsBannedIsNil() predicate.Team {
	return predicate.Team(sql.FieldIsNull(FieldIsBanned))
}

// IsBannedNotNil applies the NotNil predicate on the "is_banned" field.
func IsBannedNotNil() predicate.Team {
	return predicate.Team(sql.FieldNotNull(FieldIsBanned))
}

// IsBlockedEQ applies the EQ predicate on the "is_blocked" field.
func IsBlockedEQ(v bool) predicate.Team {
	return predicate.Team(sql.FieldEQ(FieldIsBlocked, v))
}

// IsBlockedNEQ applies the NEQ predicate on the "is_blocked" field.
func IsBlockedNEQ(v bool) predicate.Team {
	return predicate.Team(sql.FieldNEQ(FieldIsBlocked, v))
}

// IsBlockedIsNil applies the IsNil predicate on the "is_blocked" field.
func IsBlockedIsNil() predicate.Team {
	return predicate.Team(sql.FieldIsNull(FieldIsBlocked))
}

// IsBlockedNotNil applies the NotNil predicate on the "is_blocked" field.
func IsBlockedNotNil() predicate.Team {
	return predicate.Team(sql.FieldNotNull(FieldIsBlocked))
}

// BlockedReasonEQ applies the EQ predicate on the "blocked_reason" field.
func BlockedReasonEQ(v string) predicate.Team {
	return predicate.Team(sql.FieldEQ(FieldBlockedReason, v))
}

// BlockedReasonNEQ applies the NEQ predicate on the "blocked_reason" field.
func BlockedReasonNEQ(v string) predicate.Team {
	return predicate.Team(sql.FieldNEQ(FieldBlockedReason, v))
}

// BlockedReasonIn applies the In predicate on the "blocked_reason" field.
func BlockedReasonIn(vs ...string) predicate.Team {
	return predicate.Team(sql.FieldIn(FieldBlockedReason, vs...))
}

// BlockedReasonNotIn applies the NotIn predicate on the "blocked_reason" field.
func BlockedReasonNotIn(vs ...string) predicate.Team {
	return predicate.Team(sql.FieldNotIn(FieldBlockedReason, vs...))
}

// BlockedReasonGT applies the GT predicate on the "blocked_reason" field.
func BlockedReasonGT(v string) predicate.Team {
	return predicate.Team(sql.FieldGT(FieldBlockedReason, v))
}

// BlockedReasonGTE applies the GTE predicate on the "blocked_reason" field.
func BlockedReasonGTE(v string) predicate.Team {
	return predicate.Team(sql.FieldGTE(FieldBlockedReason, v))
}

// BlockedReasonLT applies the LT predicate on the "blocked_reason" field.
func BlockedReasonLT(v string) predicate.Team {
	return predicate.Team(sql.FieldLT(FieldBlockedReason, v))
}

// BlockedReasonLTE applies the LTE predicate on the "blocked_reason" field.
func BlockedReasonLTE(v string) predicate.Team {
	return predicate.Team(sql.FieldLTE(FieldBlockedReason, v))
}

// BlockedReasonContains applies the Contains predicate on the "blocked_reason" field.
func BlockedReasonContains(v string) predicate.Team {
	return predicate.Team(sql.FieldContains(FieldBlockedReason, v))
}

// BlockedReasonHasPrefix applies the HasPrefix predicate on the "blocked_reason" field.
func BlockedReasonHasPrefix(v string) predicate.Team {
	return predicate.Team(sql.FieldHasPrefix(FieldBlockedReason, v))
}

// BlockedReasonHasSuffix applies the HasSuffix predicate on the "blocked_reason" field.
func BlockedReasonHasSuffix(v string) predicate.Team {
	return predicate.Team(sql.FieldHasSuffix(FieldBlockedReason, v))
}

// BlockedReasonIsNil applies the IsNil predicate on the "blocked_reason" field.
func BlockedReasonIsNil() predicate.Team {
	return predicate.Team(sql.FieldIsNull(FieldBlockedReason))
}

// BlockedReasonNotNil applies the NotNil predicate on the "blocked_reason" field.
func BlockedReasonNotNil() predicate.Team {
	return predicate.Team(sql.FieldNotNull(FieldBlockedReason))
}

// BlockedReasonEqualFold applies the EqualFold predicate on the "blocked_reason" field.
func BlockedReasonEqualFold(v string) predicate.Team {
	return predicate.Team(sql.FieldEqualFold(FieldBlockedReason, v))
}

// BlockedReasonContainsFold applies the ContainsFold predicate on the "blocked_reason" field.
func BlockedReasonContainsFold(v string) predicate.Team {
	return predicate.Team(sql.FieldContainsFold(FieldBlockedReason, v))
}

// NameEQ applies the EQ predicate on the "name" field.
func NameEQ(v string) predicate.Team {
	return predicate.Team(sql.FieldEQ(FieldName, v))
}

// NameNEQ applies the NEQ predicate on the "name" field.
func NameNEQ(v string) predicate.Team {
	return predicate.Team(sql.FieldNEQ(FieldName, v))
}

// NameIn applies the In predicate on the "name" field.
func NameIn(vs ...string) predicate.Team {
	return predicate.Team(sql.FieldIn(FieldName, vs...))
}

// NameNotIn applies the NotIn predicate on the "name" field.
func NameNotIn(vs ...string) predicate.Team {
	return predicate.Team(sql.FieldNotIn(FieldName, vs...))
}

// NameGT applies the GT predicate on the "name" field.
func NameGT(v string) predicate.Team {
	return predicate.Team(sql.FieldGT(FieldName, v))
}

// NameGTE applies the GTE predicate on the "name" field.
func NameGTE(v string) predicate.Team {
	return predicate.Team(sql.FieldGTE(FieldName, v))
}

// NameLT applies the LT predicate on the "name" field.
func NameLT(v string) predicate.Team {
	return predicate.Team(sql.FieldLT(FieldName, v))
}

// NameLTE applies the LTE predicate on the "name" field.
func NameLTE(v string) predicate.Team {
	return predicate.Team(sql.FieldLTE(FieldName, v))
}

// NameContains applies the Contains predicate on the "name" field.
func NameContains(v string) predicate.Team {
	return predicate.Team(sql.FieldContains(FieldName, v))
}

// NameHasPrefix applies the HasPrefix predicate on the "name" field.
func NameHasPrefix(v string) predicate.Team {
	return predicate.Team(sql.FieldHasPrefix(FieldName, v))
}

// NameHasSuffix applies the HasSuffix predicate on the "name" field.
func NameHasSuffix(v string) predicate.Team {
	return predicate.Team(sql.FieldHasSuffix(FieldName, v))
}

// NameEqualFold applies the EqualFold predicate on the "name" field.
func NameEqualFold(v string) predicate.Team {
	return predicate.Team(sql.FieldEqualFold(FieldName, v))
}

// NameContainsFold applies the ContainsFold predicate on the "name" field.
func NameContainsFold(v string) predicate.Team {
	return predicate.Team(sql.FieldContainsFold(FieldName, v))
}

// TierEQ applies the EQ predicate on the "tier" field.
func TierEQ(v string) predicate.Team {
	return predicate.Team(sql.FieldEQ(FieldTier, v))
}

// TierNEQ applies the NEQ predicate on the "tier" field.
func TierNEQ(v string) predicate.Team {
	return predicate.Team(sql.FieldNEQ(FieldTier, v))
}

// TierIn applies the In predicate on the "tier" field.
func TierIn(vs ...string) predicate.Team {
	return predicate.Team(sql.FieldIn(FieldTier, vs...))
}

// TierNotIn applies the NotIn predicate on the "tier" field.
func TierNotIn(vs ...string) predicate.Team {
	return predicate.Team(sql.FieldNotIn(FieldTier, vs...))
}

// TierGT applies the GT predicate on the "tier" field.
func TierGT(v string) predicate.Team {
	return predicate.Team(sql.FieldGT(FieldTier, v))
}

// TierGTE applies the GTE predicate on the "tier" field.
func TierGTE(v string) predicate.Team {
	return predicate.Team(sql.FieldGTE(FieldTier, v))
}

// TierLT applies the LT predicate on the "tier" field.
func TierLT(v string) predicate.Team {
	return predicate.Team(sql.FieldLT(FieldTier, v))
}

// TierLTE applies the LTE predicate on the "tier" field.
func TierLTE(v string) predicate.Team {
	return predicate.Team(sql.FieldLTE(FieldTier, v))
}

// TierContains applies the Contains predicate on the "tier" field.
func TierContains(v string) predicate.Team {
	return predicate.Team(sql.FieldContains(FieldTier, v))
}

// TierHasPrefix applies the HasPrefix predicate on the "tier" field.
func TierHasPrefix(v string) predicate.Team {
	return predicate.Team(sql.FieldHasPrefix(FieldTier, v))
}

// TierHasSuffix applies the HasSuffix predicate on the "tier" field.
func TierHasSuffix(v string) predicate.Team {
	return predicate.Team(sql.FieldHasSuffix(FieldTier, v))
}

// TierEqualFold applies the EqualFold predicate on the "tier" field.
func TierEqualFold(v string) predicate.Team {
	return predicate.Team(sql.FieldEqualFold(FieldTier, v))
}

// TierContainsFold applies the ContainsFold predicate on the "tier" field.
func TierContainsFold(v string) predicate.Team {
	return predicate.Team(sql.FieldContainsFold(FieldTier, v))
}

// EmailEQ applies the EQ predicate on the "email" field.
func EmailEQ(v string) predicate.Team {
	return predicate.Team(sql.FieldEQ(FieldEmail, v))
}

// EmailNEQ applies the NEQ predicate on the "email" field.
func EmailNEQ(v string) predicate.Team {
	return predicate.Team(sql.FieldNEQ(FieldEmail, v))
}

// EmailIn applies the In predicate on the "email" field.
func EmailIn(vs ...string) predicate.Team {
	return predicate.Team(sql.FieldIn(FieldEmail, vs...))
}

// EmailNotIn applies the NotIn predicate on the "email" field.
func EmailNotIn(vs ...string) predicate.Team {
	return predicate.Team(sql.FieldNotIn(FieldEmail, vs...))
}

// EmailGT applies the GT predicate on the "email" field.
func EmailGT(v string) predicate.Team {
	return predicate.Team(sql.FieldGT(FieldEmail, v))
}

// EmailGTE applies the GTE predicate on the "email" field.
func EmailGTE(v string) predicate.Team {
	return predicate.Team(sql.FieldGTE(FieldEmail, v))
}

// EmailLT applies the LT predicate on the "email" field.
func EmailLT(v string) predicate.Team {
	return predicate.Team(sql.FieldLT(FieldEmail, v))
}

// EmailLTE applies the LTE predicate on the "email" field.
func EmailLTE(v string) predicate.Team {
	return predicate.Team(sql.FieldLTE(FieldEmail, v))
}

// EmailContains applies the Contains predicate on the "email" field.
func EmailContains(v string) predicate.Team {
	return predicate.Team(sql.FieldContains(FieldEmail, v))
}

// EmailHasPrefix applies the HasPrefix predicate on the "email" field.
func EmailHasPrefix(v string) predicate.Team {
	return predicate.Team(sql.FieldHasPrefix(FieldEmail, v))
}

// EmailHasSuffix applies the HasSuffix predicate on the "email" field.
func EmailHasSuffix(v string) predicate.Team {
	return predicate.Team(sql.FieldHasSuffix(FieldEmail, v))
}

// EmailEqualFold applies the EqualFold predicate on the "email" field.
func EmailEqualFold(v string) predicate.Team {
	return predicate.Team(sql.FieldEqualFold(FieldEmail, v))
}

// EmailContainsFold applies the ContainsFold predicate on the "email" field.
func EmailContainsFold(v string) predicate.Team {
	return predicate.Team(sql.FieldContainsFold(FieldEmail, v))
}

// HasUsers applies the HasEdge predicate on the "users" edge.
func HasUsers() predicate.Team {
	return predicate.Team(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, UsersTable, UsersPrimaryKey...),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.UsersTeams
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasUsersWith applies the HasEdge predicate on the "users" edge with a given conditions (other predicates).
func HasUsersWith(preds ...predicate.User) predicate.Team {
	return predicate.Team(func(s *sql.Selector) {
		step := newUsersStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.UsersTeams
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasTeamAPIKeys applies the HasEdge predicate on the "team_api_keys" edge.
func HasTeamAPIKeys() predicate.Team {
	return predicate.Team(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, TeamAPIKeysTable, TeamAPIKeysColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.TeamAPIKey
		step.Edge.Schema = schemaConfig.TeamAPIKey
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasTeamAPIKeysWith applies the HasEdge predicate on the "team_api_keys" edge with a given conditions (other predicates).
func HasTeamAPIKeysWith(preds ...predicate.TeamAPIKey) predicate.Team {
	return predicate.Team(func(s *sql.Selector) {
		step := newTeamAPIKeysStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.TeamAPIKey
		step.Edge.Schema = schemaConfig.TeamAPIKey
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasTeamTier applies the HasEdge predicate on the "team_tier" edge.
func HasTeamTier() predicate.Team {
	return predicate.Team(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, TeamTierTable, TeamTierColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Tier
		step.Edge.Schema = schemaConfig.Team
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasTeamTierWith applies the HasEdge predicate on the "team_tier" edge with a given conditions (other predicates).
func HasTeamTierWith(preds ...predicate.Tier) predicate.Team {
	return predicate.Team(func(s *sql.Selector) {
		step := newTeamTierStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Tier
		step.Edge.Schema = schemaConfig.Team
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasEnvs applies the HasEdge predicate on the "envs" edge.
func HasEnvs() predicate.Team {
	return predicate.Team(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, EnvsTable, EnvsColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.Env
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasEnvsWith applies the HasEdge predicate on the "envs" edge with a given conditions (other predicates).
func HasEnvsWith(preds ...predicate.Env) predicate.Team {
	return predicate.Team(func(s *sql.Selector) {
		step := newEnvsStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.Env
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasUsersTeams applies the HasEdge predicate on the "users_teams" edge.
func HasUsersTeams() predicate.Team {
	return predicate.Team(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, UsersTeamsTable, UsersTeamsColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.UsersTeams
		step.Edge.Schema = schemaConfig.UsersTeams
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasUsersTeamsWith applies the HasEdge predicate on the "users_teams" edge with a given conditions (other predicates).
func HasUsersTeamsWith(preds ...predicate.UsersTeams) predicate.Team {
	return predicate.Team(func(s *sql.Selector) {
		step := newUsersTeamsStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.UsersTeams
		step.Edge.Schema = schemaConfig.UsersTeams
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Team) predicate.Team {
	return predicate.Team(sql.AndPredicates(predicates...))
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Team) predicate.Team {
	return predicate.Team(sql.OrPredicates(predicates...))
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Team) predicate.Team {
	return predicate.Team(sql.NotPredicates(p))
}



================================================
File: models/teamapikey/teamapikey.go
================================================
// Code generated by ent, DO NOT EDIT.

package teamapikey

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the teamapikey type in the database.
	Label = "team_api_key"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldAPIKey holds the string denoting the api_key field in the database.
	FieldAPIKey = "api_key"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// FieldTeamID holds the string denoting the team_id field in the database.
	FieldTeamID = "team_id"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// FieldCreatedBy holds the string denoting the created_by field in the database.
	FieldCreatedBy = "created_by"
	// FieldLastUsed holds the string denoting the last_used field in the database.
	FieldLastUsed = "last_used"
	// EdgeTeam holds the string denoting the team edge name in mutations.
	EdgeTeam = "team"
	// EdgeCreator holds the string denoting the creator edge name in mutations.
	EdgeCreator = "creator"
	// Table holds the table name of the teamapikey in the database.
	Table = "team_api_keys"
	// TeamTable is the table that holds the team relation/edge.
	TeamTable = "team_api_keys"
	// TeamInverseTable is the table name for the Team entity.
	// It exists in this package in order to avoid circular dependency with the "team" package.
	TeamInverseTable = "teams"
	// TeamColumn is the table column denoting the team relation/edge.
	TeamColumn = "team_id"
	// CreatorTable is the table that holds the creator relation/edge.
	CreatorTable = "team_api_keys"
	// CreatorInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	CreatorInverseTable = "users"
	// CreatorColumn is the table column denoting the creator relation/edge.
	CreatorColumn = "created_by"
)

// Columns holds all SQL columns for teamapikey fields.
var Columns = []string{
	FieldID,
	FieldAPIKey,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldTeamID,
	FieldName,
	FieldCreatedBy,
	FieldLastUsed,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
	// DefaultName holds the default value on creation for the "name" field.
	DefaultName string
)

// OrderOption defines the ordering options for the TeamAPIKey queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByAPIKey orders the results by the api_key field.
func ByAPIKey(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAPIKey, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByTeamID orders the results by the team_id field.
func ByTeamID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTeamID, opts...).ToFunc()
}

// ByName orders the results by the name field.
func ByName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldName, opts...).ToFunc()
}

// ByCreatedBy orders the results by the created_by field.
func ByCreatedBy(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedBy, opts...).ToFunc()
}

// ByLastUsed orders the results by the last_used field.
func ByLastUsed(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldLastUsed, opts...).ToFunc()
}

// ByTeamField orders the results by team field.
func ByTeamField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTeamStep(), sql.OrderByField(field, opts...))
	}
}

// ByCreatorField orders the results by creator field.
func ByCreatorField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCreatorStep(), sql.OrderByField(field, opts...))
	}
}
func newTeamStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TeamInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, TeamTable, TeamColumn),
	)
}
func newCreatorStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CreatorInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, CreatorTable, CreatorColumn),
	)
}



================================================
File: models/teamapikey/where.go
================================================
// Code generated by ent, DO NOT EDIT.

package teamapikey

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/google/uuid"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldLTE(FieldID, id))
}

// APIKey applies equality check predicate on the "api_key" field. It's identical to APIKeyEQ.
func APIKey(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEQ(FieldAPIKey, v))
}

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEQ(FieldCreatedAt, v))
}

// UpdatedAt applies equality check predicate on the "updated_at" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEQ(FieldUpdatedAt, v))
}

// TeamID applies equality check predicate on the "team_id" field. It's identical to TeamIDEQ.
func TeamID(v uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEQ(FieldTeamID, v))
}

// Name applies equality check predicate on the "name" field. It's identical to NameEQ.
func Name(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEQ(FieldName, v))
}

// CreatedBy applies equality check predicate on the "created_by" field. It's identical to CreatedByEQ.
func CreatedBy(v uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEQ(FieldCreatedBy, v))
}

// LastUsed applies equality check predicate on the "last_used" field. It's identical to LastUsedEQ.
func LastUsed(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEQ(FieldLastUsed, v))
}

// APIKeyEQ applies the EQ predicate on the "api_key" field.
func APIKeyEQ(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEQ(FieldAPIKey, v))
}

// APIKeyNEQ applies the NEQ predicate on the "api_key" field.
func APIKeyNEQ(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNEQ(FieldAPIKey, v))
}

// APIKeyIn applies the In predicate on the "api_key" field.
func APIKeyIn(vs ...string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldIn(FieldAPIKey, vs...))
}

// APIKeyNotIn applies the NotIn predicate on the "api_key" field.
func APIKeyNotIn(vs ...string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNotIn(FieldAPIKey, vs...))
}

// APIKeyGT applies the GT predicate on the "api_key" field.
func APIKeyGT(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldGT(FieldAPIKey, v))
}

// APIKeyGTE applies the GTE predicate on the "api_key" field.
func APIKeyGTE(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldGTE(FieldAPIKey, v))
}

// APIKeyLT applies the LT predicate on the "api_key" field.
func APIKeyLT(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldLT(FieldAPIKey, v))
}

// APIKeyLTE applies the LTE predicate on the "api_key" field.
func APIKeyLTE(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldLTE(FieldAPIKey, v))
}

// APIKeyContains applies the Contains predicate on the "api_key" field.
func APIKeyContains(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldContains(FieldAPIKey, v))
}

// APIKeyHasPrefix applies the HasPrefix predicate on the "api_key" field.
func APIKeyHasPrefix(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldHasPrefix(FieldAPIKey, v))
}

// APIKeyHasSuffix applies the HasSuffix predicate on the "api_key" field.
func APIKeyHasSuffix(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldHasSuffix(FieldAPIKey, v))
}

// APIKeyEqualFold applies the EqualFold predicate on the "api_key" field.
func APIKeyEqualFold(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEqualFold(FieldAPIKey, v))
}

// APIKeyContainsFold applies the ContainsFold predicate on the "api_key" field.
func APIKeyContainsFold(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldContainsFold(FieldAPIKey, v))
}

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEQ(FieldCreatedAt, v))
}

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNEQ(FieldCreatedAt, v))
}

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldIn(FieldCreatedAt, vs...))
}

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNotIn(FieldCreatedAt, vs...))
}

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldGT(FieldCreatedAt, v))
}

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldGTE(FieldCreatedAt, v))
}

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldLT(FieldCreatedAt, v))
}

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldLTE(FieldCreatedAt, v))
}

// UpdatedAtEQ applies the EQ predicate on the "updated_at" field.
func UpdatedAtEQ(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEQ(FieldUpdatedAt, v))
}

// UpdatedAtNEQ applies the NEQ predicate on the "updated_at" field.
func UpdatedAtNEQ(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNEQ(FieldUpdatedAt, v))
}

// UpdatedAtIn applies the In predicate on the "updated_at" field.
func UpdatedAtIn(vs ...time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldIn(FieldUpdatedAt, vs...))
}

// UpdatedAtNotIn applies the NotIn predicate on the "updated_at" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNotIn(FieldUpdatedAt, vs...))
}

// UpdatedAtGT applies the GT predicate on the "updated_at" field.
func UpdatedAtGT(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldGT(FieldUpdatedAt, v))
}

// UpdatedAtGTE applies the GTE predicate on the "updated_at" field.
func UpdatedAtGTE(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldGTE(FieldUpdatedAt, v))
}

// UpdatedAtLT applies the LT predicate on the "updated_at" field.
func UpdatedAtLT(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldLT(FieldUpdatedAt, v))
}

// UpdatedAtLTE applies the LTE predicate on the "updated_at" field.
func UpdatedAtLTE(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldLTE(FieldUpdatedAt, v))
}

// UpdatedAtIsNil applies the IsNil predicate on the "updated_at" field.
func UpdatedAtIsNil() predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldIsNull(FieldUpdatedAt))
}

// UpdatedAtNotNil applies the NotNil predicate on the "updated_at" field.
func UpdatedAtNotNil() predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNotNull(FieldUpdatedAt))
}

// TeamIDEQ applies the EQ predicate on the "team_id" field.
func TeamIDEQ(v uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEQ(FieldTeamID, v))
}

// TeamIDNEQ applies the NEQ predicate on the "team_id" field.
func TeamIDNEQ(v uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNEQ(FieldTeamID, v))
}

// TeamIDIn applies the In predicate on the "team_id" field.
func TeamIDIn(vs ...uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldIn(FieldTeamID, vs...))
}

// TeamIDNotIn applies the NotIn predicate on the "team_id" field.
func TeamIDNotIn(vs ...uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNotIn(FieldTeamID, vs...))
}

// NameEQ applies the EQ predicate on the "name" field.
func NameEQ(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEQ(FieldName, v))
}

// NameNEQ applies the NEQ predicate on the "name" field.
func NameNEQ(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNEQ(FieldName, v))
}

// NameIn applies the In predicate on the "name" field.
func NameIn(vs ...string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldIn(FieldName, vs...))
}

// NameNotIn applies the NotIn predicate on the "name" field.
func NameNotIn(vs ...string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNotIn(FieldName, vs...))
}

// NameGT applies the GT predicate on the "name" field.
func NameGT(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldGT(FieldName, v))
}

// NameGTE applies the GTE predicate on the "name" field.
func NameGTE(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldGTE(FieldName, v))
}

// NameLT applies the LT predicate on the "name" field.
func NameLT(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldLT(FieldName, v))
}

// NameLTE applies the LTE predicate on the "name" field.
func NameLTE(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldLTE(FieldName, v))
}

// NameContains applies the Contains predicate on the "name" field.
func NameContains(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldContains(FieldName, v))
}

// NameHasPrefix applies the HasPrefix predicate on the "name" field.
func NameHasPrefix(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldHasPrefix(FieldName, v))
}

// NameHasSuffix applies the HasSuffix predicate on the "name" field.
func NameHasSuffix(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldHasSuffix(FieldName, v))
}

// NameEqualFold applies the EqualFold predicate on the "name" field.
func NameEqualFold(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEqualFold(FieldName, v))
}

// NameContainsFold applies the ContainsFold predicate on the "name" field.
func NameContainsFold(v string) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldContainsFold(FieldName, v))
}

// CreatedByEQ applies the EQ predicate on the "created_by" field.
func CreatedByEQ(v uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEQ(FieldCreatedBy, v))
}

// CreatedByNEQ applies the NEQ predicate on the "created_by" field.
func CreatedByNEQ(v uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNEQ(FieldCreatedBy, v))
}

// CreatedByIn applies the In predicate on the "created_by" field.
func CreatedByIn(vs ...uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldIn(FieldCreatedBy, vs...))
}

// CreatedByNotIn applies the NotIn predicate on the "created_by" field.
func CreatedByNotIn(vs ...uuid.UUID) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNotIn(FieldCreatedBy, vs...))
}

// CreatedByIsNil applies the IsNil predicate on the "created_by" field.
func CreatedByIsNil() predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldIsNull(FieldCreatedBy))
}

// CreatedByNotNil applies the NotNil predicate on the "created_by" field.
func CreatedByNotNil() predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNotNull(FieldCreatedBy))
}

// LastUsedEQ applies the EQ predicate on the "last_used" field.
func LastUsedEQ(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldEQ(FieldLastUsed, v))
}

// LastUsedNEQ applies the NEQ predicate on the "last_used" field.
func LastUsedNEQ(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNEQ(FieldLastUsed, v))
}

// LastUsedIn applies the In predicate on the "last_used" field.
func LastUsedIn(vs ...time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldIn(FieldLastUsed, vs...))
}

// LastUsedNotIn applies the NotIn predicate on the "last_used" field.
func LastUsedNotIn(vs ...time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNotIn(FieldLastUsed, vs...))
}

// LastUsedGT applies the GT predicate on the "last_used" field.
func LastUsedGT(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldGT(FieldLastUsed, v))
}

// LastUsedGTE applies the GTE predicate on the "last_used" field.
func LastUsedGTE(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldGTE(FieldLastUsed, v))
}

// LastUsedLT applies the LT predicate on the "last_used" field.
func LastUsedLT(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldLT(FieldLastUsed, v))
}

// LastUsedLTE applies the LTE predicate on the "last_used" field.
func LastUsedLTE(v time.Time) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldLTE(FieldLastUsed, v))
}

// LastUsedIsNil applies the IsNil predicate on the "last_used" field.
func LastUsedIsNil() predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldIsNull(FieldLastUsed))
}

// LastUsedNotNil applies the NotNil predicate on the "last_used" field.
func LastUsedNotNil() predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.FieldNotNull(FieldLastUsed))
}

// HasTeam applies the HasEdge predicate on the "team" edge.
func HasTeam() predicate.TeamAPIKey {
	return predicate.TeamAPIKey(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, TeamTable, TeamColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.TeamAPIKey
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasTeamWith applies the HasEdge predicate on the "team" edge with a given conditions (other predicates).
func HasTeamWith(preds ...predicate.Team) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(func(s *sql.Selector) {
		step := newTeamStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.TeamAPIKey
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasCreator applies the HasEdge predicate on the "creator" edge.
func HasCreator() predicate.TeamAPIKey {
	return predicate.TeamAPIKey(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, CreatorTable, CreatorColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.TeamAPIKey
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasCreatorWith applies the HasEdge predicate on the "creator" edge with a given conditions (other predicates).
func HasCreatorWith(preds ...predicate.User) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(func(s *sql.Selector) {
		step := newCreatorStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.TeamAPIKey
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.TeamAPIKey) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.AndPredicates(predicates...))
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.TeamAPIKey) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.OrPredicates(predicates...))
}

// Not applies the not operator on the given predicate.
func Not(p predicate.TeamAPIKey) predicate.TeamAPIKey {
	return predicate.TeamAPIKey(sql.NotPredicates(p))
}



================================================
File: models/tier/tier.go
================================================
// Code generated by ent, DO NOT EDIT.

package tier

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the tier type in the database.
	Label = "tier"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// FieldDiskMB holds the string denoting the disk_mb field in the database.
	FieldDiskMB = "disk_mb"
	// FieldConcurrentInstances holds the string denoting the concurrent_instances field in the database.
	FieldConcurrentInstances = "concurrent_instances"
	// FieldMaxLengthHours holds the string denoting the max_length_hours field in the database.
	FieldMaxLengthHours = "max_length_hours"
	// EdgeTeams holds the string denoting the teams edge name in mutations.
	EdgeTeams = "teams"
	// Table holds the table name of the tier in the database.
	Table = "tiers"
	// TeamsTable is the table that holds the teams relation/edge.
	TeamsTable = "teams"
	// TeamsInverseTable is the table name for the Team entity.
	// It exists in this package in order to avoid circular dependency with the "team" package.
	TeamsInverseTable = "teams"
	// TeamsColumn is the table column denoting the teams relation/edge.
	TeamsColumn = "tier"
)

// Columns holds all SQL columns for tier fields.
var Columns = []string{
	FieldID,
	FieldName,
	FieldDiskMB,
	FieldConcurrentInstances,
	FieldMaxLengthHours,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

// OrderOption defines the ordering options for the Tier queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByName orders the results by the name field.
func ByName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldName, opts...).ToFunc()
}

// ByDiskMB orders the results by the disk_mb field.
func ByDiskMB(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDiskMB, opts...).ToFunc()
}

// ByConcurrentInstances orders the results by the concurrent_instances field.
func ByConcurrentInstances(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldConcurrentInstances, opts...).ToFunc()
}

// ByMaxLengthHours orders the results by the max_length_hours field.
func ByMaxLengthHours(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldMaxLengthHours, opts...).ToFunc()
}

// ByTeamsCount orders the results by teams count.
func ByTeamsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newTeamsStep(), opts...)
	}
}

// ByTeams orders the results by teams terms.
func ByTeams(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTeamsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newTeamsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TeamsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, TeamsTable, TeamsColumn),
	)
}



================================================
File: models/tier/where.go
================================================
// Code generated by ent, DO NOT EDIT.

package tier

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
)

// ID filters vertices based on their ID field.
func ID(id string) predicate.Tier {
	return predicate.Tier(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id string) predicate.Tier {
	return predicate.Tier(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id string) predicate.Tier {
	return predicate.Tier(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...string) predicate.Tier {
	return predicate.Tier(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...string) predicate.Tier {
	return predicate.Tier(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id string) predicate.Tier {
	return predicate.Tier(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id string) predicate.Tier {
	return predicate.Tier(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id string) predicate.Tier {
	return predicate.Tier(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id string) predicate.Tier {
	return predicate.Tier(sql.FieldLTE(FieldID, id))
}

// IDEqualFold applies the EqualFold predicate on the ID field.
func IDEqualFold(id string) predicate.Tier {
	return predicate.Tier(sql.FieldEqualFold(FieldID, id))
}

// IDContainsFold applies the ContainsFold predicate on the ID field.
func IDContainsFold(id string) predicate.Tier {
	return predicate.Tier(sql.FieldContainsFold(FieldID, id))
}

// Name applies equality check predicate on the "name" field. It's identical to NameEQ.
func Name(v string) predicate.Tier {
	return predicate.Tier(sql.FieldEQ(FieldName, v))
}

// DiskMB applies equality check predicate on the "disk_mb" field. It's identical to DiskMBEQ.
func DiskMB(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldEQ(FieldDiskMB, v))
}

// ConcurrentInstances applies equality check predicate on the "concurrent_instances" field. It's identical to ConcurrentInstancesEQ.
func ConcurrentInstances(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldEQ(FieldConcurrentInstances, v))
}

// MaxLengthHours applies equality check predicate on the "max_length_hours" field. It's identical to MaxLengthHoursEQ.
func MaxLengthHours(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldEQ(FieldMaxLengthHours, v))
}

// NameEQ applies the EQ predicate on the "name" field.
func NameEQ(v string) predicate.Tier {
	return predicate.Tier(sql.FieldEQ(FieldName, v))
}

// NameNEQ applies the NEQ predicate on the "name" field.
func NameNEQ(v string) predicate.Tier {
	return predicate.Tier(sql.FieldNEQ(FieldName, v))
}

// NameIn applies the In predicate on the "name" field.
func NameIn(vs ...string) predicate.Tier {
	return predicate.Tier(sql.FieldIn(FieldName, vs...))
}

// NameNotIn applies the NotIn predicate on the "name" field.
func NameNotIn(vs ...string) predicate.Tier {
	return predicate.Tier(sql.FieldNotIn(FieldName, vs...))
}

// NameGT applies the GT predicate on the "name" field.
func NameGT(v string) predicate.Tier {
	return predicate.Tier(sql.FieldGT(FieldName, v))
}

// NameGTE applies the GTE predicate on the "name" field.
func NameGTE(v string) predicate.Tier {
	return predicate.Tier(sql.FieldGTE(FieldName, v))
}

// NameLT applies the LT predicate on the "name" field.
func NameLT(v string) predicate.Tier {
	return predicate.Tier(sql.FieldLT(FieldName, v))
}

// NameLTE applies the LTE predicate on the "name" field.
func NameLTE(v string) predicate.Tier {
	return predicate.Tier(sql.FieldLTE(FieldName, v))
}

// NameContains applies the Contains predicate on the "name" field.
func NameContains(v string) predicate.Tier {
	return predicate.Tier(sql.FieldContains(FieldName, v))
}

// NameHasPrefix applies the HasPrefix predicate on the "name" field.
func NameHasPrefix(v string) predicate.Tier {
	return predicate.Tier(sql.FieldHasPrefix(FieldName, v))
}

// NameHasSuffix applies the HasSuffix predicate on the "name" field.
func NameHasSuffix(v string) predicate.Tier {
	return predicate.Tier(sql.FieldHasSuffix(FieldName, v))
}

// NameEqualFold applies the EqualFold predicate on the "name" field.
func NameEqualFold(v string) predicate.Tier {
	return predicate.Tier(sql.FieldEqualFold(FieldName, v))
}

// NameContainsFold applies the ContainsFold predicate on the "name" field.
func NameContainsFold(v string) predicate.Tier {
	return predicate.Tier(sql.FieldContainsFold(FieldName, v))
}

// DiskMBEQ applies the EQ predicate on the "disk_mb" field.
func DiskMBEQ(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldEQ(FieldDiskMB, v))
}

// DiskMBNEQ applies the NEQ predicate on the "disk_mb" field.
func DiskMBNEQ(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldNEQ(FieldDiskMB, v))
}

// DiskMBIn applies the In predicate on the "disk_mb" field.
func DiskMBIn(vs ...int64) predicate.Tier {
	return predicate.Tier(sql.FieldIn(FieldDiskMB, vs...))
}

// DiskMBNotIn applies the NotIn predicate on the "disk_mb" field.
func DiskMBNotIn(vs ...int64) predicate.Tier {
	return predicate.Tier(sql.FieldNotIn(FieldDiskMB, vs...))
}

// DiskMBGT applies the GT predicate on the "disk_mb" field.
func DiskMBGT(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldGT(FieldDiskMB, v))
}

// DiskMBGTE applies the GTE predicate on the "disk_mb" field.
func DiskMBGTE(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldGTE(FieldDiskMB, v))
}

// DiskMBLT applies the LT predicate on the "disk_mb" field.
func DiskMBLT(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldLT(FieldDiskMB, v))
}

// DiskMBLTE applies the LTE predicate on the "disk_mb" field.
func DiskMBLTE(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldLTE(FieldDiskMB, v))
}

// ConcurrentInstancesEQ applies the EQ predicate on the "concurrent_instances" field.
func ConcurrentInstancesEQ(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldEQ(FieldConcurrentInstances, v))
}

// ConcurrentInstancesNEQ applies the NEQ predicate on the "concurrent_instances" field.
func ConcurrentInstancesNEQ(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldNEQ(FieldConcurrentInstances, v))
}

// ConcurrentInstancesIn applies the In predicate on the "concurrent_instances" field.
func ConcurrentInstancesIn(vs ...int64) predicate.Tier {
	return predicate.Tier(sql.FieldIn(FieldConcurrentInstances, vs...))
}

// ConcurrentInstancesNotIn applies the NotIn predicate on the "concurrent_instances" field.
func ConcurrentInstancesNotIn(vs ...int64) predicate.Tier {
	return predicate.Tier(sql.FieldNotIn(FieldConcurrentInstances, vs...))
}

// ConcurrentInstancesGT applies the GT predicate on the "concurrent_instances" field.
func ConcurrentInstancesGT(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldGT(FieldConcurrentInstances, v))
}

// ConcurrentInstancesGTE applies the GTE predicate on the "concurrent_instances" field.
func ConcurrentInstancesGTE(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldGTE(FieldConcurrentInstances, v))
}

// ConcurrentInstancesLT applies the LT predicate on the "concurrent_instances" field.
func ConcurrentInstancesLT(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldLT(FieldConcurrentInstances, v))
}

// ConcurrentInstancesLTE applies the LTE predicate on the "concurrent_instances" field.
func ConcurrentInstancesLTE(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldLTE(FieldConcurrentInstances, v))
}

// MaxLengthHoursEQ applies the EQ predicate on the "max_length_hours" field.
func MaxLengthHoursEQ(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldEQ(FieldMaxLengthHours, v))
}

// MaxLengthHoursNEQ applies the NEQ predicate on the "max_length_hours" field.
func MaxLengthHoursNEQ(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldNEQ(FieldMaxLengthHours, v))
}

// MaxLengthHoursIn applies the In predicate on the "max_length_hours" field.
func MaxLengthHoursIn(vs ...int64) predicate.Tier {
	return predicate.Tier(sql.FieldIn(FieldMaxLengthHours, vs...))
}

// MaxLengthHoursNotIn applies the NotIn predicate on the "max_length_hours" field.
func MaxLengthHoursNotIn(vs ...int64) predicate.Tier {
	return predicate.Tier(sql.FieldNotIn(FieldMaxLengthHours, vs...))
}

// MaxLengthHoursGT applies the GT predicate on the "max_length_hours" field.
func MaxLengthHoursGT(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldGT(FieldMaxLengthHours, v))
}

// MaxLengthHoursGTE applies the GTE predicate on the "max_length_hours" field.
func MaxLengthHoursGTE(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldGTE(FieldMaxLengthHours, v))
}

// MaxLengthHoursLT applies the LT predicate on the "max_length_hours" field.
func MaxLengthHoursLT(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldLT(FieldMaxLengthHours, v))
}

// MaxLengthHoursLTE applies the LTE predicate on the "max_length_hours" field.
func MaxLengthHoursLTE(v int64) predicate.Tier {
	return predicate.Tier(sql.FieldLTE(FieldMaxLengthHours, v))
}

// HasTeams applies the HasEdge predicate on the "teams" edge.
func HasTeams() predicate.Tier {
	return predicate.Tier(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, TeamsTable, TeamsColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.Team
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasTeamsWith applies the HasEdge predicate on the "teams" edge with a given conditions (other predicates).
func HasTeamsWith(preds ...predicate.Team) predicate.Tier {
	return predicate.Tier(func(s *sql.Selector) {
		step := newTeamsStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.Team
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Tier) predicate.Tier {
	return predicate.Tier(sql.AndPredicates(predicates...))
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Tier) predicate.Tier {
	return predicate.Tier(sql.OrPredicates(predicates...))
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Tier) predicate.Tier {
	return predicate.Tier(sql.NotPredicates(p))
}



================================================
File: models/user/user.go
================================================
// Code generated by ent, DO NOT EDIT.

package user

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the user type in the database.
	Label = "user"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldEmail holds the string denoting the email field in the database.
	FieldEmail = "email"
	// EdgeTeams holds the string denoting the teams edge name in mutations.
	EdgeTeams = "teams"
	// EdgeCreatedEnvs holds the string denoting the created_envs edge name in mutations.
	EdgeCreatedEnvs = "created_envs"
	// EdgeAccessTokens holds the string denoting the access_tokens edge name in mutations.
	EdgeAccessTokens = "access_tokens"
	// EdgeCreatedAPIKeys holds the string denoting the created_api_keys edge name in mutations.
	EdgeCreatedAPIKeys = "created_api_keys"
	// EdgeUsersTeams holds the string denoting the users_teams edge name in mutations.
	EdgeUsersTeams = "users_teams"
	// AccessTokenFieldID holds the string denoting the ID field of the AccessToken.
	AccessTokenFieldID = "access_token"
	// Table holds the table name of the user in the database.
	Table = "users"
	// TeamsTable is the table that holds the teams relation/edge. The primary key declared below.
	TeamsTable = "users_teams"
	// TeamsInverseTable is the table name for the Team entity.
	// It exists in this package in order to avoid circular dependency with the "team" package.
	TeamsInverseTable = "teams"
	// CreatedEnvsTable is the table that holds the created_envs relation/edge.
	CreatedEnvsTable = "envs"
	// CreatedEnvsInverseTable is the table name for the Env entity.
	// It exists in this package in order to avoid circular dependency with the "env" package.
	CreatedEnvsInverseTable = "envs"
	// CreatedEnvsColumn is the table column denoting the created_envs relation/edge.
	CreatedEnvsColumn = "created_by"
	// AccessTokensTable is the table that holds the access_tokens relation/edge.
	AccessTokensTable = "access_tokens"
	// AccessTokensInverseTable is the table name for the AccessToken entity.
	// It exists in this package in order to avoid circular dependency with the "accesstoken" package.
	AccessTokensInverseTable = "access_tokens"
	// AccessTokensColumn is the table column denoting the access_tokens relation/edge.
	AccessTokensColumn = "user_id"
	// CreatedAPIKeysTable is the table that holds the created_api_keys relation/edge.
	CreatedAPIKeysTable = "team_api_keys"
	// CreatedAPIKeysInverseTable is the table name for the TeamAPIKey entity.
	// It exists in this package in order to avoid circular dependency with the "teamapikey" package.
	CreatedAPIKeysInverseTable = "team_api_keys"
	// CreatedAPIKeysColumn is the table column denoting the created_api_keys relation/edge.
	CreatedAPIKeysColumn = "created_by"
	// UsersTeamsTable is the table that holds the users_teams relation/edge.
	UsersTeamsTable = "users_teams"
	// UsersTeamsInverseTable is the table name for the UsersTeams entity.
	// It exists in this package in order to avoid circular dependency with the "usersteams" package.
	UsersTeamsInverseTable = "users_teams"
	// UsersTeamsColumn is the table column denoting the users_teams relation/edge.
	UsersTeamsColumn = "user_id"
)

// Columns holds all SQL columns for user fields.
var Columns = []string{
	FieldID,
	FieldEmail,
}

var (
	// TeamsPrimaryKey and TeamsColumn2 are the table columns denoting the
	// primary key for the teams relation (M2M).
	TeamsPrimaryKey = []string{"team_id", "user_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

var (
	// EmailValidator is a validator for the "email" field. It is called by the builders before save.
	EmailValidator func(string) error
)

// OrderOption defines the ordering options for the User queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByEmail orders the results by the email field.
func ByEmail(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEmail, opts...).ToFunc()
}

// ByTeamsCount orders the results by teams count.
func ByTeamsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newTeamsStep(), opts...)
	}
}

// ByTeams orders the results by teams terms.
func ByTeams(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTeamsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByCreatedEnvsCount orders the results by created_envs count.
func ByCreatedEnvsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newCreatedEnvsStep(), opts...)
	}
}

// ByCreatedEnvs orders the results by created_envs terms.
func ByCreatedEnvs(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCreatedEnvsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByAccessTokensCount orders the results by access_tokens count.
func ByAccessTokensCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAccessTokensStep(), opts...)
	}
}

// ByAccessTokens orders the results by access_tokens terms.
func ByAccessTokens(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAccessTokensStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByCreatedAPIKeysCount orders the results by created_api_keys count.
func ByCreatedAPIKeysCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newCreatedAPIKeysStep(), opts...)
	}
}

// ByCreatedAPIKeys orders the results by created_api_keys terms.
func ByCreatedAPIKeys(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCreatedAPIKeysStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByUsersTeamsCount orders the results by users_teams count.
func ByUsersTeamsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newUsersTeamsStep(), opts...)
	}
}

// ByUsersTeams orders the results by users_teams terms.
func ByUsersTeams(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newUsersTeamsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newTeamsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TeamsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, TeamsTable, TeamsPrimaryKey...),
	)
}
func newCreatedEnvsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CreatedEnvsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, CreatedEnvsTable, CreatedEnvsColumn),
	)
}
func newAccessTokensStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(AccessTokensInverseTable, AccessTokenFieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, AccessTokensTable, AccessTokensColumn),
	)
}
func newCreatedAPIKeysStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CreatedAPIKeysInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, CreatedAPIKeysTable, CreatedAPIKeysColumn),
	)
}
func newUsersTeamsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(UsersTeamsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, true, UsersTeamsTable, UsersTeamsColumn),
	)
}



================================================
File: models/user/where.go
================================================
// Code generated by ent, DO NOT EDIT.

package user

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/google/uuid"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.User {
	return predicate.User(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.User {
	return predicate.User(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.User {
	return predicate.User(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.User {
	return predicate.User(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.User {
	return predicate.User(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.User {
	return predicate.User(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.User {
	return predicate.User(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.User {
	return predicate.User(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.User {
	return predicate.User(sql.FieldLTE(FieldID, id))
}

// Email applies equality check predicate on the "email" field. It's identical to EmailEQ.
func Email(v string) predicate.User {
	return predicate.User(sql.FieldEQ(FieldEmail, v))
}

// EmailEQ applies the EQ predicate on the "email" field.
func EmailEQ(v string) predicate.User {
	return predicate.User(sql.FieldEQ(FieldEmail, v))
}

// EmailNEQ applies the NEQ predicate on the "email" field.
func EmailNEQ(v string) predicate.User {
	return predicate.User(sql.FieldNEQ(FieldEmail, v))
}

// EmailIn applies the In predicate on the "email" field.
func EmailIn(vs ...string) predicate.User {
	return predicate.User(sql.FieldIn(FieldEmail, vs...))
}

// EmailNotIn applies the NotIn predicate on the "email" field.
func EmailNotIn(vs ...string) predicate.User {
	return predicate.User(sql.FieldNotIn(FieldEmail, vs...))
}

// EmailGT applies the GT predicate on the "email" field.
func EmailGT(v string) predicate.User {
	return predicate.User(sql.FieldGT(FieldEmail, v))
}

// EmailGTE applies the GTE predicate on the "email" field.
func EmailGTE(v string) predicate.User {
	return predicate.User(sql.FieldGTE(FieldEmail, v))
}

// EmailLT applies the LT predicate on the "email" field.
func EmailLT(v string) predicate.User {
	return predicate.User(sql.FieldLT(FieldEmail, v))
}

// EmailLTE applies the LTE predicate on the "email" field.
func EmailLTE(v string) predicate.User {
	return predicate.User(sql.FieldLTE(FieldEmail, v))
}

// EmailContains applies the Contains predicate on the "email" field.
func EmailContains(v string) predicate.User {
	return predicate.User(sql.FieldContains(FieldEmail, v))
}

// EmailHasPrefix applies the HasPrefix predicate on the "email" field.
func EmailHasPrefix(v string) predicate.User {
	return predicate.User(sql.FieldHasPrefix(FieldEmail, v))
}

// EmailHasSuffix applies the HasSuffix predicate on the "email" field.
func EmailHasSuffix(v string) predicate.User {
	return predicate.User(sql.FieldHasSuffix(FieldEmail, v))
}

// EmailEqualFold applies the EqualFold predicate on the "email" field.
func EmailEqualFold(v string) predicate.User {
	return predicate.User(sql.FieldEqualFold(FieldEmail, v))
}

// EmailContainsFold applies the ContainsFold predicate on the "email" field.
func EmailContainsFold(v string) predicate.User {
	return predicate.User(sql.FieldContainsFold(FieldEmail, v))
}

// HasTeams applies the HasEdge predicate on the "teams" edge.
func HasTeams() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, TeamsTable, TeamsPrimaryKey...),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.UsersTeams
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasTeamsWith applies the HasEdge predicate on the "teams" edge with a given conditions (other predicates).
func HasTeamsWith(preds ...predicate.Team) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := newTeamsStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.UsersTeams
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasCreatedEnvs applies the HasEdge predicate on the "created_envs" edge.
func HasCreatedEnvs() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, CreatedEnvsTable, CreatedEnvsColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.Env
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasCreatedEnvsWith applies the HasEdge predicate on the "created_envs" edge with a given conditions (other predicates).
func HasCreatedEnvsWith(preds ...predicate.Env) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := newCreatedEnvsStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Env
		step.Edge.Schema = schemaConfig.Env
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAccessTokens applies the HasEdge predicate on the "access_tokens" edge.
func HasAccessTokens() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AccessTokensTable, AccessTokensColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.AccessToken
		step.Edge.Schema = schemaConfig.AccessToken
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAccessTokensWith applies the HasEdge predicate on the "access_tokens" edge with a given conditions (other predicates).
func HasAccessTokensWith(preds ...predicate.AccessToken) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := newAccessTokensStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.AccessToken
		step.Edge.Schema = schemaConfig.AccessToken
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasCreatedAPIKeys applies the HasEdge predicate on the "created_api_keys" edge.
func HasCreatedAPIKeys() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, CreatedAPIKeysTable, CreatedAPIKeysColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.TeamAPIKey
		step.Edge.Schema = schemaConfig.TeamAPIKey
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasCreatedAPIKeysWith applies the HasEdge predicate on the "created_api_keys" edge with a given conditions (other predicates).
func HasCreatedAPIKeysWith(preds ...predicate.TeamAPIKey) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := newCreatedAPIKeysStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.TeamAPIKey
		step.Edge.Schema = schemaConfig.TeamAPIKey
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasUsersTeams applies the HasEdge predicate on the "users_teams" edge.
func HasUsersTeams() predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, UsersTeamsTable, UsersTeamsColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.UsersTeams
		step.Edge.Schema = schemaConfig.UsersTeams
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasUsersTeamsWith applies the HasEdge predicate on the "users_teams" edge with a given conditions (other predicates).
func HasUsersTeamsWith(preds ...predicate.UsersTeams) predicate.User {
	return predicate.User(func(s *sql.Selector) {
		step := newUsersTeamsStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.UsersTeams
		step.Edge.Schema = schemaConfig.UsersTeams
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.User) predicate.User {
	return predicate.User(sql.AndPredicates(predicates...))
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.User) predicate.User {
	return predicate.User(sql.OrPredicates(predicates...))
}

// Not applies the not operator on the given predicate.
func Not(p predicate.User) predicate.User {
	return predicate.User(sql.NotPredicates(p))
}



================================================
File: models/usersteams/usersteams.go
================================================
// Code generated by ent, DO NOT EDIT.

package usersteams

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the usersteams type in the database.
	Label = "users_teams"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldUserID holds the string denoting the user_id field in the database.
	FieldUserID = "user_id"
	// FieldTeamID holds the string denoting the team_id field in the database.
	FieldTeamID = "team_id"
	// FieldIsDefault holds the string denoting the is_default field in the database.
	FieldIsDefault = "is_default"
	// EdgeUsers holds the string denoting the users edge name in mutations.
	EdgeUsers = "users"
	// EdgeTeams holds the string denoting the teams edge name in mutations.
	EdgeTeams = "teams"
	// Table holds the table name of the usersteams in the database.
	Table = "users_teams"
	// UsersTable is the table that holds the users relation/edge.
	UsersTable = "users_teams"
	// UsersInverseTable is the table name for the User entity.
	// It exists in this package in order to avoid circular dependency with the "user" package.
	UsersInverseTable = "users"
	// UsersColumn is the table column denoting the users relation/edge.
	UsersColumn = "user_id"
	// TeamsTable is the table that holds the teams relation/edge.
	TeamsTable = "users_teams"
	// TeamsInverseTable is the table name for the Team entity.
	// It exists in this package in order to avoid circular dependency with the "team" package.
	TeamsInverseTable = "teams"
	// TeamsColumn is the table column denoting the teams relation/edge.
	TeamsColumn = "team_id"
)

// Columns holds all SQL columns for usersteams fields.
var Columns = []string{
	FieldID,
	FieldUserID,
	FieldTeamID,
	FieldIsDefault,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultIsDefault holds the default value on creation for the "is_default" field.
	DefaultIsDefault bool
)

// OrderOption defines the ordering options for the UsersTeams queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByUserID orders the results by the user_id field.
func ByUserID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUserID, opts...).ToFunc()
}

// ByTeamID orders the results by the team_id field.
func ByTeamID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTeamID, opts...).ToFunc()
}

// ByIsDefault orders the results by the is_default field.
func ByIsDefault(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIsDefault, opts...).ToFunc()
}

// ByUsersField orders the results by users field.
func ByUsersField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newUsersStep(), sql.OrderByField(field, opts...))
	}
}

// ByTeamsField orders the results by teams field.
func ByTeamsField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTeamsStep(), sql.OrderByField(field, opts...))
	}
}
func newUsersStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(UsersInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, UsersTable, UsersColumn),
	)
}
func newTeamsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TeamsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, TeamsTable, TeamsColumn),
	)
}



================================================
File: models/usersteams/where.go
================================================
// Code generated by ent, DO NOT EDIT.

package usersteams

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/internal"
	"github.com/e2b-dev/infra/packages/shared/pkg/models/predicate"
	"github.com/google/uuid"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldLTE(FieldID, id))
}

// UserID applies equality check predicate on the "user_id" field. It's identical to UserIDEQ.
func UserID(v uuid.UUID) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldEQ(FieldUserID, v))
}

// TeamID applies equality check predicate on the "team_id" field. It's identical to TeamIDEQ.
func TeamID(v uuid.UUID) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldEQ(FieldTeamID, v))
}

// IsDefault applies equality check predicate on the "is_default" field. It's identical to IsDefaultEQ.
func IsDefault(v bool) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldEQ(FieldIsDefault, v))
}

// UserIDEQ applies the EQ predicate on the "user_id" field.
func UserIDEQ(v uuid.UUID) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldEQ(FieldUserID, v))
}

// UserIDNEQ applies the NEQ predicate on the "user_id" field.
func UserIDNEQ(v uuid.UUID) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldNEQ(FieldUserID, v))
}

// UserIDIn applies the In predicate on the "user_id" field.
func UserIDIn(vs ...uuid.UUID) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldIn(FieldUserID, vs...))
}

// UserIDNotIn applies the NotIn predicate on the "user_id" field.
func UserIDNotIn(vs ...uuid.UUID) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldNotIn(FieldUserID, vs...))
}

// TeamIDEQ applies the EQ predicate on the "team_id" field.
func TeamIDEQ(v uuid.UUID) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldEQ(FieldTeamID, v))
}

// TeamIDNEQ applies the NEQ predicate on the "team_id" field.
func TeamIDNEQ(v uuid.UUID) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldNEQ(FieldTeamID, v))
}

// TeamIDIn applies the In predicate on the "team_id" field.
func TeamIDIn(vs ...uuid.UUID) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldIn(FieldTeamID, vs...))
}

// TeamIDNotIn applies the NotIn predicate on the "team_id" field.
func TeamIDNotIn(vs ...uuid.UUID) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldNotIn(FieldTeamID, vs...))
}

// IsDefaultEQ applies the EQ predicate on the "is_default" field.
func IsDefaultEQ(v bool) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldEQ(FieldIsDefault, v))
}

// IsDefaultNEQ applies the NEQ predicate on the "is_default" field.
func IsDefaultNEQ(v bool) predicate.UsersTeams {
	return predicate.UsersTeams(sql.FieldNEQ(FieldIsDefault, v))
}

// HasUsers applies the HasEdge predicate on the "users" edge.
func HasUsers() predicate.UsersTeams {
	return predicate.UsersTeams(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, UsersTable, UsersColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.UsersTeams
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasUsersWith applies the HasEdge predicate on the "users" edge with a given conditions (other predicates).
func HasUsersWith(preds ...predicate.User) predicate.UsersTeams {
	return predicate.UsersTeams(func(s *sql.Selector) {
		step := newUsersStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.UsersTeams
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasTeams applies the HasEdge predicate on the "teams" edge.
func HasTeams() predicate.UsersTeams {
	return predicate.UsersTeams(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, TeamsTable, TeamsColumn),
		)
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.UsersTeams
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasTeamsWith applies the HasEdge predicate on the "teams" edge with a given conditions (other predicates).
func HasTeamsWith(preds ...predicate.Team) predicate.UsersTeams {
	return predicate.UsersTeams(func(s *sql.Selector) {
		step := newTeamsStep()
		schemaConfig := internal.SchemaConfigFromContext(s.Context())
		step.To.Schema = schemaConfig.Team
		step.Edge.Schema = schemaConfig.UsersTeams
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.UsersTeams) predicate.UsersTeams {
	return predicate.UsersTeams(sql.AndPredicates(predicates...))
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.UsersTeams) predicate.UsersTeams {
	return predicate.UsersTeams(sql.OrPredicates(predicates...))
}

// Not applies the not operator on the given predicate.
func Not(p predicate.UsersTeams) predicate.UsersTeams {
	return predicate.UsersTeams(sql.NotPredicates(p))
}



================================================
File: schema/access_token.go
================================================
package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
)

type AccessToken struct {
	ent.Schema
}

func (AccessToken) Fields() []ent.Field {
	return []ent.Field{
		field.String("id").Unique().StorageKey("access_token").Immutable().SchemaType(map[string]string{dialect.Postgres: "text"}),
		field.UUID("user_id", uuid.UUID{}),
		field.Time("created_at").Optional().Immutable().Annotations(
			entsql.Default("CURRENT_TIMESTAMP"),
		),
	}
}

func (AccessToken) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("user", User.Type).Ref("access_tokens").Unique().Field("user_id").Required(),
	}
}

func (AccessToken) Mixin() []ent.Mixin {
	return []ent.Mixin{
		Mixin{},
	}
}



================================================
File: schema/build.go
================================================
package schema

import (
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
)

const (
	DefaultKernelVersion = "vmlinux-6.1.102"
	// The Firecracker version the last tag + the short SHA (so we can build our dev previews)
	// TODO: The short tag here has only 7 characters — the one from our build pipeline will likely have exactly 8 so this will break.
	DefaultFirecrackerVersion = "v1.10.1_1fcdaec"
)

type EnvBuild struct {
	ent.Schema
}

func (EnvBuild) Fields() []ent.Field {
	return []ent.Field{
		field.UUID("id", uuid.UUID{}).Immutable().Unique().Annotations(entsql.Default("gen_random_uuid()")),
		field.Time("created_at").Immutable().Default(time.Now).
			Annotations(
				entsql.Default("CURRENT_TIMESTAMP"),
			),
		field.Time("updated_at").Default(time.Now),
		field.Time("finished_at").Optional().Nillable(),
		field.String("env_id").SchemaType(map[string]string{dialect.Postgres: "text"}).Optional().Nillable(),
		field.Enum("status").Values("waiting", "building", "failed", "success", "uploaded").Default("waiting").SchemaType(map[string]string{dialect.Postgres: "text"}),
		field.String("dockerfile").SchemaType(map[string]string{dialect.Postgres: "text"}).Optional().Nillable(),
		field.String("start_cmd").SchemaType(map[string]string{dialect.Postgres: "text"}).Optional().Nillable(),
		field.Int64("vcpu"),
		field.Int64("ram_mb"),
		field.Int64("free_disk_size_mb"),
		field.Int64("total_disk_size_mb").Optional().Nillable(),
		field.String("kernel_version").Default(DefaultKernelVersion).SchemaType(map[string]string{dialect.Postgres: "text"}),
		field.String("firecracker_version").Default(DefaultFirecrackerVersion).SchemaType(map[string]string{dialect.Postgres: "text"}),
		field.String("envd_version").SchemaType(map[string]string{dialect.Postgres: "text"}).Nillable().Optional(),
	}
}

func (EnvBuild) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("env", Env.Type).Ref("builds").Unique().Field("env_id"),
	}
}

func (EnvBuild) Mixin() []ent.Mixin {
	return []ent.Mixin{
		Mixin{},
	}
}



================================================
File: schema/env.go
================================================
package schema

import (
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
)

type Env struct {
	ent.Schema
}

func (Env) Fields() []ent.Field {
	return []ent.Field{
		field.String("id").Unique().Immutable().SchemaType(map[string]string{dialect.Postgres: "text"}),
		field.Time("created_at").Immutable().Default(time.Now).
			Annotations(
				entsql.Default("CURRENT_TIMESTAMP"),
			),
		field.Time("updated_at").Default(time.Now),
		field.UUID("team_id", uuid.UUID{}),
		field.UUID("created_by", uuid.UUID{}).Optional().Nillable(),
		field.Bool("public").Annotations(entsql.Default("false")),
		field.Int32("build_count").Default(1),
		field.Int64("spawn_count").Default(0).Comment("Number of times the env was spawned"),
		field.Time("last_spawned_at").Optional().Comment("Timestamp of the last time the env was spawned"),
	}
}

func (Env) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("team", Team.Type).Ref("envs").Unique().Field("team_id").Required(),
		edge.From("creator", User.Type).Unique().Ref("created_envs").Field("created_by"),
		edge.To("env_aliases", EnvAlias.Type).Annotations(entsql.OnDelete(entsql.Cascade)),
		edge.To("builds", EnvBuild.Type).Annotations(entsql.OnDelete(entsql.Cascade)),
		edge.To("snapshots", Snapshot.Type).Annotations(entsql.OnDelete(entsql.Cascade)),
	}
}

func (Env) Annotations() []schema.Annotation {
	withComments := true

	return []schema.Annotation{
		entsql.Annotation{WithComments: &withComments},
	}
}

func (Env) Mixin() []ent.Mixin {
	return []ent.Mixin{
		Mixin{},
	}
}



================================================
File: schema/env_alias.go
================================================
package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
)

type EnvAlias struct {
	ent.Schema
}

func (EnvAlias) Fields() []ent.Field {
	return []ent.Field{
		field.String("id").Unique().StorageKey("alias").Immutable().SchemaType(map[string]string{dialect.Postgres: "text"}),
		field.String("env_id").SchemaType(map[string]string{dialect.Postgres: "text"}),
		field.Bool("is_renamable").Default(true),
	}
}

func (EnvAlias) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("env", Env.Type).Ref("env_aliases").Unique().Field("env_id").Required(),
	}
}

func (EnvAlias) Annotations() []schema.Annotation {
	return []schema.Annotation{
		entsql.Annotation{Table: "env_aliases"},
	}
}

func (EnvAlias) Mixin() []ent.Mixin {
	return []ent.Mixin{
		Mixin{},
	}
}



================================================
File: schema/mixin.go
================================================
package schema

import (
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema"
	"entgo.io/ent/schema/mixin"
)

// Mixin holds the default configuration for most schemas in this package.
type Mixin struct {
	mixin.Schema
}

// Annotations of the Mixin.
func (Mixin) Annotations() []schema.Annotation {
	return []schema.Annotation{
		entsql.Schema("public"),
	}
}



================================================
File: schema/snapshots.go
================================================
package schema

import (
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
)

type Snapshot struct {
	ent.Schema
}

func (Snapshot) Fields() []ent.Field {
	return []ent.Field{
		field.UUID("id", uuid.UUID{}).Immutable().Unique().Annotations(entsql.Default("gen_random_uuid()")),
		field.Time("created_at").Immutable().Default(time.Now).
			Annotations(
				entsql.Default("CURRENT_TIMESTAMP"),
			),
		field.String("base_env_id").SchemaType(map[string]string{dialect.Postgres: "text"}),
		field.String("env_id").SchemaType(map[string]string{dialect.Postgres: "text"}),
		field.String("sandbox_id").Unique().SchemaType(map[string]string{dialect.Postgres: "text"}),
		field.JSON("metadata", map[string]string{}).SchemaType(map[string]string{dialect.Postgres: "jsonb"}),
	}
}

func (Snapshot) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("env", Env.Type).Ref("snapshots").Unique().Field("env_id").Required(),
	}
}

func (Snapshot) Mixin() []ent.Mixin {
	return []ent.Mixin{
		Mixin{},
	}
}



================================================
File: schema/team.go
================================================
package schema

import (
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
)

type Team struct {
	ent.Schema
}

func (Team) Fields() []ent.Field {
	return []ent.Field{
		field.UUID("id", uuid.UUID{}).Immutable().Unique().Annotations(entsql.Default("gen_random_uuid()")),
		field.Time("created_at").Immutable().Default(time.Now).Annotations(
			entsql.Default("CURRENT_TIMESTAMP"),
		),
		field.Bool("is_banned").Optional().Annotations(entsql.Default("false")),
		field.Bool("is_blocked").Optional().Annotations(entsql.Default("false")),
		field.String("blocked_reason").Optional().Nillable().SchemaType(map[string]string{dialect.Postgres: "text"}),
		field.String("name").SchemaType(map[string]string{dialect.Postgres: "text"}),
		field.String("tier").SchemaType(map[string]string{dialect.Postgres: "text"}),
		field.String("email").MaxLen(255).SchemaType(map[string]string{dialect.Postgres: "character varying(255)"}),
	}
}

func (Team) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("users", User.Type).Through("users_teams", UsersTeams.Type).Annotations(entsql.OnDelete(entsql.Cascade)),
		edge.To("team_api_keys", TeamAPIKey.Type).Annotations(entsql.OnDelete(entsql.Cascade)),
		edge.From("team_tier", Tier.Type).Ref("teams").Unique().Field("tier").Required(),
		edge.To("envs", Env.Type),
	}
}

func (Team) Mixin() []ent.Mixin {
	return []ent.Mixin{
		Mixin{},
	}
}



================================================
File: schema/team_api_key.go
================================================
package schema

import (
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
)

type TeamAPIKey struct {
	ent.Schema
}

func (TeamAPIKey) Fields() []ent.Field {
	return []ent.Field{
		field.UUID("id", uuid.UUID{}).Immutable().Unique().Annotations(entsql.Default("gen_random_uuid()")),
		field.String("api_key").Unique().Sensitive().SchemaType(map[string]string{dialect.Postgres: "character varying(44)"}),
		field.Time("created_at").Immutable().Default(time.Now).Annotations(
			entsql.Default("CURRENT_TIMESTAMP"),
		),
		field.Time("updated_at").Nillable().Optional(),
		field.UUID("team_id", uuid.UUID{}),
		field.String("name").SchemaType(map[string]string{dialect.Postgres: "text"}).Default("Unnamed API Key"),
		field.UUID("created_by", uuid.UUID{}).Nillable().Optional(),
		field.Time("last_used").Nillable().Optional(),
	}
}

func (TeamAPIKey) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("team", Team.Type).Unique().Required().
			Ref("team_api_keys").
			Field("team_id"),
		edge.From("creator", User.Type).Unique().
			Ref("created_api_keys").Field("created_by"),
	}
}

func (TeamAPIKey) Annotations() []schema.Annotation {
	return nil
}

func (TeamAPIKey) Mixin() []ent.Mixin {
	return []ent.Mixin{
		Mixin{},
	}
}



================================================
File: schema/tier.go
================================================
package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
)

type Tier struct {
	ent.Schema
}

func (Tier) Fields() []ent.Field {
	return []ent.Field{
		field.String("id").Immutable().Unique().SchemaType(map[string]string{dialect.Postgres: "text"}),
		field.String("name").SchemaType(map[string]string{dialect.Postgres: "text"}),
		field.Int64("disk_mb").Annotations(entsql.Check("disk_mb > 0"), entsql.Default("512")),
		field.Int64("concurrent_instances").Annotations(entsql.Check("concurrent_instances > 0")).Comment("The number of instances the team can run concurrently"),
		field.Int64("max_length_hours"),
	}
}

func (Tier) Annotations() []schema.Annotation {
	withComments := true
	return []schema.Annotation{
		entsql.Annotation{
			WithComments: &withComments,
			Checks: map[string]string{
				"tiers_concurrent_sessions_check": "concurrent_instances > 0",
				"tiers_disk_mb_check":             "disk_mb > 0",
			},
		},
	}
}

func (Tier) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("teams", Team.Type),
	}
}

func (Tier) Mixin() []ent.Mixin {
	return []ent.Mixin{
		Mixin{},
	}
}



================================================
File: schema/user.go
================================================
package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
)

// User holds the schema definition for the User entity.
type User struct{ ent.Schema }

// Fields of the User.
func (User) Fields() []ent.Field {
	return []ent.Field{
		field.UUID("id", uuid.UUID{}).Immutable().Unique().Annotations(entsql.Default("gen_random_uuid()")),
		field.String("email").MaxLen(255).SchemaType(map[string]string{dialect.Postgres: "character varying(255)"}),
	}
}

func (User) Annotations() []schema.Annotation {
	return []schema.Annotation{
		entsql.Schema("auth"),
	}
}

func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("teams", Team.Type).Through("users_teams", UsersTeams.Type).Ref("users"),
		edge.To("created_envs", Env.Type).Annotations(entsql.OnDelete(entsql.SetNull)),
		edge.To("access_tokens", AccessToken.Type).Annotations(entsql.OnDelete(entsql.Cascade)),
		edge.To("created_api_keys", TeamAPIKey.Type).Annotations(entsql.OnDelete(entsql.SetNull)),
	}
}



================================================
File: schema/users_teams.go
================================================
package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema/edge"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
)

type UsersTeams struct {
	ent.Schema
}

// Fields of the UsersTeams.
func (UsersTeams) Fields() []ent.Field {
	return []ent.Field{
		field.UUID("user_id", uuid.UUID{}),
		field.UUID("team_id", uuid.UUID{}),
		field.Bool("is_default").Default(false),
	}
}

// Edges of the UsersTeams.
func (UsersTeams) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("users", User.Type).
			Required().
			Unique().
			Field("user_id").Annotations(entsql.OnDelete(entsql.Cascade)),
		edge.To("teams", Team.Type).
			Required().
			Unique().
			Field("team_id").Annotations(entsql.OnDelete(entsql.Cascade)),
	}
}

func (UsersTeams) Mixin() []ent.Mixin {
	return []ent.Mixin{
		Mixin{},
	}
}



================================================
File: smap/smap.go
================================================
package smap

import (
	cmap "github.com/orcaman/concurrent-map/v2"
)

type Map[V any] struct {
	m cmap.ConcurrentMap[string, V]
}

func New[V any]() *Map[V] {
	return &Map[V]{
		m: cmap.New[V](),
	}
}

func (m *Map[V]) Remove(key string) {
	m.m.Remove(key)
}

func (m *Map[V]) Get(key string) (V, bool) {
	return m.m.Get(key)
}

func (m *Map[V]) Insert(key string, value V) {
	m.m.Set(key, value)
}

func (m *Map[V]) InsertIfAbsent(key string, value V) bool {
	return m.m.SetIfAbsent(key, value)
}

func (m *Map[V]) Items() map[string]V {
	return m.m.Items()
}

func (m *Map[V]) RemoveCb(key string, cb func(key string, v V, exists bool) bool) bool {
	return m.m.RemoveCb(key, cb)
}

func (m *Map[V]) Count() int {
	return m.m.Count()
}



================================================
File: storage/provider.go
================================================
 


================================================
File: storage/sandbox.go
================================================
package storage

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/e2b-dev/infra/packages/shared/pkg/id"
)

const (
	sandboxCacheDir = "/orchestrator/sandbox"
)

type SandboxFiles struct {
	*TemplateCacheFiles
	SandboxID string
	tmpDir    string
	// We use random id to avoid collision between the paused and restored sandbox caches
	randomID string
}

func (c *TemplateCacheFiles) NewSandboxFiles(sandboxID string) *SandboxFiles {
	randomID := id.Generate()

	return &SandboxFiles{
		TemplateCacheFiles: c,
		SandboxID:          sandboxID,
		randomID:           randomID,
		tmpDir:             os.TempDir(),
	}
}

func (s *SandboxFiles) SandboxCacheRootfsPath() string {
	return filepath.Join(sandboxCacheDir, fmt.Sprintf("rootfs-%s-%s.cow", s.SandboxID, s.randomID))
}

func (s *SandboxFiles) SandboxFirecrackerSocketPath() string {
	return filepath.Join(s.tmpDir, fmt.Sprintf("fc-%s-%s.sock", s.SandboxID, s.randomID))
}

func (s *SandboxFiles) SandboxUffdSocketPath() string {
	return filepath.Join(s.tmpDir, fmt.Sprintf("uffd-%s-%s.sock", s.SandboxID, s.randomID))
}

func (s *SandboxFiles) SandboxCacheRootfsLinkPath() string {
	return filepath.Join(sandboxCacheDir, fmt.Sprintf("rootfs-%s-%s.link", s.SandboxID, s.randomID))
}



================================================
File: storage/template.go
================================================
package storage

import (
	"fmt"
	"path/filepath"

	"github.com/e2b-dev/infra/packages/shared/pkg/storage/header"
)

const (
	EnvsDisk = "/mnt/disks/fc-envs/v1"

	KernelsDir     = "/fc-kernels"
	KernelMountDir = "/fc-vm"
	KernelName     = "vmlinux.bin"

	HostOldEnvdPath  = "/fc-envd/envd-v0.0.1"
	HostEnvdPath     = "/fc-envd/envd"
	GuestOldEnvdPath = "/usr/bin/envd-v0.0.1"
	GuestEnvdPath    = "/usr/bin/envd"

	EnvdVersionKey = "envd_version"
	RootfsSizeKey  = "rootfs_size"

	FirecrackerVersionsDir = "/fc-versions"
	FirecrackerBinaryName  = "firecracker"

	buildDirName = "builds"

	MemfileName  = "memfile"
	RootfsName   = "rootfs.ext4"
	SnapfileName = "snapfile"

	HeaderSuffix = ".header"
)

// Path to the directory where the kernel can be accessed inside when the dirs are mounted.
var KernelMountedPath = filepath.Join(KernelMountDir, KernelName)

type TemplateFiles struct {
	TemplateId         string
	BuildId            string
	KernelVersion      string
	FirecrackerVersion string

	hugePages bool
}

func NewTemplateFiles(
	templateId,
	buildId,
	kernelVersion,
	firecrackerVersion string,
	hugePages bool,
) *TemplateFiles {
	return &TemplateFiles{
		TemplateId:         templateId,
		BuildId:            buildId,
		KernelVersion:      kernelVersion,
		FirecrackerVersion: firecrackerVersion,
		hugePages:          hugePages,
	}
}

func (t *TemplateFiles) BuildKernelPath() string {
	return filepath.Join(t.BuildKernelDir(), KernelName)
}

func (t *TemplateFiles) BuildKernelDir() string {
	return filepath.Join(KernelMountDir, t.KernelVersion)
}

// Key for the cache. Unique for template-build pair.
func (t *TemplateFiles) CacheKey() string {
	return fmt.Sprintf("%s-%s", t.TemplateId, t.BuildId)
}

func (t *TemplateFiles) CacheKernelDir() string {
	return filepath.Join(KernelsDir, t.KernelVersion)
}

func (t *TemplateFiles) CacheKernelPath() string {
	return filepath.Join(t.CacheKernelDir(), KernelName)
}

func (t *TemplateFiles) FirecrackerPath() string {
	return filepath.Join(FirecrackerVersionsDir, t.FirecrackerVersion, FirecrackerBinaryName)
}

func (t *TemplateFiles) StorageDir() string {
	return t.BuildId
}

func (t *TemplateFiles) StorageMemfilePath() string {
	return fmt.Sprintf("%s/%s", t.StorageDir(), MemfileName)
}

func (t *TemplateFiles) StorageMemfileHeaderPath() string {
	return fmt.Sprintf("%s/%s%s", t.StorageDir(), MemfileName, HeaderSuffix)
}

func (t *TemplateFiles) StorageRootfsPath() string {
	return fmt.Sprintf("%s/%s", t.StorageDir(), RootfsName)
}

func (t *TemplateFiles) StorageRootfsHeaderPath() string {
	return fmt.Sprintf("%s/%s%s", t.StorageDir(), RootfsName, HeaderSuffix)
}

func (t *TemplateFiles) StorageSnapfilePath() string {
	return fmt.Sprintf("%s/%s", t.StorageDir(), SnapfileName)
}

func (t *TemplateFiles) BuildDir() string {
	return filepath.Join(EnvsDisk, t.TemplateId, buildDirName, t.BuildId)
}

func (t *TemplateFiles) BuildMemfilePath() string {
	return filepath.Join(t.BuildDir(), MemfileName)
}

func (t *TemplateFiles) BuildRootfsPath() string {
	return filepath.Join(t.BuildDir(), RootfsName)
}

func (t *TemplateFiles) BuildSnapfilePath() string {
	return filepath.Join(t.BuildDir(), SnapfileName)
}

func (t *TemplateFiles) Hugepages() bool {
	return t.hugePages
}

func (t *TemplateFiles) MemfilePageSize() int64 {
	if t.hugePages {
		return header.HugepageSize
	}

	return header.PageSize
}

func (t *TemplateFiles) RootfsBlockSize() int64 {
	return header.RootfsBlockSize
}



================================================
File: storage/template_build.go
================================================
package storage

import (
	"context"
	"fmt"
	"io"
	"os"

	"golang.org/x/sync/errgroup"

	"github.com/e2b-dev/infra/packages/shared/pkg/storage/gcs"
	"github.com/e2b-dev/infra/packages/shared/pkg/storage/header"
)

type TemplateBuild struct {
	files *TemplateFiles

	memfileHeader *header.Header
	rootfsHeader  *header.Header

	bucket *gcs.BucketHandle
}

func NewTemplateBuild(
	memfileHeader *header.Header,
	rootfsHeader *header.Header,
	files *TemplateFiles,
) *TemplateBuild {
	return &TemplateBuild{
		bucket:        gcs.GetTemplateBucket(),
		memfileHeader: memfileHeader,
		rootfsHeader:  rootfsHeader,
		files:         files,
	}
}

func (t *TemplateBuild) Remove(ctx context.Context) error {
	err := gcs.RemoveDir(ctx, t.bucket, t.files.StorageDir())
	if err != nil {
		return fmt.Errorf("error when removing template build '%s': %w", t.files.StorageDir(), err)
	}

	return nil
}

func (t *TemplateBuild) uploadMemfileHeader(ctx context.Context, h *header.Header) error {
	object := gcs.NewObject(ctx, t.bucket, t.files.StorageMemfileHeaderPath())

	serialized, err := header.Serialize(h.Metadata, h.Mapping)
	if err != nil {
		return fmt.Errorf("error when serializing memfile header: %w", err)
	}

	_, err = object.ReadFrom(serialized)
	if err != nil {
		return fmt.Errorf("error when uploading memfile header: %w", err)
	}

	return nil
}

func (t *TemplateBuild) uploadMemfile(ctx context.Context, memfilePath string) error {
	object := gcs.NewObject(ctx, t.bucket, t.files.StorageMemfilePath())

	err := object.UploadWithCli(ctx, memfilePath)
	if err != nil {
		return fmt.Errorf("error when uploading memfile: %w", err)
	}

	return nil
}

func (t *TemplateBuild) uploadRootfsHeader(ctx context.Context, h *header.Header) error {
	object := gcs.NewObject(ctx, t.bucket, t.files.StorageRootfsHeaderPath())

	serialized, err := header.Serialize(h.Metadata, h.Mapping)
	if err != nil {
		return fmt.Errorf("error when serializing memfile header: %w", err)
	}

	_, err = object.ReadFrom(serialized)
	if err != nil {
		return fmt.Errorf("error when uploading memfile header: %w", err)
	}

	return nil
}

func (t *TemplateBuild) uploadRootfs(ctx context.Context, rootfsPath string) error {
	object := gcs.NewObject(ctx, t.bucket, t.files.StorageRootfsPath())

	err := object.UploadWithCli(ctx, rootfsPath)
	if err != nil {
		return fmt.Errorf("error when uploading rootfs: %w", err)
	}

	return nil
}

// Snapfile is small enough so we dont use composite upload.
func (t *TemplateBuild) uploadSnapfile(ctx context.Context, snapfile io.Reader) error {
	object := gcs.NewObject(ctx, t.bucket, t.files.StorageSnapfilePath())

	n, err := object.ReadFrom(snapfile)
	if err != nil {
		return fmt.Errorf("error when uploading snapfile (%d bytes): %w", n, err)
	}

	return nil
}

func (t *TemplateBuild) Upload(
	ctx context.Context,
	snapfilePath string,
	memfilePath *string,
	rootfsPath *string,
) chan error {
	eg, ctx := errgroup.WithContext(ctx)

	eg.Go(func() error {
		if t.rootfsHeader == nil {
			return nil
		}

		err := t.uploadRootfsHeader(ctx, t.rootfsHeader)
		if err != nil {
			return err
		}

		return nil
	})

	eg.Go(func() error {
		if rootfsPath == nil {
			return nil
		}

		err := t.uploadRootfs(ctx, *rootfsPath)
		if err != nil {
			return err
		}

		return nil
	})

	eg.Go(func() error {
		if t.memfileHeader == nil {
			return nil
		}

		err := t.uploadMemfileHeader(ctx, t.memfileHeader)
		if err != nil {
			return err
		}

		return nil
	})

	eg.Go(func() error {
		if memfilePath == nil {
			return nil
		}

		err := t.uploadMemfile(ctx, *memfilePath)
		if err != nil {
			return err
		}

		return nil
	})

	eg.Go(func() error {
		snapfile, err := os.Open(snapfilePath)
		if err != nil {
			return err
		}

		defer snapfile.Close()

		err = t.uploadSnapfile(ctx, snapfile)
		if err != nil {
			return err
		}

		return nil
	})

	done := make(chan error)

	go func() {
		done <- eg.Wait()
	}()

	return done
}



================================================
File: storage/template_cache.go
================================================
package storage

import (
	"fmt"
	"path/filepath"

	"github.com/google/uuid"
)

const (
	templateCacheDir = "/orchestrator/template"
	snapshotCacheDir = "/mnt/snapshot-cache"
)

type TemplateCacheFiles struct {
	*TemplateFiles
	// CacheIdentifier is used to distinguish between each entry in the cache to prevent deleting the cache files when the template cache entry is being closed and a new one is being created.
	CacheIdentifier string
}

func (f *TemplateFiles) NewTemplateCacheFiles() (*TemplateCacheFiles, error) {
	identifier, err := uuid.NewRandom()
	if err != nil {
		return nil, fmt.Errorf("failed to generate identifier: %w", err)
	}

	return &TemplateCacheFiles{
		TemplateFiles:   f,
		CacheIdentifier: identifier.String(),
	}, nil
}

func (c *TemplateCacheFiles) CacheDir() string {
	return filepath.Join(templateCacheDir, c.TemplateId, c.BuildId, "cache", c.CacheIdentifier)
}

func (c *TemplateCacheFiles) CacheMemfileFullSnapshotPath() string {
	name := fmt.Sprintf("%s-%s-%s.full", c.BuildId, MemfileName, c.CacheIdentifier)

	return filepath.Join(snapshotCacheDir, name)
}

func (c *TemplateCacheFiles) CacheSnapfilePath() string {
	return filepath.Join(c.CacheDir(), SnapfileName)
}



================================================
File: storage/gcs/bucket.go
================================================
package gcs

import (
	"context"
	"sync"

	"cloud.google.com/go/storage"

	"github.com/e2b-dev/infra/packages/shared/pkg/utils"
)

type BucketHandle = storage.BucketHandle

var getClient = sync.OnceValue(func() *storage.Client {
	return utils.Must(newClient(context.Background()))
})

func newBucket(bucket string) *BucketHandle {
	return getClient().Bucket(bucket)
}

func getTemplateBucketName() string {
	return utils.RequiredEnv("TEMPLATE_BUCKET_NAME", "bucket for storing template files")
}

func GetTemplateBucket() *BucketHandle {
	return newBucket(getTemplateBucketName())
}



================================================
File: storage/gcs/client.go
================================================
package gcs

import (
	"context"
	"fmt"

	"cloud.google.com/go/storage"
)

func newClient(ctx context.Context) (*storage.Client, error) {
	client, err := storage.NewClient(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create GCS client: %w", err)
	}

	return client, nil
}



================================================
File: storage/gcs/dir.go
================================================
package gcs

import (
	"context"
	"fmt"

	"cloud.google.com/go/storage"
	"google.golang.org/api/iterator"
)

func RemoveDir(ctx context.Context, bucket *BucketHandle, dir string) error {
	objects := bucket.Objects(ctx, &storage.Query{
		Prefix: dir + "/",
	})

	for {
		object, err := objects.Next()
		if err == iterator.Done {
			break
		}

		if err != nil {
			return fmt.Errorf("error when iterating over template objects: %w", err)
		}

		err = bucket.Object(object.Name).Delete(ctx)
		if err != nil {
			return fmt.Errorf("error when deleting template object: %w", err)
		}
	}

	return nil
}



================================================
File: storage/gcs/object.go
================================================
package gcs

import (
	"context"
	"errors"
	"fmt"
	"io"
	"os/exec"
	"time"

	"cloud.google.com/go/storage"
	"github.com/googleapis/gax-go/v2"
)

const (
	readTimeout       = 10 * time.Second
	operationTimeout  = 5 * time.Second
	bufferSize        = 2 << 21
	initialBackoff    = 10 * time.Millisecond
	maxBackoff        = 10 * time.Second
	backoffMultiplier = 2
	maxAttempts       = 10
)

type Object struct {
	object *storage.ObjectHandle
	ctx    context.Context
}

func NewObject(ctx context.Context, bucket *storage.BucketHandle, objectPath string) *Object {
	obj := bucket.Object(objectPath).Retryer(
		storage.WithMaxAttempts(maxAttempts),
		storage.WithBackoff(gax.Backoff{
			Initial:    initialBackoff,
			Max:        maxBackoff,
			Multiplier: backoffMultiplier,
		}),
		storage.WithPolicy(storage.RetryAlways),
	)

	return &Object{
		object: obj,
		ctx:    ctx,
	}
}

func (o *Object) WriteTo(dst io.Writer) (int64, error) {
	ctx, cancel := context.WithTimeout(o.ctx, readTimeout)
	defer cancel()

	reader, err := o.object.NewReader(ctx)
	if err != nil {
		return 0, fmt.Errorf("failed to create GCS reader: %w", err)
	}

	defer reader.Close()

	b := make([]byte, bufferSize)

	n, err := io.CopyBuffer(dst, reader, b)
	if err != nil {
		return n, fmt.Errorf("failed to copy GCS object to writer: %w", err)
	}

	return n, nil
}

func (o *Object) ReadFrom(src io.Reader) (int64, error) {
	w := o.object.NewWriter(o.ctx)

	n, err := io.Copy(w, src)
	if err != nil && !errors.Is(err, io.EOF) {
		return n, fmt.Errorf("failed to copy buffer to storage: %w", err)
	}

	err = w.Close()
	if err != nil {
		return n, fmt.Errorf("failed to close GCS writer: %w", err)
	}

	return n, nil
}

func (o *Object) UploadWithCli(ctx context.Context, path string) error {
	cmd := exec.CommandContext(
		ctx,
		"gcloud",
		"storage",
		"cp",
		"--verbosity",
		"error",
		path,
		fmt.Sprintf("gs://%s/%s", o.object.BucketName(), o.object.ObjectName()),
	)

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to upload file to GCS: %w\n%s", err, string(output))
	}

	return nil
}

func (o *Object) ReadAt(b []byte, off int64) (n int, err error) {
	ctx, cancel := context.WithTimeout(o.ctx, readTimeout)
	defer cancel()

	// The file should not be gzip compressed
	reader, err := o.object.NewRangeReader(ctx, off, int64(len(b)))
	if err != nil {
		return 0, fmt.Errorf("failed to create GCS reader: %w", err)
	}

	defer reader.Close()

	for reader.Remain() > 0 {
		nr, readErr := reader.Read(b[n:])
		n += nr

		if readErr == nil {
			continue
		}

		if errors.Is(readErr, io.EOF) {
			break
		}

		return n, fmt.Errorf("failed to read from GCS object: %w", readErr)
	}

	return n, nil
}

func (o *Object) Size() (int64, error) {
	ctx, cancel := context.WithTimeout(o.ctx, operationTimeout)
	defer cancel()

	attrs, err := o.object.Attrs(ctx)
	if err != nil {
		return 0, fmt.Errorf("failed to get GCS object (%s) attributes: %w", o.object.ObjectName(), err)
	}

	return attrs.Size, nil
}

func (o *Object) Delete() error {
	ctx, cancel := context.WithTimeout(o.ctx, operationTimeout)
	defer cancel()

	return o.object.Delete(ctx)
}



================================================
File: storage/header/block.go
================================================
package header

func TotalBlocks(size, blockSize int64) int64 {
	return (size + blockSize - 1) / blockSize
}

func BlocksOffsets(size, blockSize int64) []int64 {
	offsets := make([]int64, TotalBlocks(size, blockSize))

	for i := range offsets {
		offsets[i] = BlockOffset(int64(i), blockSize)
	}

	return offsets
}

func BlockIdx(off, blockSize int64) int64 {
	return off / blockSize
}

func BlockOffset(idx, blockSize int64) int64 {
	return idx * blockSize
}



================================================
File: storage/header/diff.go
================================================
package header

import (
	"fmt"
	"io"

	"github.com/bits-and-blooms/bitset"
)

const (
	PageSize        = 2 << 11
	HugepageSize    = 2 << 20
	RootfsBlockSize = 2 << 11
)

var (
	EmptyHugePage = make([]byte, HugepageSize)
	EmptyBlock    = make([]byte, RootfsBlockSize)
)

func CreateDiff(source io.ReaderAt, blockSize int64, dirty *bitset.BitSet, diff io.Writer) error {
	b := make([]byte, blockSize)

	for i, e := dirty.NextSet(0); e; i, e = dirty.NextSet(i + 1) {
		_, err := source.ReadAt(b, int64(i)*blockSize)
		if err != nil {
			return fmt.Errorf("error reading from source: %w", err)
		}

		_, err = diff.Write(b)
		if err != nil {
			return fmt.Errorf("error writing to diff: %w", err)
		}
	}

	return nil
}



================================================
File: storage/header/header.go
================================================
package header

import (
	"fmt"

	"github.com/bits-and-blooms/bitset"
	"github.com/google/uuid"
)

type Header struct {
	Metadata    *Metadata
	blockStarts *bitset.BitSet
	startMap    map[int64]*BuildMap

	Mapping []*BuildMap
}

func NewHeader(metadata *Metadata, mapping []*BuildMap) *Header {
	if len(mapping) == 0 {
		mapping = []*BuildMap{{
			Offset:             0,
			Length:             metadata.Size,
			BuildId:            metadata.BuildId,
			BuildStorageOffset: 0,
		}}
	}

	blocks := TotalBlocks(int64(metadata.Size), int64(metadata.BlockSize))

	intervals := bitset.New(uint(blocks))
	startMap := make(map[int64]*BuildMap, len(mapping))

	for _, mapping := range mapping {
		block := BlockIdx(int64(mapping.Offset), int64(metadata.BlockSize))

		intervals.Set(uint(block))
		startMap[block] = mapping
	}

	return &Header{
		blockStarts: intervals,
		Metadata:    metadata,
		Mapping:     mapping,
		startMap:    startMap,
	}
}

func (t *Header) GetShiftedMapping(offset int64) (mappedOffset int64, mappedLength int64, buildID *uuid.UUID, err error) {
	mapping, shift, err := t.getMapping(offset)
	if err != nil {
		return 0, 0, nil, err
	}

	return int64(mapping.BuildStorageOffset) + shift, int64(mapping.Length) - shift, &mapping.BuildId, nil
}

func (t *Header) getMapping(offset int64) (*BuildMap, int64, error) {
	block := BlockIdx(offset, int64(t.Metadata.BlockSize))

	start, ok := t.blockStarts.PreviousSet(uint(block))
	if !ok {
		return nil, 0, fmt.Errorf("no source found for offset %d", offset)
	}

	mapping, ok := t.startMap[int64(start)]
	if !ok {
		return nil, 0, fmt.Errorf("no mapping found for offset %d", offset)
	}

	shift := (block - int64(start)) * int64(t.Metadata.BlockSize)

	return mapping, shift, nil
}



================================================
File: storage/header/inspect.go
================================================
package header

import (
	"fmt"
	"strings"

	"github.com/google/uuid"
)

// Format returns a string representation of the mapping as:
//
// startBlock-endBlock [offset, offset+length) := [buildStorageOffset, buildStorageOffset+length) ⊂ buildId, length in bytes
//
// It is used for debugging and visualization.
func (mapping *BuildMap) Format(blockSize uint64) string {
	rangeMessage := fmt.Sprintf("%d-%d", mapping.Offset/blockSize, (mapping.Offset+mapping.Length)/blockSize)

	return fmt.Sprintf(
		"%-14s [%11d,%11d) := [%11d,%11d) ⊂ %s, %d B",
		rangeMessage,
		mapping.Offset, mapping.Offset+mapping.Length,
		mapping.BuildStorageOffset, mapping.BuildStorageOffset+mapping.Length, mapping.BuildId.String(), mapping.Length,
	)
}

const (
	SkippedBlockChar = '░'
	DirtyBlockChar1  = '▓'
	DirtyBlockChar2  = '█'
)

// Layers returns a map of buildIds that are present in the mappings.
func Layers(mappings []*BuildMap) *map[uuid.UUID]struct{} {
	layers := make(map[uuid.UUID]struct{})

	for _, mapping := range mappings {
		layers[mapping.BuildId] = struct{}{}
	}

	return &layers
}

// Visualize returns a string representation of the mappings as a grid of blocks.
// It is used for debugging and visualization.
//
// You can pass maps to visualize different groups of buildIds.
func Visualize(mappings []*BuildMap, size, blockSize, cols uint64, bottomGroup, topGroup *map[uuid.UUID]struct{}) string {
	output := make([]rune, size/blockSize)

	for outputIdx := range output {
		output[outputIdx] = SkippedBlockChar
	}

	for _, mapping := range mappings {
		for block := uint64(0); block < mapping.Length/blockSize; block++ {
			if bottomGroup != nil {
				if _, ok := (*bottomGroup)[mapping.BuildId]; ok {
					output[mapping.Offset/blockSize+block] = DirtyBlockChar1
				}
			}

			if topGroup != nil {
				if _, ok := (*topGroup)[mapping.BuildId]; ok {
					output[mapping.Offset/blockSize+block] = DirtyBlockChar2
				}
			}
		}
	}

	lineOutput := make([]string, 0)

	for i := uint64(0); i < size/blockSize; i += cols {
		if i+cols <= uint64(len(output)) {
			lineOutput = append(lineOutput, string(output[i:i+cols]))
		} else {
			lineOutput = append(lineOutput, string(output[i:]))
		}
	}

	return strings.Join(lineOutput, "\n")
}

// ValidateMappings validates the mappings.
// It is used to check if the mappings are valid.
//
// It checks if the mappings are contiguous and if the length of each mapping is a multiple of the block size.
// It also checks if the mappings cover the whole size.
func ValidateMappings(mappings []*BuildMap, size, blockSize uint64) error {
	var currentOffset uint64

	for _, mapping := range mappings {
		if currentOffset != mapping.Offset {
			return fmt.Errorf("mapping validation failed: the following mapping\n- %s\ndoes not start at the correct offset: expected %d (block %d), got %d (block %d)\n", mapping.Format(blockSize), currentOffset, currentOffset/blockSize, mapping.Offset, mapping.Offset/blockSize)
		}

		if mapping.Length%blockSize != 0 {
			return fmt.Errorf("mapping validation failed: the following mapping\n- %s\nhas an invalid length: %d. It should be a multiple of block size: %d\n", mapping.Format(blockSize), mapping.Length, blockSize)
		}

		if currentOffset+mapping.Length > size {
			return fmt.Errorf("mapping validation failed: the following mapping\n- %s\ngoes beyond the size: %d (current offset) + %d (length) > %d (size)\n", mapping.Format(blockSize), currentOffset, mapping.Length, size)
		}

		currentOffset += mapping.Length
	}

	if currentOffset != size {
		return fmt.Errorf("mapping validation failed: the following mapping\n- %s\ndoes not cover the whole size: %d (current offset) != %d (size)\n", mappings[len(mappings)-1].Format(blockSize), currentOffset, size)
	}

	return nil
}

func (mapping *BuildMap) Equal(other *BuildMap) bool {
	return mapping.Offset == other.Offset && mapping.Length == other.Length && mapping.BuildId == other.BuildId
}

func Equal(a, b []*BuildMap) bool {
	if len(a) != len(b) {
		return false
	}

	for i := range a {
		if !a[i].Equal(b[i]) {
			return false
		}
	}

	return true
}



================================================
File: storage/header/mapping.go
================================================
package header

import (
	"fmt"
	"os"

	"github.com/bits-and-blooms/bitset"
	"github.com/google/uuid"
)

// Start, Length and SourceStart are in bytes of the data file
// Length will be a multiple of BlockSize
// The list of block mappings will be in order of increasing Start, covering the entire file
type BuildMap struct {
	// Offset defines which block of the current layer this mapping starts at
	Offset             uint64
	Length             uint64
	BuildId            uuid.UUID
	BuildStorageOffset uint64
}

func CreateMapping(
	metadata *Metadata,
	buildId *uuid.UUID,
	dirty *bitset.BitSet,
) []*BuildMap {
	var mappings []*BuildMap

	var startBlock uint
	var blockLength uint
	var buildStorageOffset uint64

	for blockIdx, e := dirty.NextSet(0); e; blockIdx, e = dirty.NextSet(blockIdx + 1) {
		if startBlock+blockLength == blockIdx {
			blockLength++

			continue
		}

		if blockLength > 0 {
			m := &BuildMap{
				Offset:             uint64(int64(startBlock) * int64(metadata.BlockSize)),
				BuildId:            *buildId,
				Length:             uint64(blockLength) * uint64(metadata.BlockSize),
				BuildStorageOffset: buildStorageOffset,
			}

			mappings = append(mappings, m)

			buildStorageOffset += m.Length
		}

		startBlock = blockIdx
		blockLength = 1
	}

	if blockLength > 0 {
		mappings = append(mappings, &BuildMap{
			Offset:             uint64(startBlock) * metadata.BlockSize,
			BuildId:            *buildId,
			Length:             uint64(blockLength) * uint64(metadata.BlockSize),
			BuildStorageOffset: buildStorageOffset,
		})
	}

	return mappings
}

// MergeMappings merges two sets of mappings.
//
// The mapping are stored in a sorted order.
// The baseMapping must cover the whole size.
//
// It returns a new set of mappings that covers the whole size.
func MergeMappings(
	baseMapping []*BuildMap,
	diffMapping []*BuildMap,
) []*BuildMap {
	if len(diffMapping) == 0 {
		return baseMapping
	}

	baseMappingCopy := make([]*BuildMap, len(baseMapping))

	copy(baseMappingCopy, baseMapping)

	baseMapping = baseMappingCopy

	mappings := make([]*BuildMap, 0)

	var baseIdx int
	var diffIdx int

	for baseIdx < len(baseMapping) && diffIdx < len(diffMapping) {
		base := baseMapping[baseIdx]
		diff := diffMapping[diffIdx]

		if base.Length == 0 {
			baseIdx++

			continue
		}

		if diff.Length == 0 {
			diffIdx++

			continue
		}

		// base is before diff and there is no overlap
		// add base to the result, because it will not be overlapping by any diff
		if base.Offset+base.Length <= diff.Offset {
			mappings = append(mappings, base)

			baseIdx++

			continue
		}

		// diff is before base and there is no overlap
		// add diff to the result, because we don't need to check if it overlaps with any base
		if diff.Offset+diff.Length <= base.Offset {
			mappings = append(mappings, diff)

			diffIdx++

			continue
		}

		// base is inside diff
		// remove base, because it's fully covered by diff
		if base.Offset >= diff.Offset && base.Offset+base.Length <= diff.Offset+diff.Length {
			baseIdx++

			continue
		}

		// diff is inside base (they start and end can also be the same)
		// split base into two parts: left part (before diff) and right part (after diff)
		// if left part is not empty, add it to the result
		// add diff to the result
		// if right part is not empty, update baseMapping with it, otherwise remove it from the baseMapping
		if diff.Offset >= base.Offset && diff.Offset+diff.Length <= base.Offset+base.Length {
			leftBaseLength := int64(diff.Offset) - int64(base.Offset)

			if leftBaseLength > 0 {
				leftBase := &BuildMap{
					Offset:  base.Offset,
					Length:  uint64(leftBaseLength),
					BuildId: base.BuildId,
					// the build storage offset is the same as the base mapping
					BuildStorageOffset: base.BuildStorageOffset,
				}

				mappings = append(mappings, leftBase)
			}

			mappings = append(mappings, diff)

			diffIdx++

			rightBaseShift := int64(diff.Offset) + int64(diff.Length) - int64(base.Offset)
			rightBaseLength := int64(base.Length) - rightBaseShift

			if rightBaseLength > 0 {
				rightBase := &BuildMap{
					Offset:             base.Offset + uint64(rightBaseShift),
					Length:             uint64(rightBaseLength),
					BuildId:            base.BuildId,
					BuildStorageOffset: base.BuildStorageOffset + uint64(rightBaseShift),
				}

				baseMapping[baseIdx] = rightBase
			} else {
				baseIdx++
			}

			continue
		}

		// base is after diff and there is overlap
		// add diff to the result
		// add the right part of base to the baseMapping, it should not be empty because of the check above
		if base.Offset > diff.Offset {
			mappings = append(mappings, diff)

			diffIdx++

			rightBaseShift := int64(diff.Offset) + int64(diff.Length) - int64(base.Offset)
			rightBaseLength := int64(base.Length) - rightBaseShift

			if rightBaseLength > 0 {
				rightBase := &BuildMap{
					Offset:             base.Offset + uint64(rightBaseShift),
					Length:             uint64(rightBaseLength),
					BuildId:            base.BuildId,
					BuildStorageOffset: base.BuildStorageOffset + uint64(rightBaseShift),
				}

				baseMapping[baseIdx] = rightBase
			} else {
				baseIdx++
			}

			continue
		}

		// diff is after base and there is overlap
		// add the left part of base to the result, it should not be empty because of the check above
		if diff.Offset > base.Offset {
			leftBaseLength := int64(diff.Offset) - int64(base.Offset)

			if leftBaseLength > 0 {
				leftBase := &BuildMap{
					Offset:             base.Offset,
					Length:             uint64(leftBaseLength),
					BuildId:            base.BuildId,
					BuildStorageOffset: base.BuildStorageOffset,
				}

				mappings = append(mappings, leftBase)
			}

			baseIdx++

			continue
		}

		fmt.Fprintf(os.Stderr, "invalid case during merge mappings: %+v %+v\n", base, diff)
	}

	mappings = append(mappings, baseMapping[baseIdx:]...)
	mappings = append(mappings, diffMapping[diffIdx:]...)

	return mappings
}



================================================
File: storage/header/mapping_test.go
================================================
package header

import (
	"testing"

	"github.com/google/uuid"

	"github.com/stretchr/testify/require"
)

var ignoreID = uuid.Nil
var baseID = uuid.New()
var diffID = uuid.New()

var blockSize = uint64(2 << 20)

var size = 8 * blockSize

var simpleBase = []*BuildMap{
	{
		Offset:  0,
		Length:  2 * blockSize,
		BuildId: ignoreID,
	},
	{
		Offset:  2 * blockSize,
		Length:  4 * blockSize,
		BuildId: baseID,
	},
	{
		Offset:  6 * blockSize,
		Length:  2 * blockSize,
		BuildId: ignoreID,
	},
}

func TestMergeMappingsRemoveEmpty(t *testing.T) {
	diff := []*BuildMap{
		{
			Offset:  0,
			Length:  0,
			BuildId: ignoreID,
		},
	}

	m := MergeMappings(simpleBase, diff)

	require.True(t, Equal(m, simpleBase))

	err := ValidateMappings(m, size, blockSize)

	require.NoError(t, err)
}

func TestMergeMappingsBaseBeforeDiffNoOverlap(t *testing.T) {
	diff := []*BuildMap{
		{
			Offset:  7 * blockSize,
			Length:  1 * blockSize,
			BuildId: diffID,
		},
	}

	m := MergeMappings(simpleBase, diff)

	require.True(t, Equal(m, []*BuildMap{
		{
			Offset:  0,
			Length:  2 * blockSize,
			BuildId: ignoreID,
		},
		{
			Offset:  2 * blockSize,
			Length:  4 * blockSize,
			BuildId: baseID,
		},
		{
			Offset:  6 * blockSize,
			Length:  1 * blockSize,
			BuildId: ignoreID,
		},
		{
			Offset:  7 * blockSize,
			Length:  1 * blockSize,
			BuildId: diffID,
		},
	}))

	err := ValidateMappings(m, size, blockSize)

	require.NoError(t, err)
}

func TestMergeMappingsDiffBeforeBaseNoOverlap(t *testing.T) {
	diff := []*BuildMap{
		{
			Offset:  0,
			Length:  1 * blockSize,
			BuildId: diffID,
		},
	}

	m := MergeMappings(simpleBase, diff)

	require.True(t, Equal(m, []*BuildMap{
		{
			Offset:  0,
			Length:  1 * blockSize,
			BuildId: diffID,
		},
		{
			Offset:  1 * blockSize,
			Length:  1 * blockSize,
			BuildId: ignoreID,
		},
		{
			Offset:  2 * blockSize,
			Length:  4 * blockSize,
			BuildId: baseID,
		},
		{
			Offset:  6 * blockSize,
			Length:  2 * blockSize,
			BuildId: ignoreID,
		},
	}))

	err := ValidateMappings(m, size, blockSize)

	require.NoError(t, err)
}

func TestMergeMappingsBaseInsideDiff(t *testing.T) {
	diff := []*BuildMap{
		{
			Offset:  1 * blockSize,
			Length:  5 * blockSize,
			BuildId: diffID,
		},
	}

	m := MergeMappings(simpleBase, diff)

	require.True(t, Equal(m, []*BuildMap{
		{
			Offset:  0,
			Length:  1 * blockSize,
			BuildId: ignoreID,
		},
		{
			Offset:  1 * blockSize,
			Length:  5 * blockSize,
			BuildId: diffID,
		},
		{
			Offset:  6 * blockSize,
			Length:  2 * blockSize,
			BuildId: ignoreID,
		},
	}))

	err := ValidateMappings(m, size, blockSize)

	require.NoError(t, err)
}

func TestMergeMappingsDiffInsideBase(t *testing.T) {
	diff := []*BuildMap{
		{
			Offset:  3 * blockSize,
			Length:  1 * blockSize,
			BuildId: diffID,
		},
	}

	m := MergeMappings(simpleBase, diff)

	require.True(t, Equal(m, []*BuildMap{
		{
			Offset:  0,
			Length:  2 * blockSize,
			BuildId: ignoreID,
		},
		{
			Offset:  2 * blockSize,
			Length:  1 * blockSize,
			BuildId: baseID,
		},
		{
			Offset:  3 * blockSize,
			Length:  1 * blockSize,
			BuildId: diffID,
		},
		{
			Offset:  4 * blockSize,
			Length:  2 * blockSize,
			BuildId: baseID,
		},
		{
			Offset:  6 * blockSize,
			Length:  2 * blockSize,
			BuildId: ignoreID,
		},
	}))

	err := ValidateMappings(m, size, blockSize)

	require.NoError(t, err)
}

func TestMergeMappingsBaseAfterDiffWithOverlap(t *testing.T) {
	diff := []*BuildMap{
		{
			Offset:  1 * blockSize,
			Length:  4 * blockSize,
			BuildId: diffID,
		},
	}

	m := MergeMappings(simpleBase, diff)

	require.True(t, Equal(m, []*BuildMap{
		{
			Offset:  0,
			Length:  1 * blockSize,
			BuildId: ignoreID,
		},
		{
			Offset:  1 * blockSize,
			Length:  4 * blockSize,
			BuildId: diffID,
		},
		{
			Offset:  5 * blockSize,
			Length:  1 * blockSize,
			BuildId: baseID,
		},
		{
			Offset:  6 * blockSize,
			Length:  2 * blockSize,
			BuildId: ignoreID,
		},
	}))

	err := ValidateMappings(m, size, blockSize)

	require.NoError(t, err)
}

func TestMergeMappingsDiffAfterBaseWithOverlap(t *testing.T) {
	diff := []*BuildMap{
		{
			Offset:  3 * blockSize,
			Length:  4 * blockSize,
			BuildId: diffID,
		},
	}

	m := MergeMappings(simpleBase, diff)

	require.True(t, Equal(m, []*BuildMap{
		{
			Offset:  0,
			Length:  2 * blockSize,
			BuildId: ignoreID,
		},
		{
			Offset:  2 * blockSize,
			Length:  1 * blockSize,
			BuildId: baseID,
		},
		{
			Offset:  3 * blockSize,
			Length:  4 * blockSize,
			BuildId: diffID,
		},
		{
			Offset:  7 * blockSize,
			Length:  1 * blockSize,
			BuildId: ignoreID,
		},
	}))

	err := ValidateMappings(m, size, blockSize)

	require.NoError(t, err)
}



================================================
File: storage/header/serialization.go
================================================
package header

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"

	"github.com/google/uuid"
)

type Metadata struct {
	Version    uint64
	BlockSize  uint64
	Size       uint64
	Generation uint64
	BuildId    uuid.UUID
	// TODO: Use the base build id when setting up the snapshot rootfs
	BaseBuildId uuid.UUID
}


func Serialize(metadata *Metadata, mappings []*BuildMap) (io.Reader, error) {
	var buf bytes.Buffer

	err := binary.Write(&buf, binary.LittleEndian, metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to write metadata: %w", err)
	}

	for _, mapping := range mappings {
		err := binary.Write(&buf, binary.LittleEndian, mapping)
		if err != nil {
			return nil, fmt.Errorf("failed to write block mapping: %w", err)
		}
	}

	return &buf, nil
}

func Deserialize(in io.WriterTo) (*Header, error) {
	var buf bytes.Buffer

	_, err := in.WriteTo(&buf)
	if err != nil {
		return nil, fmt.Errorf("failed to write to buffer: %w", err)
	}

	reader := bytes.NewReader(buf.Bytes())

	var metadata Metadata

	err = binary.Read(reader, binary.LittleEndian, &metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to read metadata: %w", err)
	}

	mappings := make([]*BuildMap, 0)

	for {
		var m BuildMap
		err := binary.Read(reader, binary.LittleEndian, &m)
		if err == io.EOF {
			break
		}

		if err != nil {
			return nil, fmt.Errorf("failed to read block mapping: %w", err)
		}

		mappings = append(mappings, &m)
	}

	return NewHeader(&metadata, mappings), nil
}



================================================
File: storage/s3/bucket.go
================================================
package s3

import (
	"context"
	"sync"

	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/e2b-dev/infra/packages/shared/pkg/utils"
)

type BucketHandle struct {
	client     *s3.Client
	bucketName string
}

var getClient = sync.OnceValue(func() *s3.Client {
	return utils.Must(newClient(context.Background()))
})

func newBucket(bucket string) *BucketHandle {
	return &BucketHandle{
		client:     getClient(),
		bucketName: bucket,
	}
}

func getTemplateBucketName() string {
	return utils.RequiredEnv("TEMPLATE_BUCKET_NAME", "bucket for storing template files")
}

func GetTemplateBucket() *BucketHandle {
	return newBucket(getTemplateBucketName())
}



================================================
File: storage/s3/client.go
================================================
package s3

import (
	"context"
	"fmt"

	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/s3"
)

func newClient(ctx context.Context) (*s3.Client, error) {
	cfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to load AWS config: %w", err)
	}

	client := s3.NewFromConfig(cfg)
	return client, nil
}



================================================
File: storage/s3/dir.go
================================================
package s3

import (
	"context"
	"fmt"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/s3"
)

func RemoveDir(ctx context.Context, bucket *BucketHandle, dir string) error {
	// List all objects with the prefix
	paginator := s3.NewListObjectsV2Paginator(bucket.client, &s3.ListObjectsV2Input{
		Bucket: aws.String(bucket.bucketName),
		Prefix: aws.String(dir + "/"),
	})

	for paginator.HasMorePages() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return fmt.Errorf("error when listing S3 objects: %w", err)
		}

		for _, obj := range page.Contents {
			_, err := bucket.client.DeleteObject(ctx, &s3.DeleteObjectInput{
				Bucket: aws.String(bucket.bucketName),
				Key:    obj.Key,
			})
			if err != nil {
				return fmt.Errorf("error when deleting S3 object: %w", err)
			}
		}
	}

	return nil
}



================================================
File: storage/s3/object.go
================================================
package s3

import (
	"context"
	"fmt"
	"io"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/s3"
)

const (
	readTimeout      = 10 * time.Second
	operationTimeout = 5 * time.Second
	bufferSize       = 2 << 21
	maxRetries       = 10
)

type Object struct {
	client     *s3.Client
	bucketName string
	key        string
	ctx        context.Context
}

func (b *BucketHandle) Object(key string) *Object {
	return &Object{
		client:     b.client,
		bucketName: b.bucketName,
		key:        key,
		ctx:        context.Background(),
	}
}

func (o *Object) WriteTo(dst io.Writer) (int64, error) {
	ctx, cancel := context.WithTimeout(o.ctx, readTimeout)
	defer cancel()

	result, err := o.client.GetObject(ctx, &s3.GetObjectInput{
		Bucket: aws.String(o.bucketName),
		Key:    aws.String(o.key),
	})
	if err != nil {
		return 0, fmt.Errorf("failed to get S3 object: %w", err)
	}
	defer result.Body.Close()

	n, err := io.Copy(dst, result.Body)
	if err != nil {
		return n, fmt.Errorf("failed to copy S3 object to writer: %w", err)
	}

	return n, nil
}

func (o *Object) ReadFrom(src io.Reader) (int64, error) {
	ctx, cancel := context.WithTimeout(o.ctx, operationTimeout)
	defer cancel()

	_, err := o.client.PutObject(ctx, &s3.PutObjectInput{
		Bucket: aws.String(o.bucketName),
		Key:    aws.String(o.key),
		Body:   src,
	})
	if err != nil {
		return 0, fmt.Errorf("failed to put S3 object: %w", err)
	}

	return 0, nil
}

func (o *Object) ReadAt(b []byte, off int64) (n int, err error) {
	ctx, cancel := context.WithTimeout(o.ctx, readTimeout)
	defer cancel()

	rangeStr := fmt.Sprintf("bytes=%d-%d", off, off+int64(len(b))-1)
	result, err := o.client.GetObject(ctx, &s3.GetObjectInput{
		Bucket: aws.String(o.bucketName),
		Key:    aws.String(o.key),
		Range:  aws.String(rangeStr),
	})
	if err != nil {
		return 0, fmt.Errorf("failed to get S3 object range: %w", err)
	}
	defer result.Body.Close()

	return io.ReadFull(result.Body, b)
}

func (o *Object) Size() (int64, error) {
	ctx, cancel := context.WithTimeout(o.ctx, operationTimeout)
	defer cancel()

	result, err := o.client.HeadObject(ctx, &s3.HeadObjectInput{
		Bucket: aws.String(o.bucketName),
		Key:    aws.String(o.key),
	})
	if err != nil {
		return 0, fmt.Errorf("failed to get S3 object head: %w", err)
	}

	return result.ContentLength, nil
}

func (o *Object) Delete() error {
	ctx, cancel := context.WithTimeout(o.ctx, operationTimeout)
	defer cancel()

	_, err := o.client.DeleteObject(ctx, &s3.DeleteObjectInput{
		Bucket: aws.String(o.bucketName),
		Key:    aws.String(o.key),
	})
	if err != nil {
		return fmt.Errorf("failed to delete S3 object: %w", err)
	}

	return nil
}



================================================
File: telemetry/otel.go
================================================
package telemetry

import (
	"context"
	"fmt"
	baselog "log"
	"os"
	"time"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/exporters/otlp/otlplog/otlploggrpc"
	"go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
	"go.opentelemetry.io/otel/log/global"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/sdk/log"
	"go.opentelemetry.io/otel/sdk/metric"
	"go.opentelemetry.io/otel/sdk/resource"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
	semconv "go.opentelemetry.io/otel/semconv/v1.21.0"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/encoding/gzip"
)

const (
	metricExportPeriod = 15 * time.Second
)

var otelCollectorGRPCEndpoint = os.Getenv("OTEL_COLLECTOR_GRPC_ENDPOINT")

type client struct {
	tracerProvider *sdktrace.TracerProvider
	meterProvider  *metric.MeterProvider
	logsProvider   *log.LoggerProvider
}

// InitOTLPExporter initializes an OTLP exporter, and configures the corresponding trace providers.
func InitOTLPExporter(ctx context.Context, serviceName, serviceVersion string) func(ctx context.Context) error {
	attributes := []attribute.KeyValue{
		semconv.ServiceName(serviceName),
		semconv.ServiceVersion(serviceVersion),
		semconv.TelemetrySDKName("otel"),
		semconv.TelemetrySDKLanguageGo,
	}

	hostname, err := os.Hostname()
	if err == nil {
		attributes = append(attributes, semconv.HostName(hostname))
	}

	res, err := resource.New(
		ctx,
		resource.WithSchemaURL(semconv.SchemaURL),
		resource.WithAttributes(attributes...),
	)
	if err != nil {
		panic(fmt.Errorf("failed to create resource: %w", err))
	}

	var otelClient client

	go func() {
		// Set up a connection to the collector.
		var conn *grpc.ClientConn

		retryInterval := 5 * time.Second

		for {
			dialCtx, cancel := context.WithTimeout(ctx, time.Second)

			conn, err = grpc.DialContext(dialCtx,
				otelCollectorGRPCEndpoint,
				// Note the use of insecure transport here. TLS is recommended in production.
				grpc.WithTransportCredentials(insecure.NewCredentials()),
				grpc.WithBlock(),
			)

			cancel()

			if err != nil {
				baselog.Printf("Failed to connect to otel collector, not using OTEL for logs: %v", err)
				time.Sleep(retryInterval)
			} else {
				break
			}
		}

		// Set up a trace exporter
		traceExporter, traceErr := otlptracegrpc.New(
			ctx,
			otlptracegrpc.WithGRPCConn(conn),
			otlptracegrpc.WithCompressor(gzip.Name),
		)
		if traceErr != nil {
			panic(fmt.Errorf("failed to create trace exporter: %w", err))
		}

		// Register the trace exporter with a TracerProvider, using a batch
		// span processor to aggregate spans before export.
		bsp := sdktrace.NewBatchSpanProcessor(traceExporter)
		tracerProvider := sdktrace.NewTracerProvider(
			sdktrace.WithSampler(sdktrace.AlwaysSample()),
			sdktrace.WithResource(res),
			sdktrace.WithSpanProcessor(bsp),
		)

		otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{}))
		otel.SetTracerProvider(tracerProvider)
		otelClient.tracerProvider = tracerProvider

		metricExporter, metricErr := otlpmetricgrpc.New(ctx, otlpmetricgrpc.WithGRPCConn(conn))
		if metricErr != nil {
			panic(fmt.Errorf("failed to create metric exporter: %w", err))
		}

		meterProvider := metric.NewMeterProvider(
			metric.WithResource(res),
			metric.WithReader(
				metric.NewPeriodicReader(
					metricExporter,
					metric.WithInterval(metricExportPeriod),
				),
			),
		)

		otel.SetMeterProvider(meterProvider)
		otelClient.meterProvider = meterProvider

		logsExporter, logsErr := otlploggrpc.New(
			ctx,
			otlploggrpc.WithGRPCConn(conn),
			otlploggrpc.WithCompressor(gzip.Name),
		)
		if logsErr != nil {
			panic(fmt.Errorf("failed to create logs exporter: %w", err))
		}

		logsProcessor := log.NewBatchProcessor(logsExporter)
		logsProvider := log.NewLoggerProvider(
			log.WithResource(res),
			log.WithProcessor(logsProcessor),
		)

		global.SetLoggerProvider(logsProvider)
		otelClient.logsProvider = logsProvider
	}()

	// Shutdown will flush any remaining spans and shut down the exporter.
	return otelClient.close
}

func (c *client) close(ctx context.Context) error {
	if c.tracerProvider != nil {
		if err := c.tracerProvider.Shutdown(ctx); err != nil {
			return err
		}
	}

	if c.meterProvider != nil {
		if err := c.meterProvider.Shutdown(ctx); err != nil {
			return err
		}
	}

	if c.logsProvider != nil {
		if err := c.logsProvider.Shutdown(ctx); err != nil {
			return err
		}
	}

	return nil
}



================================================
File: telemetry/tracing.go
================================================
package telemetry

import (
	"context"
	"fmt"
	"os"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
)

var OTELTracingPrint = os.Getenv("OTEL_TRACING_PRINT") != "false"

const DebugID = "debug_id"

func getDebugID(ctx context.Context) *string {
	if ctx.Value(DebugID) == nil {
		return nil
	}

	value := ctx.Value(DebugID).(string)

	return &value
}

func debugFormat(debugID *string, msg string) string {
	if debugID == nil {
		return msg
	}

	return fmt.Sprintf("[%s] %s", *debugID, msg)
}

func SetAttributes(ctx context.Context, attrs ...attribute.KeyValue) {
	span := trace.SpanFromContext(ctx)

	if OTELTracingPrint {
		var msg string

		if len(attrs) == 0 {
			msg = "No attrs set"
		} else {
			msg = fmt.Sprintf("Attrs set: %#v\n", attrs)
		}

		debugID := getDebugID(ctx)
		fmt.Print(debugFormat(debugID, msg))
	}

	span.SetAttributes(attrs...)
}

func ReportEvent(ctx context.Context, name string, attrs ...attribute.KeyValue) {
	span := trace.SpanFromContext(ctx)

	if OTELTracingPrint {
		var msg string

		if len(attrs) == 0 {
			msg = fmt.Sprintf("-> %s\n", name)
		} else {
			msg = fmt.Sprintf("-> %s - %#v\n", name, attrs)
		}

		debugID := getDebugID(ctx)
		fmt.Print(debugFormat(debugID, msg))
	}

	span.AddEvent(name,
		trace.WithAttributes(attrs...),
	)
}

func ReportCriticalError(ctx context.Context, err error, attrs ...attribute.KeyValue) {
	span := trace.SpanFromContext(ctx)

	if OTELTracingPrint {
		var msg string

		if len(attrs) == 0 {
			msg = fmt.Sprintf("Critical error: %v\n", err)
		} else {
			msg = fmt.Sprintf("Critical error: %v - %#v\n", err, attrs)
		}

		debugID := getDebugID(ctx)
		fmt.Fprint(os.Stderr, debugFormat(debugID, msg))
	}

	span.RecordError(err,
		trace.WithStackTrace(true),
		trace.WithAttributes(
			attrs...,
		),
	)

	span.SetStatus(codes.Error, "critical error")
}

func ReportError(ctx context.Context, err error, attrs ...attribute.KeyValue) {
	span := trace.SpanFromContext(ctx)

	if OTELTracingPrint {
		var msg string

		if len(attrs) == 0 {
			msg = fmt.Sprintf("Error: %v\n", err)
		} else {
			msg = fmt.Sprintf("Error: %v - %#v\n", err, attrs)
		}

		debugID := getDebugID(ctx)
		fmt.Fprint(os.Stderr, debugFormat(debugID, msg))
	}

	span.RecordError(err,
		trace.WithStackTrace(true),
		trace.WithAttributes(
			attrs...,
		),
	)
}

func GetContextFromRemote(ctx context.Context, tracer trace.Tracer, name, spanID, traceID string) (context.Context, trace.Span) {
	tid, traceIDErr := trace.TraceIDFromHex(traceID)
	if traceIDErr != nil {
		ReportError(
			ctx,
			traceIDErr,
			attribute.String("trace.id", traceID),
			attribute.Int("trace.id.length", len(traceID)),
		)
	}

	sid, spanIDErr := trace.SpanIDFromHex(spanID)
	if spanIDErr != nil {
		ReportError(
			ctx,
			spanIDErr,
			attribute.String("span.id", spanID),
			attribute.Int("span.id.length", len(spanID)),
		)
	}

	remoteCtx := trace.NewSpanContext(trace.SpanContextConfig{
		TraceID:    tid,
		SpanID:     sid,
		TraceFlags: 0x0,
	})

	return tracer.Start(
		trace.ContextWithRemoteSpanContext(ctx, remoteCtx),
		name,
		trace.WithLinks(
			trace.LinkFromContext(ctx, attribute.String("link", "validation")),
		),
	)
}



================================================
File: telemetry/writer.go
================================================
package telemetry

import (
	"context"
	"fmt"
	"io"
	"strings"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"
)

type EventWriter struct {
	span trace.Span
	name string
}

func (w *EventWriter) Write(p []byte) (n int, err error) {
	fmt.Printf("->> [%s] %s\n", w.name, strings.Trim(string(p), " \t\n"))

	w.span.AddEvent(w.name,
		trace.WithAttributes(
			attribute.String("content", string(p)),
		),
	)

	return len(p), nil
}

func NewEventWriter(ctx context.Context, name string) io.Writer {
	span := trace.SpanFromContext(ctx)

	return &EventWriter{
		name: name,
		span: span,
	}
}



================================================
File: utils/context.go
================================================
package utils

import (
	"context"
	"sync"
	"time"
)

type LockableCancelableContext struct {
	ctx    context.Context
	mu     sync.Mutex
	cancel context.CancelFunc
}

func NewLockableCancelableContext(ctx context.Context) *LockableCancelableContext {
	lcc := &LockableCancelableContext{}
	lcc.ctx, lcc.cancel = context.WithCancel(ctx)
	return lcc
}

func (lcc *LockableCancelableContext) Lock() {
	lcc.mu.Lock()
}

func (lcc *LockableCancelableContext) Unlock() {
	lcc.mu.Unlock()
}

func (lcc *LockableCancelableContext) Done() <-chan struct{} {
	return lcc.ctx.Done()
}

func (lcc *LockableCancelableContext) Err() error {
	return lcc.ctx.Err()
}

func (lcc *LockableCancelableContext) Value(key interface{}) interface{} {
	return lcc.ctx.Value(key)
}

func (lcc *LockableCancelableContext) Cancel() {
	lcc.cancel()
}

func (lcc *LockableCancelableContext) Deadline() (deadline time.Time, ok bool) {
	return lcc.ctx.Deadline()
}



================================================
File: utils/env.go
================================================
package utils

import (
	"fmt"
	"os"
	"strings"
)

// RequiredEnv returns the value of the environment variable for key if it is set, non-empty and not only whitespace.
// It panics otherwise.
//
// Pass the envUsageMsg to describe what the environment variable is used for. This will be used in the error message.
func RequiredEnv(key string, envUsageMsg string) string {
	value, ok := os.LookupEnv(key)
	if !ok {
		panic(fmt.Sprintf("Required environment variable \"%s\" (%s) is not set. Please set it to a non-empty value.", key, envUsageMsg))
	}

	if value == "" {
		panic(fmt.Sprintf("Required environment variable \"%s\" (%s) is set but it is empty. Please set it to a non-empty value.", key, envUsageMsg))
	}

	if strings.TrimSpace(value) == "" {
		panic(fmt.Sprintf("Required environment variable \"%s\" (%s) is set but it contains only whitespace. Please set it to a non-empty value.", key, envUsageMsg))
	}

	return value
}

// OptionalEnv returns the value of the environment variable for key if it is set, non-empty and not only whitespace.
//
// Pass the envUsageMsg to describe what the environment variable is used for.
// This will be used in the message that is printed if the environment variable is not returned.
func OptionalEnv(key string, envUsageMsg string) (string, bool) {
	value, ok := os.LookupEnv(key)
	if !ok {
		fmt.Fprintf(os.Stderr, "Optional environment variable \"%s\" (%s) is not set.\n", key, envUsageMsg)

		return "", false
	}

	if strings.TrimSpace(value) == "" {
		fmt.Fprintf(os.Stderr, "Optional environment variable \"%s\" (%s) is set but it contains only whitespace.\n", key, envUsageMsg)

		return "", false
	}

	return value, true
}



================================================
File: utils/must.go
================================================
package utils

func Must[T any](obj T, err error) T {
	if err != nil {
		panic(err)
	}

	return obj
}



================================================
File: utils/set_once.go
================================================
package utils

import (
	"context"
	"fmt"
	"sync"
)

type result[T any] struct {
	value T
	err   error
}

type SetOnce[T any] struct {
	setDone func()
	done    chan struct{}
	res     *result[T]
	mu      sync.RWMutex
}

func NewSetOnce[T any]() *SetOnce[T] {
	done := make(chan struct{})

	return &SetOnce[T]{
		done: done,
		setDone: sync.OnceFunc(func() {
			close(done)
		}),
	}
}

func (s *SetOnce[T]) SetValue(value T) error {
	return s.setResult(result[T]{value: value})
}

func (s *SetOnce[T]) SetError(err error) error {
	return s.setResult(result[T]{err: err})
}

// SetResult internal method for setting the result only once.
func (s *SetOnce[T]) setResult(r result[T]) error {
	// Should do the action only once
	defer s.setDone()

	select {
	case <-s.done:
		return fmt.Errorf("value already set")
	default:
		// not set yet, so try to set it
		s.mu.Lock()
		defer s.mu.Unlock()

		if s.res != nil {
			return fmt.Errorf("value already set")
		}

		s.res = &r

		return nil
	}
}

// Wait returns the value or error set by SetValue or SetError.
// It can be called multiple times, returning the same value or error.
func (s *SetOnce[T]) Wait() (T, error) {
	<-s.done

	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.res.value, s.res.err
}

// WaitWithContext TODO: Use waitWithContext in all places instead of Wait.
func (s *SetOnce[T]) WaitWithContext(ctx context.Context) (T, error) {
	select {
	case <-s.done:
		s.mu.RLock()
		defer s.mu.RUnlock()

		return s.res.value, s.res.err
	case <-ctx.Done():
		var zero T

		return zero, ctx.Err()
	}
}



================================================
File: utils/set_once_test.go
================================================
package utils

import (
	"context"
	"fmt"
	"sync"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestSetOnce(t *testing.T) {
	setOnce := NewSetOnce[int]()

	setOnce.SetValue(1)

	value, err := setOnce.Wait()
	assert.Nil(t, err)
	assert.Equal(t, 1, value)

	setOnce.SetValue(2)

	value, err = setOnce.Wait()
	assert.Nil(t, err)
	assert.Equal(t, 1, value)

	setOnce.SetError(fmt.Errorf("error"))

	value, err = setOnce.Wait()
	assert.Nil(t, err)
	assert.Equal(t, 1, value)
}

func TestSetOnceSetError(t *testing.T) {
	setOnce := NewSetOnce[int]()

	setOnce.SetError(fmt.Errorf("error"))

	value, err := setOnce.Wait()
	assert.Error(t, err)
	assert.Equal(t, 0, value)

	setOnce.SetValue(1)

	value, err = setOnce.Wait()
	assert.Error(t, err)
	assert.Equal(t, 0, value)
}

func TestSetOnceWait(t *testing.T) {
	setOnce := NewSetOnce[int]()

	wg := sync.WaitGroup{}
	wg.Add(1)
	go func() {
		defer wg.Done()

		time.Sleep(200 * time.Millisecond)
		setOnce.SetValue(1)
	}()

	value, err := setOnce.Wait()
	assert.Nil(t, err)
	assert.Equal(t, 1, value)

	wg.Wait()
}

func TestSetOnceWaitWithContext(t *testing.T) {
	setOnce := NewSetOnce[int]()

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	wg := sync.WaitGroup{}
	wg.Add(1)
	go func() {
		defer wg.Done()

		time.Sleep(200 * time.Millisecond)
		setOnce.SetValue(1)
	}()

	value, err := setOnce.WaitWithContext(ctx)
	assert.Nil(t, err)
	assert.Equal(t, 1, value)

	wg.Wait()
}

func TestSetOnceWaitWithContextCanceled(t *testing.T) {
	setOnce := NewSetOnce[int]()

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	wg := sync.WaitGroup{}

	wg.Add(1)
	go func() {
		defer wg.Done()

		time.Sleep(10 * time.Millisecond)
		cancel()
	}()

	_, err := setOnce.WaitWithContext(ctx)
	assert.Error(t, err)

	wg.Wait()
}

func TestSetOnceSetResultConcurrent(t *testing.T) {
	setOnce := NewSetOnce[int]()

	wg1 := sync.WaitGroup{}
	wg2 := sync.WaitGroup{}
	for i := 1; i < 100; i++ {
		even := i%2 == 0
		if even {
			wg1.Add(1)
		} else {
			wg2.Add(1)
		}
		go func(i int) {
			time.Sleep(time.Microsecond)

			setOnce.SetValue(i)

			if even {
				wg1.Done()
			} else {
				wg2.Done()
			}
		}(i)
	}

	wg1.Wait()

	value, err := setOnce.Wait()
	assert.Nil(t, err)

	assert.LessOrEqual(t, 1, value)
	assert.GreaterOrEqual(t, 99, value)

	wg2.Wait()
}

func TestSetOnceSetResultConcurrentWithContext(t *testing.T) {
	setOnce := NewSetOnce[int]()

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	wg1 := sync.WaitGroup{}
	wg2 := sync.WaitGroup{}
	for i := 1; i < 100; i++ {
		even := i%2 == 0
		if even {
			wg1.Add(1)
		} else {
			wg2.Add(1)
		}
		go func(i int) {
			time.Sleep(time.Microsecond)

			setOnce.SetValue(i)

			if even {
				wg1.Done()
			} else {
				wg2.Done()
			}
		}(i)
	}

	wg1.Wait()

	value, err := setOnce.WaitWithContext(ctx)
	assert.Nil(t, err)

	assert.LessOrEqual(t, 1, value)
	assert.GreaterOrEqual(t, 99, value)

	wg2.Wait()
}

func TestSetOnceConcurrentReads(t *testing.T) {
	setOnce := NewSetOnce[int]()
	const numReaders = 100

	// Set value first
	setOnce.SetValue(42)

	// Start multiple concurrent readers
	var wg sync.WaitGroup
	wg.Add(numReaders)

	for i := 0; i < numReaders; i++ {
		go func() {
			defer wg.Done()
			value, err := setOnce.Wait()
			assert.Nil(t, err)
			assert.Equal(t, 42, value)
		}()
	}

	wg.Wait()
}

func TestSetOnceConcurrentReadsWithContext(t *testing.T) {
	setOnce := NewSetOnce[int]()
	const numReaders = 100

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Set value first
	setOnce.SetValue(42)

	// Start multiple concurrent readers
	var wg sync.WaitGroup
	wg.Add(numReaders)

	for i := 0; i < numReaders; i++ {
		go func() {
			defer wg.Done()
			value, err := setOnce.WaitWithContext(ctx)
			assert.Nil(t, err)
			assert.Equal(t, 42, value)
		}()
	}

	wg.Wait()
}

func TestSetOnceConcurrentReadersBeforeWrite(t *testing.T) {
	setOnce := NewSetOnce[int]()
	const numReaders = 50

	// Start readers before the value is set
	var wg sync.WaitGroup
	wg.Add(numReaders)

	results := make(chan int, numReaders)

	// Launch readers
	for i := 0; i < numReaders; i++ {
		go func() {
			defer wg.Done()
			value, err := setOnce.Wait()
			assert.Nil(t, err)
			results <- value
		}()
	}

	// Small delay to ensure readers are waiting
	time.Sleep(10 * time.Millisecond)

	// Set the value
	setOnce.SetValue(42)

	// Wait for all readers
	wg.Wait()
	close(results)

	// Verify all readers got the same value
	for value := range results {
		assert.Equal(t, 42, value)
	}
}

func TestSetOnceConcurrentReadWriteRace(t *testing.T) {
	setOnce := NewSetOnce[int]()
	const numOperations = 100

	var wg sync.WaitGroup
	wg.Add(numOperations * 2) // For both readers and writers

	// Launch concurrent readers and writers
	for i := 0; i < numOperations; i++ {
		// Reader
		go func() {
			defer wg.Done()
			value, _ := setOnce.Wait()
			// Value should be either 0 (not set) or 42 (set)
			assert.Contains(t, []int{0, 42}, value)
		}()

		// Writer
		go func() {
			defer wg.Done()
			_ = setOnce.SetValue(42)
		}()
	}

	wg.Wait()

	// Final value should be 42 if any write succeeded
	finalValue, err := setOnce.Wait()
	assert.Nil(t, err)
	assert.Equal(t, 42, finalValue)
}



================================================
File: utils/wait_map.go
================================================
package utils

import "sync"

// WaitMap allows you to wait for functions with given keys and execute them only once.
type WaitMap struct {
	mu sync.Mutex
	m  map[int64]func() error
}

func NewWaitMap() *WaitMap {
	return &WaitMap{
		m: make(map[int64]func() error),
	}
}

// Wait waits for the function with the given key to be executed.
// If the function is already executing, it waits for it to finish.
// If the function is not yet executing, it executes the function and returns its result.
func (m *WaitMap) Wait(key int64, fn func() error) error {
	m.mu.Lock()

	once, ok := m.m[key]
	if ok {
		m.mu.Unlock()

		return once()
	}

	once = sync.OnceValue(fn)

	m.m[key] = once

	m.mu.Unlock()

	return once()
}


